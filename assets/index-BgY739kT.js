function Yle(e,t){for(var n=0;n<t.length;n++){const a=t[n];if(typeof a!="string"&&!Array.isArray(a)){for(const r in a)if(r!=="default"&&!(r in e)){const s=Object.getOwnPropertyDescriptor(a,r);s&&Object.defineProperty(e,r,s.get?s:{enumerable:!0,get:()=>a[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))a(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&a(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function a(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();function n2(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function aF(e){if(Object.prototype.hasOwnProperty.call(e,"__esModule"))return e;var t=e.default;if(typeof t=="function"){var n=function a(){var r=!1;try{r=this instanceof a}catch{}return r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach(function(a){var r=Object.getOwnPropertyDescriptor(e,a);Object.defineProperty(n,a,r.get?r:{enumerable:!0,get:function(){return e[a]}})}),n}var J_={exports:{}},yv={};var tG;function Qle(){if(tG)return yv;tG=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function n(a,r,s){var i=null;if(s!==void 0&&(i=""+s),r.key!==void 0&&(i=""+r.key),"key"in r){s={};for(var o in r)o!=="key"&&(s[o]=r[o])}else s=r;return r=s.ref,{$$typeof:e,type:a,key:i,ref:r!==void 0?r:null,props:s}}return yv.Fragment=t,yv.jsx=n,yv.jsxs=n,yv}var nG;function Zle(){return nG||(nG=1,J_.exports=Qle()),J_.exports}var ce=Zle(),eR={exports:{}},zt={};var aG;function Jle(){if(aG)return zt;aG=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),s=Symbol.for("react.consumer"),i=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),h=Symbol.for("react.activity"),p=Symbol.iterator;function m(V){return V===null||typeof V!="object"?null:(V=p&&V[p]||V["@@iterator"],typeof V=="function"?V:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y=Object.assign,b={};function v(V,Q,ee){this.props=V,this.context=Q,this.refs=b,this.updater=ee||g}v.prototype.isReactComponent={},v.prototype.setState=function(V,Q){if(typeof V!="object"&&typeof V!="function"&&V!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,V,Q,"setState")},v.prototype.forceUpdate=function(V){this.updater.enqueueForceUpdate(this,V,"forceUpdate")};function w(){}w.prototype=v.prototype;function S(V,Q,ee){this.props=V,this.context=Q,this.refs=b,this.updater=ee||g}var k=S.prototype=new w;k.constructor=S,y(k,v.prototype),k.isPureReactComponent=!0;var I=Array.isArray;function T(){}var E={H:null,A:null,T:null,S:null},R=Object.prototype.hasOwnProperty;function D(V,Q,ee){var ae=ee.ref;return{$$typeof:e,type:V,key:Q,ref:ae!==void 0?ae:null,props:ee}}function O(V,Q){return D(V.type,Q,V.props)}function $(V){return typeof V=="object"&&V!==null&&V.$$typeof===e}function _(V){var Q={"=":"=0",":":"=2"};return"$"+V.replace(/[=:]/g,function(ee){return Q[ee]})}var P=/\/+/g;function U(V,Q){return typeof V=="object"&&V!==null&&V.key!=null?_(""+V.key):Q.toString(36)}function W(V){switch(V.status){case"fulfilled":return V.value;case"rejected":throw V.reason;default:switch(typeof V.status=="string"?V.then(T,T):(V.status="pending",V.then(function(Q){V.status==="pending"&&(V.status="fulfilled",V.value=Q)},function(Q){V.status==="pending"&&(V.status="rejected",V.reason=Q)})),V.status){case"fulfilled":return V.value;case"rejected":throw V.reason}}throw V}function B(V,Q,ee,ae,de){var ke=typeof V;(ke==="undefined"||ke==="boolean")&&(V=null);var Te=!1;if(V===null)Te=!0;else switch(ke){case"bigint":case"string":case"number":Te=!0;break;case"object":switch(V.$$typeof){case e:case t:Te=!0;break;case c:return Te=V._init,B(Te(V._payload),Q,ee,ae,de)}}if(Te)return de=de(V),Te=ae===""?"."+U(V,0):ae,I(de)?(ee="",Te!=null&&(ee=Te.replace(P,"$&/")+"/"),B(de,Q,ee,"",function(Ge){return Ge})):de!=null&&($(de)&&(de=O(de,ee+(de.key==null||V&&V.key===de.key?"":(""+de.key).replace(P,"$&/")+"/")+Te)),Q.push(de)),1;Te=0;var $e=ae===""?".":ae+":";if(I(V))for(var Le=0;Le<V.length;Le++)ae=V[Le],ke=$e+U(ae,Le),Te+=B(ae,Q,ee,ke,de);else if(Le=m(V),typeof Le=="function")for(V=Le.call(V),Le=0;!(ae=V.next()).done;)ae=ae.value,ke=$e+U(ae,Le++),Te+=B(ae,Q,ee,ke,de);else if(ke==="object"){if(typeof V.then=="function")return B(W(V),Q,ee,ae,de);throw Q=String(V),Error("Objects are not valid as a React child (found: "+(Q==="[object Object]"?"object with keys {"+Object.keys(V).join(", ")+"}":Q)+"). If you meant to render a collection of children, use an array instead.")}return Te}function H(V,Q,ee){if(V==null)return V;var ae=[],de=0;return B(V,ae,"","",function(ke){return Q.call(ee,ke,de++)}),ae}function j(V){if(V._status===-1){var Q=V._result;Q=Q(),Q.then(function(ee){(V._status===0||V._status===-1)&&(V._status=1,V._result=ee)},function(ee){(V._status===0||V._status===-1)&&(V._status=2,V._result=ee)}),V._status===-1&&(V._status=0,V._result=Q)}if(V._status===1)return V._result.default;throw V._result}var Z=typeof reportError=="function"?reportError:function(V){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var Q=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof V=="object"&&V!==null&&typeof V.message=="string"?String(V.message):String(V),error:V});if(!window.dispatchEvent(Q))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",V);return}console.error(V)},te={map:H,forEach:function(V,Q,ee){H(V,function(){Q.apply(this,arguments)},ee)},count:function(V){var Q=0;return H(V,function(){Q++}),Q},toArray:function(V){return H(V,function(Q){return Q})||[]},only:function(V){if(!$(V))throw Error("React.Children.only expected to receive a single React element child.");return V}};return zt.Activity=h,zt.Children=te,zt.Component=v,zt.Fragment=n,zt.Profiler=r,zt.PureComponent=S,zt.StrictMode=a,zt.Suspense=l,zt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=E,zt.__COMPILER_RUNTIME={__proto__:null,c:function(V){return E.H.useMemoCache(V)}},zt.cache=function(V){return function(){return V.apply(null,arguments)}},zt.cacheSignal=function(){return null},zt.cloneElement=function(V,Q,ee){if(V==null)throw Error("The argument must be a React element, but you passed "+V+".");var ae=y({},V.props),de=V.key;if(Q!=null)for(ke in Q.key!==void 0&&(de=""+Q.key),Q)!R.call(Q,ke)||ke==="key"||ke==="__self"||ke==="__source"||ke==="ref"&&Q.ref===void 0||(ae[ke]=Q[ke]);var ke=arguments.length-2;if(ke===1)ae.children=ee;else if(1<ke){for(var Te=Array(ke),$e=0;$e<ke;$e++)Te[$e]=arguments[$e+2];ae.children=Te}return D(V.type,de,ae)},zt.createContext=function(V){return V={$$typeof:i,_currentValue:V,_currentValue2:V,_threadCount:0,Provider:null,Consumer:null},V.Provider=V,V.Consumer={$$typeof:s,_context:V},V},zt.createElement=function(V,Q,ee){var ae,de={},ke=null;if(Q!=null)for(ae in Q.key!==void 0&&(ke=""+Q.key),Q)R.call(Q,ae)&&ae!=="key"&&ae!=="__self"&&ae!=="__source"&&(de[ae]=Q[ae]);var Te=arguments.length-2;if(Te===1)de.children=ee;else if(1<Te){for(var $e=Array(Te),Le=0;Le<Te;Le++)$e[Le]=arguments[Le+2];de.children=$e}if(V&&V.defaultProps)for(ae in Te=V.defaultProps,Te)de[ae]===void 0&&(de[ae]=Te[ae]);return D(V,ke,de)},zt.createRef=function(){return{current:null}},zt.forwardRef=function(V){return{$$typeof:o,render:V}},zt.isValidElement=$,zt.lazy=function(V){return{$$typeof:c,_payload:{_status:-1,_result:V},_init:j}},zt.memo=function(V,Q){return{$$typeof:u,type:V,compare:Q===void 0?null:Q}},zt.startTransition=function(V){var Q=E.T,ee={};E.T=ee;try{var ae=V(),de=E.S;de!==null&&de(ee,ae),typeof ae=="object"&&ae!==null&&typeof ae.then=="function"&&ae.then(T,Z)}catch(ke){Z(ke)}finally{Q!==null&&ee.types!==null&&(Q.types=ee.types),E.T=Q}},zt.unstable_useCacheRefresh=function(){return E.H.useCacheRefresh()},zt.use=function(V){return E.H.use(V)},zt.useActionState=function(V,Q,ee){return E.H.useActionState(V,Q,ee)},zt.useCallback=function(V,Q){return E.H.useCallback(V,Q)},zt.useContext=function(V){return E.H.useContext(V)},zt.useDebugValue=function(){},zt.useDeferredValue=function(V,Q){return E.H.useDeferredValue(V,Q)},zt.useEffect=function(V,Q){return E.H.useEffect(V,Q)},zt.useEffectEvent=function(V){return E.H.useEffectEvent(V)},zt.useId=function(){return E.H.useId()},zt.useImperativeHandle=function(V,Q,ee){return E.H.useImperativeHandle(V,Q,ee)},zt.useInsertionEffect=function(V,Q){return E.H.useInsertionEffect(V,Q)},zt.useLayoutEffect=function(V,Q){return E.H.useLayoutEffect(V,Q)},zt.useMemo=function(V,Q){return E.H.useMemo(V,Q)},zt.useOptimistic=function(V,Q){return E.H.useOptimistic(V,Q)},zt.useReducer=function(V,Q,ee){return E.H.useReducer(V,Q,ee)},zt.useRef=function(V){return E.H.useRef(V)},zt.useState=function(V){return E.H.useState(V)},zt.useSyncExternalStore=function(V,Q,ee){return E.H.useSyncExternalStore(V,Q,ee)},zt.useTransition=function(){return E.H.useTransition()},zt.version="19.2.3",zt}var rG;function a2(){return rG||(rG=1,eR.exports=Jle()),eR.exports}var Ae=a2();const Ir=n2(Ae);var tR={exports:{}},bv={},nR={exports:{}},aR={};var sG;function eue(){return sG||(sG=1,(function(e){function t(B,H){var j=B.length;B.push(H);e:for(;0<j;){var Z=j-1>>>1,te=B[Z];if(0<r(te,H))B[Z]=H,B[j]=te,j=Z;else break e}}function n(B){return B.length===0?null:B[0]}function a(B){if(B.length===0)return null;var H=B[0],j=B.pop();if(j!==H){B[0]=j;e:for(var Z=0,te=B.length,V=te>>>1;Z<V;){var Q=2*(Z+1)-1,ee=B[Q],ae=Q+1,de=B[ae];if(0>r(ee,j))ae<te&&0>r(de,ee)?(B[Z]=de,B[ae]=j,Z=ae):(B[Z]=ee,B[Q]=j,Z=Q);else if(ae<te&&0>r(de,j))B[Z]=de,B[ae]=j,Z=ae;else break e}}return H}function r(B,H){var j=B.sortIndex-H.sortIndex;return j!==0?j:B.id-H.id}if(e.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var s=performance;e.unstable_now=function(){return s.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],u=[],c=1,h=null,p=3,m=!1,g=!1,y=!1,b=!1,v=typeof setTimeout=="function"?setTimeout:null,w=typeof clearTimeout=="function"?clearTimeout:null,S=typeof setImmediate<"u"?setImmediate:null;function k(B){for(var H=n(u);H!==null;){if(H.callback===null)a(u);else if(H.startTime<=B)a(u),H.sortIndex=H.expirationTime,t(l,H);else break;H=n(u)}}function I(B){if(y=!1,k(B),!g)if(n(l)!==null)g=!0,T||(T=!0,_());else{var H=n(u);H!==null&&W(I,H.startTime-B)}}var T=!1,E=-1,R=5,D=-1;function O(){return b?!0:!(e.unstable_now()-D<R)}function $(){if(b=!1,T){var B=e.unstable_now();D=B;var H=!0;try{e:{g=!1,y&&(y=!1,w(E),E=-1),m=!0;var j=p;try{t:{for(k(B),h=n(l);h!==null&&!(h.expirationTime>B&&O());){var Z=h.callback;if(typeof Z=="function"){h.callback=null,p=h.priorityLevel;var te=Z(h.expirationTime<=B);if(B=e.unstable_now(),typeof te=="function"){h.callback=te,k(B),H=!0;break t}h===n(l)&&a(l),k(B)}else a(l);h=n(l)}if(h!==null)H=!0;else{var V=n(u);V!==null&&W(I,V.startTime-B),H=!1}}break e}finally{h=null,p=j,m=!1}H=void 0}}finally{H?_():T=!1}}}var _;if(typeof S=="function")_=function(){S($)};else if(typeof MessageChannel<"u"){var P=new MessageChannel,U=P.port2;P.port1.onmessage=$,_=function(){U.postMessage(null)}}else _=function(){v($,0)};function W(B,H){E=v(function(){B(e.unstable_now())},H)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(B){B.callback=null},e.unstable_forceFrameRate=function(B){0>B||125<B?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<B?Math.floor(1e3/B):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_next=function(B){switch(p){case 1:case 2:case 3:var H=3;break;default:H=p}var j=p;p=H;try{return B()}finally{p=j}},e.unstable_requestPaint=function(){b=!0},e.unstable_runWithPriority=function(B,H){switch(B){case 1:case 2:case 3:case 4:case 5:break;default:B=3}var j=p;p=B;try{return H()}finally{p=j}},e.unstable_scheduleCallback=function(B,H,j){var Z=e.unstable_now();switch(typeof j=="object"&&j!==null?(j=j.delay,j=typeof j=="number"&&0<j?Z+j:Z):j=Z,B){case 1:var te=-1;break;case 2:te=250;break;case 5:te=1073741823;break;case 4:te=1e4;break;default:te=5e3}return te=j+te,B={id:c++,callback:H,priorityLevel:B,startTime:j,expirationTime:te,sortIndex:-1},j>Z?(B.sortIndex=j,t(u,B),n(l)===null&&B===n(u)&&(y?(w(E),E=-1):y=!0,W(I,j-Z))):(B.sortIndex=te,t(l,B),g||m||(g=!0,T||(T=!0,_()))),B},e.unstable_shouldYield=O,e.unstable_wrapCallback=function(B){var H=p;return function(){var j=p;p=H;try{return B.apply(this,arguments)}finally{p=j}}}})(aR)),aR}var iG;function tue(){return iG||(iG=1,nR.exports=eue()),nR.exports}var rR={exports:{}},bs={};var oG;function nue(){if(oG)return bs;oG=1;var e=a2();function t(l){var u="https://react.dev/errors/"+l;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var c=2;c<arguments.length;c++)u+="&args[]="+encodeURIComponent(arguments[c])}return"Minified React error #"+l+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function n(){}var a={d:{f:n,r:function(){throw Error(t(522))},D:n,C:n,L:n,m:n,X:n,S:n,M:n},p:0,findDOMNode:null},r=Symbol.for("react.portal");function s(l,u,c){var h=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:h==null?null:""+h,children:l,containerInfo:u,implementation:c}}var i=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,u){if(l==="font")return"";if(typeof u=="string")return u==="use-credentials"?u:""}return bs.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=a,bs.createPortal=function(l,u){var c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)throw Error(t(299));return s(l,u,null,c)},bs.flushSync=function(l){var u=i.T,c=a.p;try{if(i.T=null,a.p=2,l)return l()}finally{i.T=u,a.p=c,a.d.f()}},bs.preconnect=function(l,u){typeof l=="string"&&(u?(u=u.crossOrigin,u=typeof u=="string"?u==="use-credentials"?u:"":void 0):u=null,a.d.C(l,u))},bs.prefetchDNS=function(l){typeof l=="string"&&a.d.D(l)},bs.preinit=function(l,u){if(typeof l=="string"&&u&&typeof u.as=="string"){var c=u.as,h=o(c,u.crossOrigin),p=typeof u.integrity=="string"?u.integrity:void 0,m=typeof u.fetchPriority=="string"?u.fetchPriority:void 0;c==="style"?a.d.S(l,typeof u.precedence=="string"?u.precedence:void 0,{crossOrigin:h,integrity:p,fetchPriority:m}):c==="script"&&a.d.X(l,{crossOrigin:h,integrity:p,fetchPriority:m,nonce:typeof u.nonce=="string"?u.nonce:void 0})}},bs.preinitModule=function(l,u){if(typeof l=="string")if(typeof u=="object"&&u!==null){if(u.as==null||u.as==="script"){var c=o(u.as,u.crossOrigin);a.d.M(l,{crossOrigin:c,integrity:typeof u.integrity=="string"?u.integrity:void 0,nonce:typeof u.nonce=="string"?u.nonce:void 0})}}else u==null&&a.d.M(l)},bs.preload=function(l,u){if(typeof l=="string"&&typeof u=="object"&&u!==null&&typeof u.as=="string"){var c=u.as,h=o(c,u.crossOrigin);a.d.L(l,c,{crossOrigin:h,integrity:typeof u.integrity=="string"?u.integrity:void 0,nonce:typeof u.nonce=="string"?u.nonce:void 0,type:typeof u.type=="string"?u.type:void 0,fetchPriority:typeof u.fetchPriority=="string"?u.fetchPriority:void 0,referrerPolicy:typeof u.referrerPolicy=="string"?u.referrerPolicy:void 0,imageSrcSet:typeof u.imageSrcSet=="string"?u.imageSrcSet:void 0,imageSizes:typeof u.imageSizes=="string"?u.imageSizes:void 0,media:typeof u.media=="string"?u.media:void 0})}},bs.preloadModule=function(l,u){if(typeof l=="string")if(u){var c=o(u.as,u.crossOrigin);a.d.m(l,{as:typeof u.as=="string"&&u.as!=="script"?u.as:void 0,crossOrigin:c,integrity:typeof u.integrity=="string"?u.integrity:void 0})}else a.d.m(l)},bs.requestFormReset=function(l){a.d.r(l)},bs.unstable_batchedUpdates=function(l,u){return l(u)},bs.useFormState=function(l,u,c){return i.H.useFormState(l,u,c)},bs.useFormStatus=function(){return i.H.useHostTransitionStatus()},bs.version="19.2.3",bs}var lG;function aue(){if(lG)return rR.exports;lG=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),rR.exports=nue(),rR.exports}var uG;function rue(){if(uG)return bv;uG=1;var e=tue(),t=a2(),n=aue();function a(d){var f="https://react.dev/errors/"+d;if(1<arguments.length){f+="?args[]="+encodeURIComponent(arguments[1]);for(var x=2;x<arguments.length;x++)f+="&args[]="+encodeURIComponent(arguments[x])}return"Minified React error #"+d+"; visit "+f+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(d){return!(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)}function s(d){var f=d,x=d;if(d.alternate)for(;f.return;)f=f.return;else{d=f;do f=d,(f.flags&4098)!==0&&(x=f.return),d=f.return;while(d)}return f.tag===3?x:null}function i(d){if(d.tag===13){var f=d.memoizedState;if(f===null&&(d=d.alternate,d!==null&&(f=d.memoizedState)),f!==null)return f.dehydrated}return null}function o(d){if(d.tag===31){var f=d.memoizedState;if(f===null&&(d=d.alternate,d!==null&&(f=d.memoizedState)),f!==null)return f.dehydrated}return null}function l(d){if(s(d)!==d)throw Error(a(188))}function u(d){var f=d.alternate;if(!f){if(f=s(d),f===null)throw Error(a(188));return f!==d?null:d}for(var x=d,A=f;;){var N=x.return;if(N===null)break;var C=N.alternate;if(C===null){if(A=N.return,A!==null){x=A;continue}break}if(N.child===C.child){for(C=N.child;C;){if(C===x)return l(N),d;if(C===A)return l(N),f;C=C.sibling}throw Error(a(188))}if(x.return!==A.return)x=N,A=C;else{for(var z=!1,Y=N.child;Y;){if(Y===x){z=!0,x=N,A=C;break}if(Y===A){z=!0,A=N,x=C;break}Y=Y.sibling}if(!z){for(Y=C.child;Y;){if(Y===x){z=!0,x=C,A=N;break}if(Y===A){z=!0,A=C,x=N;break}Y=Y.sibling}if(!z)throw Error(a(189))}}if(x.alternate!==A)throw Error(a(190))}if(x.tag!==3)throw Error(a(188));return x.stateNode.current===x?d:f}function c(d){var f=d.tag;if(f===5||f===26||f===27||f===6)return d;for(d=d.child;d!==null;){if(f=c(d),f!==null)return f;d=d.sibling}return null}var h=Object.assign,p=Symbol.for("react.element"),m=Symbol.for("react.transitional.element"),g=Symbol.for("react.portal"),y=Symbol.for("react.fragment"),b=Symbol.for("react.strict_mode"),v=Symbol.for("react.profiler"),w=Symbol.for("react.consumer"),S=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),I=Symbol.for("react.suspense"),T=Symbol.for("react.suspense_list"),E=Symbol.for("react.memo"),R=Symbol.for("react.lazy"),D=Symbol.for("react.activity"),O=Symbol.for("react.memo_cache_sentinel"),$=Symbol.iterator;function _(d){return d===null||typeof d!="object"?null:(d=$&&d[$]||d["@@iterator"],typeof d=="function"?d:null)}var P=Symbol.for("react.client.reference");function U(d){if(d==null)return null;if(typeof d=="function")return d.$$typeof===P?null:d.displayName||d.name||null;if(typeof d=="string")return d;switch(d){case y:return"Fragment";case v:return"Profiler";case b:return"StrictMode";case I:return"Suspense";case T:return"SuspenseList";case D:return"Activity"}if(typeof d=="object")switch(d.$$typeof){case g:return"Portal";case S:return d.displayName||"Context";case w:return(d._context.displayName||"Context")+".Consumer";case k:var f=d.render;return d=d.displayName,d||(d=f.displayName||f.name||"",d=d!==""?"ForwardRef("+d+")":"ForwardRef"),d;case E:return f=d.displayName||null,f!==null?f:U(d.type)||"Memo";case R:f=d._payload,d=d._init;try{return U(d(f))}catch{}}return null}var W=Array.isArray,B=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,H=n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,j={pending:!1,data:null,method:null,action:null},Z=[],te=-1;function V(d){return{current:d}}function Q(d){0>te||(d.current=Z[te],Z[te]=null,te--)}function ee(d,f){te++,Z[te]=d.current,d.current=f}var ae=V(null),de=V(null),ke=V(null),Te=V(null);function $e(d,f){switch(ee(ke,f),ee(de,d),ee(ae,null),f.nodeType){case 9:case 11:d=(d=f.documentElement)&&(d=d.namespaceURI)?kW(d):0;break;default:if(d=f.tagName,f=f.namespaceURI)f=kW(f),d=IW(f,d);else switch(d){case"svg":d=1;break;case"math":d=2;break;default:d=0}}Q(ae),ee(ae,d)}function Le(){Q(ae),Q(de),Q(ke)}function Ge(d){d.memoizedState!==null&&ee(Te,d);var f=ae.current,x=IW(f,d.type);f!==x&&(ee(de,d),ee(ae,x))}function Ke(d){de.current===d&&(Q(ae),Q(de)),Te.current===d&&(Q(Te),pv._currentValue=j)}var at,vt;function ot(d){if(at===void 0)try{throw Error()}catch(x){var f=x.stack.trim().match(/\n( *(at )?)/);at=f&&f[1]||"",vt=-1<x.stack.indexOf(`
    at`)?" (<anonymous>)":-1<x.stack.indexOf("@")?"@unknown:0:0":""}return`
`+at+d+vt}var lt=!1;function tt(d,f){if(!d||lt)return"";lt=!0;var x=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var A={DetermineComponentFrameRoot:function(){try{if(f){var Ve=function(){throw Error()};if(Object.defineProperty(Ve.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Ve,[])}catch(De){var Ee=De}Reflect.construct(d,[],Ve)}else{try{Ve.call()}catch(De){Ee=De}d.call(Ve.prototype)}}else{try{throw Error()}catch(De){Ee=De}(Ve=d())&&typeof Ve.catch=="function"&&Ve.catch(function(){})}}catch(De){if(De&&Ee&&typeof De.stack=="string")return[De.stack,Ee.stack]}return[null,null]}};A.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var N=Object.getOwnPropertyDescriptor(A.DetermineComponentFrameRoot,"name");N&&N.configurable&&Object.defineProperty(A.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var C=A.DetermineComponentFrameRoot(),z=C[0],Y=C[1];if(z&&Y){var ue=z.split(`
`),Ce=Y.split(`
`);for(N=A=0;A<ue.length&&!ue[A].includes("DetermineComponentFrameRoot");)A++;for(;N<Ce.length&&!Ce[N].includes("DetermineComponentFrameRoot");)N++;if(A===ue.length||N===Ce.length)for(A=ue.length-1,N=Ce.length-1;1<=A&&0<=N&&ue[A]!==Ce[N];)N--;for(;1<=A&&0<=N;A--,N--)if(ue[A]!==Ce[N]){if(A!==1||N!==1)do if(A--,N--,0>N||ue[A]!==Ce[N]){var ze=`
`+ue[A].replace(" at new "," at ");return d.displayName&&ze.includes("<anonymous>")&&(ze=ze.replace("<anonymous>",d.displayName)),ze}while(1<=A&&0<=N);break}}}finally{lt=!1,Error.prepareStackTrace=x}return(x=d?d.displayName||d.name:"")?ot(x):""}function wt(d,f){switch(d.tag){case 26:case 27:case 5:return ot(d.type);case 16:return ot("Lazy");case 13:return d.child!==f&&f!==null?ot("Suspense Fallback"):ot("Suspense");case 19:return ot("SuspenseList");case 0:case 15:return tt(d.type,!1);case 11:return tt(d.type.render,!1);case 1:return tt(d.type,!0);case 31:return ot("Activity");default:return""}}function It(d){try{var f="",x=null;do f+=wt(d,x),x=d,d=d.return;while(d);return f}catch(A){return`
Error generating stack: `+A.message+`
`+A.stack}}var jn=Object.prototype.hasOwnProperty,Dt=e.unstable_scheduleCallback,qn=e.unstable_cancelCallback,yn=e.unstable_shouldYield,ca=e.unstable_requestPaint,nn=e.unstable_now,ua=e.unstable_getCurrentPriorityLevel,ea=e.unstable_ImmediatePriority,Cn=e.unstable_UserBlockingPriority,ta=e.unstable_NormalPriority,ys=e.unstable_LowPriority,po=e.unstable_IdlePriority,Bs=e.log,yu=e.unstable_setDisableYieldValue,Ha=null,ba=null;function Fn(d){if(typeof Bs=="function"&&yu(d),ba&&typeof ba.setStrictMode=="function")try{ba.setStrictMode(Ha,d)}catch{}}var Vr=Math.clz32?Math.clz32:Jm,Qm=Math.log,Zm=Math.LN2;function Jm(d){return d>>>=0,d===0?32:31-(Qm(d)/Zm|0)|0}var oi=256,jo=262144,bu=4194304;function Ps(d){var f=d&42;if(f!==0)return f;switch(d&-d){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return d&261888;case 262144:case 524288:case 1048576:case 2097152:return d&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return d&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return d}}function fo(d,f,x){var A=d.pendingLanes;if(A===0)return 0;var N=0,C=d.suspendedLanes,z=d.pingedLanes;d=d.warmLanes;var Y=A&134217727;return Y!==0?(A=Y&~C,A!==0?N=Ps(A):(z&=Y,z!==0?N=Ps(z):x||(x=Y&~d,x!==0&&(N=Ps(x))))):(Y=A&~C,Y!==0?N=Ps(Y):z!==0?N=Ps(z):x||(x=A&~d,x!==0&&(N=Ps(x)))),N===0?0:f!==0&&f!==N&&(f&C)===0&&(C=N&-N,x=f&-f,C>=x||C===32&&(x&4194048)!==0)?f:N}function Nl(d,f){return(d.pendingLanes&~(d.suspendedLanes&~d.pingedLanes)&f)===0}function Me(d,f){switch(d){case 1:case 2:case 4:case 8:case 64:return f+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function je(){var d=bu;return bu<<=1,(bu&62914560)===0&&(bu=4194304),d}function At(d){for(var f=[],x=0;31>x;x++)f.push(d);return f}function Ye(d,f){d.pendingLanes|=f,f!==268435456&&(d.suspendedLanes=0,d.pingedLanes=0,d.warmLanes=0)}function Mn(d,f,x,A,N,C){var z=d.pendingLanes;d.pendingLanes=x,d.suspendedLanes=0,d.pingedLanes=0,d.warmLanes=0,d.expiredLanes&=x,d.entangledLanes&=x,d.errorRecoveryDisabledLanes&=x,d.shellSuspendCounter=0;var Y=d.entanglements,ue=d.expirationTimes,Ce=d.hiddenUpdates;for(x=z&~x;0<x;){var ze=31-Vr(x),Ve=1<<ze;Y[ze]=0,ue[ze]=-1;var Ee=Ce[ze];if(Ee!==null)for(Ce[ze]=null,ze=0;ze<Ee.length;ze++){var De=Ee[ze];De!==null&&(De.lane&=-536870913)}x&=~Ve}A!==0&&Kn(d,A,0),C!==0&&N===0&&d.tag!==0&&(d.suspendedLanes|=C&~(z&~f))}function Kn(d,f,x){d.pendingLanes|=f,d.suspendedLanes&=~f;var A=31-Vr(f);d.entangledLanes|=f,d.entanglements[A]=d.entanglements[A]|1073741824|x&261930}function Pt(d,f){var x=d.entangledLanes|=f;for(d=d.entanglements;x;){var A=31-Vr(x),N=1<<A;N&f|d[A]&f&&(d[A]|=f),x&=~N}}function Ot(d,f){var x=f&-f;return x=(x&42)!==0?1:ha(x),(x&(d.suspendedLanes|f))!==0?0:x}function ha(d){switch(d){case 2:d=1;break;case 8:d=4;break;case 32:d=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:d=128;break;case 268435456:d=134217728;break;default:d=0}return d}function as(d){return d&=-d,2<d?8<d?(d&134217727)!==0?32:268435456:8:2}function mo(){var d=H.p;return d!==0?d:(d=window.event,d===void 0?32:KW(d.type))}function Ad(d,f){var x=H.p;try{return H.p=d,f()}finally{H.p=x}}var li=Math.random().toString(36).slice(2),Da="__reactFiber$"+li,Sn="__reactProps$"+li,Vs="__reactContainer$"+li,kc="__reactEvents$"+li,QE="__reactListeners$"+li,S0="__reactHandles$"+li,_S="__reactResources$"+li,Sd="__reactMarker$"+li;function k0(d){delete d[Da],delete d[Sn],delete d[kc],delete d[QE],delete d[S0]}function go(d){var f=d[Da];if(f)return f;for(var x=d.parentNode;x;){if(f=x[Vs]||x[Da]){if(x=f.alternate,f.child!==null||x!==null&&x.child!==null)for(d=RW(d);d!==null;){if(x=d[Da])return x;d=RW(d)}return f}d=x,x=d.parentNode}return null}function Ic(d){if(d=d[Da]||d[Vs]){var f=d.tag;if(f===5||f===6||f===13||f===31||f===26||f===27||f===3)return d}return null}function kd(d){var f=d.tag;if(f===5||f===26||f===27||f===6)return d.stateNode;throw Error(a(33))}function xu(d){var f=d[_S];return f||(f=d[_S]={hoistableStyles:new Map,hoistableScripts:new Map}),f}function sr(d){d[Sd]=!0}var eg=new Set,RS={};function vu(d,f){Nc(d,f),Nc(d+"Capture",f)}function Nc(d,f){for(RS[d]=f,d=0;d<f.length;d++)eg.add(f[d])}var Cc=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),tg={},DS={};function ZE(d){return jn.call(DS,d)?!0:jn.call(tg,d)?!1:Cc.test(d)?DS[d]=!0:(tg[d]=!0,!1)}function ng(d,f,x){if(ZE(f))if(x===null)d.removeAttribute(f);else{switch(typeof x){case"undefined":case"function":case"symbol":d.removeAttribute(f);return;case"boolean":var A=f.toLowerCase().slice(0,5);if(A!=="data-"&&A!=="aria-"){d.removeAttribute(f);return}}d.setAttribute(f,""+x)}}function ag(d,f,x){if(x===null)d.removeAttribute(f);else{switch(typeof x){case"undefined":case"function":case"symbol":case"boolean":d.removeAttribute(f);return}d.setAttribute(f,""+x)}}function yo(d,f,x,A){if(A===null)d.removeAttribute(x);else{switch(typeof A){case"undefined":case"function":case"symbol":case"boolean":d.removeAttribute(x);return}d.setAttributeNS(f,x,""+A)}}function Us(d){switch(typeof d){case"bigint":case"boolean":case"number":case"string":case"undefined":return d;case"object":return d;default:return""}}function OS(d){var f=d.type;return(d=d.nodeName)&&d.toLowerCase()==="input"&&(f==="checkbox"||f==="radio")}function JE(d,f,x){var A=Object.getOwnPropertyDescriptor(d.constructor.prototype,f);if(!d.hasOwnProperty(f)&&typeof A<"u"&&typeof A.get=="function"&&typeof A.set=="function"){var N=A.get,C=A.set;return Object.defineProperty(d,f,{configurable:!0,get:function(){return N.call(this)},set:function(z){x=""+z,C.call(this,z)}}),Object.defineProperty(d,f,{enumerable:A.enumerable}),{getValue:function(){return x},setValue:function(z){x=""+z},stopTracking:function(){d._valueTracker=null,delete d[f]}}}}function rg(d){if(!d._valueTracker){var f=OS(d)?"checked":"value";d._valueTracker=JE(d,f,""+d[f])}}function I0(d){if(!d)return!1;var f=d._valueTracker;if(!f)return!0;var x=f.getValue(),A="";return d&&(A=OS(d)?d.checked?"true":"false":d.value),d=A,d!==x?(f.setValue(d),!0):!1}function sg(d){if(d=d||(typeof document<"u"?document:void 0),typeof d>"u")return null;try{return d.activeElement||d.body}catch{return d.body}}var e$=/[\n"\\]/g;function ui(d){return d.replace(e$,function(f){return"\\"+f.charCodeAt(0).toString(16)+" "})}function N0(d,f,x,A,N,C,z,Y){d.name="",z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"?d.type=z:d.removeAttribute("type"),f!=null?z==="number"?(f===0&&d.value===""||d.value!=f)&&(d.value=""+Us(f)):d.value!==""+Us(f)&&(d.value=""+Us(f)):z!=="submit"&&z!=="reset"||d.removeAttribute("value"),f!=null?Tc(d,z,Us(f)):x!=null?Tc(d,z,Us(x)):A!=null&&d.removeAttribute("value"),N==null&&C!=null&&(d.defaultChecked=!!C),N!=null&&(d.checked=N&&typeof N!="function"&&typeof N!="symbol"),Y!=null&&typeof Y!="function"&&typeof Y!="symbol"&&typeof Y!="boolean"?d.name=""+Us(Y):d.removeAttribute("name")}function C0(d,f,x,A,N,C,z,Y){if(C!=null&&typeof C!="function"&&typeof C!="symbol"&&typeof C!="boolean"&&(d.type=C),f!=null||x!=null){if(!(C!=="submit"&&C!=="reset"||f!=null)){rg(d);return}x=x!=null?""+Us(x):"",f=f!=null?""+Us(f):x,Y||f===d.value||(d.value=f),d.defaultValue=f}A=A??N,A=typeof A!="function"&&typeof A!="symbol"&&!!A,d.checked=Y?d.checked:!!A,d.defaultChecked=!!A,z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"&&(d.name=z),rg(d)}function Tc(d,f,x){f==="number"&&sg(d.ownerDocument)===d||d.defaultValue===""+x||(d.defaultValue=""+x)}function wu(d,f,x,A){if(d=d.options,f){f={};for(var N=0;N<x.length;N++)f["$"+x[N]]=!0;for(x=0;x<d.length;x++)N=f.hasOwnProperty("$"+d[x].value),d[x].selected!==N&&(d[x].selected=N),N&&A&&(d[x].defaultSelected=!0)}else{for(x=""+Us(x),f=null,N=0;N<d.length;N++){if(d[N].value===x){d[N].selected=!0,A&&(d[N].defaultSelected=!0);return}f!==null||d[N].disabled||(f=d[N])}f!==null&&(f.selected=!0)}}function T0(d,f,x){if(f!=null&&(f=""+Us(f),f!==d.value&&(d.value=f),x==null)){d.defaultValue!==f&&(d.defaultValue=f);return}d.defaultValue=x!=null?""+Us(x):""}function E0(d,f,x,A){if(f==null){if(A!=null){if(x!=null)throw Error(a(92));if(W(A)){if(1<A.length)throw Error(a(93));A=A[0]}x=A}x==null&&(x=""),f=x}x=Us(f),d.defaultValue=x,A=d.textContent,A===x&&A!==""&&A!==null&&(d.value=A),rg(d)}function Cl(d,f){if(f){var x=d.firstChild;if(x&&x===d.lastChild&&x.nodeType===3){x.nodeValue=f;return}}d.textContent=f}var FS=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function $0(d,f,x){var A=f.indexOf("--")===0;x==null||typeof x=="boolean"||x===""?A?d.setProperty(f,""):f==="float"?d.cssFloat="":d[f]="":A?d.setProperty(f,x):typeof x!="number"||x===0||FS.has(f)?f==="float"?d.cssFloat=x:d[f]=(""+x).trim():d[f]=x+"px"}function ig(d,f,x){if(f!=null&&typeof f!="object")throw Error(a(62));if(d=d.style,x!=null){for(var A in x)!x.hasOwnProperty(A)||f!=null&&f.hasOwnProperty(A)||(A.indexOf("--")===0?d.setProperty(A,""):A==="float"?d.cssFloat="":d[A]="");for(var N in f)A=f[N],f.hasOwnProperty(N)&&x[N]!==A&&$0(d,N,A)}else for(var C in f)f.hasOwnProperty(C)&&$0(d,C,f[C])}function Ec(d){if(d.indexOf("-")===-1)return!1;switch(d){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var og=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),lg=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Id(d){return lg.test(""+d)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":d}function ci(){}var $c=null;function _0(d){return d=d.target||d.srcElement||window,d.correspondingUseElement&&(d=d.correspondingUseElement),d.nodeType===3?d.parentNode:d}var ne=null,we=null;function qe(d){var f=Ic(d);if(f&&(d=f.stateNode)){var x=d[Sn]||null;e:switch(d=f.stateNode,f.type){case"input":if(N0(d,x.value,x.defaultValue,x.defaultValue,x.checked,x.defaultChecked,x.type,x.name),f=x.name,x.type==="radio"&&f!=null){for(x=d;x.parentNode;)x=x.parentNode;for(x=x.querySelectorAll('input[name="'+ui(""+f)+'"][type="radio"]'),f=0;f<x.length;f++){var A=x[f];if(A!==d&&A.form===d.form){var N=A[Sn]||null;if(!N)throw Error(a(90));N0(A,N.value,N.defaultValue,N.defaultValue,N.checked,N.defaultChecked,N.type,N.name)}}for(f=0;f<x.length;f++)A=x[f],A.form===d.form&&I0(A)}break e;case"textarea":T0(d,x.value,x.defaultValue);break e;case"select":f=x.value,f!=null&&wu(d,!!x.multiple,f,!1)}}}var Nt=!1;function Rt(d,f,x){if(Nt)return d(f,x);Nt=!0;try{var A=d(f);return A}finally{if(Nt=!1,(ne!==null||we!==null)&&(xk(),ne&&(f=ne,d=we,we=ne=null,qe(f),d)))for(f=0;f<d.length;f++)qe(d[f])}}function _t(d,f){var x=d.stateNode;if(x===null)return null;var A=x[Sn]||null;if(A===null)return null;x=A[f];e:switch(f){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(A=!A.disabled)||(d=d.type,A=!(d==="button"||d==="input"||d==="select"||d==="textarea")),d=!A;break e;default:d=!1}if(d)return null;if(x&&typeof x!="function")throw Error(a(231,f,typeof x));return x}var Qe=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),yt=!1;if(Qe)try{var Tn={};Object.defineProperty(Tn,"passive",{get:function(){yt=!0}}),window.addEventListener("test",Tn,Tn),window.removeEventListener("test",Tn,Tn)}catch{yt=!1}var Oa=null,Bi=null,Nd=null;function ug(){if(Nd)return Nd;var d,f=Bi,x=f.length,A,N="value"in Oa?Oa.value:Oa.textContent,C=N.length;for(d=0;d<x&&f[d]===N[d];d++);var z=x-d;for(A=1;A<=z&&f[x-A]===N[C-A];A++);return Nd=N.slice(d,1<A?1-A:void 0)}function cg(d){var f=d.keyCode;return"charCode"in d?(d=d.charCode,d===0&&f===13&&(d=13)):d=f,d===10&&(d=13),32<=d||d===13?d:0}function Ur(){return!0}function Au(){return!1}function rs(d){function f(x,A,N,C,z){this._reactName=x,this._targetInst=N,this.type=A,this.nativeEvent=C,this.target=z,this.currentTarget=null;for(var Y in d)d.hasOwnProperty(Y)&&(x=d[Y],this[Y]=x?x(C):C[Y]);return this.isDefaultPrevented=(C.defaultPrevented!=null?C.defaultPrevented:C.returnValue===!1)?Ur:Au,this.isPropagationStopped=Au,this}return h(f.prototype,{preventDefault:function(){this.defaultPrevented=!0;var x=this.nativeEvent;x&&(x.preventDefault?x.preventDefault():typeof x.returnValue!="unknown"&&(x.returnValue=!1),this.isDefaultPrevented=Ur)},stopPropagation:function(){var x=this.nativeEvent;x&&(x.stopPropagation?x.stopPropagation():typeof x.cancelBubble!="unknown"&&(x.cancelBubble=!0),this.isPropagationStopped=Ur)},persist:function(){},isPersistent:Ur}),f}var Cd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(d){return d.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},MS=rs(Cd),R0=h({},Cd,{view:0,detail:0}),Kie=rs(R0),t$,n$,D0,LS=h({},R0,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:r$,button:0,buttons:0,relatedTarget:function(d){return d.relatedTarget===void 0?d.fromElement===d.srcElement?d.toElement:d.fromElement:d.relatedTarget},movementX:function(d){return"movementX"in d?d.movementX:(d!==D0&&(D0&&d.type==="mousemove"?(t$=d.screenX-D0.screenX,n$=d.screenY-D0.screenY):n$=t$=0,D0=d),t$)},movementY:function(d){return"movementY"in d?d.movementY:n$}}),C4=rs(LS),Xie=h({},LS,{dataTransfer:0}),Yie=rs(Xie),Qie=h({},R0,{relatedTarget:0}),a$=rs(Qie),Zie=h({},Cd,{animationName:0,elapsedTime:0,pseudoElement:0}),Jie=rs(Zie),eoe=h({},Cd,{clipboardData:function(d){return"clipboardData"in d?d.clipboardData:window.clipboardData}}),toe=rs(eoe),noe=h({},Cd,{data:0}),T4=rs(noe),aoe={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},roe={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},soe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function ioe(d){var f=this.nativeEvent;return f.getModifierState?f.getModifierState(d):(d=soe[d])?!!f[d]:!1}function r$(){return ioe}var ooe=h({},R0,{key:function(d){if(d.key){var f=aoe[d.key]||d.key;if(f!=="Unidentified")return f}return d.type==="keypress"?(d=cg(d),d===13?"Enter":String.fromCharCode(d)):d.type==="keydown"||d.type==="keyup"?roe[d.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:r$,charCode:function(d){return d.type==="keypress"?cg(d):0},keyCode:function(d){return d.type==="keydown"||d.type==="keyup"?d.keyCode:0},which:function(d){return d.type==="keypress"?cg(d):d.type==="keydown"||d.type==="keyup"?d.keyCode:0}}),loe=rs(ooe),uoe=h({},LS,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),E4=rs(uoe),coe=h({},R0,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:r$}),hoe=rs(coe),doe=h({},Cd,{propertyName:0,elapsedTime:0,pseudoElement:0}),poe=rs(doe),foe=h({},LS,{deltaX:function(d){return"deltaX"in d?d.deltaX:"wheelDeltaX"in d?-d.wheelDeltaX:0},deltaY:function(d){return"deltaY"in d?d.deltaY:"wheelDeltaY"in d?-d.wheelDeltaY:"wheelDelta"in d?-d.wheelDelta:0},deltaZ:0,deltaMode:0}),moe=rs(foe),goe=h({},Cd,{newState:0,oldState:0}),yoe=rs(goe),boe=[9,13,27,32],s$=Qe&&"CompositionEvent"in window,O0=null;Qe&&"documentMode"in document&&(O0=document.documentMode);var xoe=Qe&&"TextEvent"in window&&!O0,$4=Qe&&(!s$||O0&&8<O0&&11>=O0),_4=" ",R4=!1;function D4(d,f){switch(d){case"keyup":return boe.indexOf(f.keyCode)!==-1;case"keydown":return f.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function O4(d){return d=d.detail,typeof d=="object"&&"data"in d?d.data:null}var hg=!1;function voe(d,f){switch(d){case"compositionend":return O4(f);case"keypress":return f.which!==32?null:(R4=!0,_4);case"textInput":return d=f.data,d===_4&&R4?null:d;default:return null}}function woe(d,f){if(hg)return d==="compositionend"||!s$&&D4(d,f)?(d=ug(),Nd=Bi=Oa=null,hg=!1,d):null;switch(d){case"paste":return null;case"keypress":if(!(f.ctrlKey||f.altKey||f.metaKey)||f.ctrlKey&&f.altKey){if(f.char&&1<f.char.length)return f.char;if(f.which)return String.fromCharCode(f.which)}return null;case"compositionend":return $4&&f.locale!=="ko"?null:f.data;default:return null}}var Aoe={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function F4(d){var f=d&&d.nodeName&&d.nodeName.toLowerCase();return f==="input"?!!Aoe[d.type]:f==="textarea"}function M4(d,f,x,A){ne?we?we.push(A):we=[A]:ne=A,f=Nk(f,"onChange"),0<f.length&&(x=new MS("onChange","change",null,x,A),d.push({event:x,listeners:f}))}var F0=null,M0=null;function Soe(d){bW(d,0)}function zS(d){var f=kd(d);if(I0(f))return d}function L4(d,f){if(d==="change")return f}var z4=!1;if(Qe){var i$;if(Qe){var o$="oninput"in document;if(!o$){var B4=document.createElement("div");B4.setAttribute("oninput","return;"),o$=typeof B4.oninput=="function"}i$=o$}else i$=!1;z4=i$&&(!document.documentMode||9<document.documentMode)}function P4(){F0&&(F0.detachEvent("onpropertychange",V4),M0=F0=null)}function V4(d){if(d.propertyName==="value"&&zS(M0)){var f=[];M4(f,M0,d,_0(d)),Rt(Soe,f)}}function koe(d,f,x){d==="focusin"?(P4(),F0=f,M0=x,F0.attachEvent("onpropertychange",V4)):d==="focusout"&&P4()}function Ioe(d){if(d==="selectionchange"||d==="keyup"||d==="keydown")return zS(M0)}function Noe(d,f){if(d==="click")return zS(f)}function Coe(d,f){if(d==="input"||d==="change")return zS(f)}function Toe(d,f){return d===f&&(d!==0||1/d===1/f)||d!==d&&f!==f}var Pi=typeof Object.is=="function"?Object.is:Toe;function L0(d,f){if(Pi(d,f))return!0;if(typeof d!="object"||d===null||typeof f!="object"||f===null)return!1;var x=Object.keys(d),A=Object.keys(f);if(x.length!==A.length)return!1;for(A=0;A<x.length;A++){var N=x[A];if(!jn.call(f,N)||!Pi(d[N],f[N]))return!1}return!0}function U4(d){for(;d&&d.firstChild;)d=d.firstChild;return d}function W4(d,f){var x=U4(d);d=0;for(var A;x;){if(x.nodeType===3){if(A=d+x.textContent.length,d<=f&&A>=f)return{node:x,offset:f-d};d=A}e:{for(;x;){if(x.nextSibling){x=x.nextSibling;break e}x=x.parentNode}x=void 0}x=U4(x)}}function G4(d,f){return d&&f?d===f?!0:d&&d.nodeType===3?!1:f&&f.nodeType===3?G4(d,f.parentNode):"contains"in d?d.contains(f):d.compareDocumentPosition?!!(d.compareDocumentPosition(f)&16):!1:!1}function H4(d){d=d!=null&&d.ownerDocument!=null&&d.ownerDocument.defaultView!=null?d.ownerDocument.defaultView:window;for(var f=sg(d.document);f instanceof d.HTMLIFrameElement;){try{var x=typeof f.contentWindow.location.href=="string"}catch{x=!1}if(x)d=f.contentWindow;else break;f=sg(d.document)}return f}function l$(d){var f=d&&d.nodeName&&d.nodeName.toLowerCase();return f&&(f==="input"&&(d.type==="text"||d.type==="search"||d.type==="tel"||d.type==="url"||d.type==="password")||f==="textarea"||d.contentEditable==="true")}var Eoe=Qe&&"documentMode"in document&&11>=document.documentMode,dg=null,u$=null,z0=null,c$=!1;function j4(d,f,x){var A=x.window===x?x.document:x.nodeType===9?x:x.ownerDocument;c$||dg==null||dg!==sg(A)||(A=dg,"selectionStart"in A&&l$(A)?A={start:A.selectionStart,end:A.selectionEnd}:(A=(A.ownerDocument&&A.ownerDocument.defaultView||window).getSelection(),A={anchorNode:A.anchorNode,anchorOffset:A.anchorOffset,focusNode:A.focusNode,focusOffset:A.focusOffset}),z0&&L0(z0,A)||(z0=A,A=Nk(u$,"onSelect"),0<A.length&&(f=new MS("onSelect","select",null,f,x),d.push({event:f,listeners:A}),f.target=dg)))}function Td(d,f){var x={};return x[d.toLowerCase()]=f.toLowerCase(),x["Webkit"+d]="webkit"+f,x["Moz"+d]="moz"+f,x}var pg={animationend:Td("Animation","AnimationEnd"),animationiteration:Td("Animation","AnimationIteration"),animationstart:Td("Animation","AnimationStart"),transitionrun:Td("Transition","TransitionRun"),transitionstart:Td("Transition","TransitionStart"),transitioncancel:Td("Transition","TransitionCancel"),transitionend:Td("Transition","TransitionEnd")},h$={},q4={};Qe&&(q4=document.createElement("div").style,"AnimationEvent"in window||(delete pg.animationend.animation,delete pg.animationiteration.animation,delete pg.animationstart.animation),"TransitionEvent"in window||delete pg.transitionend.transition);function Ed(d){if(h$[d])return h$[d];if(!pg[d])return d;var f=pg[d],x;for(x in f)if(f.hasOwnProperty(x)&&x in q4)return h$[d]=f[x];return d}var K4=Ed("animationend"),X4=Ed("animationiteration"),Y4=Ed("animationstart"),$oe=Ed("transitionrun"),_oe=Ed("transitionstart"),Roe=Ed("transitioncancel"),Q4=Ed("transitionend"),Z4=new Map,d$="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");d$.push("scrollEnd");function qo(d,f){Z4.set(d,f),vu(f,[d])}var BS=typeof reportError=="function"?reportError:function(d){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var f=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof d=="object"&&d!==null&&typeof d.message=="string"?String(d.message):String(d),error:d});if(!window.dispatchEvent(f))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",d);return}console.error(d)},bo=[],fg=0,p$=0;function PS(){for(var d=fg,f=p$=fg=0;f<d;){var x=bo[f];bo[f++]=null;var A=bo[f];bo[f++]=null;var N=bo[f];bo[f++]=null;var C=bo[f];if(bo[f++]=null,A!==null&&N!==null){var z=A.pending;z===null?N.next=N:(N.next=z.next,z.next=N),A.pending=N}C!==0&&J4(x,N,C)}}function VS(d,f,x,A){bo[fg++]=d,bo[fg++]=f,bo[fg++]=x,bo[fg++]=A,p$|=A,d.lanes|=A,d=d.alternate,d!==null&&(d.lanes|=A)}function f$(d,f,x,A){return VS(d,f,x,A),US(d)}function $d(d,f){return VS(d,null,null,f),US(d)}function J4(d,f,x){d.lanes|=x;var A=d.alternate;A!==null&&(A.lanes|=x);for(var N=!1,C=d.return;C!==null;)C.childLanes|=x,A=C.alternate,A!==null&&(A.childLanes|=x),C.tag===22&&(d=C.stateNode,d===null||d._visibility&1||(N=!0)),d=C,C=C.return;return d.tag===3?(C=d.stateNode,N&&f!==null&&(N=31-Vr(x),d=C.hiddenUpdates,A=d[N],A===null?d[N]=[f]:A.push(f),f.lane=x|536870912),C):null}function US(d){if(50<iv)throw iv=0,S_=null,Error(a(185));for(var f=d.return;f!==null;)d=f,f=d.return;return d.tag===3?d.stateNode:null}var mg={};function Doe(d,f,x,A){this.tag=d,this.key=x,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=f,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=A,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Vi(d,f,x,A){return new Doe(d,f,x,A)}function m$(d){return d=d.prototype,!(!d||!d.isReactComponent)}function Su(d,f){var x=d.alternate;return x===null?(x=Vi(d.tag,f,d.key,d.mode),x.elementType=d.elementType,x.type=d.type,x.stateNode=d.stateNode,x.alternate=d,d.alternate=x):(x.pendingProps=f,x.type=d.type,x.flags=0,x.subtreeFlags=0,x.deletions=null),x.flags=d.flags&65011712,x.childLanes=d.childLanes,x.lanes=d.lanes,x.child=d.child,x.memoizedProps=d.memoizedProps,x.memoizedState=d.memoizedState,x.updateQueue=d.updateQueue,f=d.dependencies,x.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext},x.sibling=d.sibling,x.index=d.index,x.ref=d.ref,x.refCleanup=d.refCleanup,x}function eV(d,f){d.flags&=65011714;var x=d.alternate;return x===null?(d.childLanes=0,d.lanes=f,d.child=null,d.subtreeFlags=0,d.memoizedProps=null,d.memoizedState=null,d.updateQueue=null,d.dependencies=null,d.stateNode=null):(d.childLanes=x.childLanes,d.lanes=x.lanes,d.child=x.child,d.subtreeFlags=0,d.deletions=null,d.memoizedProps=x.memoizedProps,d.memoizedState=x.memoizedState,d.updateQueue=x.updateQueue,d.type=x.type,f=x.dependencies,d.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext}),d}function WS(d,f,x,A,N,C){var z=0;if(A=d,typeof d=="function")m$(d)&&(z=1);else if(typeof d=="string")z=zle(d,x,ae.current)?26:d==="html"||d==="head"||d==="body"?27:5;else e:switch(d){case D:return d=Vi(31,x,f,N),d.elementType=D,d.lanes=C,d;case y:return _d(x.children,N,C,f);case b:z=8,N|=24;break;case v:return d=Vi(12,x,f,N|2),d.elementType=v,d.lanes=C,d;case I:return d=Vi(13,x,f,N),d.elementType=I,d.lanes=C,d;case T:return d=Vi(19,x,f,N),d.elementType=T,d.lanes=C,d;default:if(typeof d=="object"&&d!==null)switch(d.$$typeof){case S:z=10;break e;case w:z=9;break e;case k:z=11;break e;case E:z=14;break e;case R:z=16,A=null;break e}z=29,x=Error(a(130,d===null?"null":typeof d,"")),A=null}return f=Vi(z,x,f,N),f.elementType=d,f.type=A,f.lanes=C,f}function _d(d,f,x,A){return d=Vi(7,d,A,f),d.lanes=x,d}function g$(d,f,x){return d=Vi(6,d,null,f),d.lanes=x,d}function tV(d){var f=Vi(18,null,null,0);return f.stateNode=d,f}function y$(d,f,x){return f=Vi(4,d.children!==null?d.children:[],d.key,f),f.lanes=x,f.stateNode={containerInfo:d.containerInfo,pendingChildren:null,implementation:d.implementation},f}var nV=new WeakMap;function xo(d,f){if(typeof d=="object"&&d!==null){var x=nV.get(d);return x!==void 0?x:(f={value:d,source:f,stack:It(f)},nV.set(d,f),f)}return{value:d,source:f,stack:It(f)}}var gg=[],yg=0,GS=null,B0=0,vo=[],wo=0,_c=null,Tl=1,El="";function ku(d,f){gg[yg++]=B0,gg[yg++]=GS,GS=d,B0=f}function aV(d,f,x){vo[wo++]=Tl,vo[wo++]=El,vo[wo++]=_c,_c=d;var A=Tl;d=El;var N=32-Vr(A)-1;A&=~(1<<N),x+=1;var C=32-Vr(f)+N;if(30<C){var z=N-N%5;C=(A&(1<<z)-1).toString(32),A>>=z,N-=z,Tl=1<<32-Vr(f)+N|x<<N|A,El=C+d}else Tl=1<<C|x<<N|A,El=d}function b$(d){d.return!==null&&(ku(d,1),aV(d,1,0))}function x$(d){for(;d===GS;)GS=gg[--yg],gg[yg]=null,B0=gg[--yg],gg[yg]=null;for(;d===_c;)_c=vo[--wo],vo[wo]=null,El=vo[--wo],vo[wo]=null,Tl=vo[--wo],vo[wo]=null}function rV(d,f){vo[wo++]=Tl,vo[wo++]=El,vo[wo++]=_c,Tl=f.id,El=f.overflow,_c=d}var ss=null,da=null,fn=!1,Rc=null,Ao=!1,v$=Error(a(519));function Dc(d){var f=Error(a(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw P0(xo(f,d)),v$}function sV(d){var f=d.stateNode,x=d.type,A=d.memoizedProps;switch(f[Da]=d,f[Sn]=A,x){case"dialog":sn("cancel",f),sn("close",f);break;case"iframe":case"object":case"embed":sn("load",f);break;case"video":case"audio":for(x=0;x<lv.length;x++)sn(lv[x],f);break;case"source":sn("error",f);break;case"img":case"image":case"link":sn("error",f),sn("load",f);break;case"details":sn("toggle",f);break;case"input":sn("invalid",f),C0(f,A.value,A.defaultValue,A.checked,A.defaultChecked,A.type,A.name,!0);break;case"select":sn("invalid",f);break;case"textarea":sn("invalid",f),E0(f,A.value,A.defaultValue,A.children)}x=A.children,typeof x!="string"&&typeof x!="number"&&typeof x!="bigint"||f.textContent===""+x||A.suppressHydrationWarning===!0||AW(f.textContent,x)?(A.popover!=null&&(sn("beforetoggle",f),sn("toggle",f)),A.onScroll!=null&&sn("scroll",f),A.onScrollEnd!=null&&sn("scrollend",f),A.onClick!=null&&(f.onclick=ci),f=!0):f=!1,f||Dc(d,!0)}function iV(d){for(ss=d.return;ss;)switch(ss.tag){case 5:case 31:case 13:Ao=!1;return;case 27:case 3:Ao=!0;return;default:ss=ss.return}}function bg(d){if(d!==ss)return!1;if(!fn)return iV(d),fn=!0,!1;var f=d.tag,x;if((x=f!==3&&f!==27)&&((x=f===5)&&(x=d.type,x=!(x!=="form"&&x!=="button")||z_(d.type,d.memoizedProps)),x=!x),x&&da&&Dc(d),iV(d),f===13){if(d=d.memoizedState,d=d!==null?d.dehydrated:null,!d)throw Error(a(317));da=_W(d)}else if(f===31){if(d=d.memoizedState,d=d!==null?d.dehydrated:null,!d)throw Error(a(317));da=_W(d)}else f===27?(f=da,qc(d.type)?(d=W_,W_=null,da=d):da=f):da=ss?ko(d.stateNode.nextSibling):null;return!0}function Rd(){da=ss=null,fn=!1}function w$(){var d=Rc;return d!==null&&(fi===null?fi=d:fi.push.apply(fi,d),Rc=null),d}function P0(d){Rc===null?Rc=[d]:Rc.push(d)}var A$=V(null),Dd=null,Iu=null;function Oc(d,f,x){ee(A$,f._currentValue),f._currentValue=x}function Nu(d){d._currentValue=A$.current,Q(A$)}function S$(d,f,x){for(;d!==null;){var A=d.alternate;if((d.childLanes&f)!==f?(d.childLanes|=f,A!==null&&(A.childLanes|=f)):A!==null&&(A.childLanes&f)!==f&&(A.childLanes|=f),d===x)break;d=d.return}}function k$(d,f,x,A){var N=d.child;for(N!==null&&(N.return=d);N!==null;){var C=N.dependencies;if(C!==null){var z=N.child;C=C.firstContext;e:for(;C!==null;){var Y=C;C=N;for(var ue=0;ue<f.length;ue++)if(Y.context===f[ue]){C.lanes|=x,Y=C.alternate,Y!==null&&(Y.lanes|=x),S$(C.return,x,d),A||(z=null);break e}C=Y.next}}else if(N.tag===18){if(z=N.return,z===null)throw Error(a(341));z.lanes|=x,C=z.alternate,C!==null&&(C.lanes|=x),S$(z,x,d),z=null}else z=N.child;if(z!==null)z.return=N;else for(z=N;z!==null;){if(z===d){z=null;break}if(N=z.sibling,N!==null){N.return=z.return,z=N;break}z=z.return}N=z}}function xg(d,f,x,A){d=null;for(var N=f,C=!1;N!==null;){if(!C){if((N.flags&524288)!==0)C=!0;else if((N.flags&262144)!==0)break}if(N.tag===10){var z=N.alternate;if(z===null)throw Error(a(387));if(z=z.memoizedProps,z!==null){var Y=N.type;Pi(N.pendingProps.value,z.value)||(d!==null?d.push(Y):d=[Y])}}else if(N===Te.current){if(z=N.alternate,z===null)throw Error(a(387));z.memoizedState.memoizedState!==N.memoizedState.memoizedState&&(d!==null?d.push(pv):d=[pv])}N=N.return}d!==null&&k$(f,d,x,A),f.flags|=262144}function HS(d){for(d=d.firstContext;d!==null;){if(!Pi(d.context._currentValue,d.memoizedValue))return!0;d=d.next}return!1}function Od(d){Dd=d,Iu=null,d=d.dependencies,d!==null&&(d.firstContext=null)}function is(d){return oV(Dd,d)}function jS(d,f){return Dd===null&&Od(d),oV(d,f)}function oV(d,f){var x=f._currentValue;if(f={context:f,memoizedValue:x,next:null},Iu===null){if(d===null)throw Error(a(308));Iu=f,d.dependencies={lanes:0,firstContext:f},d.flags|=524288}else Iu=Iu.next=f;return x}var Ooe=typeof AbortController<"u"?AbortController:function(){var d=[],f=this.signal={aborted:!1,addEventListener:function(x,A){d.push(A)}};this.abort=function(){f.aborted=!0,d.forEach(function(x){return x()})}},Foe=e.unstable_scheduleCallback,Moe=e.unstable_NormalPriority,ir={$$typeof:S,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function I$(){return{controller:new Ooe,data:new Map,refCount:0}}function V0(d){d.refCount--,d.refCount===0&&Foe(Moe,function(){d.controller.abort()})}var U0=null,N$=0,vg=0,wg=null;function Loe(d,f){if(U0===null){var x=U0=[];N$=0,vg=E_(),wg={status:"pending",value:void 0,then:function(A){x.push(A)}}}return N$++,f.then(lV,lV),f}function lV(){if(--N$===0&&U0!==null){wg!==null&&(wg.status="fulfilled");var d=U0;U0=null,vg=0,wg=null;for(var f=0;f<d.length;f++)(0,d[f])()}}function zoe(d,f){var x=[],A={status:"pending",value:null,reason:null,then:function(N){x.push(N)}};return d.then(function(){A.status="fulfilled",A.value=f;for(var N=0;N<x.length;N++)(0,x[N])(f)},function(N){for(A.status="rejected",A.reason=N,N=0;N<x.length;N++)(0,x[N])(void 0)}),A}var uV=B.S;B.S=function(d,f){jU=nn(),typeof f=="object"&&f!==null&&typeof f.then=="function"&&Loe(d,f),uV!==null&&uV(d,f)};var Fd=V(null);function C$(){var d=Fd.current;return d!==null?d:na.pooledCache}function qS(d,f){f===null?ee(Fd,Fd.current):ee(Fd,f.pool)}function cV(){var d=C$();return d===null?null:{parent:ir._currentValue,pool:d}}var Ag=Error(a(460)),T$=Error(a(474)),KS=Error(a(542)),XS={then:function(){}};function hV(d){return d=d.status,d==="fulfilled"||d==="rejected"}function dV(d,f,x){switch(x=d[x],x===void 0?d.push(f):x!==f&&(f.then(ci,ci),f=x),f.status){case"fulfilled":return f.value;case"rejected":throw d=f.reason,fV(d),d;default:if(typeof f.status=="string")f.then(ci,ci);else{if(d=na,d!==null&&100<d.shellSuspendCounter)throw Error(a(482));d=f,d.status="pending",d.then(function(A){if(f.status==="pending"){var N=f;N.status="fulfilled",N.value=A}},function(A){if(f.status==="pending"){var N=f;N.status="rejected",N.reason=A}})}switch(f.status){case"fulfilled":return f.value;case"rejected":throw d=f.reason,fV(d),d}throw Ld=f,Ag}}function Md(d){try{var f=d._init;return f(d._payload)}catch(x){throw x!==null&&typeof x=="object"&&typeof x.then=="function"?(Ld=x,Ag):x}}var Ld=null;function pV(){if(Ld===null)throw Error(a(459));var d=Ld;return Ld=null,d}function fV(d){if(d===Ag||d===KS)throw Error(a(483))}var Sg=null,W0=0;function YS(d){var f=W0;return W0+=1,Sg===null&&(Sg=[]),dV(Sg,d,f)}function G0(d,f){f=f.props.ref,d.ref=f!==void 0?f:null}function QS(d,f){throw f.$$typeof===p?Error(a(525)):(d=Object.prototype.toString.call(f),Error(a(31,d==="[object Object]"?"object with keys {"+Object.keys(f).join(", ")+"}":d)))}function mV(d){function f(ve,be){if(d){var Ne=ve.deletions;Ne===null?(ve.deletions=[be],ve.flags|=16):Ne.push(be)}}function x(ve,be){if(!d)return null;for(;be!==null;)f(ve,be),be=be.sibling;return null}function A(ve){for(var be=new Map;ve!==null;)ve.key!==null?be.set(ve.key,ve):be.set(ve.index,ve),ve=ve.sibling;return be}function N(ve,be){return ve=Su(ve,be),ve.index=0,ve.sibling=null,ve}function C(ve,be,Ne){return ve.index=Ne,d?(Ne=ve.alternate,Ne!==null?(Ne=Ne.index,Ne<be?(ve.flags|=67108866,be):Ne):(ve.flags|=67108866,be)):(ve.flags|=1048576,be)}function z(ve){return d&&ve.alternate===null&&(ve.flags|=67108866),ve}function Y(ve,be,Ne,Be){return be===null||be.tag!==6?(be=g$(Ne,ve.mode,Be),be.return=ve,be):(be=N(be,Ne),be.return=ve,be)}function ue(ve,be,Ne,Be){var Ct=Ne.type;return Ct===y?ze(ve,be,Ne.props.children,Be,Ne.key):be!==null&&(be.elementType===Ct||typeof Ct=="object"&&Ct!==null&&Ct.$$typeof===R&&Md(Ct)===be.type)?(be=N(be,Ne.props),G0(be,Ne),be.return=ve,be):(be=WS(Ne.type,Ne.key,Ne.props,null,ve.mode,Be),G0(be,Ne),be.return=ve,be)}function Ce(ve,be,Ne,Be){return be===null||be.tag!==4||be.stateNode.containerInfo!==Ne.containerInfo||be.stateNode.implementation!==Ne.implementation?(be=y$(Ne,ve.mode,Be),be.return=ve,be):(be=N(be,Ne.children||[]),be.return=ve,be)}function ze(ve,be,Ne,Be,Ct){return be===null||be.tag!==7?(be=_d(Ne,ve.mode,Be,Ct),be.return=ve,be):(be=N(be,Ne),be.return=ve,be)}function Ve(ve,be,Ne){if(typeof be=="string"&&be!==""||typeof be=="number"||typeof be=="bigint")return be=g$(""+be,ve.mode,Ne),be.return=ve,be;if(typeof be=="object"&&be!==null){switch(be.$$typeof){case m:return Ne=WS(be.type,be.key,be.props,null,ve.mode,Ne),G0(Ne,be),Ne.return=ve,Ne;case g:return be=y$(be,ve.mode,Ne),be.return=ve,be;case R:return be=Md(be),Ve(ve,be,Ne)}if(W(be)||_(be))return be=_d(be,ve.mode,Ne,null),be.return=ve,be;if(typeof be.then=="function")return Ve(ve,YS(be),Ne);if(be.$$typeof===S)return Ve(ve,jS(ve,be),Ne);QS(ve,be)}return null}function Ee(ve,be,Ne,Be){var Ct=be!==null?be.key:null;if(typeof Ne=="string"&&Ne!==""||typeof Ne=="number"||typeof Ne=="bigint")return Ct!==null?null:Y(ve,be,""+Ne,Be);if(typeof Ne=="object"&&Ne!==null){switch(Ne.$$typeof){case m:return Ne.key===Ct?ue(ve,be,Ne,Be):null;case g:return Ne.key===Ct?Ce(ve,be,Ne,Be):null;case R:return Ne=Md(Ne),Ee(ve,be,Ne,Be)}if(W(Ne)||_(Ne))return Ct!==null?null:ze(ve,be,Ne,Be,null);if(typeof Ne.then=="function")return Ee(ve,be,YS(Ne),Be);if(Ne.$$typeof===S)return Ee(ve,be,jS(ve,Ne),Be);QS(ve,Ne)}return null}function De(ve,be,Ne,Be,Ct){if(typeof Be=="string"&&Be!==""||typeof Be=="number"||typeof Be=="bigint")return ve=ve.get(Ne)||null,Y(be,ve,""+Be,Ct);if(typeof Be=="object"&&Be!==null){switch(Be.$$typeof){case m:return ve=ve.get(Be.key===null?Ne:Be.key)||null,ue(be,ve,Be,Ct);case g:return ve=ve.get(Be.key===null?Ne:Be.key)||null,Ce(be,ve,Be,Ct);case R:return Be=Md(Be),De(ve,be,Ne,Be,Ct)}if(W(Be)||_(Be))return ve=ve.get(Ne)||null,ze(be,ve,Be,Ct,null);if(typeof Be.then=="function")return De(ve,be,Ne,YS(Be),Ct);if(Be.$$typeof===S)return De(ve,be,Ne,jS(be,Be),Ct);QS(be,Be)}return null}function ht(ve,be,Ne,Be){for(var Ct=null,wn=null,bt=be,qt=be=0,dn=null;bt!==null&&qt<Ne.length;qt++){bt.index>qt?(dn=bt,bt=null):dn=bt.sibling;var An=Ee(ve,bt,Ne[qt],Be);if(An===null){bt===null&&(bt=dn);break}d&&bt&&An.alternate===null&&f(ve,bt),be=C(An,be,qt),wn===null?Ct=An:wn.sibling=An,wn=An,bt=dn}if(qt===Ne.length)return x(ve,bt),fn&&ku(ve,qt),Ct;if(bt===null){for(;qt<Ne.length;qt++)bt=Ve(ve,Ne[qt],Be),bt!==null&&(be=C(bt,be,qt),wn===null?Ct=bt:wn.sibling=bt,wn=bt);return fn&&ku(ve,qt),Ct}for(bt=A(bt);qt<Ne.length;qt++)dn=De(bt,ve,qt,Ne[qt],Be),dn!==null&&(d&&dn.alternate!==null&&bt.delete(dn.key===null?qt:dn.key),be=C(dn,be,qt),wn===null?Ct=dn:wn.sibling=dn,wn=dn);return d&&bt.forEach(function(Zc){return f(ve,Zc)}),fn&&ku(ve,qt),Ct}function Tt(ve,be,Ne,Be){if(Ne==null)throw Error(a(151));for(var Ct=null,wn=null,bt=be,qt=be=0,dn=null,An=Ne.next();bt!==null&&!An.done;qt++,An=Ne.next()){bt.index>qt?(dn=bt,bt=null):dn=bt.sibling;var Zc=Ee(ve,bt,An.value,Be);if(Zc===null){bt===null&&(bt=dn);break}d&&bt&&Zc.alternate===null&&f(ve,bt),be=C(Zc,be,qt),wn===null?Ct=Zc:wn.sibling=Zc,wn=Zc,bt=dn}if(An.done)return x(ve,bt),fn&&ku(ve,qt),Ct;if(bt===null){for(;!An.done;qt++,An=Ne.next())An=Ve(ve,An.value,Be),An!==null&&(be=C(An,be,qt),wn===null?Ct=An:wn.sibling=An,wn=An);return fn&&ku(ve,qt),Ct}for(bt=A(bt);!An.done;qt++,An=Ne.next())An=De(bt,ve,qt,An.value,Be),An!==null&&(d&&An.alternate!==null&&bt.delete(An.key===null?qt:An.key),be=C(An,be,qt),wn===null?Ct=An:wn.sibling=An,wn=An);return d&&bt.forEach(function(Xle){return f(ve,Xle)}),fn&&ku(ve,qt),Ct}function Qn(ve,be,Ne,Be){if(typeof Ne=="object"&&Ne!==null&&Ne.type===y&&Ne.key===null&&(Ne=Ne.props.children),typeof Ne=="object"&&Ne!==null){switch(Ne.$$typeof){case m:e:{for(var Ct=Ne.key;be!==null;){if(be.key===Ct){if(Ct=Ne.type,Ct===y){if(be.tag===7){x(ve,be.sibling),Be=N(be,Ne.props.children),Be.return=ve,ve=Be;break e}}else if(be.elementType===Ct||typeof Ct=="object"&&Ct!==null&&Ct.$$typeof===R&&Md(Ct)===be.type){x(ve,be.sibling),Be=N(be,Ne.props),G0(Be,Ne),Be.return=ve,ve=Be;break e}x(ve,be);break}else f(ve,be);be=be.sibling}Ne.type===y?(Be=_d(Ne.props.children,ve.mode,Be,Ne.key),Be.return=ve,ve=Be):(Be=WS(Ne.type,Ne.key,Ne.props,null,ve.mode,Be),G0(Be,Ne),Be.return=ve,ve=Be)}return z(ve);case g:e:{for(Ct=Ne.key;be!==null;){if(be.key===Ct)if(be.tag===4&&be.stateNode.containerInfo===Ne.containerInfo&&be.stateNode.implementation===Ne.implementation){x(ve,be.sibling),Be=N(be,Ne.children||[]),Be.return=ve,ve=Be;break e}else{x(ve,be);break}else f(ve,be);be=be.sibling}Be=y$(Ne,ve.mode,Be),Be.return=ve,ve=Be}return z(ve);case R:return Ne=Md(Ne),Qn(ve,be,Ne,Be)}if(W(Ne))return ht(ve,be,Ne,Be);if(_(Ne)){if(Ct=_(Ne),typeof Ct!="function")throw Error(a(150));return Ne=Ct.call(Ne),Tt(ve,be,Ne,Be)}if(typeof Ne.then=="function")return Qn(ve,be,YS(Ne),Be);if(Ne.$$typeof===S)return Qn(ve,be,jS(ve,Ne),Be);QS(ve,Ne)}return typeof Ne=="string"&&Ne!==""||typeof Ne=="number"||typeof Ne=="bigint"?(Ne=""+Ne,be!==null&&be.tag===6?(x(ve,be.sibling),Be=N(be,Ne),Be.return=ve,ve=Be):(x(ve,be),Be=g$(Ne,ve.mode,Be),Be.return=ve,ve=Be),z(ve)):x(ve,be)}return function(ve,be,Ne,Be){try{W0=0;var Ct=Qn(ve,be,Ne,Be);return Sg=null,Ct}catch(bt){if(bt===Ag||bt===KS)throw bt;var wn=Vi(29,bt,null,ve.mode);return wn.lanes=Be,wn.return=ve,wn}}}var zd=mV(!0),gV=mV(!1),Fc=!1;function E$(d){d.updateQueue={baseState:d.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function $$(d,f){d=d.updateQueue,f.updateQueue===d&&(f.updateQueue={baseState:d.baseState,firstBaseUpdate:d.firstBaseUpdate,lastBaseUpdate:d.lastBaseUpdate,shared:d.shared,callbacks:null})}function Mc(d){return{lane:d,tag:0,payload:null,callback:null,next:null}}function Lc(d,f,x){var A=d.updateQueue;if(A===null)return null;if(A=A.shared,(kn&2)!==0){var N=A.pending;return N===null?f.next=f:(f.next=N.next,N.next=f),A.pending=f,f=US(d),J4(d,null,x),f}return VS(d,A,f,x),US(d)}function H0(d,f,x){if(f=f.updateQueue,f!==null&&(f=f.shared,(x&4194048)!==0)){var A=f.lanes;A&=d.pendingLanes,x|=A,f.lanes=x,Pt(d,x)}}function _$(d,f){var x=d.updateQueue,A=d.alternate;if(A!==null&&(A=A.updateQueue,x===A)){var N=null,C=null;if(x=x.firstBaseUpdate,x!==null){do{var z={lane:x.lane,tag:x.tag,payload:x.payload,callback:null,next:null};C===null?N=C=z:C=C.next=z,x=x.next}while(x!==null);C===null?N=C=f:C=C.next=f}else N=C=f;x={baseState:A.baseState,firstBaseUpdate:N,lastBaseUpdate:C,shared:A.shared,callbacks:A.callbacks},d.updateQueue=x;return}d=x.lastBaseUpdate,d===null?x.firstBaseUpdate=f:d.next=f,x.lastBaseUpdate=f}var R$=!1;function j0(){if(R$){var d=wg;if(d!==null)throw d}}function q0(d,f,x,A){R$=!1;var N=d.updateQueue;Fc=!1;var C=N.firstBaseUpdate,z=N.lastBaseUpdate,Y=N.shared.pending;if(Y!==null){N.shared.pending=null;var ue=Y,Ce=ue.next;ue.next=null,z===null?C=Ce:z.next=Ce,z=ue;var ze=d.alternate;ze!==null&&(ze=ze.updateQueue,Y=ze.lastBaseUpdate,Y!==z&&(Y===null?ze.firstBaseUpdate=Ce:Y.next=Ce,ze.lastBaseUpdate=ue))}if(C!==null){var Ve=N.baseState;z=0,ze=Ce=ue=null,Y=C;do{var Ee=Y.lane&-536870913,De=Ee!==Y.lane;if(De?(hn&Ee)===Ee:(A&Ee)===Ee){Ee!==0&&Ee===vg&&(R$=!0),ze!==null&&(ze=ze.next={lane:0,tag:Y.tag,payload:Y.payload,callback:null,next:null});e:{var ht=d,Tt=Y;Ee=f;var Qn=x;switch(Tt.tag){case 1:if(ht=Tt.payload,typeof ht=="function"){Ve=ht.call(Qn,Ve,Ee);break e}Ve=ht;break e;case 3:ht.flags=ht.flags&-65537|128;case 0:if(ht=Tt.payload,Ee=typeof ht=="function"?ht.call(Qn,Ve,Ee):ht,Ee==null)break e;Ve=h({},Ve,Ee);break e;case 2:Fc=!0}}Ee=Y.callback,Ee!==null&&(d.flags|=64,De&&(d.flags|=8192),De=N.callbacks,De===null?N.callbacks=[Ee]:De.push(Ee))}else De={lane:Ee,tag:Y.tag,payload:Y.payload,callback:Y.callback,next:null},ze===null?(Ce=ze=De,ue=Ve):ze=ze.next=De,z|=Ee;if(Y=Y.next,Y===null){if(Y=N.shared.pending,Y===null)break;De=Y,Y=De.next,De.next=null,N.lastBaseUpdate=De,N.shared.pending=null}}while(!0);ze===null&&(ue=Ve),N.baseState=ue,N.firstBaseUpdate=Ce,N.lastBaseUpdate=ze,C===null&&(N.shared.lanes=0),Uc|=z,d.lanes=z,d.memoizedState=Ve}}function yV(d,f){if(typeof d!="function")throw Error(a(191,d));d.call(f)}function bV(d,f){var x=d.callbacks;if(x!==null)for(d.callbacks=null,d=0;d<x.length;d++)yV(x[d],f)}var kg=V(null),ZS=V(0);function xV(d,f){d=Fu,ee(ZS,d),ee(kg,f),Fu=d|f.baseLanes}function D$(){ee(ZS,Fu),ee(kg,kg.current)}function O$(){Fu=ZS.current,Q(kg),Q(ZS)}var Ui=V(null),So=null;function zc(d){var f=d.alternate;ee(ja,ja.current&1),ee(Ui,d),So===null&&(f===null||kg.current!==null||f.memoizedState!==null)&&(So=d)}function F$(d){ee(ja,ja.current),ee(Ui,d),So===null&&(So=d)}function vV(d){d.tag===22?(ee(ja,ja.current),ee(Ui,d),So===null&&(So=d)):Bc()}function Bc(){ee(ja,ja.current),ee(Ui,Ui.current)}function Wi(d){Q(Ui),So===d&&(So=null),Q(ja)}var ja=V(0);function JS(d){for(var f=d;f!==null;){if(f.tag===13){var x=f.memoizedState;if(x!==null&&(x=x.dehydrated,x===null||V_(x)||U_(x)))return f}else if(f.tag===19&&(f.memoizedProps.revealOrder==="forwards"||f.memoizedProps.revealOrder==="backwards"||f.memoizedProps.revealOrder==="unstable_legacy-backwards"||f.memoizedProps.revealOrder==="together")){if((f.flags&128)!==0)return f}else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===d)break;for(;f.sibling===null;){if(f.return===null||f.return===d)return null;f=f.return}f.sibling.return=f.return,f=f.sibling}return null}var Cu=0,Ht=null,Xn=null,or=null,ek=!1,Ig=!1,Bd=!1,tk=0,K0=0,Ng=null,Boe=0;function Fa(){throw Error(a(321))}function M$(d,f){if(f===null)return!1;for(var x=0;x<f.length&&x<d.length;x++)if(!Pi(d[x],f[x]))return!1;return!0}function L$(d,f,x,A,N,C){return Cu=C,Ht=f,f.memoizedState=null,f.updateQueue=null,f.lanes=0,B.H=d===null||d.memoizedState===null?aU:Z$,Bd=!1,C=x(A,N),Bd=!1,Ig&&(C=AV(f,x,A,N)),wV(d),C}function wV(d){B.H=Q0;var f=Xn!==null&&Xn.next!==null;if(Cu=0,or=Xn=Ht=null,ek=!1,K0=0,Ng=null,f)throw Error(a(300));d===null||lr||(d=d.dependencies,d!==null&&HS(d)&&(lr=!0))}function AV(d,f,x,A){Ht=d;var N=0;do{if(Ig&&(Ng=null),K0=0,Ig=!1,25<=N)throw Error(a(301));if(N+=1,or=Xn=null,d.updateQueue!=null){var C=d.updateQueue;C.lastEffect=null,C.events=null,C.stores=null,C.memoCache!=null&&(C.memoCache.index=0)}B.H=rU,C=f(x,A)}while(Ig);return C}function Poe(){var d=B.H,f=d.useState()[0];return f=typeof f.then=="function"?X0(f):f,d=d.useState()[0],(Xn!==null?Xn.memoizedState:null)!==d&&(Ht.flags|=1024),f}function z$(){var d=tk!==0;return tk=0,d}function B$(d,f,x){f.updateQueue=d.updateQueue,f.flags&=-2053,d.lanes&=~x}function P$(d){if(ek){for(d=d.memoizedState;d!==null;){var f=d.queue;f!==null&&(f.pending=null),d=d.next}ek=!1}Cu=0,or=Xn=Ht=null,Ig=!1,K0=tk=0,Ng=null}function Ws(){var d={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return or===null?Ht.memoizedState=or=d:or=or.next=d,or}function qa(){if(Xn===null){var d=Ht.alternate;d=d!==null?d.memoizedState:null}else d=Xn.next;var f=or===null?Ht.memoizedState:or.next;if(f!==null)or=f,Xn=d;else{if(d===null)throw Ht.alternate===null?Error(a(467)):Error(a(310));Xn=d,d={memoizedState:Xn.memoizedState,baseState:Xn.baseState,baseQueue:Xn.baseQueue,queue:Xn.queue,next:null},or===null?Ht.memoizedState=or=d:or=or.next=d}return or}function nk(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function X0(d){var f=K0;return K0+=1,Ng===null&&(Ng=[]),d=dV(Ng,d,f),f=Ht,(or===null?f.memoizedState:or.next)===null&&(f=f.alternate,B.H=f===null||f.memoizedState===null?aU:Z$),d}function ak(d){if(d!==null&&typeof d=="object"){if(typeof d.then=="function")return X0(d);if(d.$$typeof===S)return is(d)}throw Error(a(438,String(d)))}function V$(d){var f=null,x=Ht.updateQueue;if(x!==null&&(f=x.memoCache),f==null){var A=Ht.alternate;A!==null&&(A=A.updateQueue,A!==null&&(A=A.memoCache,A!=null&&(f={data:A.data.map(function(N){return N.slice()}),index:0})))}if(f==null&&(f={data:[],index:0}),x===null&&(x=nk(),Ht.updateQueue=x),x.memoCache=f,x=f.data[f.index],x===void 0)for(x=f.data[f.index]=Array(d),A=0;A<d;A++)x[A]=O;return f.index++,x}function Tu(d,f){return typeof f=="function"?f(d):f}function rk(d){var f=qa();return U$(f,Xn,d)}function U$(d,f,x){var A=d.queue;if(A===null)throw Error(a(311));A.lastRenderedReducer=x;var N=d.baseQueue,C=A.pending;if(C!==null){if(N!==null){var z=N.next;N.next=C.next,C.next=z}f.baseQueue=N=C,A.pending=null}if(C=d.baseState,N===null)d.memoizedState=C;else{f=N.next;var Y=z=null,ue=null,Ce=f,ze=!1;do{var Ve=Ce.lane&-536870913;if(Ve!==Ce.lane?(hn&Ve)===Ve:(Cu&Ve)===Ve){var Ee=Ce.revertLane;if(Ee===0)ue!==null&&(ue=ue.next={lane:0,revertLane:0,gesture:null,action:Ce.action,hasEagerState:Ce.hasEagerState,eagerState:Ce.eagerState,next:null}),Ve===vg&&(ze=!0);else if((Cu&Ee)===Ee){Ce=Ce.next,Ee===vg&&(ze=!0);continue}else Ve={lane:0,revertLane:Ce.revertLane,gesture:null,action:Ce.action,hasEagerState:Ce.hasEagerState,eagerState:Ce.eagerState,next:null},ue===null?(Y=ue=Ve,z=C):ue=ue.next=Ve,Ht.lanes|=Ee,Uc|=Ee;Ve=Ce.action,Bd&&x(C,Ve),C=Ce.hasEagerState?Ce.eagerState:x(C,Ve)}else Ee={lane:Ve,revertLane:Ce.revertLane,gesture:Ce.gesture,action:Ce.action,hasEagerState:Ce.hasEagerState,eagerState:Ce.eagerState,next:null},ue===null?(Y=ue=Ee,z=C):ue=ue.next=Ee,Ht.lanes|=Ve,Uc|=Ve;Ce=Ce.next}while(Ce!==null&&Ce!==f);if(ue===null?z=C:ue.next=Y,!Pi(C,d.memoizedState)&&(lr=!0,ze&&(x=wg,x!==null)))throw x;d.memoizedState=C,d.baseState=z,d.baseQueue=ue,A.lastRenderedState=C}return N===null&&(A.lanes=0),[d.memoizedState,A.dispatch]}function W$(d){var f=qa(),x=f.queue;if(x===null)throw Error(a(311));x.lastRenderedReducer=d;var A=x.dispatch,N=x.pending,C=f.memoizedState;if(N!==null){x.pending=null;var z=N=N.next;do C=d(C,z.action),z=z.next;while(z!==N);Pi(C,f.memoizedState)||(lr=!0),f.memoizedState=C,f.baseQueue===null&&(f.baseState=C),x.lastRenderedState=C}return[C,A]}function SV(d,f,x){var A=Ht,N=qa(),C=fn;if(C){if(x===void 0)throw Error(a(407));x=x()}else x=f();var z=!Pi((Xn||N).memoizedState,x);if(z&&(N.memoizedState=x,lr=!0),N=N.queue,j$(NV.bind(null,A,N,d),[d]),N.getSnapshot!==f||z||or!==null&&or.memoizedState.tag&1){if(A.flags|=2048,Cg(9,{destroy:void 0},IV.bind(null,A,N,x,f),null),na===null)throw Error(a(349));C||(Cu&127)!==0||kV(A,f,x)}return x}function kV(d,f,x){d.flags|=16384,d={getSnapshot:f,value:x},f=Ht.updateQueue,f===null?(f=nk(),Ht.updateQueue=f,f.stores=[d]):(x=f.stores,x===null?f.stores=[d]:x.push(d))}function IV(d,f,x,A){f.value=x,f.getSnapshot=A,CV(f)&&TV(d)}function NV(d,f,x){return x(function(){CV(f)&&TV(d)})}function CV(d){var f=d.getSnapshot;d=d.value;try{var x=f();return!Pi(d,x)}catch{return!0}}function TV(d){var f=$d(d,2);f!==null&&mi(f,d,2)}function G$(d){var f=Ws();if(typeof d=="function"){var x=d;if(d=x(),Bd){Fn(!0);try{x()}finally{Fn(!1)}}}return f.memoizedState=f.baseState=d,f.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Tu,lastRenderedState:d},f}function EV(d,f,x,A){return d.baseState=x,U$(d,Xn,typeof A=="function"?A:Tu)}function Voe(d,f,x,A,N){if(ok(d))throw Error(a(485));if(d=f.action,d!==null){var C={payload:N,action:d,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(z){C.listeners.push(z)}};B.T!==null?x(!0):C.isTransition=!1,A(C),x=f.pending,x===null?(C.next=f.pending=C,$V(f,C)):(C.next=x.next,f.pending=x.next=C)}}function $V(d,f){var x=f.action,A=f.payload,N=d.state;if(f.isTransition){var C=B.T,z={};B.T=z;try{var Y=x(N,A),ue=B.S;ue!==null&&ue(z,Y),_V(d,f,Y)}catch(Ce){H$(d,f,Ce)}finally{C!==null&&z.types!==null&&(C.types=z.types),B.T=C}}else try{C=x(N,A),_V(d,f,C)}catch(Ce){H$(d,f,Ce)}}function _V(d,f,x){x!==null&&typeof x=="object"&&typeof x.then=="function"?x.then(function(A){RV(d,f,A)},function(A){return H$(d,f,A)}):RV(d,f,x)}function RV(d,f,x){f.status="fulfilled",f.value=x,DV(f),d.state=x,f=d.pending,f!==null&&(x=f.next,x===f?d.pending=null:(x=x.next,f.next=x,$V(d,x)))}function H$(d,f,x){var A=d.pending;if(d.pending=null,A!==null){A=A.next;do f.status="rejected",f.reason=x,DV(f),f=f.next;while(f!==A)}d.action=null}function DV(d){d=d.listeners;for(var f=0;f<d.length;f++)(0,d[f])()}function OV(d,f){return f}function FV(d,f){if(fn){var x=na.formState;if(x!==null){e:{var A=Ht;if(fn){if(da){t:{for(var N=da,C=Ao;N.nodeType!==8;){if(!C){N=null;break t}if(N=ko(N.nextSibling),N===null){N=null;break t}}C=N.data,N=C==="F!"||C==="F"?N:null}if(N){da=ko(N.nextSibling),A=N.data==="F!";break e}}Dc(A)}A=!1}A&&(f=x[0])}}return x=Ws(),x.memoizedState=x.baseState=f,A={pending:null,lanes:0,dispatch:null,lastRenderedReducer:OV,lastRenderedState:f},x.queue=A,x=eU.bind(null,Ht,A),A.dispatch=x,A=G$(!1),C=Q$.bind(null,Ht,!1,A.queue),A=Ws(),N={state:f,dispatch:null,action:d,pending:null},A.queue=N,x=Voe.bind(null,Ht,N,C,x),N.dispatch=x,A.memoizedState=d,[f,x,!1]}function MV(d){var f=qa();return LV(f,Xn,d)}function LV(d,f,x){if(f=U$(d,f,OV)[0],d=rk(Tu)[0],typeof f=="object"&&f!==null&&typeof f.then=="function")try{var A=X0(f)}catch(z){throw z===Ag?KS:z}else A=f;f=qa();var N=f.queue,C=N.dispatch;return x!==f.memoizedState&&(Ht.flags|=2048,Cg(9,{destroy:void 0},Uoe.bind(null,N,x),null)),[A,C,d]}function Uoe(d,f){d.action=f}function zV(d){var f=qa(),x=Xn;if(x!==null)return LV(f,x,d);qa(),f=f.memoizedState,x=qa();var A=x.queue.dispatch;return x.memoizedState=d,[f,A,!1]}function Cg(d,f,x,A){return d={tag:d,create:x,deps:A,inst:f,next:null},f=Ht.updateQueue,f===null&&(f=nk(),Ht.updateQueue=f),x=f.lastEffect,x===null?f.lastEffect=d.next=d:(A=x.next,x.next=d,d.next=A,f.lastEffect=d),d}function BV(){return qa().memoizedState}function sk(d,f,x,A){var N=Ws();Ht.flags|=d,N.memoizedState=Cg(1|f,{destroy:void 0},x,A===void 0?null:A)}function ik(d,f,x,A){var N=qa();A=A===void 0?null:A;var C=N.memoizedState.inst;Xn!==null&&A!==null&&M$(A,Xn.memoizedState.deps)?N.memoizedState=Cg(f,C,x,A):(Ht.flags|=d,N.memoizedState=Cg(1|f,C,x,A))}function PV(d,f){sk(8390656,8,d,f)}function j$(d,f){ik(2048,8,d,f)}function Woe(d){Ht.flags|=4;var f=Ht.updateQueue;if(f===null)f=nk(),Ht.updateQueue=f,f.events=[d];else{var x=f.events;x===null?f.events=[d]:x.push(d)}}function VV(d){var f=qa().memoizedState;return Woe({ref:f,nextImpl:d}),function(){if((kn&2)!==0)throw Error(a(440));return f.impl.apply(void 0,arguments)}}function UV(d,f){return ik(4,2,d,f)}function WV(d,f){return ik(4,4,d,f)}function GV(d,f){if(typeof f=="function"){d=d();var x=f(d);return function(){typeof x=="function"?x():f(null)}}if(f!=null)return d=d(),f.current=d,function(){f.current=null}}function HV(d,f,x){x=x!=null?x.concat([d]):null,ik(4,4,GV.bind(null,f,d),x)}function q$(){}function jV(d,f){var x=qa();f=f===void 0?null:f;var A=x.memoizedState;return f!==null&&M$(f,A[1])?A[0]:(x.memoizedState=[d,f],d)}function qV(d,f){var x=qa();f=f===void 0?null:f;var A=x.memoizedState;if(f!==null&&M$(f,A[1]))return A[0];if(A=d(),Bd){Fn(!0);try{d()}finally{Fn(!1)}}return x.memoizedState=[A,f],A}function K$(d,f,x){return x===void 0||(Cu&1073741824)!==0&&(hn&261930)===0?d.memoizedState=f:(d.memoizedState=x,d=KU(),Ht.lanes|=d,Uc|=d,x)}function KV(d,f,x,A){return Pi(x,f)?x:kg.current!==null?(d=K$(d,x,A),Pi(d,f)||(lr=!0),d):(Cu&42)===0||(Cu&1073741824)!==0&&(hn&261930)===0?(lr=!0,d.memoizedState=x):(d=KU(),Ht.lanes|=d,Uc|=d,f)}function XV(d,f,x,A,N){var C=H.p;H.p=C!==0&&8>C?C:8;var z=B.T,Y={};B.T=Y,Q$(d,!1,f,x);try{var ue=N(),Ce=B.S;if(Ce!==null&&Ce(Y,ue),ue!==null&&typeof ue=="object"&&typeof ue.then=="function"){var ze=zoe(ue,A);Y0(d,f,ze,ji(d))}else Y0(d,f,A,ji(d))}catch(Ve){Y0(d,f,{then:function(){},status:"rejected",reason:Ve},ji())}finally{H.p=C,z!==null&&Y.types!==null&&(z.types=Y.types),B.T=z}}function Goe(){}function X$(d,f,x,A){if(d.tag!==5)throw Error(a(476));var N=YV(d).queue;XV(d,N,f,j,x===null?Goe:function(){return QV(d),x(A)})}function YV(d){var f=d.memoizedState;if(f!==null)return f;f={memoizedState:j,baseState:j,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Tu,lastRenderedState:j},next:null};var x={};return f.next={memoizedState:x,baseState:x,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Tu,lastRenderedState:x},next:null},d.memoizedState=f,d=d.alternate,d!==null&&(d.memoizedState=f),f}function QV(d){var f=YV(d);f.next===null&&(f=d.alternate.memoizedState),Y0(d,f.next.queue,{},ji())}function Y$(){return is(pv)}function ZV(){return qa().memoizedState}function JV(){return qa().memoizedState}function Hoe(d){for(var f=d.return;f!==null;){switch(f.tag){case 24:case 3:var x=ji();d=Mc(x);var A=Lc(f,d,x);A!==null&&(mi(A,f,x),H0(A,f,x)),f={cache:I$()},d.payload=f;return}f=f.return}}function joe(d,f,x){var A=ji();x={lane:A,revertLane:0,gesture:null,action:x,hasEagerState:!1,eagerState:null,next:null},ok(d)?tU(f,x):(x=f$(d,f,x,A),x!==null&&(mi(x,d,A),nU(x,f,A)))}function eU(d,f,x){var A=ji();Y0(d,f,x,A)}function Y0(d,f,x,A){var N={lane:A,revertLane:0,gesture:null,action:x,hasEagerState:!1,eagerState:null,next:null};if(ok(d))tU(f,N);else{var C=d.alternate;if(d.lanes===0&&(C===null||C.lanes===0)&&(C=f.lastRenderedReducer,C!==null))try{var z=f.lastRenderedState,Y=C(z,x);if(N.hasEagerState=!0,N.eagerState=Y,Pi(Y,z))return VS(d,f,N,0),na===null&&PS(),!1}catch{}if(x=f$(d,f,N,A),x!==null)return mi(x,d,A),nU(x,f,A),!0}return!1}function Q$(d,f,x,A){if(A={lane:2,revertLane:E_(),gesture:null,action:A,hasEagerState:!1,eagerState:null,next:null},ok(d)){if(f)throw Error(a(479))}else f=f$(d,x,A,2),f!==null&&mi(f,d,2)}function ok(d){var f=d.alternate;return d===Ht||f!==null&&f===Ht}function tU(d,f){Ig=ek=!0;var x=d.pending;x===null?f.next=f:(f.next=x.next,x.next=f),d.pending=f}function nU(d,f,x){if((x&4194048)!==0){var A=f.lanes;A&=d.pendingLanes,x|=A,f.lanes=x,Pt(d,x)}}var Q0={readContext:is,use:ak,useCallback:Fa,useContext:Fa,useEffect:Fa,useImperativeHandle:Fa,useLayoutEffect:Fa,useInsertionEffect:Fa,useMemo:Fa,useReducer:Fa,useRef:Fa,useState:Fa,useDebugValue:Fa,useDeferredValue:Fa,useTransition:Fa,useSyncExternalStore:Fa,useId:Fa,useHostTransitionStatus:Fa,useFormState:Fa,useActionState:Fa,useOptimistic:Fa,useMemoCache:Fa,useCacheRefresh:Fa};Q0.useEffectEvent=Fa;var aU={readContext:is,use:ak,useCallback:function(d,f){return Ws().memoizedState=[d,f===void 0?null:f],d},useContext:is,useEffect:PV,useImperativeHandle:function(d,f,x){x=x!=null?x.concat([d]):null,sk(4194308,4,GV.bind(null,f,d),x)},useLayoutEffect:function(d,f){return sk(4194308,4,d,f)},useInsertionEffect:function(d,f){sk(4,2,d,f)},useMemo:function(d,f){var x=Ws();f=f===void 0?null:f;var A=d();if(Bd){Fn(!0);try{d()}finally{Fn(!1)}}return x.memoizedState=[A,f],A},useReducer:function(d,f,x){var A=Ws();if(x!==void 0){var N=x(f);if(Bd){Fn(!0);try{x(f)}finally{Fn(!1)}}}else N=f;return A.memoizedState=A.baseState=N,d={pending:null,lanes:0,dispatch:null,lastRenderedReducer:d,lastRenderedState:N},A.queue=d,d=d.dispatch=joe.bind(null,Ht,d),[A.memoizedState,d]},useRef:function(d){var f=Ws();return d={current:d},f.memoizedState=d},useState:function(d){d=G$(d);var f=d.queue,x=eU.bind(null,Ht,f);return f.dispatch=x,[d.memoizedState,x]},useDebugValue:q$,useDeferredValue:function(d,f){var x=Ws();return K$(x,d,f)},useTransition:function(){var d=G$(!1);return d=XV.bind(null,Ht,d.queue,!0,!1),Ws().memoizedState=d,[!1,d]},useSyncExternalStore:function(d,f,x){var A=Ht,N=Ws();if(fn){if(x===void 0)throw Error(a(407));x=x()}else{if(x=f(),na===null)throw Error(a(349));(hn&127)!==0||kV(A,f,x)}N.memoizedState=x;var C={value:x,getSnapshot:f};return N.queue=C,PV(NV.bind(null,A,C,d),[d]),A.flags|=2048,Cg(9,{destroy:void 0},IV.bind(null,A,C,x,f),null),x},useId:function(){var d=Ws(),f=na.identifierPrefix;if(fn){var x=El,A=Tl;x=(A&~(1<<32-Vr(A)-1)).toString(32)+x,f="_"+f+"R_"+x,x=tk++,0<x&&(f+="H"+x.toString(32)),f+="_"}else x=Boe++,f="_"+f+"r_"+x.toString(32)+"_";return d.memoizedState=f},useHostTransitionStatus:Y$,useFormState:FV,useActionState:FV,useOptimistic:function(d){var f=Ws();f.memoizedState=f.baseState=d;var x={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return f.queue=x,f=Q$.bind(null,Ht,!0,x),x.dispatch=f,[d,f]},useMemoCache:V$,useCacheRefresh:function(){return Ws().memoizedState=Hoe.bind(null,Ht)},useEffectEvent:function(d){var f=Ws(),x={impl:d};return f.memoizedState=x,function(){if((kn&2)!==0)throw Error(a(440));return x.impl.apply(void 0,arguments)}}},Z$={readContext:is,use:ak,useCallback:jV,useContext:is,useEffect:j$,useImperativeHandle:HV,useInsertionEffect:UV,useLayoutEffect:WV,useMemo:qV,useReducer:rk,useRef:BV,useState:function(){return rk(Tu)},useDebugValue:q$,useDeferredValue:function(d,f){var x=qa();return KV(x,Xn.memoizedState,d,f)},useTransition:function(){var d=rk(Tu)[0],f=qa().memoizedState;return[typeof d=="boolean"?d:X0(d),f]},useSyncExternalStore:SV,useId:ZV,useHostTransitionStatus:Y$,useFormState:MV,useActionState:MV,useOptimistic:function(d,f){var x=qa();return EV(x,Xn,d,f)},useMemoCache:V$,useCacheRefresh:JV};Z$.useEffectEvent=VV;var rU={readContext:is,use:ak,useCallback:jV,useContext:is,useEffect:j$,useImperativeHandle:HV,useInsertionEffect:UV,useLayoutEffect:WV,useMemo:qV,useReducer:W$,useRef:BV,useState:function(){return W$(Tu)},useDebugValue:q$,useDeferredValue:function(d,f){var x=qa();return Xn===null?K$(x,d,f):KV(x,Xn.memoizedState,d,f)},useTransition:function(){var d=W$(Tu)[0],f=qa().memoizedState;return[typeof d=="boolean"?d:X0(d),f]},useSyncExternalStore:SV,useId:ZV,useHostTransitionStatus:Y$,useFormState:zV,useActionState:zV,useOptimistic:function(d,f){var x=qa();return Xn!==null?EV(x,Xn,d,f):(x.baseState=d,[d,x.queue.dispatch])},useMemoCache:V$,useCacheRefresh:JV};rU.useEffectEvent=VV;function J$(d,f,x,A){f=d.memoizedState,x=x(A,f),x=x==null?f:h({},f,x),d.memoizedState=x,d.lanes===0&&(d.updateQueue.baseState=x)}var e_={enqueueSetState:function(d,f,x){d=d._reactInternals;var A=ji(),N=Mc(A);N.payload=f,x!=null&&(N.callback=x),f=Lc(d,N,A),f!==null&&(mi(f,d,A),H0(f,d,A))},enqueueReplaceState:function(d,f,x){d=d._reactInternals;var A=ji(),N=Mc(A);N.tag=1,N.payload=f,x!=null&&(N.callback=x),f=Lc(d,N,A),f!==null&&(mi(f,d,A),H0(f,d,A))},enqueueForceUpdate:function(d,f){d=d._reactInternals;var x=ji(),A=Mc(x);A.tag=2,f!=null&&(A.callback=f),f=Lc(d,A,x),f!==null&&(mi(f,d,x),H0(f,d,x))}};function sU(d,f,x,A,N,C,z){return d=d.stateNode,typeof d.shouldComponentUpdate=="function"?d.shouldComponentUpdate(A,C,z):f.prototype&&f.prototype.isPureReactComponent?!L0(x,A)||!L0(N,C):!0}function iU(d,f,x,A){d=f.state,typeof f.componentWillReceiveProps=="function"&&f.componentWillReceiveProps(x,A),typeof f.UNSAFE_componentWillReceiveProps=="function"&&f.UNSAFE_componentWillReceiveProps(x,A),f.state!==d&&e_.enqueueReplaceState(f,f.state,null)}function Pd(d,f){var x=f;if("ref"in f){x={};for(var A in f)A!=="ref"&&(x[A]=f[A])}if(d=d.defaultProps){x===f&&(x=h({},x));for(var N in d)x[N]===void 0&&(x[N]=d[N])}return x}function oU(d){BS(d)}function lU(d){console.error(d)}function uU(d){BS(d)}function lk(d,f){try{var x=d.onUncaughtError;x(f.value,{componentStack:f.stack})}catch(A){setTimeout(function(){throw A})}}function cU(d,f,x){try{var A=d.onCaughtError;A(x.value,{componentStack:x.stack,errorBoundary:f.tag===1?f.stateNode:null})}catch(N){setTimeout(function(){throw N})}}function t_(d,f,x){return x=Mc(x),x.tag=3,x.payload={element:null},x.callback=function(){lk(d,f)},x}function hU(d){return d=Mc(d),d.tag=3,d}function dU(d,f,x,A){var N=x.type.getDerivedStateFromError;if(typeof N=="function"){var C=A.value;d.payload=function(){return N(C)},d.callback=function(){cU(f,x,A)}}var z=x.stateNode;z!==null&&typeof z.componentDidCatch=="function"&&(d.callback=function(){cU(f,x,A),typeof N!="function"&&(Wc===null?Wc=new Set([this]):Wc.add(this));var Y=A.stack;this.componentDidCatch(A.value,{componentStack:Y!==null?Y:""})})}function qoe(d,f,x,A,N){if(x.flags|=32768,A!==null&&typeof A=="object"&&typeof A.then=="function"){if(f=x.alternate,f!==null&&xg(f,x,N,!0),x=Ui.current,x!==null){switch(x.tag){case 31:case 13:return So===null?vk():x.alternate===null&&Ma===0&&(Ma=3),x.flags&=-257,x.flags|=65536,x.lanes=N,A===XS?x.flags|=16384:(f=x.updateQueue,f===null?x.updateQueue=new Set([A]):f.add(A),N_(d,A,N)),!1;case 22:return x.flags|=65536,A===XS?x.flags|=16384:(f=x.updateQueue,f===null?(f={transitions:null,markerInstances:null,retryQueue:new Set([A])},x.updateQueue=f):(x=f.retryQueue,x===null?f.retryQueue=new Set([A]):x.add(A)),N_(d,A,N)),!1}throw Error(a(435,x.tag))}return N_(d,A,N),vk(),!1}if(fn)return f=Ui.current,f!==null?((f.flags&65536)===0&&(f.flags|=256),f.flags|=65536,f.lanes=N,A!==v$&&(d=Error(a(422),{cause:A}),P0(xo(d,x)))):(A!==v$&&(f=Error(a(423),{cause:A}),P0(xo(f,x))),d=d.current.alternate,d.flags|=65536,N&=-N,d.lanes|=N,A=xo(A,x),N=t_(d.stateNode,A,N),_$(d,N),Ma!==4&&(Ma=2)),!1;var C=Error(a(520),{cause:A});if(C=xo(C,x),sv===null?sv=[C]:sv.push(C),Ma!==4&&(Ma=2),f===null)return!0;A=xo(A,x),x=f;do{switch(x.tag){case 3:return x.flags|=65536,d=N&-N,x.lanes|=d,d=t_(x.stateNode,A,d),_$(x,d),!1;case 1:if(f=x.type,C=x.stateNode,(x.flags&128)===0&&(typeof f.getDerivedStateFromError=="function"||C!==null&&typeof C.componentDidCatch=="function"&&(Wc===null||!Wc.has(C))))return x.flags|=65536,N&=-N,x.lanes|=N,N=hU(N),dU(N,d,x,A),_$(x,N),!1}x=x.return}while(x!==null);return!1}var n_=Error(a(461)),lr=!1;function os(d,f,x,A){f.child=d===null?gV(f,null,x,A):zd(f,d.child,x,A)}function pU(d,f,x,A,N){x=x.render;var C=f.ref;if("ref"in A){var z={};for(var Y in A)Y!=="ref"&&(z[Y]=A[Y])}else z=A;return Od(f),A=L$(d,f,x,z,C,N),Y=z$(),d!==null&&!lr?(B$(d,f,N),Eu(d,f,N)):(fn&&Y&&b$(f),f.flags|=1,os(d,f,A,N),f.child)}function fU(d,f,x,A,N){if(d===null){var C=x.type;return typeof C=="function"&&!m$(C)&&C.defaultProps===void 0&&x.compare===null?(f.tag=15,f.type=C,mU(d,f,C,A,N)):(d=WS(x.type,null,A,f,f.mode,N),d.ref=f.ref,d.return=f,f.child=d)}if(C=d.child,!c_(d,N)){var z=C.memoizedProps;if(x=x.compare,x=x!==null?x:L0,x(z,A)&&d.ref===f.ref)return Eu(d,f,N)}return f.flags|=1,d=Su(C,A),d.ref=f.ref,d.return=f,f.child=d}function mU(d,f,x,A,N){if(d!==null){var C=d.memoizedProps;if(L0(C,A)&&d.ref===f.ref)if(lr=!1,f.pendingProps=A=C,c_(d,N))(d.flags&131072)!==0&&(lr=!0);else return f.lanes=d.lanes,Eu(d,f,N)}return a_(d,f,x,A,N)}function gU(d,f,x,A){var N=A.children,C=d!==null?d.memoizedState:null;if(d===null&&f.stateNode===null&&(f.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),A.mode==="hidden"){if((f.flags&128)!==0){if(C=C!==null?C.baseLanes|x:x,d!==null){for(A=f.child=d.child,N=0;A!==null;)N=N|A.lanes|A.childLanes,A=A.sibling;A=N&~C}else A=0,f.child=null;return yU(d,f,C,x,A)}if((x&536870912)!==0)f.memoizedState={baseLanes:0,cachePool:null},d!==null&&qS(f,C!==null?C.cachePool:null),C!==null?xV(f,C):D$(),vV(f);else return A=f.lanes=536870912,yU(d,f,C!==null?C.baseLanes|x:x,x,A)}else C!==null?(qS(f,C.cachePool),xV(f,C),Bc(),f.memoizedState=null):(d!==null&&qS(f,null),D$(),Bc());return os(d,f,N,x),f.child}function Z0(d,f){return d!==null&&d.tag===22||f.stateNode!==null||(f.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),f.sibling}function yU(d,f,x,A,N){var C=C$();return C=C===null?null:{parent:ir._currentValue,pool:C},f.memoizedState={baseLanes:x,cachePool:C},d!==null&&qS(f,null),D$(),vV(f),d!==null&&xg(d,f,A,!0),f.childLanes=N,null}function uk(d,f){return f=hk({mode:f.mode,children:f.children},d.mode),f.ref=d.ref,d.child=f,f.return=d,f}function bU(d,f,x){return zd(f,d.child,null,x),d=uk(f,f.pendingProps),d.flags|=2,Wi(f),f.memoizedState=null,d}function Koe(d,f,x){var A=f.pendingProps,N=(f.flags&128)!==0;if(f.flags&=-129,d===null){if(fn){if(A.mode==="hidden")return d=uk(f,A),f.lanes=536870912,Z0(null,d);if(F$(f),(d=da)?(d=$W(d,Ao),d=d!==null&&d.data==="&"?d:null,d!==null&&(f.memoizedState={dehydrated:d,treeContext:_c!==null?{id:Tl,overflow:El}:null,retryLane:536870912,hydrationErrors:null},x=tV(d),x.return=f,f.child=x,ss=f,da=null)):d=null,d===null)throw Dc(f);return f.lanes=536870912,null}return uk(f,A)}var C=d.memoizedState;if(C!==null){var z=C.dehydrated;if(F$(f),N)if(f.flags&256)f.flags&=-257,f=bU(d,f,x);else if(f.memoizedState!==null)f.child=d.child,f.flags|=128,f=null;else throw Error(a(558));else if(lr||xg(d,f,x,!1),N=(x&d.childLanes)!==0,lr||N){if(A=na,A!==null&&(z=Ot(A,x),z!==0&&z!==C.retryLane))throw C.retryLane=z,$d(d,z),mi(A,d,z),n_;vk(),f=bU(d,f,x)}else d=C.treeContext,da=ko(z.nextSibling),ss=f,fn=!0,Rc=null,Ao=!1,d!==null&&rV(f,d),f=uk(f,A),f.flags|=4096;return f}return d=Su(d.child,{mode:A.mode,children:A.children}),d.ref=f.ref,f.child=d,d.return=f,d}function ck(d,f){var x=f.ref;if(x===null)d!==null&&d.ref!==null&&(f.flags|=4194816);else{if(typeof x!="function"&&typeof x!="object")throw Error(a(284));(d===null||d.ref!==x)&&(f.flags|=4194816)}}function a_(d,f,x,A,N){return Od(f),x=L$(d,f,x,A,void 0,N),A=z$(),d!==null&&!lr?(B$(d,f,N),Eu(d,f,N)):(fn&&A&&b$(f),f.flags|=1,os(d,f,x,N),f.child)}function xU(d,f,x,A,N,C){return Od(f),f.updateQueue=null,x=AV(f,A,x,N),wV(d),A=z$(),d!==null&&!lr?(B$(d,f,C),Eu(d,f,C)):(fn&&A&&b$(f),f.flags|=1,os(d,f,x,C),f.child)}function vU(d,f,x,A,N){if(Od(f),f.stateNode===null){var C=mg,z=x.contextType;typeof z=="object"&&z!==null&&(C=is(z)),C=new x(A,C),f.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,C.updater=e_,f.stateNode=C,C._reactInternals=f,C=f.stateNode,C.props=A,C.state=f.memoizedState,C.refs={},E$(f),z=x.contextType,C.context=typeof z=="object"&&z!==null?is(z):mg,C.state=f.memoizedState,z=x.getDerivedStateFromProps,typeof z=="function"&&(J$(f,x,z,A),C.state=f.memoizedState),typeof x.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(z=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),z!==C.state&&e_.enqueueReplaceState(C,C.state,null),q0(f,A,C,N),j0(),C.state=f.memoizedState),typeof C.componentDidMount=="function"&&(f.flags|=4194308),A=!0}else if(d===null){C=f.stateNode;var Y=f.memoizedProps,ue=Pd(x,Y);C.props=ue;var Ce=C.context,ze=x.contextType;z=mg,typeof ze=="object"&&ze!==null&&(z=is(ze));var Ve=x.getDerivedStateFromProps;ze=typeof Ve=="function"||typeof C.getSnapshotBeforeUpdate=="function",Y=f.pendingProps!==Y,ze||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(Y||Ce!==z)&&iU(f,C,A,z),Fc=!1;var Ee=f.memoizedState;C.state=Ee,q0(f,A,C,N),j0(),Ce=f.memoizedState,Y||Ee!==Ce||Fc?(typeof Ve=="function"&&(J$(f,x,Ve,A),Ce=f.memoizedState),(ue=Fc||sU(f,x,ue,A,Ee,Ce,z))?(ze||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount()),typeof C.componentDidMount=="function"&&(f.flags|=4194308)):(typeof C.componentDidMount=="function"&&(f.flags|=4194308),f.memoizedProps=A,f.memoizedState=Ce),C.props=A,C.state=Ce,C.context=z,A=ue):(typeof C.componentDidMount=="function"&&(f.flags|=4194308),A=!1)}else{C=f.stateNode,$$(d,f),z=f.memoizedProps,ze=Pd(x,z),C.props=ze,Ve=f.pendingProps,Ee=C.context,Ce=x.contextType,ue=mg,typeof Ce=="object"&&Ce!==null&&(ue=is(Ce)),Y=x.getDerivedStateFromProps,(Ce=typeof Y=="function"||typeof C.getSnapshotBeforeUpdate=="function")||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(z!==Ve||Ee!==ue)&&iU(f,C,A,ue),Fc=!1,Ee=f.memoizedState,C.state=Ee,q0(f,A,C,N),j0();var De=f.memoizedState;z!==Ve||Ee!==De||Fc||d!==null&&d.dependencies!==null&&HS(d.dependencies)?(typeof Y=="function"&&(J$(f,x,Y,A),De=f.memoizedState),(ze=Fc||sU(f,x,ze,A,Ee,De,ue)||d!==null&&d.dependencies!==null&&HS(d.dependencies))?(Ce||typeof C.UNSAFE_componentWillUpdate!="function"&&typeof C.componentWillUpdate!="function"||(typeof C.componentWillUpdate=="function"&&C.componentWillUpdate(A,De,ue),typeof C.UNSAFE_componentWillUpdate=="function"&&C.UNSAFE_componentWillUpdate(A,De,ue)),typeof C.componentDidUpdate=="function"&&(f.flags|=4),typeof C.getSnapshotBeforeUpdate=="function"&&(f.flags|=1024)):(typeof C.componentDidUpdate!="function"||z===d.memoizedProps&&Ee===d.memoizedState||(f.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||z===d.memoizedProps&&Ee===d.memoizedState||(f.flags|=1024),f.memoizedProps=A,f.memoizedState=De),C.props=A,C.state=De,C.context=ue,A=ze):(typeof C.componentDidUpdate!="function"||z===d.memoizedProps&&Ee===d.memoizedState||(f.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||z===d.memoizedProps&&Ee===d.memoizedState||(f.flags|=1024),A=!1)}return C=A,ck(d,f),A=(f.flags&128)!==0,C||A?(C=f.stateNode,x=A&&typeof x.getDerivedStateFromError!="function"?null:C.render(),f.flags|=1,d!==null&&A?(f.child=zd(f,d.child,null,N),f.child=zd(f,null,x,N)):os(d,f,x,N),f.memoizedState=C.state,d=f.child):d=Eu(d,f,N),d}function wU(d,f,x,A){return Rd(),f.flags|=256,os(d,f,x,A),f.child}var r_={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function s_(d){return{baseLanes:d,cachePool:cV()}}function i_(d,f,x){return d=d!==null?d.childLanes&~x:0,f&&(d|=Hi),d}function AU(d,f,x){var A=f.pendingProps,N=!1,C=(f.flags&128)!==0,z;if((z=C)||(z=d!==null&&d.memoizedState===null?!1:(ja.current&2)!==0),z&&(N=!0,f.flags&=-129),z=(f.flags&32)!==0,f.flags&=-33,d===null){if(fn){if(N?zc(f):Bc(),(d=da)?(d=$W(d,Ao),d=d!==null&&d.data!=="&"?d:null,d!==null&&(f.memoizedState={dehydrated:d,treeContext:_c!==null?{id:Tl,overflow:El}:null,retryLane:536870912,hydrationErrors:null},x=tV(d),x.return=f,f.child=x,ss=f,da=null)):d=null,d===null)throw Dc(f);return U_(d)?f.lanes=32:f.lanes=536870912,null}var Y=A.children;return A=A.fallback,N?(Bc(),N=f.mode,Y=hk({mode:"hidden",children:Y},N),A=_d(A,N,x,null),Y.return=f,A.return=f,Y.sibling=A,f.child=Y,A=f.child,A.memoizedState=s_(x),A.childLanes=i_(d,z,x),f.memoizedState=r_,Z0(null,A)):(zc(f),o_(f,Y))}var ue=d.memoizedState;if(ue!==null&&(Y=ue.dehydrated,Y!==null)){if(C)f.flags&256?(zc(f),f.flags&=-257,f=l_(d,f,x)):f.memoizedState!==null?(Bc(),f.child=d.child,f.flags|=128,f=null):(Bc(),Y=A.fallback,N=f.mode,A=hk({mode:"visible",children:A.children},N),Y=_d(Y,N,x,null),Y.flags|=2,A.return=f,Y.return=f,A.sibling=Y,f.child=A,zd(f,d.child,null,x),A=f.child,A.memoizedState=s_(x),A.childLanes=i_(d,z,x),f.memoizedState=r_,f=Z0(null,A));else if(zc(f),U_(Y)){if(z=Y.nextSibling&&Y.nextSibling.dataset,z)var Ce=z.dgst;z=Ce,A=Error(a(419)),A.stack="",A.digest=z,P0({value:A,source:null,stack:null}),f=l_(d,f,x)}else if(lr||xg(d,f,x,!1),z=(x&d.childLanes)!==0,lr||z){if(z=na,z!==null&&(A=Ot(z,x),A!==0&&A!==ue.retryLane))throw ue.retryLane=A,$d(d,A),mi(z,d,A),n_;V_(Y)||vk(),f=l_(d,f,x)}else V_(Y)?(f.flags|=192,f.child=d.child,f=null):(d=ue.treeContext,da=ko(Y.nextSibling),ss=f,fn=!0,Rc=null,Ao=!1,d!==null&&rV(f,d),f=o_(f,A.children),f.flags|=4096);return f}return N?(Bc(),Y=A.fallback,N=f.mode,ue=d.child,Ce=ue.sibling,A=Su(ue,{mode:"hidden",children:A.children}),A.subtreeFlags=ue.subtreeFlags&65011712,Ce!==null?Y=Su(Ce,Y):(Y=_d(Y,N,x,null),Y.flags|=2),Y.return=f,A.return=f,A.sibling=Y,f.child=A,Z0(null,A),A=f.child,Y=d.child.memoizedState,Y===null?Y=s_(x):(N=Y.cachePool,N!==null?(ue=ir._currentValue,N=N.parent!==ue?{parent:ue,pool:ue}:N):N=cV(),Y={baseLanes:Y.baseLanes|x,cachePool:N}),A.memoizedState=Y,A.childLanes=i_(d,z,x),f.memoizedState=r_,Z0(d.child,A)):(zc(f),x=d.child,d=x.sibling,x=Su(x,{mode:"visible",children:A.children}),x.return=f,x.sibling=null,d!==null&&(z=f.deletions,z===null?(f.deletions=[d],f.flags|=16):z.push(d)),f.child=x,f.memoizedState=null,x)}function o_(d,f){return f=hk({mode:"visible",children:f},d.mode),f.return=d,d.child=f}function hk(d,f){return d=Vi(22,d,null,f),d.lanes=0,d}function l_(d,f,x){return zd(f,d.child,null,x),d=o_(f,f.pendingProps.children),d.flags|=2,f.memoizedState=null,d}function SU(d,f,x){d.lanes|=f;var A=d.alternate;A!==null&&(A.lanes|=f),S$(d.return,f,x)}function u_(d,f,x,A,N,C){var z=d.memoizedState;z===null?d.memoizedState={isBackwards:f,rendering:null,renderingStartTime:0,last:A,tail:x,tailMode:N,treeForkCount:C}:(z.isBackwards=f,z.rendering=null,z.renderingStartTime=0,z.last=A,z.tail=x,z.tailMode=N,z.treeForkCount=C)}function kU(d,f,x){var A=f.pendingProps,N=A.revealOrder,C=A.tail;A=A.children;var z=ja.current,Y=(z&2)!==0;if(Y?(z=z&1|2,f.flags|=128):z&=1,ee(ja,z),os(d,f,A,x),A=fn?B0:0,!Y&&d!==null&&(d.flags&128)!==0)e:for(d=f.child;d!==null;){if(d.tag===13)d.memoizedState!==null&&SU(d,x,f);else if(d.tag===19)SU(d,x,f);else if(d.child!==null){d.child.return=d,d=d.child;continue}if(d===f)break e;for(;d.sibling===null;){if(d.return===null||d.return===f)break e;d=d.return}d.sibling.return=d.return,d=d.sibling}switch(N){case"forwards":for(x=f.child,N=null;x!==null;)d=x.alternate,d!==null&&JS(d)===null&&(N=x),x=x.sibling;x=N,x===null?(N=f.child,f.child=null):(N=x.sibling,x.sibling=null),u_(f,!1,N,x,C,A);break;case"backwards":case"unstable_legacy-backwards":for(x=null,N=f.child,f.child=null;N!==null;){if(d=N.alternate,d!==null&&JS(d)===null){f.child=N;break}d=N.sibling,N.sibling=x,x=N,N=d}u_(f,!0,x,null,C,A);break;case"together":u_(f,!1,null,null,void 0,A);break;default:f.memoizedState=null}return f.child}function Eu(d,f,x){if(d!==null&&(f.dependencies=d.dependencies),Uc|=f.lanes,(x&f.childLanes)===0)if(d!==null){if(xg(d,f,x,!1),(x&f.childLanes)===0)return null}else return null;if(d!==null&&f.child!==d.child)throw Error(a(153));if(f.child!==null){for(d=f.child,x=Su(d,d.pendingProps),f.child=x,x.return=f;d.sibling!==null;)d=d.sibling,x=x.sibling=Su(d,d.pendingProps),x.return=f;x.sibling=null}return f.child}function c_(d,f){return(d.lanes&f)!==0?!0:(d=d.dependencies,!!(d!==null&&HS(d)))}function Xoe(d,f,x){switch(f.tag){case 3:$e(f,f.stateNode.containerInfo),Oc(f,ir,d.memoizedState.cache),Rd();break;case 27:case 5:Ge(f);break;case 4:$e(f,f.stateNode.containerInfo);break;case 10:Oc(f,f.type,f.memoizedProps.value);break;case 31:if(f.memoizedState!==null)return f.flags|=128,F$(f),null;break;case 13:var A=f.memoizedState;if(A!==null)return A.dehydrated!==null?(zc(f),f.flags|=128,null):(x&f.child.childLanes)!==0?AU(d,f,x):(zc(f),d=Eu(d,f,x),d!==null?d.sibling:null);zc(f);break;case 19:var N=(d.flags&128)!==0;if(A=(x&f.childLanes)!==0,A||(xg(d,f,x,!1),A=(x&f.childLanes)!==0),N){if(A)return kU(d,f,x);f.flags|=128}if(N=f.memoizedState,N!==null&&(N.rendering=null,N.tail=null,N.lastEffect=null),ee(ja,ja.current),A)break;return null;case 22:return f.lanes=0,gU(d,f,x,f.pendingProps);case 24:Oc(f,ir,d.memoizedState.cache)}return Eu(d,f,x)}function IU(d,f,x){if(d!==null)if(d.memoizedProps!==f.pendingProps)lr=!0;else{if(!c_(d,x)&&(f.flags&128)===0)return lr=!1,Xoe(d,f,x);lr=(d.flags&131072)!==0}else lr=!1,fn&&(f.flags&1048576)!==0&&aV(f,B0,f.index);switch(f.lanes=0,f.tag){case 16:e:{var A=f.pendingProps;if(d=Md(f.elementType),f.type=d,typeof d=="function")m$(d)?(A=Pd(d,A),f.tag=1,f=vU(null,f,d,A,x)):(f.tag=0,f=a_(null,f,d,A,x));else{if(d!=null){var N=d.$$typeof;if(N===k){f.tag=11,f=pU(null,f,d,A,x);break e}else if(N===E){f.tag=14,f=fU(null,f,d,A,x);break e}}throw f=U(d)||d,Error(a(306,f,""))}}return f;case 0:return a_(d,f,f.type,f.pendingProps,x);case 1:return A=f.type,N=Pd(A,f.pendingProps),vU(d,f,A,N,x);case 3:e:{if($e(f,f.stateNode.containerInfo),d===null)throw Error(a(387));A=f.pendingProps;var C=f.memoizedState;N=C.element,$$(d,f),q0(f,A,null,x);var z=f.memoizedState;if(A=z.cache,Oc(f,ir,A),A!==C.cache&&k$(f,[ir],x,!0),j0(),A=z.element,C.isDehydrated)if(C={element:A,isDehydrated:!1,cache:z.cache},f.updateQueue.baseState=C,f.memoizedState=C,f.flags&256){f=wU(d,f,A,x);break e}else if(A!==N){N=xo(Error(a(424)),f),P0(N),f=wU(d,f,A,x);break e}else for(d=f.stateNode.containerInfo,d.nodeType===9?d=d.body:d=d.nodeName==="HTML"?d.ownerDocument.body:d,da=ko(d.firstChild),ss=f,fn=!0,Rc=null,Ao=!0,x=gV(f,null,A,x),f.child=x;x;)x.flags=x.flags&-3|4096,x=x.sibling;else{if(Rd(),A===N){f=Eu(d,f,x);break e}os(d,f,A,x)}f=f.child}return f;case 26:return ck(d,f),d===null?(x=MW(f.type,null,f.pendingProps,null))?f.memoizedState=x:fn||(x=f.type,d=f.pendingProps,A=Ck(ke.current).createElement(x),A[Da]=f,A[Sn]=d,ls(A,x,d),sr(A),f.stateNode=A):f.memoizedState=MW(f.type,d.memoizedProps,f.pendingProps,d.memoizedState),null;case 27:return Ge(f),d===null&&fn&&(A=f.stateNode=DW(f.type,f.pendingProps,ke.current),ss=f,Ao=!0,N=da,qc(f.type)?(W_=N,da=ko(A.firstChild)):da=N),os(d,f,f.pendingProps.children,x),ck(d,f),d===null&&(f.flags|=4194304),f.child;case 5:return d===null&&fn&&((N=A=da)&&(A=Ile(A,f.type,f.pendingProps,Ao),A!==null?(f.stateNode=A,ss=f,da=ko(A.firstChild),Ao=!1,N=!0):N=!1),N||Dc(f)),Ge(f),N=f.type,C=f.pendingProps,z=d!==null?d.memoizedProps:null,A=C.children,z_(N,C)?A=null:z!==null&&z_(N,z)&&(f.flags|=32),f.memoizedState!==null&&(N=L$(d,f,Poe,null,null,x),pv._currentValue=N),ck(d,f),os(d,f,A,x),f.child;case 6:return d===null&&fn&&((d=x=da)&&(x=Nle(x,f.pendingProps,Ao),x!==null?(f.stateNode=x,ss=f,da=null,d=!0):d=!1),d||Dc(f)),null;case 13:return AU(d,f,x);case 4:return $e(f,f.stateNode.containerInfo),A=f.pendingProps,d===null?f.child=zd(f,null,A,x):os(d,f,A,x),f.child;case 11:return pU(d,f,f.type,f.pendingProps,x);case 7:return os(d,f,f.pendingProps,x),f.child;case 8:return os(d,f,f.pendingProps.children,x),f.child;case 12:return os(d,f,f.pendingProps.children,x),f.child;case 10:return A=f.pendingProps,Oc(f,f.type,A.value),os(d,f,A.children,x),f.child;case 9:return N=f.type._context,A=f.pendingProps.children,Od(f),N=is(N),A=A(N),f.flags|=1,os(d,f,A,x),f.child;case 14:return fU(d,f,f.type,f.pendingProps,x);case 15:return mU(d,f,f.type,f.pendingProps,x);case 19:return kU(d,f,x);case 31:return Koe(d,f,x);case 22:return gU(d,f,x,f.pendingProps);case 24:return Od(f),A=is(ir),d===null?(N=C$(),N===null&&(N=na,C=I$(),N.pooledCache=C,C.refCount++,C!==null&&(N.pooledCacheLanes|=x),N=C),f.memoizedState={parent:A,cache:N},E$(f),Oc(f,ir,N)):((d.lanes&x)!==0&&($$(d,f),q0(f,null,null,x),j0()),N=d.memoizedState,C=f.memoizedState,N.parent!==A?(N={parent:A,cache:A},f.memoizedState=N,f.lanes===0&&(f.memoizedState=f.updateQueue.baseState=N),Oc(f,ir,A)):(A=C.cache,Oc(f,ir,A),A!==N.cache&&k$(f,[ir],x,!0))),os(d,f,f.pendingProps.children,x),f.child;case 29:throw f.pendingProps}throw Error(a(156,f.tag))}function $u(d){d.flags|=4}function h_(d,f,x,A,N){if((f=(d.mode&32)!==0)&&(f=!1),f){if(d.flags|=16777216,(N&335544128)===N)if(d.stateNode.complete)d.flags|=8192;else if(ZU())d.flags|=8192;else throw Ld=XS,T$}else d.flags&=-16777217}function NU(d,f){if(f.type!=="stylesheet"||(f.state.loading&4)!==0)d.flags&=-16777217;else if(d.flags|=16777216,!VW(f))if(ZU())d.flags|=8192;else throw Ld=XS,T$}function dk(d,f){f!==null&&(d.flags|=4),d.flags&16384&&(f=d.tag!==22?je():536870912,d.lanes|=f,_g|=f)}function J0(d,f){if(!fn)switch(d.tailMode){case"hidden":f=d.tail;for(var x=null;f!==null;)f.alternate!==null&&(x=f),f=f.sibling;x===null?d.tail=null:x.sibling=null;break;case"collapsed":x=d.tail;for(var A=null;x!==null;)x.alternate!==null&&(A=x),x=x.sibling;A===null?f||d.tail===null?d.tail=null:d.tail.sibling=null:A.sibling=null}}function pa(d){var f=d.alternate!==null&&d.alternate.child===d.child,x=0,A=0;if(f)for(var N=d.child;N!==null;)x|=N.lanes|N.childLanes,A|=N.subtreeFlags&65011712,A|=N.flags&65011712,N.return=d,N=N.sibling;else for(N=d.child;N!==null;)x|=N.lanes|N.childLanes,A|=N.subtreeFlags,A|=N.flags,N.return=d,N=N.sibling;return d.subtreeFlags|=A,d.childLanes=x,f}function Yoe(d,f,x){var A=f.pendingProps;switch(x$(f),f.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return pa(f),null;case 1:return pa(f),null;case 3:return x=f.stateNode,A=null,d!==null&&(A=d.memoizedState.cache),f.memoizedState.cache!==A&&(f.flags|=2048),Nu(ir),Le(),x.pendingContext&&(x.context=x.pendingContext,x.pendingContext=null),(d===null||d.child===null)&&(bg(f)?$u(f):d===null||d.memoizedState.isDehydrated&&(f.flags&256)===0||(f.flags|=1024,w$())),pa(f),null;case 26:var N=f.type,C=f.memoizedState;return d===null?($u(f),C!==null?(pa(f),NU(f,C)):(pa(f),h_(f,N,null,A,x))):C?C!==d.memoizedState?($u(f),pa(f),NU(f,C)):(pa(f),f.flags&=-16777217):(d=d.memoizedProps,d!==A&&$u(f),pa(f),h_(f,N,d,A,x)),null;case 27:if(Ke(f),x=ke.current,N=f.type,d!==null&&f.stateNode!=null)d.memoizedProps!==A&&$u(f);else{if(!A){if(f.stateNode===null)throw Error(a(166));return pa(f),null}d=ae.current,bg(f)?sV(f):(d=DW(N,A,x),f.stateNode=d,$u(f))}return pa(f),null;case 5:if(Ke(f),N=f.type,d!==null&&f.stateNode!=null)d.memoizedProps!==A&&$u(f);else{if(!A){if(f.stateNode===null)throw Error(a(166));return pa(f),null}if(C=ae.current,bg(f))sV(f);else{var z=Ck(ke.current);switch(C){case 1:C=z.createElementNS("http://www.w3.org/2000/svg",N);break;case 2:C=z.createElementNS("http://www.w3.org/1998/Math/MathML",N);break;default:switch(N){case"svg":C=z.createElementNS("http://www.w3.org/2000/svg",N);break;case"math":C=z.createElementNS("http://www.w3.org/1998/Math/MathML",N);break;case"script":C=z.createElement("div"),C.innerHTML="<script><\/script>",C=C.removeChild(C.firstChild);break;case"select":C=typeof A.is=="string"?z.createElement("select",{is:A.is}):z.createElement("select"),A.multiple?C.multiple=!0:A.size&&(C.size=A.size);break;default:C=typeof A.is=="string"?z.createElement(N,{is:A.is}):z.createElement(N)}}C[Da]=f,C[Sn]=A;e:for(z=f.child;z!==null;){if(z.tag===5||z.tag===6)C.appendChild(z.stateNode);else if(z.tag!==4&&z.tag!==27&&z.child!==null){z.child.return=z,z=z.child;continue}if(z===f)break e;for(;z.sibling===null;){if(z.return===null||z.return===f)break e;z=z.return}z.sibling.return=z.return,z=z.sibling}f.stateNode=C;e:switch(ls(C,N,A),N){case"button":case"input":case"select":case"textarea":A=!!A.autoFocus;break e;case"img":A=!0;break e;default:A=!1}A&&$u(f)}}return pa(f),h_(f,f.type,d===null?null:d.memoizedProps,f.pendingProps,x),null;case 6:if(d&&f.stateNode!=null)d.memoizedProps!==A&&$u(f);else{if(typeof A!="string"&&f.stateNode===null)throw Error(a(166));if(d=ke.current,bg(f)){if(d=f.stateNode,x=f.memoizedProps,A=null,N=ss,N!==null)switch(N.tag){case 27:case 5:A=N.memoizedProps}d[Da]=f,d=!!(d.nodeValue===x||A!==null&&A.suppressHydrationWarning===!0||AW(d.nodeValue,x)),d||Dc(f,!0)}else d=Ck(d).createTextNode(A),d[Da]=f,f.stateNode=d}return pa(f),null;case 31:if(x=f.memoizedState,d===null||d.memoizedState!==null){if(A=bg(f),x!==null){if(d===null){if(!A)throw Error(a(318));if(d=f.memoizedState,d=d!==null?d.dehydrated:null,!d)throw Error(a(557));d[Da]=f}else Rd(),(f.flags&128)===0&&(f.memoizedState=null),f.flags|=4;pa(f),d=!1}else x=w$(),d!==null&&d.memoizedState!==null&&(d.memoizedState.hydrationErrors=x),d=!0;if(!d)return f.flags&256?(Wi(f),f):(Wi(f),null);if((f.flags&128)!==0)throw Error(a(558))}return pa(f),null;case 13:if(A=f.memoizedState,d===null||d.memoizedState!==null&&d.memoizedState.dehydrated!==null){if(N=bg(f),A!==null&&A.dehydrated!==null){if(d===null){if(!N)throw Error(a(318));if(N=f.memoizedState,N=N!==null?N.dehydrated:null,!N)throw Error(a(317));N[Da]=f}else Rd(),(f.flags&128)===0&&(f.memoizedState=null),f.flags|=4;pa(f),N=!1}else N=w$(),d!==null&&d.memoizedState!==null&&(d.memoizedState.hydrationErrors=N),N=!0;if(!N)return f.flags&256?(Wi(f),f):(Wi(f),null)}return Wi(f),(f.flags&128)!==0?(f.lanes=x,f):(x=A!==null,d=d!==null&&d.memoizedState!==null,x&&(A=f.child,N=null,A.alternate!==null&&A.alternate.memoizedState!==null&&A.alternate.memoizedState.cachePool!==null&&(N=A.alternate.memoizedState.cachePool.pool),C=null,A.memoizedState!==null&&A.memoizedState.cachePool!==null&&(C=A.memoizedState.cachePool.pool),C!==N&&(A.flags|=2048)),x!==d&&x&&(f.child.flags|=8192),dk(f,f.updateQueue),pa(f),null);case 4:return Le(),d===null&&D_(f.stateNode.containerInfo),pa(f),null;case 10:return Nu(f.type),pa(f),null;case 19:if(Q(ja),A=f.memoizedState,A===null)return pa(f),null;if(N=(f.flags&128)!==0,C=A.rendering,C===null)if(N)J0(A,!1);else{if(Ma!==0||d!==null&&(d.flags&128)!==0)for(d=f.child;d!==null;){if(C=JS(d),C!==null){for(f.flags|=128,J0(A,!1),d=C.updateQueue,f.updateQueue=d,dk(f,d),f.subtreeFlags=0,d=x,x=f.child;x!==null;)eV(x,d),x=x.sibling;return ee(ja,ja.current&1|2),fn&&ku(f,A.treeForkCount),f.child}d=d.sibling}A.tail!==null&&nn()>yk&&(f.flags|=128,N=!0,J0(A,!1),f.lanes=4194304)}else{if(!N)if(d=JS(C),d!==null){if(f.flags|=128,N=!0,d=d.updateQueue,f.updateQueue=d,dk(f,d),J0(A,!0),A.tail===null&&A.tailMode==="hidden"&&!C.alternate&&!fn)return pa(f),null}else 2*nn()-A.renderingStartTime>yk&&x!==536870912&&(f.flags|=128,N=!0,J0(A,!1),f.lanes=4194304);A.isBackwards?(C.sibling=f.child,f.child=C):(d=A.last,d!==null?d.sibling=C:f.child=C,A.last=C)}return A.tail!==null?(d=A.tail,A.rendering=d,A.tail=d.sibling,A.renderingStartTime=nn(),d.sibling=null,x=ja.current,ee(ja,N?x&1|2:x&1),fn&&ku(f,A.treeForkCount),d):(pa(f),null);case 22:case 23:return Wi(f),O$(),A=f.memoizedState!==null,d!==null?d.memoizedState!==null!==A&&(f.flags|=8192):A&&(f.flags|=8192),A?(x&536870912)!==0&&(f.flags&128)===0&&(pa(f),f.subtreeFlags&6&&(f.flags|=8192)):pa(f),x=f.updateQueue,x!==null&&dk(f,x.retryQueue),x=null,d!==null&&d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(x=d.memoizedState.cachePool.pool),A=null,f.memoizedState!==null&&f.memoizedState.cachePool!==null&&(A=f.memoizedState.cachePool.pool),A!==x&&(f.flags|=2048),d!==null&&Q(Fd),null;case 24:return x=null,d!==null&&(x=d.memoizedState.cache),f.memoizedState.cache!==x&&(f.flags|=2048),Nu(ir),pa(f),null;case 25:return null;case 30:return null}throw Error(a(156,f.tag))}function Qoe(d,f){switch(x$(f),f.tag){case 1:return d=f.flags,d&65536?(f.flags=d&-65537|128,f):null;case 3:return Nu(ir),Le(),d=f.flags,(d&65536)!==0&&(d&128)===0?(f.flags=d&-65537|128,f):null;case 26:case 27:case 5:return Ke(f),null;case 31:if(f.memoizedState!==null){if(Wi(f),f.alternate===null)throw Error(a(340));Rd()}return d=f.flags,d&65536?(f.flags=d&-65537|128,f):null;case 13:if(Wi(f),d=f.memoizedState,d!==null&&d.dehydrated!==null){if(f.alternate===null)throw Error(a(340));Rd()}return d=f.flags,d&65536?(f.flags=d&-65537|128,f):null;case 19:return Q(ja),null;case 4:return Le(),null;case 10:return Nu(f.type),null;case 22:case 23:return Wi(f),O$(),d!==null&&Q(Fd),d=f.flags,d&65536?(f.flags=d&-65537|128,f):null;case 24:return Nu(ir),null;case 25:return null;default:return null}}function CU(d,f){switch(x$(f),f.tag){case 3:Nu(ir),Le();break;case 26:case 27:case 5:Ke(f);break;case 4:Le();break;case 31:f.memoizedState!==null&&Wi(f);break;case 13:Wi(f);break;case 19:Q(ja);break;case 10:Nu(f.type);break;case 22:case 23:Wi(f),O$(),d!==null&&Q(Fd);break;case 24:Nu(ir)}}function ev(d,f){try{var x=f.updateQueue,A=x!==null?x.lastEffect:null;if(A!==null){var N=A.next;x=N;do{if((x.tag&d)===d){A=void 0;var C=x.create,z=x.inst;A=C(),z.destroy=A}x=x.next}while(x!==N)}}catch(Y){zn(f,f.return,Y)}}function Pc(d,f,x){try{var A=f.updateQueue,N=A!==null?A.lastEffect:null;if(N!==null){var C=N.next;A=C;do{if((A.tag&d)===d){var z=A.inst,Y=z.destroy;if(Y!==void 0){z.destroy=void 0,N=f;var ue=x,Ce=Y;try{Ce()}catch(ze){zn(N,ue,ze)}}}A=A.next}while(A!==C)}}catch(ze){zn(f,f.return,ze)}}function TU(d){var f=d.updateQueue;if(f!==null){var x=d.stateNode;try{bV(f,x)}catch(A){zn(d,d.return,A)}}}function EU(d,f,x){x.props=Pd(d.type,d.memoizedProps),x.state=d.memoizedState;try{x.componentWillUnmount()}catch(A){zn(d,f,A)}}function tv(d,f){try{var x=d.ref;if(x!==null){switch(d.tag){case 26:case 27:case 5:var A=d.stateNode;break;case 30:A=d.stateNode;break;default:A=d.stateNode}typeof x=="function"?d.refCleanup=x(A):x.current=A}}catch(N){zn(d,f,N)}}function $l(d,f){var x=d.ref,A=d.refCleanup;if(x!==null)if(typeof A=="function")try{A()}catch(N){zn(d,f,N)}finally{d.refCleanup=null,d=d.alternate,d!=null&&(d.refCleanup=null)}else if(typeof x=="function")try{x(null)}catch(N){zn(d,f,N)}else x.current=null}function $U(d){var f=d.type,x=d.memoizedProps,A=d.stateNode;try{e:switch(f){case"button":case"input":case"select":case"textarea":x.autoFocus&&A.focus();break e;case"img":x.src?A.src=x.src:x.srcSet&&(A.srcset=x.srcSet)}}catch(N){zn(d,d.return,N)}}function d_(d,f,x){try{var A=d.stateNode;xle(A,d.type,x,f),A[Sn]=f}catch(N){zn(d,d.return,N)}}function _U(d){return d.tag===5||d.tag===3||d.tag===26||d.tag===27&&qc(d.type)||d.tag===4}function p_(d){e:for(;;){for(;d.sibling===null;){if(d.return===null||_U(d.return))return null;d=d.return}for(d.sibling.return=d.return,d=d.sibling;d.tag!==5&&d.tag!==6&&d.tag!==18;){if(d.tag===27&&qc(d.type)||d.flags&2||d.child===null||d.tag===4)continue e;d.child.return=d,d=d.child}if(!(d.flags&2))return d.stateNode}}function f_(d,f,x){var A=d.tag;if(A===5||A===6)d=d.stateNode,f?(x.nodeType===9?x.body:x.nodeName==="HTML"?x.ownerDocument.body:x).insertBefore(d,f):(f=x.nodeType===9?x.body:x.nodeName==="HTML"?x.ownerDocument.body:x,f.appendChild(d),x=x._reactRootContainer,x!=null||f.onclick!==null||(f.onclick=ci));else if(A!==4&&(A===27&&qc(d.type)&&(x=d.stateNode,f=null),d=d.child,d!==null))for(f_(d,f,x),d=d.sibling;d!==null;)f_(d,f,x),d=d.sibling}function pk(d,f,x){var A=d.tag;if(A===5||A===6)d=d.stateNode,f?x.insertBefore(d,f):x.appendChild(d);else if(A!==4&&(A===27&&qc(d.type)&&(x=d.stateNode),d=d.child,d!==null))for(pk(d,f,x),d=d.sibling;d!==null;)pk(d,f,x),d=d.sibling}function RU(d){var f=d.stateNode,x=d.memoizedProps;try{for(var A=d.type,N=f.attributes;N.length;)f.removeAttributeNode(N[0]);ls(f,A,x),f[Da]=d,f[Sn]=x}catch(C){zn(d,d.return,C)}}var _u=!1,ur=!1,m_=!1,DU=typeof WeakSet=="function"?WeakSet:Set,Wr=null;function Zoe(d,f){if(d=d.containerInfo,M_=Ok,d=H4(d),l$(d)){if("selectionStart"in d)var x={start:d.selectionStart,end:d.selectionEnd};else e:{x=(x=d.ownerDocument)&&x.defaultView||window;var A=x.getSelection&&x.getSelection();if(A&&A.rangeCount!==0){x=A.anchorNode;var N=A.anchorOffset,C=A.focusNode;A=A.focusOffset;try{x.nodeType,C.nodeType}catch{x=null;break e}var z=0,Y=-1,ue=-1,Ce=0,ze=0,Ve=d,Ee=null;t:for(;;){for(var De;Ve!==x||N!==0&&Ve.nodeType!==3||(Y=z+N),Ve!==C||A!==0&&Ve.nodeType!==3||(ue=z+A),Ve.nodeType===3&&(z+=Ve.nodeValue.length),(De=Ve.firstChild)!==null;)Ee=Ve,Ve=De;for(;;){if(Ve===d)break t;if(Ee===x&&++Ce===N&&(Y=z),Ee===C&&++ze===A&&(ue=z),(De=Ve.nextSibling)!==null)break;Ve=Ee,Ee=Ve.parentNode}Ve=De}x=Y===-1||ue===-1?null:{start:Y,end:ue}}else x=null}x=x||{start:0,end:0}}else x=null;for(L_={focusedElem:d,selectionRange:x},Ok=!1,Wr=f;Wr!==null;)if(f=Wr,d=f.child,(f.subtreeFlags&1028)!==0&&d!==null)d.return=f,Wr=d;else for(;Wr!==null;){switch(f=Wr,C=f.alternate,d=f.flags,f.tag){case 0:if((d&4)!==0&&(d=f.updateQueue,d=d!==null?d.events:null,d!==null))for(x=0;x<d.length;x++)N=d[x],N.ref.impl=N.nextImpl;break;case 11:case 15:break;case 1:if((d&1024)!==0&&C!==null){d=void 0,x=f,N=C.memoizedProps,C=C.memoizedState,A=x.stateNode;try{var ht=Pd(x.type,N);d=A.getSnapshotBeforeUpdate(ht,C),A.__reactInternalSnapshotBeforeUpdate=d}catch(Tt){zn(x,x.return,Tt)}}break;case 3:if((d&1024)!==0){if(d=f.stateNode.containerInfo,x=d.nodeType,x===9)P_(d);else if(x===1)switch(d.nodeName){case"HEAD":case"HTML":case"BODY":P_(d);break;default:d.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((d&1024)!==0)throw Error(a(163))}if(d=f.sibling,d!==null){d.return=f.return,Wr=d;break}Wr=f.return}}function OU(d,f,x){var A=x.flags;switch(x.tag){case 0:case 11:case 15:Du(d,x),A&4&&ev(5,x);break;case 1:if(Du(d,x),A&4)if(d=x.stateNode,f===null)try{d.componentDidMount()}catch(z){zn(x,x.return,z)}else{var N=Pd(x.type,f.memoizedProps);f=f.memoizedState;try{d.componentDidUpdate(N,f,d.__reactInternalSnapshotBeforeUpdate)}catch(z){zn(x,x.return,z)}}A&64&&TU(x),A&512&&tv(x,x.return);break;case 3:if(Du(d,x),A&64&&(d=x.updateQueue,d!==null)){if(f=null,x.child!==null)switch(x.child.tag){case 27:case 5:f=x.child.stateNode;break;case 1:f=x.child.stateNode}try{bV(d,f)}catch(z){zn(x,x.return,z)}}break;case 27:f===null&&A&4&&RU(x);case 26:case 5:Du(d,x),f===null&&A&4&&$U(x),A&512&&tv(x,x.return);break;case 12:Du(d,x);break;case 31:Du(d,x),A&4&&LU(d,x);break;case 13:Du(d,x),A&4&&zU(d,x),A&64&&(d=x.memoizedState,d!==null&&(d=d.dehydrated,d!==null&&(x=ole.bind(null,x),Cle(d,x))));break;case 22:if(A=x.memoizedState!==null||_u,!A){f=f!==null&&f.memoizedState!==null||ur,N=_u;var C=ur;_u=A,(ur=f)&&!C?Ou(d,x,(x.subtreeFlags&8772)!==0):Du(d,x),_u=N,ur=C}break;case 30:break;default:Du(d,x)}}function FU(d){var f=d.alternate;f!==null&&(d.alternate=null,FU(f)),d.child=null,d.deletions=null,d.sibling=null,d.tag===5&&(f=d.stateNode,f!==null&&k0(f)),d.stateNode=null,d.return=null,d.dependencies=null,d.memoizedProps=null,d.memoizedState=null,d.pendingProps=null,d.stateNode=null,d.updateQueue=null}var xa=null,hi=!1;function Ru(d,f,x){for(x=x.child;x!==null;)MU(d,f,x),x=x.sibling}function MU(d,f,x){if(ba&&typeof ba.onCommitFiberUnmount=="function")try{ba.onCommitFiberUnmount(Ha,x)}catch{}switch(x.tag){case 26:ur||$l(x,f),Ru(d,f,x),x.memoizedState?x.memoizedState.count--:x.stateNode&&(x=x.stateNode,x.parentNode.removeChild(x));break;case 27:ur||$l(x,f);var A=xa,N=hi;qc(x.type)&&(xa=x.stateNode,hi=!1),Ru(d,f,x),cv(x.stateNode),xa=A,hi=N;break;case 5:ur||$l(x,f);case 6:if(A=xa,N=hi,xa=null,Ru(d,f,x),xa=A,hi=N,xa!==null)if(hi)try{(xa.nodeType===9?xa.body:xa.nodeName==="HTML"?xa.ownerDocument.body:xa).removeChild(x.stateNode)}catch(C){zn(x,f,C)}else try{xa.removeChild(x.stateNode)}catch(C){zn(x,f,C)}break;case 18:xa!==null&&(hi?(d=xa,TW(d.nodeType===9?d.body:d.nodeName==="HTML"?d.ownerDocument.body:d,x.stateNode),Bg(d)):TW(xa,x.stateNode));break;case 4:A=xa,N=hi,xa=x.stateNode.containerInfo,hi=!0,Ru(d,f,x),xa=A,hi=N;break;case 0:case 11:case 14:case 15:Pc(2,x,f),ur||Pc(4,x,f),Ru(d,f,x);break;case 1:ur||($l(x,f),A=x.stateNode,typeof A.componentWillUnmount=="function"&&EU(x,f,A)),Ru(d,f,x);break;case 21:Ru(d,f,x);break;case 22:ur=(A=ur)||x.memoizedState!==null,Ru(d,f,x),ur=A;break;default:Ru(d,f,x)}}function LU(d,f){if(f.memoizedState===null&&(d=f.alternate,d!==null&&(d=d.memoizedState,d!==null))){d=d.dehydrated;try{Bg(d)}catch(x){zn(f,f.return,x)}}}function zU(d,f){if(f.memoizedState===null&&(d=f.alternate,d!==null&&(d=d.memoizedState,d!==null&&(d=d.dehydrated,d!==null))))try{Bg(d)}catch(x){zn(f,f.return,x)}}function Joe(d){switch(d.tag){case 31:case 13:case 19:var f=d.stateNode;return f===null&&(f=d.stateNode=new DU),f;case 22:return d=d.stateNode,f=d._retryCache,f===null&&(f=d._retryCache=new DU),f;default:throw Error(a(435,d.tag))}}function fk(d,f){var x=Joe(d);f.forEach(function(A){if(!x.has(A)){x.add(A);var N=lle.bind(null,d,A);A.then(N,N)}})}function di(d,f){var x=f.deletions;if(x!==null)for(var A=0;A<x.length;A++){var N=x[A],C=d,z=f,Y=z;e:for(;Y!==null;){switch(Y.tag){case 27:if(qc(Y.type)){xa=Y.stateNode,hi=!1;break e}break;case 5:xa=Y.stateNode,hi=!1;break e;case 3:case 4:xa=Y.stateNode.containerInfo,hi=!0;break e}Y=Y.return}if(xa===null)throw Error(a(160));MU(C,z,N),xa=null,hi=!1,C=N.alternate,C!==null&&(C.return=null),N.return=null}if(f.subtreeFlags&13886)for(f=f.child;f!==null;)BU(f,d),f=f.sibling}var Ko=null;function BU(d,f){var x=d.alternate,A=d.flags;switch(d.tag){case 0:case 11:case 14:case 15:di(f,d),pi(d),A&4&&(Pc(3,d,d.return),ev(3,d),Pc(5,d,d.return));break;case 1:di(f,d),pi(d),A&512&&(ur||x===null||$l(x,x.return)),A&64&&_u&&(d=d.updateQueue,d!==null&&(A=d.callbacks,A!==null&&(x=d.shared.hiddenCallbacks,d.shared.hiddenCallbacks=x===null?A:x.concat(A))));break;case 26:var N=Ko;if(di(f,d),pi(d),A&512&&(ur||x===null||$l(x,x.return)),A&4){var C=x!==null?x.memoizedState:null;if(A=d.memoizedState,x===null)if(A===null)if(d.stateNode===null){e:{A=d.type,x=d.memoizedProps,N=N.ownerDocument||N;t:switch(A){case"title":C=N.getElementsByTagName("title")[0],(!C||C[Sd]||C[Da]||C.namespaceURI==="http://www.w3.org/2000/svg"||C.hasAttribute("itemprop"))&&(C=N.createElement(A),N.head.insertBefore(C,N.querySelector("head > title"))),ls(C,A,x),C[Da]=d,sr(C),A=C;break e;case"link":var z=BW("link","href",N).get(A+(x.href||""));if(z){for(var Y=0;Y<z.length;Y++)if(C=z[Y],C.getAttribute("href")===(x.href==null||x.href===""?null:x.href)&&C.getAttribute("rel")===(x.rel==null?null:x.rel)&&C.getAttribute("title")===(x.title==null?null:x.title)&&C.getAttribute("crossorigin")===(x.crossOrigin==null?null:x.crossOrigin)){z.splice(Y,1);break t}}C=N.createElement(A),ls(C,A,x),N.head.appendChild(C);break;case"meta":if(z=BW("meta","content",N).get(A+(x.content||""))){for(Y=0;Y<z.length;Y++)if(C=z[Y],C.getAttribute("content")===(x.content==null?null:""+x.content)&&C.getAttribute("name")===(x.name==null?null:x.name)&&C.getAttribute("property")===(x.property==null?null:x.property)&&C.getAttribute("http-equiv")===(x.httpEquiv==null?null:x.httpEquiv)&&C.getAttribute("charset")===(x.charSet==null?null:x.charSet)){z.splice(Y,1);break t}}C=N.createElement(A),ls(C,A,x),N.head.appendChild(C);break;default:throw Error(a(468,A))}C[Da]=d,sr(C),A=C}d.stateNode=A}else PW(N,d.type,d.stateNode);else d.stateNode=zW(N,A,d.memoizedProps);else C!==A?(C===null?x.stateNode!==null&&(x=x.stateNode,x.parentNode.removeChild(x)):C.count--,A===null?PW(N,d.type,d.stateNode):zW(N,A,d.memoizedProps)):A===null&&d.stateNode!==null&&d_(d,d.memoizedProps,x.memoizedProps)}break;case 27:di(f,d),pi(d),A&512&&(ur||x===null||$l(x,x.return)),x!==null&&A&4&&d_(d,d.memoizedProps,x.memoizedProps);break;case 5:if(di(f,d),pi(d),A&512&&(ur||x===null||$l(x,x.return)),d.flags&32){N=d.stateNode;try{Cl(N,"")}catch(ht){zn(d,d.return,ht)}}A&4&&d.stateNode!=null&&(N=d.memoizedProps,d_(d,N,x!==null?x.memoizedProps:N)),A&1024&&(m_=!0);break;case 6:if(di(f,d),pi(d),A&4){if(d.stateNode===null)throw Error(a(162));A=d.memoizedProps,x=d.stateNode;try{x.nodeValue=A}catch(ht){zn(d,d.return,ht)}}break;case 3:if($k=null,N=Ko,Ko=Tk(f.containerInfo),di(f,d),Ko=N,pi(d),A&4&&x!==null&&x.memoizedState.isDehydrated)try{Bg(f.containerInfo)}catch(ht){zn(d,d.return,ht)}m_&&(m_=!1,PU(d));break;case 4:A=Ko,Ko=Tk(d.stateNode.containerInfo),di(f,d),pi(d),Ko=A;break;case 12:di(f,d),pi(d);break;case 31:di(f,d),pi(d),A&4&&(A=d.updateQueue,A!==null&&(d.updateQueue=null,fk(d,A)));break;case 13:di(f,d),pi(d),d.child.flags&8192&&d.memoizedState!==null!=(x!==null&&x.memoizedState!==null)&&(gk=nn()),A&4&&(A=d.updateQueue,A!==null&&(d.updateQueue=null,fk(d,A)));break;case 22:N=d.memoizedState!==null;var ue=x!==null&&x.memoizedState!==null,Ce=_u,ze=ur;if(_u=Ce||N,ur=ze||ue,di(f,d),ur=ze,_u=Ce,pi(d),A&8192)e:for(f=d.stateNode,f._visibility=N?f._visibility&-2:f._visibility|1,N&&(x===null||ue||_u||ur||Vd(d)),x=null,f=d;;){if(f.tag===5||f.tag===26){if(x===null){ue=x=f;try{if(C=ue.stateNode,N)z=C.style,typeof z.setProperty=="function"?z.setProperty("display","none","important"):z.display="none";else{Y=ue.stateNode;var Ve=ue.memoizedProps.style,Ee=Ve!=null&&Ve.hasOwnProperty("display")?Ve.display:null;Y.style.display=Ee==null||typeof Ee=="boolean"?"":(""+Ee).trim()}}catch(ht){zn(ue,ue.return,ht)}}}else if(f.tag===6){if(x===null){ue=f;try{ue.stateNode.nodeValue=N?"":ue.memoizedProps}catch(ht){zn(ue,ue.return,ht)}}}else if(f.tag===18){if(x===null){ue=f;try{var De=ue.stateNode;N?EW(De,!0):EW(ue.stateNode,!1)}catch(ht){zn(ue,ue.return,ht)}}}else if((f.tag!==22&&f.tag!==23||f.memoizedState===null||f===d)&&f.child!==null){f.child.return=f,f=f.child;continue}if(f===d)break e;for(;f.sibling===null;){if(f.return===null||f.return===d)break e;x===f&&(x=null),f=f.return}x===f&&(x=null),f.sibling.return=f.return,f=f.sibling}A&4&&(A=d.updateQueue,A!==null&&(x=A.retryQueue,x!==null&&(A.retryQueue=null,fk(d,x))));break;case 19:di(f,d),pi(d),A&4&&(A=d.updateQueue,A!==null&&(d.updateQueue=null,fk(d,A)));break;case 30:break;case 21:break;default:di(f,d),pi(d)}}function pi(d){var f=d.flags;if(f&2){try{for(var x,A=d.return;A!==null;){if(_U(A)){x=A;break}A=A.return}if(x==null)throw Error(a(160));switch(x.tag){case 27:var N=x.stateNode,C=p_(d);pk(d,C,N);break;case 5:var z=x.stateNode;x.flags&32&&(Cl(z,""),x.flags&=-33);var Y=p_(d);pk(d,Y,z);break;case 3:case 4:var ue=x.stateNode.containerInfo,Ce=p_(d);f_(d,Ce,ue);break;default:throw Error(a(161))}}catch(ze){zn(d,d.return,ze)}d.flags&=-3}f&4096&&(d.flags&=-4097)}function PU(d){if(d.subtreeFlags&1024)for(d=d.child;d!==null;){var f=d;PU(f),f.tag===5&&f.flags&1024&&f.stateNode.reset(),d=d.sibling}}function Du(d,f){if(f.subtreeFlags&8772)for(f=f.child;f!==null;)OU(d,f.alternate,f),f=f.sibling}function Vd(d){for(d=d.child;d!==null;){var f=d;switch(f.tag){case 0:case 11:case 14:case 15:Pc(4,f,f.return),Vd(f);break;case 1:$l(f,f.return);var x=f.stateNode;typeof x.componentWillUnmount=="function"&&EU(f,f.return,x),Vd(f);break;case 27:cv(f.stateNode);case 26:case 5:$l(f,f.return),Vd(f);break;case 22:f.memoizedState===null&&Vd(f);break;case 30:Vd(f);break;default:Vd(f)}d=d.sibling}}function Ou(d,f,x){for(x=x&&(f.subtreeFlags&8772)!==0,f=f.child;f!==null;){var A=f.alternate,N=d,C=f,z=C.flags;switch(C.tag){case 0:case 11:case 15:Ou(N,C,x),ev(4,C);break;case 1:if(Ou(N,C,x),A=C,N=A.stateNode,typeof N.componentDidMount=="function")try{N.componentDidMount()}catch(Ce){zn(A,A.return,Ce)}if(A=C,N=A.updateQueue,N!==null){var Y=A.stateNode;try{var ue=N.shared.hiddenCallbacks;if(ue!==null)for(N.shared.hiddenCallbacks=null,N=0;N<ue.length;N++)yV(ue[N],Y)}catch(Ce){zn(A,A.return,Ce)}}x&&z&64&&TU(C),tv(C,C.return);break;case 27:RU(C);case 26:case 5:Ou(N,C,x),x&&A===null&&z&4&&$U(C),tv(C,C.return);break;case 12:Ou(N,C,x);break;case 31:Ou(N,C,x),x&&z&4&&LU(N,C);break;case 13:Ou(N,C,x),x&&z&4&&zU(N,C);break;case 22:C.memoizedState===null&&Ou(N,C,x),tv(C,C.return);break;case 30:break;default:Ou(N,C,x)}f=f.sibling}}function g_(d,f){var x=null;d!==null&&d.memoizedState!==null&&d.memoizedState.cachePool!==null&&(x=d.memoizedState.cachePool.pool),d=null,f.memoizedState!==null&&f.memoizedState.cachePool!==null&&(d=f.memoizedState.cachePool.pool),d!==x&&(d!=null&&d.refCount++,x!=null&&V0(x))}function y_(d,f){d=null,f.alternate!==null&&(d=f.alternate.memoizedState.cache),f=f.memoizedState.cache,f!==d&&(f.refCount++,d!=null&&V0(d))}function Xo(d,f,x,A){if(f.subtreeFlags&10256)for(f=f.child;f!==null;)VU(d,f,x,A),f=f.sibling}function VU(d,f,x,A){var N=f.flags;switch(f.tag){case 0:case 11:case 15:Xo(d,f,x,A),N&2048&&ev(9,f);break;case 1:Xo(d,f,x,A);break;case 3:Xo(d,f,x,A),N&2048&&(d=null,f.alternate!==null&&(d=f.alternate.memoizedState.cache),f=f.memoizedState.cache,f!==d&&(f.refCount++,d!=null&&V0(d)));break;case 12:if(N&2048){Xo(d,f,x,A),d=f.stateNode;try{var C=f.memoizedProps,z=C.id,Y=C.onPostCommit;typeof Y=="function"&&Y(z,f.alternate===null?"mount":"update",d.passiveEffectDuration,-0)}catch(ue){zn(f,f.return,ue)}}else Xo(d,f,x,A);break;case 31:Xo(d,f,x,A);break;case 13:Xo(d,f,x,A);break;case 23:break;case 22:C=f.stateNode,z=f.alternate,f.memoizedState!==null?C._visibility&2?Xo(d,f,x,A):nv(d,f):C._visibility&2?Xo(d,f,x,A):(C._visibility|=2,Tg(d,f,x,A,(f.subtreeFlags&10256)!==0||!1)),N&2048&&g_(z,f);break;case 24:Xo(d,f,x,A),N&2048&&y_(f.alternate,f);break;default:Xo(d,f,x,A)}}function Tg(d,f,x,A,N){for(N=N&&((f.subtreeFlags&10256)!==0||!1),f=f.child;f!==null;){var C=d,z=f,Y=x,ue=A,Ce=z.flags;switch(z.tag){case 0:case 11:case 15:Tg(C,z,Y,ue,N),ev(8,z);break;case 23:break;case 22:var ze=z.stateNode;z.memoizedState!==null?ze._visibility&2?Tg(C,z,Y,ue,N):nv(C,z):(ze._visibility|=2,Tg(C,z,Y,ue,N)),N&&Ce&2048&&g_(z.alternate,z);break;case 24:Tg(C,z,Y,ue,N),N&&Ce&2048&&y_(z.alternate,z);break;default:Tg(C,z,Y,ue,N)}f=f.sibling}}function nv(d,f){if(f.subtreeFlags&10256)for(f=f.child;f!==null;){var x=d,A=f,N=A.flags;switch(A.tag){case 22:nv(x,A),N&2048&&g_(A.alternate,A);break;case 24:nv(x,A),N&2048&&y_(A.alternate,A);break;default:nv(x,A)}f=f.sibling}}var av=8192;function Eg(d,f,x){if(d.subtreeFlags&av)for(d=d.child;d!==null;)UU(d,f,x),d=d.sibling}function UU(d,f,x){switch(d.tag){case 26:Eg(d,f,x),d.flags&av&&d.memoizedState!==null&&Ble(x,Ko,d.memoizedState,d.memoizedProps);break;case 5:Eg(d,f,x);break;case 3:case 4:var A=Ko;Ko=Tk(d.stateNode.containerInfo),Eg(d,f,x),Ko=A;break;case 22:d.memoizedState===null&&(A=d.alternate,A!==null&&A.memoizedState!==null?(A=av,av=16777216,Eg(d,f,x),av=A):Eg(d,f,x));break;default:Eg(d,f,x)}}function WU(d){var f=d.alternate;if(f!==null&&(d=f.child,d!==null)){f.child=null;do f=d.sibling,d.sibling=null,d=f;while(d!==null)}}function rv(d){var f=d.deletions;if((d.flags&16)!==0){if(f!==null)for(var x=0;x<f.length;x++){var A=f[x];Wr=A,HU(A,d)}WU(d)}if(d.subtreeFlags&10256)for(d=d.child;d!==null;)GU(d),d=d.sibling}function GU(d){switch(d.tag){case 0:case 11:case 15:rv(d),d.flags&2048&&Pc(9,d,d.return);break;case 3:rv(d);break;case 12:rv(d);break;case 22:var f=d.stateNode;d.memoizedState!==null&&f._visibility&2&&(d.return===null||d.return.tag!==13)?(f._visibility&=-3,mk(d)):rv(d);break;default:rv(d)}}function mk(d){var f=d.deletions;if((d.flags&16)!==0){if(f!==null)for(var x=0;x<f.length;x++){var A=f[x];Wr=A,HU(A,d)}WU(d)}for(d=d.child;d!==null;){switch(f=d,f.tag){case 0:case 11:case 15:Pc(8,f,f.return),mk(f);break;case 22:x=f.stateNode,x._visibility&2&&(x._visibility&=-3,mk(f));break;default:mk(f)}d=d.sibling}}function HU(d,f){for(;Wr!==null;){var x=Wr;switch(x.tag){case 0:case 11:case 15:Pc(8,x,f);break;case 23:case 22:if(x.memoizedState!==null&&x.memoizedState.cachePool!==null){var A=x.memoizedState.cachePool.pool;A!=null&&A.refCount++}break;case 24:V0(x.memoizedState.cache)}if(A=x.child,A!==null)A.return=x,Wr=A;else e:for(x=d;Wr!==null;){A=Wr;var N=A.sibling,C=A.return;if(FU(A),A===x){Wr=null;break e}if(N!==null){N.return=C,Wr=N;break e}Wr=C}}}var ele={getCacheForType:function(d){var f=is(ir),x=f.data.get(d);return x===void 0&&(x=d(),f.data.set(d,x)),x},cacheSignal:function(){return is(ir).controller.signal}},tle=typeof WeakMap=="function"?WeakMap:Map,kn=0,na=null,rn=null,hn=0,Ln=0,Gi=null,Vc=!1,$g=!1,b_=!1,Fu=0,Ma=0,Uc=0,Ud=0,x_=0,Hi=0,_g=0,sv=null,fi=null,v_=!1,gk=0,jU=0,yk=1/0,bk=null,Wc=null,Ar=0,Gc=null,Rg=null,Mu=0,w_=0,A_=null,qU=null,iv=0,S_=null;function ji(){return(kn&2)!==0&&hn!==0?hn&-hn:B.T!==null?E_():mo()}function KU(){if(Hi===0)if((hn&536870912)===0||fn){var d=jo;jo<<=1,(jo&3932160)===0&&(jo=262144),Hi=d}else Hi=536870912;return d=Ui.current,d!==null&&(d.flags|=32),Hi}function mi(d,f,x){(d===na&&(Ln===2||Ln===9)||d.cancelPendingCommit!==null)&&(Dg(d,0),Hc(d,hn,Hi,!1)),Ye(d,x),((kn&2)===0||d!==na)&&(d===na&&((kn&2)===0&&(Ud|=x),Ma===4&&Hc(d,hn,Hi,!1)),_l(d))}function XU(d,f,x){if((kn&6)!==0)throw Error(a(327));var A=!x&&(f&127)===0&&(f&d.expiredLanes)===0||Nl(d,f),N=A?rle(d,f):I_(d,f,!0),C=A;do{if(N===0){$g&&!A&&Hc(d,f,0,!1);break}else{if(x=d.current.alternate,C&&!nle(x)){N=I_(d,f,!1),C=!1;continue}if(N===2){if(C=f,d.errorRecoveryDisabledLanes&C)var z=0;else z=d.pendingLanes&-536870913,z=z!==0?z:z&536870912?536870912:0;if(z!==0){f=z;e:{var Y=d;N=sv;var ue=Y.current.memoizedState.isDehydrated;if(ue&&(Dg(Y,z).flags|=256),z=I_(Y,z,!1),z!==2){if(b_&&!ue){Y.errorRecoveryDisabledLanes|=C,Ud|=C,N=4;break e}C=fi,fi=N,C!==null&&(fi===null?fi=C:fi.push.apply(fi,C))}N=z}if(C=!1,N!==2)continue}}if(N===1){Dg(d,0),Hc(d,f,0,!0);break}e:{switch(A=d,C=N,C){case 0:case 1:throw Error(a(345));case 4:if((f&4194048)!==f)break;case 6:Hc(A,f,Hi,!Vc);break e;case 2:fi=null;break;case 3:case 5:break;default:throw Error(a(329))}if((f&62914560)===f&&(N=gk+300-nn(),10<N)){if(Hc(A,f,Hi,!Vc),fo(A,0,!0)!==0)break e;Mu=f,A.timeoutHandle=NW(YU.bind(null,A,x,fi,bk,v_,f,Hi,Ud,_g,Vc,C,"Throttled",-0,0),N);break e}YU(A,x,fi,bk,v_,f,Hi,Ud,_g,Vc,C,null,-0,0)}}break}while(!0);_l(d)}function YU(d,f,x,A,N,C,z,Y,ue,Ce,ze,Ve,Ee,De){if(d.timeoutHandle=-1,Ve=f.subtreeFlags,Ve&8192||(Ve&16785408)===16785408){Ve={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:ci},UU(f,C,Ve);var ht=(C&62914560)===C?gk-nn():(C&4194048)===C?jU-nn():0;if(ht=Ple(Ve,ht),ht!==null){Mu=C,d.cancelPendingCommit=ht(rW.bind(null,d,f,C,x,A,N,z,Y,ue,ze,Ve,null,Ee,De)),Hc(d,C,z,!Ce);return}}rW(d,f,C,x,A,N,z,Y,ue)}function nle(d){for(var f=d;;){var x=f.tag;if((x===0||x===11||x===15)&&f.flags&16384&&(x=f.updateQueue,x!==null&&(x=x.stores,x!==null)))for(var A=0;A<x.length;A++){var N=x[A],C=N.getSnapshot;N=N.value;try{if(!Pi(C(),N))return!1}catch{return!1}}if(x=f.child,f.subtreeFlags&16384&&x!==null)x.return=f,f=x;else{if(f===d)break;for(;f.sibling===null;){if(f.return===null||f.return===d)return!0;f=f.return}f.sibling.return=f.return,f=f.sibling}}return!0}function Hc(d,f,x,A){f&=~x_,f&=~Ud,d.suspendedLanes|=f,d.pingedLanes&=~f,A&&(d.warmLanes|=f),A=d.expirationTimes;for(var N=f;0<N;){var C=31-Vr(N),z=1<<C;A[C]=-1,N&=~z}x!==0&&Kn(d,x,f)}function xk(){return(kn&6)===0?(ov(0),!1):!0}function k_(){if(rn!==null){if(Ln===0)var d=rn.return;else d=rn,Iu=Dd=null,P$(d),Sg=null,W0=0,d=rn;for(;d!==null;)CU(d.alternate,d),d=d.return;rn=null}}function Dg(d,f){var x=d.timeoutHandle;x!==-1&&(d.timeoutHandle=-1,Ale(x)),x=d.cancelPendingCommit,x!==null&&(d.cancelPendingCommit=null,x()),Mu=0,k_(),na=d,rn=x=Su(d.current,null),hn=f,Ln=0,Gi=null,Vc=!1,$g=Nl(d,f),b_=!1,_g=Hi=x_=Ud=Uc=Ma=0,fi=sv=null,v_=!1,(f&8)!==0&&(f|=f&32);var A=d.entangledLanes;if(A!==0)for(d=d.entanglements,A&=f;0<A;){var N=31-Vr(A),C=1<<N;f|=d[N],A&=~C}return Fu=f,PS(),x}function QU(d,f){Ht=null,B.H=Q0,f===Ag||f===KS?(f=pV(),Ln=3):f===T$?(f=pV(),Ln=4):Ln=f===n_?8:f!==null&&typeof f=="object"&&typeof f.then=="function"?6:1,Gi=f,rn===null&&(Ma=1,lk(d,xo(f,d.current)))}function ZU(){var d=Ui.current;return d===null?!0:(hn&4194048)===hn?So===null:(hn&62914560)===hn||(hn&536870912)!==0?d===So:!1}function JU(){var d=B.H;return B.H=Q0,d===null?Q0:d}function eW(){var d=B.A;return B.A=ele,d}function vk(){Ma=4,Vc||(hn&4194048)!==hn&&Ui.current!==null||($g=!0),(Uc&134217727)===0&&(Ud&134217727)===0||na===null||Hc(na,hn,Hi,!1)}function I_(d,f,x){var A=kn;kn|=2;var N=JU(),C=eW();(na!==d||hn!==f)&&(bk=null,Dg(d,f)),f=!1;var z=Ma;e:do try{if(Ln!==0&&rn!==null){var Y=rn,ue=Gi;switch(Ln){case 8:k_(),z=6;break e;case 3:case 2:case 9:case 6:Ui.current===null&&(f=!0);var Ce=Ln;if(Ln=0,Gi=null,Og(d,Y,ue,Ce),x&&$g){z=0;break e}break;default:Ce=Ln,Ln=0,Gi=null,Og(d,Y,ue,Ce)}}ale(),z=Ma;break}catch(ze){QU(d,ze)}while(!0);return f&&d.shellSuspendCounter++,Iu=Dd=null,kn=A,B.H=N,B.A=C,rn===null&&(na=null,hn=0,PS()),z}function ale(){for(;rn!==null;)tW(rn)}function rle(d,f){var x=kn;kn|=2;var A=JU(),N=eW();na!==d||hn!==f?(bk=null,yk=nn()+500,Dg(d,f)):$g=Nl(d,f);e:do try{if(Ln!==0&&rn!==null){f=rn;var C=Gi;t:switch(Ln){case 1:Ln=0,Gi=null,Og(d,f,C,1);break;case 2:case 9:if(hV(C)){Ln=0,Gi=null,nW(f);break}f=function(){Ln!==2&&Ln!==9||na!==d||(Ln=7),_l(d)},C.then(f,f);break e;case 3:Ln=7;break e;case 4:Ln=5;break e;case 7:hV(C)?(Ln=0,Gi=null,nW(f)):(Ln=0,Gi=null,Og(d,f,C,7));break;case 5:var z=null;switch(rn.tag){case 26:z=rn.memoizedState;case 5:case 27:var Y=rn;if(z?VW(z):Y.stateNode.complete){Ln=0,Gi=null;var ue=Y.sibling;if(ue!==null)rn=ue;else{var Ce=Y.return;Ce!==null?(rn=Ce,wk(Ce)):rn=null}break t}}Ln=0,Gi=null,Og(d,f,C,5);break;case 6:Ln=0,Gi=null,Og(d,f,C,6);break;case 8:k_(),Ma=6;break e;default:throw Error(a(462))}}sle();break}catch(ze){QU(d,ze)}while(!0);return Iu=Dd=null,B.H=A,B.A=N,kn=x,rn!==null?0:(na=null,hn=0,PS(),Ma)}function sle(){for(;rn!==null&&!yn();)tW(rn)}function tW(d){var f=IU(d.alternate,d,Fu);d.memoizedProps=d.pendingProps,f===null?wk(d):rn=f}function nW(d){var f=d,x=f.alternate;switch(f.tag){case 15:case 0:f=xU(x,f,f.pendingProps,f.type,void 0,hn);break;case 11:f=xU(x,f,f.pendingProps,f.type.render,f.ref,hn);break;case 5:P$(f);default:CU(x,f),f=rn=eV(f,Fu),f=IU(x,f,Fu)}d.memoizedProps=d.pendingProps,f===null?wk(d):rn=f}function Og(d,f,x,A){Iu=Dd=null,P$(f),Sg=null,W0=0;var N=f.return;try{if(qoe(d,N,f,x,hn)){Ma=1,lk(d,xo(x,d.current)),rn=null;return}}catch(C){if(N!==null)throw rn=N,C;Ma=1,lk(d,xo(x,d.current)),rn=null;return}f.flags&32768?(fn||A===1?d=!0:$g||(hn&536870912)!==0?d=!1:(Vc=d=!0,(A===2||A===9||A===3||A===6)&&(A=Ui.current,A!==null&&A.tag===13&&(A.flags|=16384))),aW(f,d)):wk(f)}function wk(d){var f=d;do{if((f.flags&32768)!==0){aW(f,Vc);return}d=f.return;var x=Yoe(f.alternate,f,Fu);if(x!==null){rn=x;return}if(f=f.sibling,f!==null){rn=f;return}rn=f=d}while(f!==null);Ma===0&&(Ma=5)}function aW(d,f){do{var x=Qoe(d.alternate,d);if(x!==null){x.flags&=32767,rn=x;return}if(x=d.return,x!==null&&(x.flags|=32768,x.subtreeFlags=0,x.deletions=null),!f&&(d=d.sibling,d!==null)){rn=d;return}rn=d=x}while(d!==null);Ma=6,rn=null}function rW(d,f,x,A,N,C,z,Y,ue){d.cancelPendingCommit=null;do Ak();while(Ar!==0);if((kn&6)!==0)throw Error(a(327));if(f!==null){if(f===d.current)throw Error(a(177));if(C=f.lanes|f.childLanes,C|=p$,Mn(d,x,C,z,Y,ue),d===na&&(rn=na=null,hn=0),Rg=f,Gc=d,Mu=x,w_=C,A_=N,qU=A,(f.subtreeFlags&10256)!==0||(f.flags&10256)!==0?(d.callbackNode=null,d.callbackPriority=0,ule(ta,function(){return uW(),null})):(d.callbackNode=null,d.callbackPriority=0),A=(f.flags&13878)!==0,(f.subtreeFlags&13878)!==0||A){A=B.T,B.T=null,N=H.p,H.p=2,z=kn,kn|=4;try{Zoe(d,f,x)}finally{kn=z,H.p=N,B.T=A}}Ar=1,sW(),iW(),oW()}}function sW(){if(Ar===1){Ar=0;var d=Gc,f=Rg,x=(f.flags&13878)!==0;if((f.subtreeFlags&13878)!==0||x){x=B.T,B.T=null;var A=H.p;H.p=2;var N=kn;kn|=4;try{BU(f,d);var C=L_,z=H4(d.containerInfo),Y=C.focusedElem,ue=C.selectionRange;if(z!==Y&&Y&&Y.ownerDocument&&G4(Y.ownerDocument.documentElement,Y)){if(ue!==null&&l$(Y)){var Ce=ue.start,ze=ue.end;if(ze===void 0&&(ze=Ce),"selectionStart"in Y)Y.selectionStart=Ce,Y.selectionEnd=Math.min(ze,Y.value.length);else{var Ve=Y.ownerDocument||document,Ee=Ve&&Ve.defaultView||window;if(Ee.getSelection){var De=Ee.getSelection(),ht=Y.textContent.length,Tt=Math.min(ue.start,ht),Qn=ue.end===void 0?Tt:Math.min(ue.end,ht);!De.extend&&Tt>Qn&&(z=Qn,Qn=Tt,Tt=z);var ve=W4(Y,Tt),be=W4(Y,Qn);if(ve&&be&&(De.rangeCount!==1||De.anchorNode!==ve.node||De.anchorOffset!==ve.offset||De.focusNode!==be.node||De.focusOffset!==be.offset)){var Ne=Ve.createRange();Ne.setStart(ve.node,ve.offset),De.removeAllRanges(),Tt>Qn?(De.addRange(Ne),De.extend(be.node,be.offset)):(Ne.setEnd(be.node,be.offset),De.addRange(Ne))}}}}for(Ve=[],De=Y;De=De.parentNode;)De.nodeType===1&&Ve.push({element:De,left:De.scrollLeft,top:De.scrollTop});for(typeof Y.focus=="function"&&Y.focus(),Y=0;Y<Ve.length;Y++){var Be=Ve[Y];Be.element.scrollLeft=Be.left,Be.element.scrollTop=Be.top}}Ok=!!M_,L_=M_=null}finally{kn=N,H.p=A,B.T=x}}d.current=f,Ar=2}}function iW(){if(Ar===2){Ar=0;var d=Gc,f=Rg,x=(f.flags&8772)!==0;if((f.subtreeFlags&8772)!==0||x){x=B.T,B.T=null;var A=H.p;H.p=2;var N=kn;kn|=4;try{OU(d,f.alternate,f)}finally{kn=N,H.p=A,B.T=x}}Ar=3}}function oW(){if(Ar===4||Ar===3){Ar=0,ca();var d=Gc,f=Rg,x=Mu,A=qU;(f.subtreeFlags&10256)!==0||(f.flags&10256)!==0?Ar=5:(Ar=0,Rg=Gc=null,lW(d,d.pendingLanes));var N=d.pendingLanes;if(N===0&&(Wc=null),as(x),f=f.stateNode,ba&&typeof ba.onCommitFiberRoot=="function")try{ba.onCommitFiberRoot(Ha,f,void 0,(f.current.flags&128)===128)}catch{}if(A!==null){f=B.T,N=H.p,H.p=2,B.T=null;try{for(var C=d.onRecoverableError,z=0;z<A.length;z++){var Y=A[z];C(Y.value,{componentStack:Y.stack})}}finally{B.T=f,H.p=N}}(Mu&3)!==0&&Ak(),_l(d),N=d.pendingLanes,(x&261930)!==0&&(N&42)!==0?d===S_?iv++:(iv=0,S_=d):iv=0,ov(0)}}function lW(d,f){(d.pooledCacheLanes&=f)===0&&(f=d.pooledCache,f!=null&&(d.pooledCache=null,V0(f)))}function Ak(){return sW(),iW(),oW(),uW()}function uW(){if(Ar!==5)return!1;var d=Gc,f=w_;w_=0;var x=as(Mu),A=B.T,N=H.p;try{H.p=32>x?32:x,B.T=null,x=A_,A_=null;var C=Gc,z=Mu;if(Ar=0,Rg=Gc=null,Mu=0,(kn&6)!==0)throw Error(a(331));var Y=kn;if(kn|=4,GU(C.current),VU(C,C.current,z,x),kn=Y,ov(0,!1),ba&&typeof ba.onPostCommitFiberRoot=="function")try{ba.onPostCommitFiberRoot(Ha,C)}catch{}return!0}finally{H.p=N,B.T=A,lW(d,f)}}function cW(d,f,x){f=xo(x,f),f=t_(d.stateNode,f,2),d=Lc(d,f,2),d!==null&&(Ye(d,2),_l(d))}function zn(d,f,x){if(d.tag===3)cW(d,d,x);else for(;f!==null;){if(f.tag===3){cW(f,d,x);break}else if(f.tag===1){var A=f.stateNode;if(typeof f.type.getDerivedStateFromError=="function"||typeof A.componentDidCatch=="function"&&(Wc===null||!Wc.has(A))){d=xo(x,d),x=hU(2),A=Lc(f,x,2),A!==null&&(dU(x,A,f,d),Ye(A,2),_l(A));break}}f=f.return}}function N_(d,f,x){var A=d.pingCache;if(A===null){A=d.pingCache=new tle;var N=new Set;A.set(f,N)}else N=A.get(f),N===void 0&&(N=new Set,A.set(f,N));N.has(x)||(b_=!0,N.add(x),d=ile.bind(null,d,f,x),f.then(d,d))}function ile(d,f,x){var A=d.pingCache;A!==null&&A.delete(f),d.pingedLanes|=d.suspendedLanes&x,d.warmLanes&=~x,na===d&&(hn&x)===x&&(Ma===4||Ma===3&&(hn&62914560)===hn&&300>nn()-gk?(kn&2)===0&&Dg(d,0):x_|=x,_g===hn&&(_g=0)),_l(d)}function hW(d,f){f===0&&(f=je()),d=$d(d,f),d!==null&&(Ye(d,f),_l(d))}function ole(d){var f=d.memoizedState,x=0;f!==null&&(x=f.retryLane),hW(d,x)}function lle(d,f){var x=0;switch(d.tag){case 31:case 13:var A=d.stateNode,N=d.memoizedState;N!==null&&(x=N.retryLane);break;case 19:A=d.stateNode;break;case 22:A=d.stateNode._retryCache;break;default:throw Error(a(314))}A!==null&&A.delete(f),hW(d,x)}function ule(d,f){return Dt(d,f)}var Sk=null,Fg=null,C_=!1,kk=!1,T_=!1,jc=0;function _l(d){d!==Fg&&d.next===null&&(Fg===null?Sk=Fg=d:Fg=Fg.next=d),kk=!0,C_||(C_=!0,hle())}function ov(d,f){if(!T_&&kk){T_=!0;do for(var x=!1,A=Sk;A!==null;){if(d!==0){var N=A.pendingLanes;if(N===0)var C=0;else{var z=A.suspendedLanes,Y=A.pingedLanes;C=(1<<31-Vr(42|d)+1)-1,C&=N&~(z&~Y),C=C&201326741?C&201326741|1:C?C|2:0}C!==0&&(x=!0,mW(A,C))}else C=hn,C=fo(A,A===na?C:0,A.cancelPendingCommit!==null||A.timeoutHandle!==-1),(C&3)===0||Nl(A,C)||(x=!0,mW(A,C));A=A.next}while(x);T_=!1}}function cle(){dW()}function dW(){kk=C_=!1;var d=0;jc!==0&&wle()&&(d=jc);for(var f=nn(),x=null,A=Sk;A!==null;){var N=A.next,C=pW(A,f);C===0?(A.next=null,x===null?Sk=N:x.next=N,N===null&&(Fg=x)):(x=A,(d!==0||(C&3)!==0)&&(kk=!0)),A=N}Ar!==0&&Ar!==5||ov(d),jc!==0&&(jc=0)}function pW(d,f){for(var x=d.suspendedLanes,A=d.pingedLanes,N=d.expirationTimes,C=d.pendingLanes&-62914561;0<C;){var z=31-Vr(C),Y=1<<z,ue=N[z];ue===-1?((Y&x)===0||(Y&A)!==0)&&(N[z]=Me(Y,f)):ue<=f&&(d.expiredLanes|=Y),C&=~Y}if(f=na,x=hn,x=fo(d,d===f?x:0,d.cancelPendingCommit!==null||d.timeoutHandle!==-1),A=d.callbackNode,x===0||d===f&&(Ln===2||Ln===9)||d.cancelPendingCommit!==null)return A!==null&&A!==null&&qn(A),d.callbackNode=null,d.callbackPriority=0;if((x&3)===0||Nl(d,x)){if(f=x&-x,f===d.callbackPriority)return f;switch(A!==null&&qn(A),as(x)){case 2:case 8:x=Cn;break;case 32:x=ta;break;case 268435456:x=po;break;default:x=ta}return A=fW.bind(null,d),x=Dt(x,A),d.callbackPriority=f,d.callbackNode=x,f}return A!==null&&A!==null&&qn(A),d.callbackPriority=2,d.callbackNode=null,2}function fW(d,f){if(Ar!==0&&Ar!==5)return d.callbackNode=null,d.callbackPriority=0,null;var x=d.callbackNode;if(Ak()&&d.callbackNode!==x)return null;var A=hn;return A=fo(d,d===na?A:0,d.cancelPendingCommit!==null||d.timeoutHandle!==-1),A===0?null:(XU(d,A,f),pW(d,nn()),d.callbackNode!=null&&d.callbackNode===x?fW.bind(null,d):null)}function mW(d,f){if(Ak())return null;XU(d,f,!0)}function hle(){Sle(function(){(kn&6)!==0?Dt(ea,cle):dW()})}function E_(){if(jc===0){var d=vg;d===0&&(d=oi,oi<<=1,(oi&261888)===0&&(oi=256)),jc=d}return jc}function gW(d){return d==null||typeof d=="symbol"||typeof d=="boolean"?null:typeof d=="function"?d:Id(""+d)}function yW(d,f){var x=f.ownerDocument.createElement("input");return x.name=f.name,x.value=f.value,d.id&&x.setAttribute("form",d.id),f.parentNode.insertBefore(x,f),d=new FormData(d),x.parentNode.removeChild(x),d}function dle(d,f,x,A,N){if(f==="submit"&&x&&x.stateNode===N){var C=gW((N[Sn]||null).action),z=A.submitter;z&&(f=(f=z[Sn]||null)?gW(f.formAction):z.getAttribute("formAction"),f!==null&&(C=f,z=null));var Y=new MS("action","action",null,A,N);d.push({event:Y,listeners:[{instance:null,listener:function(){if(A.defaultPrevented){if(jc!==0){var ue=z?yW(N,z):new FormData(N);X$(x,{pending:!0,data:ue,method:N.method,action:C},null,ue)}}else typeof C=="function"&&(Y.preventDefault(),ue=z?yW(N,z):new FormData(N),X$(x,{pending:!0,data:ue,method:N.method,action:C},C,ue))},currentTarget:N}]})}}for(var $_=0;$_<d$.length;$_++){var __=d$[$_],ple=__.toLowerCase(),fle=__[0].toUpperCase()+__.slice(1);qo(ple,"on"+fle)}qo(K4,"onAnimationEnd"),qo(X4,"onAnimationIteration"),qo(Y4,"onAnimationStart"),qo("dblclick","onDoubleClick"),qo("focusin","onFocus"),qo("focusout","onBlur"),qo($oe,"onTransitionRun"),qo(_oe,"onTransitionStart"),qo(Roe,"onTransitionCancel"),qo(Q4,"onTransitionEnd"),Nc("onMouseEnter",["mouseout","mouseover"]),Nc("onMouseLeave",["mouseout","mouseover"]),Nc("onPointerEnter",["pointerout","pointerover"]),Nc("onPointerLeave",["pointerout","pointerover"]),vu("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),vu("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),vu("onBeforeInput",["compositionend","keypress","textInput","paste"]),vu("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),vu("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),vu("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lv="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mle=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(lv));function bW(d,f){f=(f&4)!==0;for(var x=0;x<d.length;x++){var A=d[x],N=A.event;A=A.listeners;e:{var C=void 0;if(f)for(var z=A.length-1;0<=z;z--){var Y=A[z],ue=Y.instance,Ce=Y.currentTarget;if(Y=Y.listener,ue!==C&&N.isPropagationStopped())break e;C=Y,N.currentTarget=Ce;try{C(N)}catch(ze){BS(ze)}N.currentTarget=null,C=ue}else for(z=0;z<A.length;z++){if(Y=A[z],ue=Y.instance,Ce=Y.currentTarget,Y=Y.listener,ue!==C&&N.isPropagationStopped())break e;C=Y,N.currentTarget=Ce;try{C(N)}catch(ze){BS(ze)}N.currentTarget=null,C=ue}}}}function sn(d,f){var x=f[kc];x===void 0&&(x=f[kc]=new Set);var A=d+"__bubble";x.has(A)||(xW(f,d,2,!1),x.add(A))}function R_(d,f,x){var A=0;f&&(A|=4),xW(x,d,A,f)}var Ik="_reactListening"+Math.random().toString(36).slice(2);function D_(d){if(!d[Ik]){d[Ik]=!0,eg.forEach(function(x){x!=="selectionchange"&&(mle.has(x)||R_(x,!1,d),R_(x,!0,d))});var f=d.nodeType===9?d:d.ownerDocument;f===null||f[Ik]||(f[Ik]=!0,R_("selectionchange",!1,f))}}function xW(d,f,x,A){switch(KW(f)){case 2:var N=Wle;break;case 8:N=Gle;break;default:N=K_}x=N.bind(null,f,x,d),N=void 0,!yt||f!=="touchstart"&&f!=="touchmove"&&f!=="wheel"||(N=!0),A?N!==void 0?d.addEventListener(f,x,{capture:!0,passive:N}):d.addEventListener(f,x,!0):N!==void 0?d.addEventListener(f,x,{passive:N}):d.addEventListener(f,x,!1)}function O_(d,f,x,A,N){var C=A;if((f&1)===0&&(f&2)===0&&A!==null)e:for(;;){if(A===null)return;var z=A.tag;if(z===3||z===4){var Y=A.stateNode.containerInfo;if(Y===N)break;if(z===4)for(z=A.return;z!==null;){var ue=z.tag;if((ue===3||ue===4)&&z.stateNode.containerInfo===N)return;z=z.return}for(;Y!==null;){if(z=go(Y),z===null)return;if(ue=z.tag,ue===5||ue===6||ue===26||ue===27){A=C=z;continue e}Y=Y.parentNode}}A=A.return}Rt(function(){var Ce=C,ze=_0(x),Ve=[];e:{var Ee=Z4.get(d);if(Ee!==void 0){var De=MS,ht=d;switch(d){case"keypress":if(cg(x)===0)break e;case"keydown":case"keyup":De=loe;break;case"focusin":ht="focus",De=a$;break;case"focusout":ht="blur",De=a$;break;case"beforeblur":case"afterblur":De=a$;break;case"click":if(x.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":De=C4;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":De=Yie;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":De=hoe;break;case K4:case X4:case Y4:De=Jie;break;case Q4:De=poe;break;case"scroll":case"scrollend":De=Kie;break;case"wheel":De=moe;break;case"copy":case"cut":case"paste":De=toe;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":De=E4;break;case"toggle":case"beforetoggle":De=yoe}var Tt=(f&4)!==0,Qn=!Tt&&(d==="scroll"||d==="scrollend"),ve=Tt?Ee!==null?Ee+"Capture":null:Ee;Tt=[];for(var be=Ce,Ne;be!==null;){var Be=be;if(Ne=Be.stateNode,Be=Be.tag,Be!==5&&Be!==26&&Be!==27||Ne===null||ve===null||(Be=_t(be,ve),Be!=null&&Tt.push(uv(be,Be,Ne))),Qn)break;be=be.return}0<Tt.length&&(Ee=new De(Ee,ht,null,x,ze),Ve.push({event:Ee,listeners:Tt}))}}if((f&7)===0){e:{if(Ee=d==="mouseover"||d==="pointerover",De=d==="mouseout"||d==="pointerout",Ee&&x!==$c&&(ht=x.relatedTarget||x.fromElement)&&(go(ht)||ht[Vs]))break e;if((De||Ee)&&(Ee=ze.window===ze?ze:(Ee=ze.ownerDocument)?Ee.defaultView||Ee.parentWindow:window,De?(ht=x.relatedTarget||x.toElement,De=Ce,ht=ht?go(ht):null,ht!==null&&(Qn=s(ht),Tt=ht.tag,ht!==Qn||Tt!==5&&Tt!==27&&Tt!==6)&&(ht=null)):(De=null,ht=Ce),De!==ht)){if(Tt=C4,Be="onMouseLeave",ve="onMouseEnter",be="mouse",(d==="pointerout"||d==="pointerover")&&(Tt=E4,Be="onPointerLeave",ve="onPointerEnter",be="pointer"),Qn=De==null?Ee:kd(De),Ne=ht==null?Ee:kd(ht),Ee=new Tt(Be,be+"leave",De,x,ze),Ee.target=Qn,Ee.relatedTarget=Ne,Be=null,go(ze)===Ce&&(Tt=new Tt(ve,be+"enter",ht,x,ze),Tt.target=Ne,Tt.relatedTarget=Qn,Be=Tt),Qn=Be,De&&ht)t:{for(Tt=gle,ve=De,be=ht,Ne=0,Be=ve;Be;Be=Tt(Be))Ne++;Be=0;for(var Ct=be;Ct;Ct=Tt(Ct))Be++;for(;0<Ne-Be;)ve=Tt(ve),Ne--;for(;0<Be-Ne;)be=Tt(be),Be--;for(;Ne--;){if(ve===be||be!==null&&ve===be.alternate){Tt=ve;break t}ve=Tt(ve),be=Tt(be)}Tt=null}else Tt=null;De!==null&&vW(Ve,Ee,De,Tt,!1),ht!==null&&Qn!==null&&vW(Ve,Qn,ht,Tt,!0)}}e:{if(Ee=Ce?kd(Ce):window,De=Ee.nodeName&&Ee.nodeName.toLowerCase(),De==="select"||De==="input"&&Ee.type==="file")var wn=L4;else if(F4(Ee))if(z4)wn=Coe;else{wn=Ioe;var bt=koe}else De=Ee.nodeName,!De||De.toLowerCase()!=="input"||Ee.type!=="checkbox"&&Ee.type!=="radio"?Ce&&Ec(Ce.elementType)&&(wn=L4):wn=Noe;if(wn&&(wn=wn(d,Ce))){M4(Ve,wn,x,ze);break e}bt&&bt(d,Ee,Ce),d==="focusout"&&Ce&&Ee.type==="number"&&Ce.memoizedProps.value!=null&&Tc(Ee,"number",Ee.value)}switch(bt=Ce?kd(Ce):window,d){case"focusin":(F4(bt)||bt.contentEditable==="true")&&(dg=bt,u$=Ce,z0=null);break;case"focusout":z0=u$=dg=null;break;case"mousedown":c$=!0;break;case"contextmenu":case"mouseup":case"dragend":c$=!1,j4(Ve,x,ze);break;case"selectionchange":if(Eoe)break;case"keydown":case"keyup":j4(Ve,x,ze)}var qt;if(s$)e:{switch(d){case"compositionstart":var dn="onCompositionStart";break e;case"compositionend":dn="onCompositionEnd";break e;case"compositionupdate":dn="onCompositionUpdate";break e}dn=void 0}else hg?D4(d,x)&&(dn="onCompositionEnd"):d==="keydown"&&x.keyCode===229&&(dn="onCompositionStart");dn&&($4&&x.locale!=="ko"&&(hg||dn!=="onCompositionStart"?dn==="onCompositionEnd"&&hg&&(qt=ug()):(Oa=ze,Bi="value"in Oa?Oa.value:Oa.textContent,hg=!0)),bt=Nk(Ce,dn),0<bt.length&&(dn=new T4(dn,d,null,x,ze),Ve.push({event:dn,listeners:bt}),qt?dn.data=qt:(qt=O4(x),qt!==null&&(dn.data=qt)))),(qt=xoe?voe(d,x):woe(d,x))&&(dn=Nk(Ce,"onBeforeInput"),0<dn.length&&(bt=new T4("onBeforeInput","beforeinput",null,x,ze),Ve.push({event:bt,listeners:dn}),bt.data=qt)),dle(Ve,d,Ce,x,ze)}bW(Ve,f)})}function uv(d,f,x){return{instance:d,listener:f,currentTarget:x}}function Nk(d,f){for(var x=f+"Capture",A=[];d!==null;){var N=d,C=N.stateNode;if(N=N.tag,N!==5&&N!==26&&N!==27||C===null||(N=_t(d,x),N!=null&&A.unshift(uv(d,N,C)),N=_t(d,f),N!=null&&A.push(uv(d,N,C))),d.tag===3)return A;d=d.return}return[]}function gle(d){if(d===null)return null;do d=d.return;while(d&&d.tag!==5&&d.tag!==27);return d||null}function vW(d,f,x,A,N){for(var C=f._reactName,z=[];x!==null&&x!==A;){var Y=x,ue=Y.alternate,Ce=Y.stateNode;if(Y=Y.tag,ue!==null&&ue===A)break;Y!==5&&Y!==26&&Y!==27||Ce===null||(ue=Ce,N?(Ce=_t(x,C),Ce!=null&&z.unshift(uv(x,Ce,ue))):N||(Ce=_t(x,C),Ce!=null&&z.push(uv(x,Ce,ue)))),x=x.return}z.length!==0&&d.push({event:f,listeners:z})}var yle=/\r\n?/g,ble=/\u0000|\uFFFD/g;function wW(d){return(typeof d=="string"?d:""+d).replace(yle,`
`).replace(ble,"")}function AW(d,f){return f=wW(f),wW(d)===f}function Yn(d,f,x,A,N,C){switch(x){case"children":typeof A=="string"?f==="body"||f==="textarea"&&A===""||Cl(d,A):(typeof A=="number"||typeof A=="bigint")&&f!=="body"&&Cl(d,""+A);break;case"className":ag(d,"class",A);break;case"tabIndex":ag(d,"tabindex",A);break;case"dir":case"role":case"viewBox":case"width":case"height":ag(d,x,A);break;case"style":ig(d,A,C);break;case"data":if(f!=="object"){ag(d,"data",A);break}case"src":case"href":if(A===""&&(f!=="a"||x!=="href")){d.removeAttribute(x);break}if(A==null||typeof A=="function"||typeof A=="symbol"||typeof A=="boolean"){d.removeAttribute(x);break}A=Id(""+A),d.setAttribute(x,A);break;case"action":case"formAction":if(typeof A=="function"){d.setAttribute(x,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof C=="function"&&(x==="formAction"?(f!=="input"&&Yn(d,f,"name",N.name,N,null),Yn(d,f,"formEncType",N.formEncType,N,null),Yn(d,f,"formMethod",N.formMethod,N,null),Yn(d,f,"formTarget",N.formTarget,N,null)):(Yn(d,f,"encType",N.encType,N,null),Yn(d,f,"method",N.method,N,null),Yn(d,f,"target",N.target,N,null)));if(A==null||typeof A=="symbol"||typeof A=="boolean"){d.removeAttribute(x);break}A=Id(""+A),d.setAttribute(x,A);break;case"onClick":A!=null&&(d.onclick=ci);break;case"onScroll":A!=null&&sn("scroll",d);break;case"onScrollEnd":A!=null&&sn("scrollend",d);break;case"dangerouslySetInnerHTML":if(A!=null){if(typeof A!="object"||!("__html"in A))throw Error(a(61));if(x=A.__html,x!=null){if(N.children!=null)throw Error(a(60));d.innerHTML=x}}break;case"multiple":d.multiple=A&&typeof A!="function"&&typeof A!="symbol";break;case"muted":d.muted=A&&typeof A!="function"&&typeof A!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(A==null||typeof A=="function"||typeof A=="boolean"||typeof A=="symbol"){d.removeAttribute("xlink:href");break}x=Id(""+A),d.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",x);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":A!=null&&typeof A!="function"&&typeof A!="symbol"?d.setAttribute(x,""+A):d.removeAttribute(x);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":A&&typeof A!="function"&&typeof A!="symbol"?d.setAttribute(x,""):d.removeAttribute(x);break;case"capture":case"download":A===!0?d.setAttribute(x,""):A!==!1&&A!=null&&typeof A!="function"&&typeof A!="symbol"?d.setAttribute(x,A):d.removeAttribute(x);break;case"cols":case"rows":case"size":case"span":A!=null&&typeof A!="function"&&typeof A!="symbol"&&!isNaN(A)&&1<=A?d.setAttribute(x,A):d.removeAttribute(x);break;case"rowSpan":case"start":A==null||typeof A=="function"||typeof A=="symbol"||isNaN(A)?d.removeAttribute(x):d.setAttribute(x,A);break;case"popover":sn("beforetoggle",d),sn("toggle",d),ng(d,"popover",A);break;case"xlinkActuate":yo(d,"http://www.w3.org/1999/xlink","xlink:actuate",A);break;case"xlinkArcrole":yo(d,"http://www.w3.org/1999/xlink","xlink:arcrole",A);break;case"xlinkRole":yo(d,"http://www.w3.org/1999/xlink","xlink:role",A);break;case"xlinkShow":yo(d,"http://www.w3.org/1999/xlink","xlink:show",A);break;case"xlinkTitle":yo(d,"http://www.w3.org/1999/xlink","xlink:title",A);break;case"xlinkType":yo(d,"http://www.w3.org/1999/xlink","xlink:type",A);break;case"xmlBase":yo(d,"http://www.w3.org/XML/1998/namespace","xml:base",A);break;case"xmlLang":yo(d,"http://www.w3.org/XML/1998/namespace","xml:lang",A);break;case"xmlSpace":yo(d,"http://www.w3.org/XML/1998/namespace","xml:space",A);break;case"is":ng(d,"is",A);break;case"innerText":case"textContent":break;default:(!(2<x.length)||x[0]!=="o"&&x[0]!=="O"||x[1]!=="n"&&x[1]!=="N")&&(x=og.get(x)||x,ng(d,x,A))}}function F_(d,f,x,A,N,C){switch(x){case"style":ig(d,A,C);break;case"dangerouslySetInnerHTML":if(A!=null){if(typeof A!="object"||!("__html"in A))throw Error(a(61));if(x=A.__html,x!=null){if(N.children!=null)throw Error(a(60));d.innerHTML=x}}break;case"children":typeof A=="string"?Cl(d,A):(typeof A=="number"||typeof A=="bigint")&&Cl(d,""+A);break;case"onScroll":A!=null&&sn("scroll",d);break;case"onScrollEnd":A!=null&&sn("scrollend",d);break;case"onClick":A!=null&&(d.onclick=ci);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!RS.hasOwnProperty(x))e:{if(x[0]==="o"&&x[1]==="n"&&(N=x.endsWith("Capture"),f=x.slice(2,N?x.length-7:void 0),C=d[Sn]||null,C=C!=null?C[x]:null,typeof C=="function"&&d.removeEventListener(f,C,N),typeof A=="function")){typeof C!="function"&&C!==null&&(x in d?d[x]=null:d.hasAttribute(x)&&d.removeAttribute(x)),d.addEventListener(f,A,N);break e}x in d?d[x]=A:A===!0?d.setAttribute(x,""):ng(d,x,A)}}}function ls(d,f,x){switch(f){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":sn("error",d),sn("load",d);var A=!1,N=!1,C;for(C in x)if(x.hasOwnProperty(C)){var z=x[C];if(z!=null)switch(C){case"src":A=!0;break;case"srcSet":N=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(a(137,f));default:Yn(d,f,C,z,x,null)}}N&&Yn(d,f,"srcSet",x.srcSet,x,null),A&&Yn(d,f,"src",x.src,x,null);return;case"input":sn("invalid",d);var Y=C=z=N=null,ue=null,Ce=null;for(A in x)if(x.hasOwnProperty(A)){var ze=x[A];if(ze!=null)switch(A){case"name":N=ze;break;case"type":z=ze;break;case"checked":ue=ze;break;case"defaultChecked":Ce=ze;break;case"value":C=ze;break;case"defaultValue":Y=ze;break;case"children":case"dangerouslySetInnerHTML":if(ze!=null)throw Error(a(137,f));break;default:Yn(d,f,A,ze,x,null)}}C0(d,C,Y,ue,Ce,z,N,!1);return;case"select":sn("invalid",d),A=z=C=null;for(N in x)if(x.hasOwnProperty(N)&&(Y=x[N],Y!=null))switch(N){case"value":C=Y;break;case"defaultValue":z=Y;break;case"multiple":A=Y;default:Yn(d,f,N,Y,x,null)}f=C,x=z,d.multiple=!!A,f!=null?wu(d,!!A,f,!1):x!=null&&wu(d,!!A,x,!0);return;case"textarea":sn("invalid",d),C=N=A=null;for(z in x)if(x.hasOwnProperty(z)&&(Y=x[z],Y!=null))switch(z){case"value":A=Y;break;case"defaultValue":N=Y;break;case"children":C=Y;break;case"dangerouslySetInnerHTML":if(Y!=null)throw Error(a(91));break;default:Yn(d,f,z,Y,x,null)}E0(d,A,N,C);return;case"option":for(ue in x)x.hasOwnProperty(ue)&&(A=x[ue],A!=null)&&(ue==="selected"?d.selected=A&&typeof A!="function"&&typeof A!="symbol":Yn(d,f,ue,A,x,null));return;case"dialog":sn("beforetoggle",d),sn("toggle",d),sn("cancel",d),sn("close",d);break;case"iframe":case"object":sn("load",d);break;case"video":case"audio":for(A=0;A<lv.length;A++)sn(lv[A],d);break;case"image":sn("error",d),sn("load",d);break;case"details":sn("toggle",d);break;case"embed":case"source":case"link":sn("error",d),sn("load",d);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Ce in x)if(x.hasOwnProperty(Ce)&&(A=x[Ce],A!=null))switch(Ce){case"children":case"dangerouslySetInnerHTML":throw Error(a(137,f));default:Yn(d,f,Ce,A,x,null)}return;default:if(Ec(f)){for(ze in x)x.hasOwnProperty(ze)&&(A=x[ze],A!==void 0&&F_(d,f,ze,A,x,void 0));return}}for(Y in x)x.hasOwnProperty(Y)&&(A=x[Y],A!=null&&Yn(d,f,Y,A,x,null))}function xle(d,f,x,A){switch(f){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var N=null,C=null,z=null,Y=null,ue=null,Ce=null,ze=null;for(De in x){var Ve=x[De];if(x.hasOwnProperty(De)&&Ve!=null)switch(De){case"checked":break;case"value":break;case"defaultValue":ue=Ve;default:A.hasOwnProperty(De)||Yn(d,f,De,null,A,Ve)}}for(var Ee in A){var De=A[Ee];if(Ve=x[Ee],A.hasOwnProperty(Ee)&&(De!=null||Ve!=null))switch(Ee){case"type":C=De;break;case"name":N=De;break;case"checked":Ce=De;break;case"defaultChecked":ze=De;break;case"value":z=De;break;case"defaultValue":Y=De;break;case"children":case"dangerouslySetInnerHTML":if(De!=null)throw Error(a(137,f));break;default:De!==Ve&&Yn(d,f,Ee,De,A,Ve)}}N0(d,z,Y,ue,Ce,ze,C,N);return;case"select":De=z=Y=Ee=null;for(C in x)if(ue=x[C],x.hasOwnProperty(C)&&ue!=null)switch(C){case"value":break;case"multiple":De=ue;default:A.hasOwnProperty(C)||Yn(d,f,C,null,A,ue)}for(N in A)if(C=A[N],ue=x[N],A.hasOwnProperty(N)&&(C!=null||ue!=null))switch(N){case"value":Ee=C;break;case"defaultValue":Y=C;break;case"multiple":z=C;default:C!==ue&&Yn(d,f,N,C,A,ue)}f=Y,x=z,A=De,Ee!=null?wu(d,!!x,Ee,!1):!!A!=!!x&&(f!=null?wu(d,!!x,f,!0):wu(d,!!x,x?[]:"",!1));return;case"textarea":De=Ee=null;for(Y in x)if(N=x[Y],x.hasOwnProperty(Y)&&N!=null&&!A.hasOwnProperty(Y))switch(Y){case"value":break;case"children":break;default:Yn(d,f,Y,null,A,N)}for(z in A)if(N=A[z],C=x[z],A.hasOwnProperty(z)&&(N!=null||C!=null))switch(z){case"value":Ee=N;break;case"defaultValue":De=N;break;case"children":break;case"dangerouslySetInnerHTML":if(N!=null)throw Error(a(91));break;default:N!==C&&Yn(d,f,z,N,A,C)}T0(d,Ee,De);return;case"option":for(var ht in x)Ee=x[ht],x.hasOwnProperty(ht)&&Ee!=null&&!A.hasOwnProperty(ht)&&(ht==="selected"?d.selected=!1:Yn(d,f,ht,null,A,Ee));for(ue in A)Ee=A[ue],De=x[ue],A.hasOwnProperty(ue)&&Ee!==De&&(Ee!=null||De!=null)&&(ue==="selected"?d.selected=Ee&&typeof Ee!="function"&&typeof Ee!="symbol":Yn(d,f,ue,Ee,A,De));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Tt in x)Ee=x[Tt],x.hasOwnProperty(Tt)&&Ee!=null&&!A.hasOwnProperty(Tt)&&Yn(d,f,Tt,null,A,Ee);for(Ce in A)if(Ee=A[Ce],De=x[Ce],A.hasOwnProperty(Ce)&&Ee!==De&&(Ee!=null||De!=null))switch(Ce){case"children":case"dangerouslySetInnerHTML":if(Ee!=null)throw Error(a(137,f));break;default:Yn(d,f,Ce,Ee,A,De)}return;default:if(Ec(f)){for(var Qn in x)Ee=x[Qn],x.hasOwnProperty(Qn)&&Ee!==void 0&&!A.hasOwnProperty(Qn)&&F_(d,f,Qn,void 0,A,Ee);for(ze in A)Ee=A[ze],De=x[ze],!A.hasOwnProperty(ze)||Ee===De||Ee===void 0&&De===void 0||F_(d,f,ze,Ee,A,De);return}}for(var ve in x)Ee=x[ve],x.hasOwnProperty(ve)&&Ee!=null&&!A.hasOwnProperty(ve)&&Yn(d,f,ve,null,A,Ee);for(Ve in A)Ee=A[Ve],De=x[Ve],!A.hasOwnProperty(Ve)||Ee===De||Ee==null&&De==null||Yn(d,f,Ve,Ee,A,De)}function SW(d){switch(d){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function vle(){if(typeof performance.getEntriesByType=="function"){for(var d=0,f=0,x=performance.getEntriesByType("resource"),A=0;A<x.length;A++){var N=x[A],C=N.transferSize,z=N.initiatorType,Y=N.duration;if(C&&Y&&SW(z)){for(z=0,Y=N.responseEnd,A+=1;A<x.length;A++){var ue=x[A],Ce=ue.startTime;if(Ce>Y)break;var ze=ue.transferSize,Ve=ue.initiatorType;ze&&SW(Ve)&&(ue=ue.responseEnd,z+=ze*(ue<Y?1:(Y-Ce)/(ue-Ce)))}if(--A,f+=8*(C+z)/(N.duration/1e3),d++,10<d)break}}if(0<d)return f/d/1e6}return navigator.connection&&(d=navigator.connection.downlink,typeof d=="number")?d:5}var M_=null,L_=null;function Ck(d){return d.nodeType===9?d:d.ownerDocument}function kW(d){switch(d){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function IW(d,f){if(d===0)switch(f){case"svg":return 1;case"math":return 2;default:return 0}return d===1&&f==="foreignObject"?0:d}function z_(d,f){return d==="textarea"||d==="noscript"||typeof f.children=="string"||typeof f.children=="number"||typeof f.children=="bigint"||typeof f.dangerouslySetInnerHTML=="object"&&f.dangerouslySetInnerHTML!==null&&f.dangerouslySetInnerHTML.__html!=null}var B_=null;function wle(){var d=window.event;return d&&d.type==="popstate"?d===B_?!1:(B_=d,!0):(B_=null,!1)}var NW=typeof setTimeout=="function"?setTimeout:void 0,Ale=typeof clearTimeout=="function"?clearTimeout:void 0,CW=typeof Promise=="function"?Promise:void 0,Sle=typeof queueMicrotask=="function"?queueMicrotask:typeof CW<"u"?function(d){return CW.resolve(null).then(d).catch(kle)}:NW;function kle(d){setTimeout(function(){throw d})}function qc(d){return d==="head"}function TW(d,f){var x=f,A=0;do{var N=x.nextSibling;if(d.removeChild(x),N&&N.nodeType===8)if(x=N.data,x==="/$"||x==="/&"){if(A===0){d.removeChild(N),Bg(f);return}A--}else if(x==="$"||x==="$?"||x==="$~"||x==="$!"||x==="&")A++;else if(x==="html")cv(d.ownerDocument.documentElement);else if(x==="head"){x=d.ownerDocument.head,cv(x);for(var C=x.firstChild;C;){var z=C.nextSibling,Y=C.nodeName;C[Sd]||Y==="SCRIPT"||Y==="STYLE"||Y==="LINK"&&C.rel.toLowerCase()==="stylesheet"||x.removeChild(C),C=z}}else x==="body"&&cv(d.ownerDocument.body);x=N}while(x);Bg(f)}function EW(d,f){var x=d;d=0;do{var A=x.nextSibling;if(x.nodeType===1?f?(x._stashedDisplay=x.style.display,x.style.display="none"):(x.style.display=x._stashedDisplay||"",x.getAttribute("style")===""&&x.removeAttribute("style")):x.nodeType===3&&(f?(x._stashedText=x.nodeValue,x.nodeValue=""):x.nodeValue=x._stashedText||""),A&&A.nodeType===8)if(x=A.data,x==="/$"){if(d===0)break;d--}else x!=="$"&&x!=="$?"&&x!=="$~"&&x!=="$!"||d++;x=A}while(x)}function P_(d){var f=d.firstChild;for(f&&f.nodeType===10&&(f=f.nextSibling);f;){var x=f;switch(f=f.nextSibling,x.nodeName){case"HTML":case"HEAD":case"BODY":P_(x),k0(x);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(x.rel.toLowerCase()==="stylesheet")continue}d.removeChild(x)}}function Ile(d,f,x,A){for(;d.nodeType===1;){var N=x;if(d.nodeName.toLowerCase()!==f.toLowerCase()){if(!A&&(d.nodeName!=="INPUT"||d.type!=="hidden"))break}else if(A){if(!d[Sd])switch(f){case"meta":if(!d.hasAttribute("itemprop"))break;return d;case"link":if(C=d.getAttribute("rel"),C==="stylesheet"&&d.hasAttribute("data-precedence"))break;if(C!==N.rel||d.getAttribute("href")!==(N.href==null||N.href===""?null:N.href)||d.getAttribute("crossorigin")!==(N.crossOrigin==null?null:N.crossOrigin)||d.getAttribute("title")!==(N.title==null?null:N.title))break;return d;case"style":if(d.hasAttribute("data-precedence"))break;return d;case"script":if(C=d.getAttribute("src"),(C!==(N.src==null?null:N.src)||d.getAttribute("type")!==(N.type==null?null:N.type)||d.getAttribute("crossorigin")!==(N.crossOrigin==null?null:N.crossOrigin))&&C&&d.hasAttribute("async")&&!d.hasAttribute("itemprop"))break;return d;default:return d}}else if(f==="input"&&d.type==="hidden"){var C=N.name==null?null:""+N.name;if(N.type==="hidden"&&d.getAttribute("name")===C)return d}else return d;if(d=ko(d.nextSibling),d===null)break}return null}function Nle(d,f,x){if(f==="")return null;for(;d.nodeType!==3;)if((d.nodeType!==1||d.nodeName!=="INPUT"||d.type!=="hidden")&&!x||(d=ko(d.nextSibling),d===null))return null;return d}function $W(d,f){for(;d.nodeType!==8;)if((d.nodeType!==1||d.nodeName!=="INPUT"||d.type!=="hidden")&&!f||(d=ko(d.nextSibling),d===null))return null;return d}function V_(d){return d.data==="$?"||d.data==="$~"}function U_(d){return d.data==="$!"||d.data==="$?"&&d.ownerDocument.readyState!=="loading"}function Cle(d,f){var x=d.ownerDocument;if(d.data==="$~")d._reactRetry=f;else if(d.data!=="$?"||x.readyState!=="loading")f();else{var A=function(){f(),x.removeEventListener("DOMContentLoaded",A)};x.addEventListener("DOMContentLoaded",A),d._reactRetry=A}}function ko(d){for(;d!=null;d=d.nextSibling){var f=d.nodeType;if(f===1||f===3)break;if(f===8){if(f=d.data,f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"||f==="F!"||f==="F")break;if(f==="/$"||f==="/&")return null}}return d}var W_=null;function _W(d){d=d.nextSibling;for(var f=0;d;){if(d.nodeType===8){var x=d.data;if(x==="/$"||x==="/&"){if(f===0)return ko(d.nextSibling);f--}else x!=="$"&&x!=="$!"&&x!=="$?"&&x!=="$~"&&x!=="&"||f++}d=d.nextSibling}return null}function RW(d){d=d.previousSibling;for(var f=0;d;){if(d.nodeType===8){var x=d.data;if(x==="$"||x==="$!"||x==="$?"||x==="$~"||x==="&"){if(f===0)return d;f--}else x!=="/$"&&x!=="/&"||f++}d=d.previousSibling}return null}function DW(d,f,x){switch(f=Ck(x),d){case"html":if(d=f.documentElement,!d)throw Error(a(452));return d;case"head":if(d=f.head,!d)throw Error(a(453));return d;case"body":if(d=f.body,!d)throw Error(a(454));return d;default:throw Error(a(451))}}function cv(d){for(var f=d.attributes;f.length;)d.removeAttributeNode(f[0]);k0(d)}var Io=new Map,OW=new Set;function Tk(d){return typeof d.getRootNode=="function"?d.getRootNode():d.nodeType===9?d:d.ownerDocument}var Lu=H.d;H.d={f:Tle,r:Ele,D:$le,C:_le,L:Rle,m:Dle,X:Fle,S:Ole,M:Mle};function Tle(){var d=Lu.f(),f=xk();return d||f}function Ele(d){var f=Ic(d);f!==null&&f.tag===5&&f.type==="form"?QV(f):Lu.r(d)}var Mg=typeof document>"u"?null:document;function FW(d,f,x){var A=Mg;if(A&&typeof f=="string"&&f){var N=ui(f);N='link[rel="'+d+'"][href="'+N+'"]',typeof x=="string"&&(N+='[crossorigin="'+x+'"]'),OW.has(N)||(OW.add(N),d={rel:d,crossOrigin:x,href:f},A.querySelector(N)===null&&(f=A.createElement("link"),ls(f,"link",d),sr(f),A.head.appendChild(f)))}}function $le(d){Lu.D(d),FW("dns-prefetch",d,null)}function _le(d,f){Lu.C(d,f),FW("preconnect",d,f)}function Rle(d,f,x){Lu.L(d,f,x);var A=Mg;if(A&&d&&f){var N='link[rel="preload"][as="'+ui(f)+'"]';f==="image"&&x&&x.imageSrcSet?(N+='[imagesrcset="'+ui(x.imageSrcSet)+'"]',typeof x.imageSizes=="string"&&(N+='[imagesizes="'+ui(x.imageSizes)+'"]')):N+='[href="'+ui(d)+'"]';var C=N;switch(f){case"style":C=Lg(d);break;case"script":C=zg(d)}Io.has(C)||(d=h({rel:"preload",href:f==="image"&&x&&x.imageSrcSet?void 0:d,as:f},x),Io.set(C,d),A.querySelector(N)!==null||f==="style"&&A.querySelector(hv(C))||f==="script"&&A.querySelector(dv(C))||(f=A.createElement("link"),ls(f,"link",d),sr(f),A.head.appendChild(f)))}}function Dle(d,f){Lu.m(d,f);var x=Mg;if(x&&d){var A=f&&typeof f.as=="string"?f.as:"script",N='link[rel="modulepreload"][as="'+ui(A)+'"][href="'+ui(d)+'"]',C=N;switch(A){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":C=zg(d)}if(!Io.has(C)&&(d=h({rel:"modulepreload",href:d},f),Io.set(C,d),x.querySelector(N)===null)){switch(A){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(x.querySelector(dv(C)))return}A=x.createElement("link"),ls(A,"link",d),sr(A),x.head.appendChild(A)}}}function Ole(d,f,x){Lu.S(d,f,x);var A=Mg;if(A&&d){var N=xu(A).hoistableStyles,C=Lg(d);f=f||"default";var z=N.get(C);if(!z){var Y={loading:0,preload:null};if(z=A.querySelector(hv(C)))Y.loading=5;else{d=h({rel:"stylesheet",href:d,"data-precedence":f},x),(x=Io.get(C))&&G_(d,x);var ue=z=A.createElement("link");sr(ue),ls(ue,"link",d),ue._p=new Promise(function(Ce,ze){ue.onload=Ce,ue.onerror=ze}),ue.addEventListener("load",function(){Y.loading|=1}),ue.addEventListener("error",function(){Y.loading|=2}),Y.loading|=4,Ek(z,f,A)}z={type:"stylesheet",instance:z,count:1,state:Y},N.set(C,z)}}}function Fle(d,f){Lu.X(d,f);var x=Mg;if(x&&d){var A=xu(x).hoistableScripts,N=zg(d),C=A.get(N);C||(C=x.querySelector(dv(N)),C||(d=h({src:d,async:!0},f),(f=Io.get(N))&&H_(d,f),C=x.createElement("script"),sr(C),ls(C,"link",d),x.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},A.set(N,C))}}function Mle(d,f){Lu.M(d,f);var x=Mg;if(x&&d){var A=xu(x).hoistableScripts,N=zg(d),C=A.get(N);C||(C=x.querySelector(dv(N)),C||(d=h({src:d,async:!0,type:"module"},f),(f=Io.get(N))&&H_(d,f),C=x.createElement("script"),sr(C),ls(C,"link",d),x.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},A.set(N,C))}}function MW(d,f,x,A){var N=(N=ke.current)?Tk(N):null;if(!N)throw Error(a(446));switch(d){case"meta":case"title":return null;case"style":return typeof x.precedence=="string"&&typeof x.href=="string"?(f=Lg(x.href),x=xu(N).hoistableStyles,A=x.get(f),A||(A={type:"style",instance:null,count:0,state:null},x.set(f,A)),A):{type:"void",instance:null,count:0,state:null};case"link":if(x.rel==="stylesheet"&&typeof x.href=="string"&&typeof x.precedence=="string"){d=Lg(x.href);var C=xu(N).hoistableStyles,z=C.get(d);if(z||(N=N.ownerDocument||N,z={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},C.set(d,z),(C=N.querySelector(hv(d)))&&!C._p&&(z.instance=C,z.state.loading=5),Io.has(d)||(x={rel:"preload",as:"style",href:x.href,crossOrigin:x.crossOrigin,integrity:x.integrity,media:x.media,hrefLang:x.hrefLang,referrerPolicy:x.referrerPolicy},Io.set(d,x),C||Lle(N,d,x,z.state))),f&&A===null)throw Error(a(528,""));return z}if(f&&A!==null)throw Error(a(529,""));return null;case"script":return f=x.async,x=x.src,typeof x=="string"&&f&&typeof f!="function"&&typeof f!="symbol"?(f=zg(x),x=xu(N).hoistableScripts,A=x.get(f),A||(A={type:"script",instance:null,count:0,state:null},x.set(f,A)),A):{type:"void",instance:null,count:0,state:null};default:throw Error(a(444,d))}}function Lg(d){return'href="'+ui(d)+'"'}function hv(d){return'link[rel="stylesheet"]['+d+"]"}function LW(d){return h({},d,{"data-precedence":d.precedence,precedence:null})}function Lle(d,f,x,A){d.querySelector('link[rel="preload"][as="style"]['+f+"]")?A.loading=1:(f=d.createElement("link"),A.preload=f,f.addEventListener("load",function(){return A.loading|=1}),f.addEventListener("error",function(){return A.loading|=2}),ls(f,"link",x),sr(f),d.head.appendChild(f))}function zg(d){return'[src="'+ui(d)+'"]'}function dv(d){return"script[async]"+d}function zW(d,f,x){if(f.count++,f.instance===null)switch(f.type){case"style":var A=d.querySelector('style[data-href~="'+ui(x.href)+'"]');if(A)return f.instance=A,sr(A),A;var N=h({},x,{"data-href":x.href,"data-precedence":x.precedence,href:null,precedence:null});return A=(d.ownerDocument||d).createElement("style"),sr(A),ls(A,"style",N),Ek(A,x.precedence,d),f.instance=A;case"stylesheet":N=Lg(x.href);var C=d.querySelector(hv(N));if(C)return f.state.loading|=4,f.instance=C,sr(C),C;A=LW(x),(N=Io.get(N))&&G_(A,N),C=(d.ownerDocument||d).createElement("link"),sr(C);var z=C;return z._p=new Promise(function(Y,ue){z.onload=Y,z.onerror=ue}),ls(C,"link",A),f.state.loading|=4,Ek(C,x.precedence,d),f.instance=C;case"script":return C=zg(x.src),(N=d.querySelector(dv(C)))?(f.instance=N,sr(N),N):(A=x,(N=Io.get(C))&&(A=h({},x),H_(A,N)),d=d.ownerDocument||d,N=d.createElement("script"),sr(N),ls(N,"link",A),d.head.appendChild(N),f.instance=N);case"void":return null;default:throw Error(a(443,f.type))}else f.type==="stylesheet"&&(f.state.loading&4)===0&&(A=f.instance,f.state.loading|=4,Ek(A,x.precedence,d));return f.instance}function Ek(d,f,x){for(var A=x.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),N=A.length?A[A.length-1]:null,C=N,z=0;z<A.length;z++){var Y=A[z];if(Y.dataset.precedence===f)C=Y;else if(C!==N)break}C?C.parentNode.insertBefore(d,C.nextSibling):(f=x.nodeType===9?x.head:x,f.insertBefore(d,f.firstChild))}function G_(d,f){d.crossOrigin==null&&(d.crossOrigin=f.crossOrigin),d.referrerPolicy==null&&(d.referrerPolicy=f.referrerPolicy),d.title==null&&(d.title=f.title)}function H_(d,f){d.crossOrigin==null&&(d.crossOrigin=f.crossOrigin),d.referrerPolicy==null&&(d.referrerPolicy=f.referrerPolicy),d.integrity==null&&(d.integrity=f.integrity)}var $k=null;function BW(d,f,x){if($k===null){var A=new Map,N=$k=new Map;N.set(x,A)}else N=$k,A=N.get(x),A||(A=new Map,N.set(x,A));if(A.has(d))return A;for(A.set(d,null),x=x.getElementsByTagName(d),N=0;N<x.length;N++){var C=x[N];if(!(C[Sd]||C[Da]||d==="link"&&C.getAttribute("rel")==="stylesheet")&&C.namespaceURI!=="http://www.w3.org/2000/svg"){var z=C.getAttribute(f)||"";z=d+z;var Y=A.get(z);Y?Y.push(C):A.set(z,[C])}}return A}function PW(d,f,x){d=d.ownerDocument||d,d.head.insertBefore(x,f==="title"?d.querySelector("head > title"):null)}function zle(d,f,x){if(x===1||f.itemProp!=null)return!1;switch(d){case"meta":case"title":return!0;case"style":if(typeof f.precedence!="string"||typeof f.href!="string"||f.href==="")break;return!0;case"link":if(typeof f.rel!="string"||typeof f.href!="string"||f.href===""||f.onLoad||f.onError)break;return f.rel==="stylesheet"?(d=f.disabled,typeof f.precedence=="string"&&d==null):!0;case"script":if(f.async&&typeof f.async!="function"&&typeof f.async!="symbol"&&!f.onLoad&&!f.onError&&f.src&&typeof f.src=="string")return!0}return!1}function VW(d){return!(d.type==="stylesheet"&&(d.state.loading&3)===0)}function Ble(d,f,x,A){if(x.type==="stylesheet"&&(typeof A.media!="string"||matchMedia(A.media).matches!==!1)&&(x.state.loading&4)===0){if(x.instance===null){var N=Lg(A.href),C=f.querySelector(hv(N));if(C){f=C._p,f!==null&&typeof f=="object"&&typeof f.then=="function"&&(d.count++,d=_k.bind(d),f.then(d,d)),x.state.loading|=4,x.instance=C,sr(C);return}C=f.ownerDocument||f,A=LW(A),(N=Io.get(N))&&G_(A,N),C=C.createElement("link"),sr(C);var z=C;z._p=new Promise(function(Y,ue){z.onload=Y,z.onerror=ue}),ls(C,"link",A),x.instance=C}d.stylesheets===null&&(d.stylesheets=new Map),d.stylesheets.set(x,f),(f=x.state.preload)&&(x.state.loading&3)===0&&(d.count++,x=_k.bind(d),f.addEventListener("load",x),f.addEventListener("error",x))}}var j_=0;function Ple(d,f){return d.stylesheets&&d.count===0&&Dk(d,d.stylesheets),0<d.count||0<d.imgCount?function(x){var A=setTimeout(function(){if(d.stylesheets&&Dk(d,d.stylesheets),d.unsuspend){var C=d.unsuspend;d.unsuspend=null,C()}},6e4+f);0<d.imgBytes&&j_===0&&(j_=62500*vle());var N=setTimeout(function(){if(d.waitingForImages=!1,d.count===0&&(d.stylesheets&&Dk(d,d.stylesheets),d.unsuspend)){var C=d.unsuspend;d.unsuspend=null,C()}},(d.imgBytes>j_?50:800)+f);return d.unsuspend=x,function(){d.unsuspend=null,clearTimeout(A),clearTimeout(N)}}:null}function _k(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Dk(this,this.stylesheets);else if(this.unsuspend){var d=this.unsuspend;this.unsuspend=null,d()}}}var Rk=null;function Dk(d,f){d.stylesheets=null,d.unsuspend!==null&&(d.count++,Rk=new Map,f.forEach(Vle,d),Rk=null,_k.call(d))}function Vle(d,f){if(!(f.state.loading&4)){var x=Rk.get(d);if(x)var A=x.get(null);else{x=new Map,Rk.set(d,x);for(var N=d.querySelectorAll("link[data-precedence],style[data-precedence]"),C=0;C<N.length;C++){var z=N[C];(z.nodeName==="LINK"||z.getAttribute("media")!=="not all")&&(x.set(z.dataset.precedence,z),A=z)}A&&x.set(null,A)}N=f.instance,z=N.getAttribute("data-precedence"),C=x.get(z)||A,C===A&&x.set(null,N),x.set(z,N),this.count++,A=_k.bind(this),N.addEventListener("load",A),N.addEventListener("error",A),C?C.parentNode.insertBefore(N,C.nextSibling):(d=d.nodeType===9?d.head:d,d.insertBefore(N,d.firstChild)),f.state.loading|=4}}var pv={$$typeof:S,Provider:null,Consumer:null,_currentValue:j,_currentValue2:j,_threadCount:0};function Ule(d,f,x,A,N,C,z,Y,ue){this.tag=1,this.containerInfo=d,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=At(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=At(0),this.hiddenUpdates=At(null),this.identifierPrefix=A,this.onUncaughtError=N,this.onCaughtError=C,this.onRecoverableError=z,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=ue,this.incompleteTransitions=new Map}function UW(d,f,x,A,N,C,z,Y,ue,Ce,ze,Ve){return d=new Ule(d,f,x,z,ue,Ce,ze,Ve,Y),f=1,C===!0&&(f|=24),C=Vi(3,null,null,f),d.current=C,C.stateNode=d,f=I$(),f.refCount++,d.pooledCache=f,f.refCount++,C.memoizedState={element:A,isDehydrated:x,cache:f},E$(C),d}function WW(d){return d?(d=mg,d):mg}function GW(d,f,x,A,N,C){N=WW(N),A.context===null?A.context=N:A.pendingContext=N,A=Mc(f),A.payload={element:x},C=C===void 0?null:C,C!==null&&(A.callback=C),x=Lc(d,A,f),x!==null&&(mi(x,d,f),H0(x,d,f))}function HW(d,f){if(d=d.memoizedState,d!==null&&d.dehydrated!==null){var x=d.retryLane;d.retryLane=x!==0&&x<f?x:f}}function q_(d,f){HW(d,f),(d=d.alternate)&&HW(d,f)}function jW(d){if(d.tag===13||d.tag===31){var f=$d(d,67108864);f!==null&&mi(f,d,67108864),q_(d,67108864)}}function qW(d){if(d.tag===13||d.tag===31){var f=ji();f=ha(f);var x=$d(d,f);x!==null&&mi(x,d,f),q_(d,f)}}var Ok=!0;function Wle(d,f,x,A){var N=B.T;B.T=null;var C=H.p;try{H.p=2,K_(d,f,x,A)}finally{H.p=C,B.T=N}}function Gle(d,f,x,A){var N=B.T;B.T=null;var C=H.p;try{H.p=8,K_(d,f,x,A)}finally{H.p=C,B.T=N}}function K_(d,f,x,A){if(Ok){var N=X_(A);if(N===null)O_(d,f,A,Fk,x),XW(d,A);else if(jle(N,d,f,x,A))A.stopPropagation();else if(XW(d,A),f&4&&-1<Hle.indexOf(d)){for(;N!==null;){var C=Ic(N);if(C!==null)switch(C.tag){case 3:if(C=C.stateNode,C.current.memoizedState.isDehydrated){var z=Ps(C.pendingLanes);if(z!==0){var Y=C;for(Y.pendingLanes|=2,Y.entangledLanes|=2;z;){var ue=1<<31-Vr(z);Y.entanglements[1]|=ue,z&=~ue}_l(C),(kn&6)===0&&(yk=nn()+500,ov(0))}}break;case 31:case 13:Y=$d(C,2),Y!==null&&mi(Y,C,2),xk(),q_(C,2)}if(C=X_(A),C===null&&O_(d,f,A,Fk,x),C===N)break;N=C}N!==null&&A.stopPropagation()}else O_(d,f,A,null,x)}}function X_(d){return d=_0(d),Y_(d)}var Fk=null;function Y_(d){if(Fk=null,d=go(d),d!==null){var f=s(d);if(f===null)d=null;else{var x=f.tag;if(x===13){if(d=i(f),d!==null)return d;d=null}else if(x===31){if(d=o(f),d!==null)return d;d=null}else if(x===3){if(f.stateNode.current.memoizedState.isDehydrated)return f.tag===3?f.stateNode.containerInfo:null;d=null}else f!==d&&(d=null)}}return Fk=d,null}function KW(d){switch(d){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ua()){case ea:return 2;case Cn:return 8;case ta:case ys:return 32;case po:return 268435456;default:return 32}default:return 32}}var Q_=!1,Kc=null,Xc=null,Yc=null,fv=new Map,mv=new Map,Qc=[],Hle="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function XW(d,f){switch(d){case"focusin":case"focusout":Kc=null;break;case"dragenter":case"dragleave":Xc=null;break;case"mouseover":case"mouseout":Yc=null;break;case"pointerover":case"pointerout":fv.delete(f.pointerId);break;case"gotpointercapture":case"lostpointercapture":mv.delete(f.pointerId)}}function gv(d,f,x,A,N,C){return d===null||d.nativeEvent!==C?(d={blockedOn:f,domEventName:x,eventSystemFlags:A,nativeEvent:C,targetContainers:[N]},f!==null&&(f=Ic(f),f!==null&&jW(f)),d):(d.eventSystemFlags|=A,f=d.targetContainers,N!==null&&f.indexOf(N)===-1&&f.push(N),d)}function jle(d,f,x,A,N){switch(f){case"focusin":return Kc=gv(Kc,d,f,x,A,N),!0;case"dragenter":return Xc=gv(Xc,d,f,x,A,N),!0;case"mouseover":return Yc=gv(Yc,d,f,x,A,N),!0;case"pointerover":var C=N.pointerId;return fv.set(C,gv(fv.get(C)||null,d,f,x,A,N)),!0;case"gotpointercapture":return C=N.pointerId,mv.set(C,gv(mv.get(C)||null,d,f,x,A,N)),!0}return!1}function YW(d){var f=go(d.target);if(f!==null){var x=s(f);if(x!==null){if(f=x.tag,f===13){if(f=i(x),f!==null){d.blockedOn=f,Ad(d.priority,function(){qW(x)});return}}else if(f===31){if(f=o(x),f!==null){d.blockedOn=f,Ad(d.priority,function(){qW(x)});return}}else if(f===3&&x.stateNode.current.memoizedState.isDehydrated){d.blockedOn=x.tag===3?x.stateNode.containerInfo:null;return}}}d.blockedOn=null}function Mk(d){if(d.blockedOn!==null)return!1;for(var f=d.targetContainers;0<f.length;){var x=X_(d.nativeEvent);if(x===null){x=d.nativeEvent;var A=new x.constructor(x.type,x);$c=A,x.target.dispatchEvent(A),$c=null}else return f=Ic(x),f!==null&&jW(f),d.blockedOn=x,!1;f.shift()}return!0}function QW(d,f,x){Mk(d)&&x.delete(f)}function qle(){Q_=!1,Kc!==null&&Mk(Kc)&&(Kc=null),Xc!==null&&Mk(Xc)&&(Xc=null),Yc!==null&&Mk(Yc)&&(Yc=null),fv.forEach(QW),mv.forEach(QW)}function Lk(d,f){d.blockedOn===f&&(d.blockedOn=null,Q_||(Q_=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,qle)))}var zk=null;function ZW(d){zk!==d&&(zk=d,e.unstable_scheduleCallback(e.unstable_NormalPriority,function(){zk===d&&(zk=null);for(var f=0;f<d.length;f+=3){var x=d[f],A=d[f+1],N=d[f+2];if(typeof A!="function"){if(Y_(A||x)===null)continue;break}var C=Ic(x);C!==null&&(d.splice(f,3),f-=3,X$(C,{pending:!0,data:N,method:x.method,action:A},A,N))}}))}function Bg(d){function f(ue){return Lk(ue,d)}Kc!==null&&Lk(Kc,d),Xc!==null&&Lk(Xc,d),Yc!==null&&Lk(Yc,d),fv.forEach(f),mv.forEach(f);for(var x=0;x<Qc.length;x++){var A=Qc[x];A.blockedOn===d&&(A.blockedOn=null)}for(;0<Qc.length&&(x=Qc[0],x.blockedOn===null);)YW(x),x.blockedOn===null&&Qc.shift();if(x=(d.ownerDocument||d).$$reactFormReplay,x!=null)for(A=0;A<x.length;A+=3){var N=x[A],C=x[A+1],z=N[Sn]||null;if(typeof C=="function")z||ZW(x);else if(z){var Y=null;if(C&&C.hasAttribute("formAction")){if(N=C,z=C[Sn]||null)Y=z.formAction;else if(Y_(N)!==null)continue}else Y=z.action;typeof Y=="function"?x[A+1]=Y:(x.splice(A,3),A-=3),ZW(x)}}}function JW(){function d(C){C.canIntercept&&C.info==="react-transition"&&C.intercept({handler:function(){return new Promise(function(z){return N=z})},focusReset:"manual",scroll:"manual"})}function f(){N!==null&&(N(),N=null),A||setTimeout(x,20)}function x(){if(!A&&!navigation.transition){var C=navigation.currentEntry;C&&C.url!=null&&navigation.navigate(C.url,{state:C.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var A=!1,N=null;return navigation.addEventListener("navigate",d),navigation.addEventListener("navigatesuccess",f),navigation.addEventListener("navigateerror",f),setTimeout(x,100),function(){A=!0,navigation.removeEventListener("navigate",d),navigation.removeEventListener("navigatesuccess",f),navigation.removeEventListener("navigateerror",f),N!==null&&(N(),N=null)}}}function Z_(d){this._internalRoot=d}Bk.prototype.render=Z_.prototype.render=function(d){var f=this._internalRoot;if(f===null)throw Error(a(409));var x=f.current,A=ji();GW(x,A,d,f,null,null)},Bk.prototype.unmount=Z_.prototype.unmount=function(){var d=this._internalRoot;if(d!==null){this._internalRoot=null;var f=d.containerInfo;GW(d.current,2,null,d,null,null),xk(),f[Vs]=null}};function Bk(d){this._internalRoot=d}Bk.prototype.unstable_scheduleHydration=function(d){if(d){var f=mo();d={blockedOn:null,target:d,priority:f};for(var x=0;x<Qc.length&&f!==0&&f<Qc[x].priority;x++);Qc.splice(x,0,d),x===0&&YW(d)}};var eG=t.version;if(eG!=="19.2.3")throw Error(a(527,eG,"19.2.3"));H.findDOMNode=function(d){var f=d._reactInternals;if(f===void 0)throw typeof d.render=="function"?Error(a(188)):(d=Object.keys(d).join(","),Error(a(268,d)));return d=u(f),d=d!==null?c(d):null,d=d===null?null:d.stateNode,d};var Kle={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:B,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Pk=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Pk.isDisabled&&Pk.supportsFiber)try{Ha=Pk.inject(Kle),ba=Pk}catch{}}return bv.createRoot=function(d,f){if(!r(d))throw Error(a(299));var x=!1,A="",N=oU,C=lU,z=uU;return f!=null&&(f.unstable_strictMode===!0&&(x=!0),f.identifierPrefix!==void 0&&(A=f.identifierPrefix),f.onUncaughtError!==void 0&&(N=f.onUncaughtError),f.onCaughtError!==void 0&&(C=f.onCaughtError),f.onRecoverableError!==void 0&&(z=f.onRecoverableError)),f=UW(d,1,!1,null,null,x,A,null,N,C,z,JW),d[Vs]=f.current,D_(d),new Z_(f)},bv.hydrateRoot=function(d,f,x){if(!r(d))throw Error(a(299));var A=!1,N="",C=oU,z=lU,Y=uU,ue=null;return x!=null&&(x.unstable_strictMode===!0&&(A=!0),x.identifierPrefix!==void 0&&(N=x.identifierPrefix),x.onUncaughtError!==void 0&&(C=x.onUncaughtError),x.onCaughtError!==void 0&&(z=x.onCaughtError),x.onRecoverableError!==void 0&&(Y=x.onRecoverableError),x.formState!==void 0&&(ue=x.formState)),f=UW(d,1,!0,f,x??null,A,N,ue,C,z,Y,JW),f.context=WW(null),x=f.current,A=ji(),A=ha(A),N=Mc(A),N.callback=null,Lc(x,N,A),x=A,f.current.lanes=x,Ye(f,x),_l(f),d[Vs]=f.current,D_(d),new Bk(f)},bv.version="19.2.3",bv}var cG;function sue(){if(cG)return tR.exports;cG=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),tR.exports=rue(),tR.exports}var iue=sue();var hG="popstate";function oue(e={}){function t(r,s){let{pathname:i="/",search:o="",hash:l=""}=rf(r.location.hash.substring(1));return!i.startsWith("/")&&!i.startsWith(".")&&(i="/"+i),QR("",{pathname:i,search:o,hash:l},s.state&&s.state.usr||null,s.state&&s.state.key||"default")}function n(r,s){let i=r.document.querySelector("base"),o="";if(i&&i.getAttribute("href")){let l=r.location.href,u=l.indexOf("#");o=u===-1?l:l.slice(0,u)}return o+"#"+(typeof s=="string"?s:Zv(s))}function a(r,s){Ti(r.pathname.charAt(0)==="/",`relative pathnames are not supported in hash history.push(${JSON.stringify(s)})`)}return uue(t,n,a,e)}function Na(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function Ti(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function lue(){return Math.random().toString(36).substring(2,10)}function dG(e,t){return{usr:e.state,key:e.key,idx:t}}function QR(e,t,n=null,a){return{pathname:typeof e=="string"?e:e.pathname,search:"",hash:"",...typeof t=="string"?rf(t):t,state:n,key:t&&t.key||a||lue()}}function Zv({pathname:e="/",search:t="",hash:n=""}){return t&&t!=="?"&&(e+=t.charAt(0)==="?"?t:"?"+t),n&&n!=="#"&&(e+=n.charAt(0)==="#"?n:"#"+n),e}function rf(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substring(n),e=e.substring(0,n));let a=e.indexOf("?");a>=0&&(t.search=e.substring(a),e=e.substring(0,a)),e&&(t.pathname=e)}return t}function uue(e,t,n,a={}){let{window:r=document.defaultView,v5Compat:s=!1}=a,i=r.history,o="POP",l=null,u=c();u==null&&(u=0,i.replaceState({...i.state,idx:u},""));function c(){return(i.state||{idx:null}).idx}function h(){o="POP";let b=c(),v=b==null?null:b-u;u=b,l&&l({action:o,location:y.location,delta:v})}function p(b,v){o="PUSH";let w=QR(y.location,b,v);n&&n(w,b),u=c()+1;let S=dG(w,u),k=y.createHref(w);try{i.pushState(S,"",k)}catch(I){if(I instanceof DOMException&&I.name==="DataCloneError")throw I;r.location.assign(k)}s&&l&&l({action:o,location:y.location,delta:1})}function m(b,v){o="REPLACE";let w=QR(y.location,b,v);n&&n(w,b),u=c();let S=dG(w,u),k=y.createHref(w);i.replaceState(S,"",k),s&&l&&l({action:o,location:y.location,delta:0})}function g(b){return cue(b)}let y={get action(){return o},get location(){return e(r,i)},listen(b){if(l)throw new Error("A history only accepts one active listener");return r.addEventListener(hG,h),l=b,()=>{r.removeEventListener(hG,h),l=null}},createHref(b){return t(r,b)},createURL:g,encodeLocation(b){let v=g(b);return{pathname:v.pathname,search:v.search,hash:v.hash}},push:p,replace:m,go(b){return i.go(b)}};return y}function cue(e,t=!1){let n="http://localhost";typeof window<"u"&&(n=window.location.origin!=="null"?window.location.origin:window.location.href),Na(n,"No window.location.(origin|href) available to create URL");let a=typeof e=="string"?e:Zv(e);return a=a.replace(/ $/,"%20"),!t&&a.startsWith("//")&&(a=n+a),new URL(a,n)}function Jj(e,t,n="/"){return hue(e,t,n,!1)}function hue(e,t,n,a){let r=typeof t=="string"?rf(t):t,s=Zu(r.pathname||"/",n);if(s==null)return null;let i=e5(e);due(i);let o=null;for(let l=0;o==null&&l<i.length;++l){let u=Sue(s);o=wue(i[l],u,a)}return o}function e5(e,t=[],n=[],a="",r=!1){let s=(i,o,l=r,u)=>{let c={relativePath:u===void 0?i.path||"":u,caseSensitive:i.caseSensitive===!0,childrenIndex:o,route:i};if(c.relativePath.startsWith("/")){if(!c.relativePath.startsWith(a)&&l)return;Na(c.relativePath.startsWith(a),`Absolute route path "${c.relativePath}" nested under path "${a}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),c.relativePath=c.relativePath.slice(a.length)}let h=qu([a,c.relativePath]),p=n.concat(c);i.children&&i.children.length>0&&(Na(i.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${h}".`),e5(i.children,t,p,h,l)),!(i.path==null&&!i.index)&&t.push({path:h,score:xue(h,i.index),routesMeta:p})};return e.forEach((i,o)=>{if(i.path===""||!i.path?.includes("?"))s(i,o);else for(let l of t5(i.path))s(i,o,!0,l)}),t}function t5(e){let t=e.split("/");if(t.length===0)return[];let[n,...a]=t,r=n.endsWith("?"),s=n.replace(/\?$/,"");if(a.length===0)return r?[s,""]:[s];let i=t5(a.join("/")),o=[];return o.push(...i.map(l=>l===""?s:[s,l].join("/"))),r&&o.push(...i),o.map(l=>e.startsWith("/")&&l===""?"/":l)}function due(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:vue(t.routesMeta.map(a=>a.childrenIndex),n.routesMeta.map(a=>a.childrenIndex)))}var pue=/^:[\w-]+$/,fue=3,mue=2,gue=1,yue=10,bue=-2,pG=e=>e==="*";function xue(e,t){let n=e.split("/"),a=n.length;return n.some(pG)&&(a+=bue),t&&(a+=mue),n.filter(r=>!pG(r)).reduce((r,s)=>r+(pue.test(s)?fue:s===""?gue:yue),a)}function vue(e,t){return e.length===t.length&&e.slice(0,-1).every((a,r)=>a===t[r])?e[e.length-1]-t[t.length-1]:0}function wue(e,t,n=!1){let{routesMeta:a}=e,r={},s="/",i=[];for(let o=0;o<a.length;++o){let l=a[o],u=o===a.length-1,c=s==="/"?t:t.slice(s.length)||"/",h=jI({path:l.relativePath,caseSensitive:l.caseSensitive,end:u},c),p=l.route;if(!h&&u&&n&&!a[a.length-1].route.index&&(h=jI({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},c)),!h)return null;Object.assign(r,h.params),i.push({params:r,pathname:qu([s,h.pathname]),pathnameBase:Cue(qu([s,h.pathnameBase])),route:p}),h.pathnameBase!=="/"&&(s=qu([s,h.pathnameBase]))}return i}function jI(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,a]=Aue(e.path,e.caseSensitive,e.end),r=t.match(n);if(!r)return null;let s=r[0],i=s.replace(/(.)\/+$/,"$1"),o=r.slice(1);return{params:a.reduce((u,{paramName:c,isOptional:h},p)=>{if(c==="*"){let g=o[p]||"";i=s.slice(0,s.length-g.length).replace(/(.)\/+$/,"$1")}const m=o[p];return h&&!m?u[c]=void 0:u[c]=(m||"").replace(/%2F/g,"/"),u},{}),pathname:s,pathnameBase:i,pattern:e}}function Aue(e,t=!1,n=!0){Ti(e==="*"||!e.endsWith("*")||e.endsWith("/*"),`Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);let a=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,o,l)=>(a.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g,"(/$1)?$2");return e.endsWith("*")?(a.push({paramName:"*"}),r+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":e!==""&&e!=="/"&&(r+="(?:(?=\\/|$))"),[new RegExp(r,t?void 0:"i"),a]}function Sue(e){try{return e.split("/").map(t=>decodeURIComponent(t).replace(/\//g,"%2F")).join("/")}catch(t){return Ti(!1,`The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`),e}}function Zu(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,a=e.charAt(n);return a&&a!=="/"?null:e.slice(n)||"/"}var n5=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,kue=e=>n5.test(e);function Iue(e,t="/"){let{pathname:n,search:a="",hash:r=""}=typeof e=="string"?rf(e):e,s;if(n)if(kue(n))s=n;else{if(n.includes("//")){let i=n;n=n.replace(/\/\/+/g,"/"),Ti(!1,`Pathnames cannot have embedded double slashes - normalizing ${i} -> ${n}`)}n.startsWith("/")?s=fG(n.substring(1),"/"):s=fG(n,t)}else s=t;return{pathname:s,search:Tue(a),hash:Eue(r)}}function fG(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(r=>{r===".."?n.length>1&&n.pop():r!=="."&&n.push(r)}),n.length>1?n.join("/"):"/"}function sR(e,t,n,a){return`Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(a)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function Nue(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function rF(e){let t=Nue(e);return t.map((n,a)=>a===t.length-1?n.pathname:n.pathnameBase)}function sF(e,t,n,a=!1){let r;typeof e=="string"?r=rf(e):(r={...e},Na(!r.pathname||!r.pathname.includes("?"),sR("?","pathname","search",r)),Na(!r.pathname||!r.pathname.includes("#"),sR("#","pathname","hash",r)),Na(!r.search||!r.search.includes("#"),sR("#","search","hash",r)));let s=e===""||r.pathname==="",i=s?"/":r.pathname,o;if(i==null)o=n;else{let h=t.length-1;if(!a&&i.startsWith("..")){let p=i.split("/");for(;p[0]==="..";)p.shift(),h-=1;r.pathname=p.join("/")}o=h>=0?t[h]:"/"}let l=Iue(r,o),u=i&&i!=="/"&&i.endsWith("/"),c=(s||i===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(u||c)&&(l.pathname+="/"),l}var qu=e=>e.join("/").replace(/\/\/+/g,"/"),Cue=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),Tue=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,Eue=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e,$ue=class{constructor(e,t,n,a=!1){this.status=e,this.statusText=t||"",this.internal=a,n instanceof Error?(this.data=n.toString(),this.error=n):this.data=n}};function _ue(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}function Rue(e){return e.map(t=>t.route.path).filter(Boolean).join("/").replace(/\/\/*/g,"/")||"/"}var a5=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";function r5(e,t){let n=e;if(typeof n!="string"||!n5.test(n))return{absoluteURL:void 0,isExternal:!1,to:n};let a=n,r=!1;if(a5)try{let s=new URL(window.location.href),i=n.startsWith("//")?new URL(s.protocol+n):new URL(n),o=Zu(i.pathname,t);i.origin===s.origin&&o!=null?n=o+i.search+i.hash:r=!0}catch{Ti(!1,`<Link to="${n}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}return{absoluteURL:a,isExternal:r,to:n}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var s5=["POST","PUT","PATCH","DELETE"];new Set(s5);var Due=["GET",...s5];new Set(Due);var Py=Ae.createContext(null);Py.displayName="DataRouter";var r2=Ae.createContext(null);r2.displayName="DataRouterState";var Oue=Ae.createContext(!1),i5=Ae.createContext({isTransitioning:!1});i5.displayName="ViewTransition";var Fue=Ae.createContext(new Map);Fue.displayName="Fetchers";var Mue=Ae.createContext(null);Mue.displayName="Await";var uo=Ae.createContext(null);uo.displayName="Navigation";var Lw=Ae.createContext(null);Lw.displayName="Location";var cu=Ae.createContext({outlet:null,matches:[],isDataRoute:!1});cu.displayName="Route";var iF=Ae.createContext(null);iF.displayName="RouteError";var o5="REACT_ROUTER_ERROR",Lue="REDIRECT",zue="ROUTE_ERROR_RESPONSE";function Bue(e){if(e.startsWith(`${o5}:${Lue}:{`))try{let t=JSON.parse(e.slice(28));if(typeof t=="object"&&t&&typeof t.status=="number"&&typeof t.statusText=="string"&&typeof t.location=="string"&&typeof t.reloadDocument=="boolean"&&typeof t.replace=="boolean")return t}catch{}}function Pue(e){if(e.startsWith(`${o5}:${zue}:{`))try{let t=JSON.parse(e.slice(40));if(typeof t=="object"&&t&&typeof t.status=="number"&&typeof t.statusText=="string")return new $ue(t.status,t.statusText,t.data)}catch{}}function Vue(e,{relative:t}={}){Na(Vy(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:a}=Ae.useContext(uo),{hash:r,pathname:s,search:i}=zw(e,{relative:t}),o=s;return n!=="/"&&(o=s==="/"?n:qu([n,s])),a.createHref({pathname:o,search:i,hash:r})}function Vy(){return Ae.useContext(Lw)!=null}function ic(){return Na(Vy(),"useLocation() may be used only in the context of a <Router> component."),Ae.useContext(Lw).location}var l5="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function u5(e){Ae.useContext(uo).static||Ae.useLayoutEffect(e)}function oF(){let{isDataRoute:e}=Ae.useContext(cu);return e?ece():Uue()}function Uue(){Na(Vy(),"useNavigate() may be used only in the context of a <Router> component.");let e=Ae.useContext(Py),{basename:t,navigator:n}=Ae.useContext(uo),{matches:a}=Ae.useContext(cu),{pathname:r}=ic(),s=JSON.stringify(rF(a)),i=Ae.useRef(!1);return u5(()=>{i.current=!0}),Ae.useCallback((l,u={})=>{if(Ti(i.current,l5),!i.current)return;if(typeof l=="number"){n.go(l);return}let c=sF(l,JSON.parse(s),r,u.relative==="path");e==null&&t!=="/"&&(c.pathname=c.pathname==="/"?t:qu([t,c.pathname])),(u.replace?n.replace:n.push)(c,u.state,u)},[t,n,s,r,e])}Ae.createContext(null);function zw(e,{relative:t}={}){let{matches:n}=Ae.useContext(cu),{pathname:a}=ic(),r=JSON.stringify(rF(n));return Ae.useMemo(()=>sF(e,JSON.parse(r),a,t==="path"),[e,r,a,t])}function Wue(e,t){return c5(e,t)}function c5(e,t,n,a,r){Na(Vy(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:s}=Ae.useContext(uo),{matches:i}=Ae.useContext(cu),o=i[i.length-1],l=o?o.params:{},u=o?o.pathname:"/",c=o?o.pathnameBase:"/",h=o&&o.route;{let w=h&&h.path||"";d5(u,!h||w.endsWith("*")||w.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${w}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${w}"> to <Route path="${w==="/"?"*":`${w}/*`}">.`)}let p=ic(),m;if(t){let w=typeof t=="string"?rf(t):t;Na(c==="/"||w.pathname?.startsWith(c),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${w.pathname}" was given in the \`location\` prop.`),m=w}else m=p;let g=m.pathname||"/",y=g;if(c!=="/"){let w=c.replace(/^\//,"").split("/");y="/"+g.replace(/^\//,"").split("/").slice(w.length).join("/")}let b=Jj(e,{pathname:y});Ti(h||b!=null,`No routes matched location "${m.pathname}${m.search}${m.hash}" `),Ti(b==null||b[b.length-1].route.element!==void 0||b[b.length-1].route.Component!==void 0||b[b.length-1].route.lazy!==void 0,`Matched leaf route at location "${m.pathname}${m.search}${m.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let v=Kue(b&&b.map(w=>Object.assign({},w,{params:Object.assign({},l,w.params),pathname:qu([c,s.encodeLocation?s.encodeLocation(w.pathname.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:w.pathname]),pathnameBase:w.pathnameBase==="/"?c:qu([c,s.encodeLocation?s.encodeLocation(w.pathnameBase.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:w.pathnameBase])})),i,n,a,r);return t&&v?Ae.createElement(Lw.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...m},navigationType:"POP"}},v):v}function Gue(){let e=Jue(),t=_ue(e)?`${e.status} ${e.statusText}`:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",r={padding:"0.5rem",backgroundColor:a},s={padding:"2px 4px",backgroundColor:a},i=null;return console.error("Error handled by React Router default ErrorBoundary:",e),i=Ae.createElement(Ae.Fragment,null,Ae.createElement("p",null," Hey developer "),Ae.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",Ae.createElement("code",{style:s},"ErrorBoundary")," or"," ",Ae.createElement("code",{style:s},"errorElement")," prop on your route.")),Ae.createElement(Ae.Fragment,null,Ae.createElement("h2",null,"Unexpected Application Error!"),Ae.createElement("h3",{style:{fontStyle:"italic"}},t),n?Ae.createElement("pre",{style:r},n):null,i)}var Hue=Ae.createElement(Gue,null),h5=class extends Ae.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||t.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){this.props.onError?this.props.onError(e,t):console.error("React Router caught the following error during render",e)}render(){let e=this.state.error;if(this.context&&typeof e=="object"&&e&&"digest"in e&&typeof e.digest=="string"){const n=Pue(e.digest);n&&(e=n)}let t=e!==void 0?Ae.createElement(cu.Provider,{value:this.props.routeContext},Ae.createElement(iF.Provider,{value:e,children:this.props.component})):this.props.children;return this.context?Ae.createElement(jue,{error:e},t):t}};h5.contextType=Oue;var iR=new WeakMap;function jue({children:e,error:t}){let{basename:n}=Ae.useContext(uo);if(typeof t=="object"&&t&&"digest"in t&&typeof t.digest=="string"){let a=Bue(t.digest);if(a){let r=iR.get(t);if(r)throw r;let s=r5(a.location,n);if(a5&&!iR.get(t))if(s.isExternal||a.reloadDocument)window.location.href=s.absoluteURL||s.to;else{const i=Promise.resolve().then(()=>window.__reactRouterDataRouter.navigate(s.to,{replace:a.replace}));throw iR.set(t,i),i}return Ae.createElement("meta",{httpEquiv:"refresh",content:`0;url=${s.absoluteURL||s.to}`})}}return e}function que({routeContext:e,match:t,children:n}){let a=Ae.useContext(Py);return a&&a.static&&a.staticContext&&(t.route.errorElement||t.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=t.route.id),Ae.createElement(cu.Provider,{value:e},n)}function Kue(e,t=[],n=null,a=null,r=null){if(e==null){if(!n)return null;if(n.errors)e=n.matches;else if(t.length===0&&!n.initialized&&n.matches.length>0)e=n.matches;else return null}let s=e,i=n?.errors;if(i!=null){let c=s.findIndex(h=>h.route.id&&i?.[h.route.id]!==void 0);Na(c>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(i).join(",")}`),s=s.slice(0,Math.min(s.length,c+1))}let o=!1,l=-1;if(n)for(let c=0;c<s.length;c++){let h=s[c];if((h.route.HydrateFallback||h.route.hydrateFallbackElement)&&(l=c),h.route.id){let{loaderData:p,errors:m}=n,g=h.route.loader&&!p.hasOwnProperty(h.route.id)&&(!m||m[h.route.id]===void 0);if(h.route.lazy||g){o=!0,l>=0?s=s.slice(0,l+1):s=[s[0]];break}}}let u=n&&a?(c,h)=>{a(c,{location:n.location,params:n.matches?.[0]?.params??{},unstable_pattern:Rue(n.matches),errorInfo:h})}:void 0;return s.reduceRight((c,h,p)=>{let m,g=!1,y=null,b=null;n&&(m=i&&h.route.id?i[h.route.id]:void 0,y=h.route.errorElement||Hue,o&&(l<0&&p===0?(d5("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),g=!0,b=null):l===p&&(g=!0,b=h.route.hydrateFallbackElement||null)));let v=t.concat(s.slice(0,p+1)),w=()=>{let S;return m?S=y:g?S=b:h.route.Component?S=Ae.createElement(h.route.Component,null):h.route.element?S=h.route.element:S=c,Ae.createElement(que,{match:h,routeContext:{outlet:c,matches:v,isDataRoute:n!=null},children:S})};return n&&(h.route.ErrorBoundary||h.route.errorElement||p===0)?Ae.createElement(h5,{location:n.location,revalidation:n.revalidation,component:y,error:m,children:w(),routeContext:{outlet:null,matches:v,isDataRoute:!0},onError:u}):w()},null)}function lF(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Xue(e){let t=Ae.useContext(Py);return Na(t,lF(e)),t}function Yue(e){let t=Ae.useContext(r2);return Na(t,lF(e)),t}function Que(e){let t=Ae.useContext(cu);return Na(t,lF(e)),t}function uF(e){let t=Que(e),n=t.matches[t.matches.length-1];return Na(n.route.id,`${e} can only be used on routes that contain a unique "id"`),n.route.id}function Zue(){return uF("useRouteId")}function Jue(){let e=Ae.useContext(iF),t=Yue("useRouteError"),n=uF("useRouteError");return e!==void 0?e:t.errors?.[n]}function ece(){let{router:e}=Xue("useNavigate"),t=uF("useNavigate"),n=Ae.useRef(!1);return u5(()=>{n.current=!0}),Ae.useCallback(async(r,s={})=>{Ti(n.current,l5),n.current&&(typeof r=="number"?await e.navigate(r):await e.navigate(r,{fromRouteId:t,...s}))},[e,t])}var mG={};function d5(e,t,n){!t&&!mG[e]&&(mG[e]=!0,Ti(!1,n))}Ae.memo(tce);function tce({routes:e,future:t,state:n,onError:a}){return c5(e,void 0,n,a,t)}function nce({to:e,replace:t,state:n,relative:a}){Na(Vy(),"<Navigate> may be used only in the context of a <Router> component.");let{static:r}=Ae.useContext(uo);Ti(!r,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let{matches:s}=Ae.useContext(cu),{pathname:i}=ic(),o=oF(),l=sF(e,rF(s),i,a==="path"),u=JSON.stringify(l);return Ae.useEffect(()=>{o(JSON.parse(u),{replace:t,state:n,relative:a})},[o,u,a,t,n]),null}function AI(e){Na(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function ace({basename:e="/",children:t=null,location:n,navigationType:a="POP",navigator:r,static:s=!1,unstable_useTransitions:i}){Na(!Vy(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let o=e.replace(/^\/*/,"/"),l=Ae.useMemo(()=>({basename:o,navigator:r,static:s,unstable_useTransitions:i,future:{}}),[o,r,s,i]);typeof n=="string"&&(n=rf(n));let{pathname:u="/",search:c="",hash:h="",state:p=null,key:m="default"}=n,g=Ae.useMemo(()=>{let y=Zu(u,o);return y==null?null:{location:{pathname:y,search:c,hash:h,state:p,key:m},navigationType:a}},[o,u,c,h,p,m,a]);return Ti(g!=null,`<Router basename="${o}"> is not able to match the URL "${u}${c}${h}" because it does not start with the basename, so the <Router> won't render anything.`),g==null?null:Ae.createElement(uo.Provider,{value:l},Ae.createElement(Lw.Provider,{children:t,value:g}))}function rce({children:e,location:t}){return Wue(ZR(e),t)}function ZR(e,t=[]){let n=[];return Ae.Children.forEach(e,(a,r)=>{if(!Ae.isValidElement(a))return;let s=[...t,r];if(a.type===Ae.Fragment){n.push.apply(n,ZR(a.props.children,s));return}Na(a.type===AI,`[${typeof a.type=="string"?a.type:a.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),Na(!a.props.index||!a.props.children,"An index route cannot have child routes.");let i={id:a.props.id||s.join("-"),caseSensitive:a.props.caseSensitive,element:a.props.element,Component:a.props.Component,index:a.props.index,path:a.props.path,middleware:a.props.middleware,loader:a.props.loader,action:a.props.action,hydrateFallbackElement:a.props.hydrateFallbackElement,HydrateFallback:a.props.HydrateFallback,errorElement:a.props.errorElement,ErrorBoundary:a.props.ErrorBoundary,hasErrorBoundary:a.props.hasErrorBoundary===!0||a.props.ErrorBoundary!=null||a.props.errorElement!=null,shouldRevalidate:a.props.shouldRevalidate,handle:a.props.handle,lazy:a.props.lazy};a.props.children&&(i.children=ZR(a.props.children,s)),n.push(i)}),n}var SI="get",kI="application/x-www-form-urlencoded";function s2(e){return typeof HTMLElement<"u"&&e instanceof HTMLElement}function sce(e){return s2(e)&&e.tagName.toLowerCase()==="button"}function ice(e){return s2(e)&&e.tagName.toLowerCase()==="form"}function oce(e){return s2(e)&&e.tagName.toLowerCase()==="input"}function lce(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function uce(e,t){return e.button===0&&(!t||t==="_self")&&!lce(e)}function JR(e=""){return new URLSearchParams(typeof e=="string"||Array.isArray(e)||e instanceof URLSearchParams?e:Object.keys(e).reduce((t,n)=>{let a=e[n];return t.concat(Array.isArray(a)?a.map(r=>[n,r]):[[n,a]])},[]))}function cce(e,t){let n=JR(e);return t&&t.forEach((a,r)=>{n.has(r)||t.getAll(r).forEach(s=>{n.append(r,s)})}),n}var Vk=null;function hce(){if(Vk===null)try{new FormData(document.createElement("form"),0),Vk=!1}catch{Vk=!0}return Vk}var dce=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function oR(e){return e!=null&&!dce.has(e)?(Ti(!1,`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${kI}"`),null):e}function pce(e,t){let n,a,r,s,i;if(ice(e)){let o=e.getAttribute("action");a=o?Zu(o,t):null,n=e.getAttribute("method")||SI,r=oR(e.getAttribute("enctype"))||kI,s=new FormData(e)}else if(sce(e)||oce(e)&&(e.type==="submit"||e.type==="image")){let o=e.form;if(o==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let l=e.getAttribute("formaction")||o.getAttribute("action");if(a=l?Zu(l,t):null,n=e.getAttribute("formmethod")||o.getAttribute("method")||SI,r=oR(e.getAttribute("formenctype"))||oR(o.getAttribute("enctype"))||kI,s=new FormData(o,e),!hce()){let{name:u,type:c,value:h}=e;if(c==="image"){let p=u?`${u}.`:"";s.append(`${p}x`,"0"),s.append(`${p}y`,"0")}else u&&s.append(u,h)}}else{if(s2(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=SI,a=null,r=kI,i=e}return s&&r==="text/plain"&&(i=s,s=void 0),{action:a,method:n.toLowerCase(),encType:r,formData:s,body:i}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function cF(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function fce(e,t,n){let a=typeof e=="string"?new URL(e,typeof window>"u"?"server://singlefetch/":window.location.origin):e;return a.pathname==="/"?a.pathname=`_root.${n}`:t&&Zu(a.pathname,t)==="/"?a.pathname=`${t.replace(/\/$/,"")}/_root.${n}`:a.pathname=`${a.pathname.replace(/\/$/,"")}.${n}`,a}async function mce(e,t){if(e.id in t)return t[e.id];try{let n=await import(e.module);return t[e.id]=n,n}catch(n){return console.error(`Error loading route module \`${e.module}\`, reloading page...`),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function gce(e){return e==null?!1:e.href==null?e.rel==="preload"&&typeof e.imageSrcSet=="string"&&typeof e.imageSizes=="string":typeof e.rel=="string"&&typeof e.href=="string"}async function yce(e,t,n){let a=await Promise.all(e.map(async r=>{let s=t.routes[r.route.id];if(s){let i=await mce(s,n);return i.links?i.links():[]}return[]}));return wce(a.flat(1).filter(gce).filter(r=>r.rel==="stylesheet"||r.rel==="preload").map(r=>r.rel==="stylesheet"?{...r,rel:"prefetch",as:"style"}:{...r,rel:"prefetch"}))}function gG(e,t,n,a,r,s){let i=(l,u)=>n[u]?l.route.id!==n[u].route.id:!0,o=(l,u)=>n[u].pathname!==l.pathname||n[u].route.path?.endsWith("*")&&n[u].params["*"]!==l.params["*"];return s==="assets"?t.filter((l,u)=>i(l,u)||o(l,u)):s==="data"?t.filter((l,u)=>{let c=a.routes[l.route.id];if(!c||!c.hasLoader)return!1;if(i(l,u)||o(l,u))return!0;if(l.route.shouldRevalidate){let h=l.route.shouldRevalidate({currentUrl:new URL(r.pathname+r.search+r.hash,window.origin),currentParams:n[0]?.params||{},nextUrl:new URL(e,window.origin),nextParams:l.params,defaultShouldRevalidate:!0});if(typeof h=="boolean")return h}return!0}):[]}function bce(e,t,{includeHydrateFallback:n}={}){return xce(e.map(a=>{let r=t.routes[a.route.id];if(!r)return[];let s=[r.module];return r.clientActionModule&&(s=s.concat(r.clientActionModule)),r.clientLoaderModule&&(s=s.concat(r.clientLoaderModule)),n&&r.hydrateFallbackModule&&(s=s.concat(r.hydrateFallbackModule)),r.imports&&(s=s.concat(r.imports)),s}).flat(1))}function xce(e){return[...new Set(e)]}function vce(e){let t={},n=Object.keys(e).sort();for(let a of n)t[a]=e[a];return t}function wce(e,t){let n=new Set;return new Set(t),e.reduce((a,r)=>{let s=JSON.stringify(vce(r));return n.has(s)||(n.add(s),a.push({key:s,link:r})),a},[])}function p5(){let e=Ae.useContext(Py);return cF(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function Ace(){let e=Ae.useContext(r2);return cF(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var hF=Ae.createContext(void 0);hF.displayName="FrameworkContext";function f5(){let e=Ae.useContext(hF);return cF(e,"You must render this element inside a <HydratedRouter> element"),e}function Sce(e,t){let n=Ae.useContext(hF),[a,r]=Ae.useState(!1),[s,i]=Ae.useState(!1),{onFocus:o,onBlur:l,onMouseEnter:u,onMouseLeave:c,onTouchStart:h}=t,p=Ae.useRef(null);Ae.useEffect(()=>{if(e==="render"&&i(!0),e==="viewport"){let y=v=>{v.forEach(w=>{i(w.isIntersecting)})},b=new IntersectionObserver(y,{threshold:.5});return p.current&&b.observe(p.current),()=>{b.disconnect()}}},[e]),Ae.useEffect(()=>{if(a){let y=setTimeout(()=>{i(!0)},100);return()=>{clearTimeout(y)}}},[a]);let m=()=>{r(!0)},g=()=>{r(!1),i(!1)};return n?e!=="intent"?[s,p,{}]:[s,p,{onFocus:xv(o,m),onBlur:xv(l,g),onMouseEnter:xv(u,m),onMouseLeave:xv(c,g),onTouchStart:xv(h,m)}]:[!1,p,{}]}function xv(e,t){return n=>{e&&e(n),n.defaultPrevented||t(n)}}function kce({page:e,...t}){let{router:n}=p5(),a=Ae.useMemo(()=>Jj(n.routes,e,n.basename),[n.routes,e,n.basename]);return a?Ae.createElement(Nce,{page:e,matches:a,...t}):null}function Ice(e){let{manifest:t,routeModules:n}=f5(),[a,r]=Ae.useState([]);return Ae.useEffect(()=>{let s=!1;return yce(e,t,n).then(i=>{s||r(i)}),()=>{s=!0}},[e,t,n]),a}function Nce({page:e,matches:t,...n}){let a=ic(),{manifest:r,routeModules:s}=f5(),{basename:i}=p5(),{loaderData:o,matches:l}=Ace(),u=Ae.useMemo(()=>gG(e,t,l,r,a,"data"),[e,t,l,r,a]),c=Ae.useMemo(()=>gG(e,t,l,r,a,"assets"),[e,t,l,r,a]),h=Ae.useMemo(()=>{if(e===a.pathname+a.search+a.hash)return[];let g=new Set,y=!1;if(t.forEach(v=>{let w=r.routes[v.route.id];!w||!w.hasLoader||(!u.some(S=>S.route.id===v.route.id)&&v.route.id in o&&s[v.route.id]?.shouldRevalidate||w.hasClientLoader?y=!0:g.add(v.route.id))}),g.size===0)return[];let b=fce(e,i,"data");return y&&g.size>0&&b.searchParams.set("_routes",t.filter(v=>g.has(v.route.id)).map(v=>v.route.id).join(",")),[b.pathname+b.search]},[i,o,a,r,u,t,e,s]),p=Ae.useMemo(()=>bce(c,r),[c,r]),m=Ice(c);return Ae.createElement(Ae.Fragment,null,h.map(g=>Ae.createElement("link",{key:g,rel:"prefetch",as:"fetch",href:g,...n})),p.map(g=>Ae.createElement("link",{key:g,rel:"modulepreload",href:g,...n})),m.map(({key:g,link:y})=>Ae.createElement("link",{key:g,nonce:n.nonce,...y})))}function Cce(...e){return t=>{e.forEach(n=>{typeof n=="function"?n(t):n!=null&&(n.current=t)})}}var Tce=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{Tce&&(window.__reactRouterVersion="7.11.0")}catch{}function Ece({basename:e,children:t,unstable_useTransitions:n,window:a}){let r=Ae.useRef();r.current==null&&(r.current=oue({window:a,v5Compat:!0}));let s=r.current,[i,o]=Ae.useState({action:s.action,location:s.location}),l=Ae.useCallback(u=>{n===!1?o(u):Ae.startTransition(()=>o(u))},[n]);return Ae.useLayoutEffect(()=>s.listen(l),[s,l]),Ae.createElement(ace,{basename:e,children:t,location:i.location,navigationType:i.action,navigator:s,unstable_useTransitions:n})}var m5=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,g5=Ae.forwardRef(function({onClick:t,discover:n="render",prefetch:a="none",relative:r,reloadDocument:s,replace:i,state:o,target:l,to:u,preventScrollReset:c,viewTransition:h,unstable_defaultShouldRevalidate:p,...m},g){let{basename:y,unstable_useTransitions:b}=Ae.useContext(uo),v=typeof u=="string"&&m5.test(u),w=r5(u,y);u=w.to;let S=Vue(u,{relative:r}),[k,I,T]=Sce(a,m),E=Dce(u,{replace:i,state:o,target:l,preventScrollReset:c,relative:r,viewTransition:h,unstable_defaultShouldRevalidate:p,unstable_useTransitions:b});function R(O){t&&t(O),O.defaultPrevented||E(O)}let D=Ae.createElement("a",{...m,...T,href:w.absoluteURL||S,onClick:w.isExternal||s?t:R,ref:Cce(g,I),target:l,"data-discover":!v&&n==="render"?"true":void 0});return k&&!v?Ae.createElement(Ae.Fragment,null,D,Ae.createElement(kce,{page:S})):D});g5.displayName="Link";var $ce=Ae.forwardRef(function({"aria-current":t="page",caseSensitive:n=!1,className:a="",end:r=!1,style:s,to:i,viewTransition:o,children:l,...u},c){let h=zw(i,{relative:u.relative}),p=ic(),m=Ae.useContext(r2),{navigator:g,basename:y}=Ae.useContext(uo),b=m!=null&&Bce(h)&&o===!0,v=g.encodeLocation?g.encodeLocation(h).pathname:h.pathname,w=p.pathname,S=m&&m.navigation&&m.navigation.location?m.navigation.location.pathname:null;n||(w=w.toLowerCase(),S=S?S.toLowerCase():null,v=v.toLowerCase()),S&&y&&(S=Zu(S,y)||S);const k=v!=="/"&&v.endsWith("/")?v.length-1:v.length;let I=w===v||!r&&w.startsWith(v)&&w.charAt(k)==="/",T=S!=null&&(S===v||!r&&S.startsWith(v)&&S.charAt(v.length)==="/"),E={isActive:I,isPending:T,isTransitioning:b},R=I?t:void 0,D;typeof a=="function"?D=a(E):D=[a,I?"active":null,T?"pending":null,b?"transitioning":null].filter(Boolean).join(" ");let O=typeof s=="function"?s(E):s;return Ae.createElement(g5,{...u,"aria-current":R,className:D,ref:c,style:O,to:i,viewTransition:o},typeof l=="function"?l(E):l)});$ce.displayName="NavLink";var _ce=Ae.forwardRef(({discover:e="render",fetcherKey:t,navigate:n,reloadDocument:a,replace:r,state:s,method:i=SI,action:o,onSubmit:l,relative:u,preventScrollReset:c,viewTransition:h,unstable_defaultShouldRevalidate:p,...m},g)=>{let{unstable_useTransitions:y}=Ae.useContext(uo),b=Lce(),v=zce(o,{relative:u}),w=i.toLowerCase()==="get"?"get":"post",S=typeof o=="string"&&m5.test(o),k=I=>{if(l&&l(I),I.defaultPrevented)return;I.preventDefault();let T=I.nativeEvent.submitter,E=T?.getAttribute("formmethod")||i,R=()=>b(T||I.currentTarget,{fetcherKey:t,method:E,navigate:n,replace:r,state:s,relative:u,preventScrollReset:c,viewTransition:h,unstable_defaultShouldRevalidate:p});y&&n!==!1?Ae.startTransition(()=>R()):R()};return Ae.createElement("form",{ref:g,method:w,action:v,onSubmit:a?l:k,...m,"data-discover":!S&&e==="render"?"true":void 0})});_ce.displayName="Form";function Rce(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function y5(e){let t=Ae.useContext(Py);return Na(t,Rce(e)),t}function Dce(e,{target:t,replace:n,state:a,preventScrollReset:r,relative:s,viewTransition:i,unstable_defaultShouldRevalidate:o,unstable_useTransitions:l}={}){let u=oF(),c=ic(),h=zw(e,{relative:s});return Ae.useCallback(p=>{if(uce(p,t)){p.preventDefault();let m=n!==void 0?n:Zv(c)===Zv(h),g=()=>u(e,{replace:m,state:a,preventScrollReset:r,relative:s,viewTransition:i,unstable_defaultShouldRevalidate:o});l?Ae.startTransition(()=>g()):g()}},[c,u,h,n,a,t,e,r,s,i,o,l])}function Oce(e){Ti(typeof URLSearchParams<"u","You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.");let t=Ae.useRef(JR(e)),n=Ae.useRef(!1),a=ic(),r=Ae.useMemo(()=>cce(a.search,n.current?null:t.current),[a.search]),s=oF(),i=Ae.useCallback((o,l)=>{const u=JR(typeof o=="function"?o(new URLSearchParams(r)):o);n.current=!0,s("?"+u,l)},[s,r]);return[r,i]}var Fce=0,Mce=()=>`__${String(++Fce)}__`;function Lce(){let{router:e}=y5("useSubmit"),{basename:t}=Ae.useContext(uo),n=Zue(),a=e.fetch,r=e.navigate;return Ae.useCallback(async(s,i={})=>{let{action:o,method:l,encType:u,formData:c,body:h}=pce(s,t);if(i.navigate===!1){let p=i.fetcherKey||Mce();await a(p,n,i.action||o,{unstable_defaultShouldRevalidate:i.unstable_defaultShouldRevalidate,preventScrollReset:i.preventScrollReset,formData:c,body:h,formMethod:i.method||l,formEncType:i.encType||u,flushSync:i.flushSync})}else await r(i.action||o,{unstable_defaultShouldRevalidate:i.unstable_defaultShouldRevalidate,preventScrollReset:i.preventScrollReset,formData:c,body:h,formMethod:i.method||l,formEncType:i.encType||u,replace:i.replace,state:i.state,fromRouteId:n,flushSync:i.flushSync,viewTransition:i.viewTransition})},[a,r,t,n])}function zce(e,{relative:t}={}){let{basename:n}=Ae.useContext(uo),a=Ae.useContext(cu);Na(a,"useFormAction must be used inside a RouteContext");let[r]=a.matches.slice(-1),s={...zw(e||".",{relative:t})},i=ic();if(e==null){s.search=i.search;let o=new URLSearchParams(s.search),l=o.getAll("index");if(l.some(c=>c==="")){o.delete("index"),l.filter(h=>h).forEach(h=>o.append("index",h));let c=o.toString();s.search=c?`?${c}`:""}}return(!e||e===".")&&r.route.index&&(s.search=s.search?s.search.replace(/^\?/,"?index&"):"?index"),n!=="/"&&(s.pathname=s.pathname==="/"?n:qu([n,s.pathname])),Zv(s)}function Bce(e,{relative:t}={}){let n=Ae.useContext(i5);Na(n!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:a}=y5("useViewTransitionState"),r=zw(e,{relative:t});if(!n.isTransitioning)return!1;let s=Zu(n.currentLocation.pathname,a)||n.currentLocation.pathname,i=Zu(n.nextLocation.pathname,a)||n.nextLocation.pathname;return jI(r.pathname,i)!=null||jI(r.pathname,s)!=null}var II={exports:{}},Pce=II.exports,yG;function Vce(){return yG||(yG=1,(function(e,t){(function(a,r){e.exports=r(a2())})(Pce,function(n){return(function(a){var r={};function s(i){if(r[i])return r[i].exports;var o=r[i]={i,l:!1,exports:{}};return a[i].call(o.exports,o,o.exports,s),o.l=!0,o.exports}return s.m=a,s.c=r,s.d=function(i,o,l){s.o(i,o)||Object.defineProperty(i,o,{enumerable:!0,get:l})},s.r=function(i){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})},s.t=function(i,o){if(o&1&&(i=s(i)),o&8||o&4&&typeof i=="object"&&i&&i.__esModule)return i;var l=Object.create(null);if(s.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:i}),o&2&&typeof i!="string")for(var u in i)s.d(l,u,(function(c){return i[c]}).bind(null,u));return l},s.n=function(i){var o=i&&i.__esModule?function(){return i.default}:function(){return i};return s.d(o,"a",o),o},s.o=function(i,o){return Object.prototype.hasOwnProperty.call(i,o)},s.p="",s(s.s="./src/react-webcam.tsx")})({"./src/react-webcam.tsx":(function(a,r,s){s.r(r);var i=s("react"),o=(function(){var p=function(m,g){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,b){y.__proto__=b}||function(y,b){for(var v in b)b.hasOwnProperty(v)&&(y[v]=b[v])},p(m,g)};return function(m,g){p(m,g);function y(){this.constructor=m}m.prototype=g===null?Object.create(g):(y.prototype=g.prototype,new y)}})(),l=function(){return l=Object.assign||function(p){for(var m,g=1,y=arguments.length;g<y;g++){m=arguments[g];for(var b in m)Object.prototype.hasOwnProperty.call(m,b)&&(p[b]=m[b])}return p},l.apply(this,arguments)},u=function(p,m){var g={};for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&m.indexOf(y)<0&&(g[y]=p[y]);if(p!=null&&typeof Object.getOwnPropertySymbols=="function")for(var b=0,y=Object.getOwnPropertySymbols(p);b<y.length;b++)m.indexOf(y[b])<0&&Object.prototype.propertyIsEnumerable.call(p,y[b])&&(g[y[b]]=p[y[b]]);return g};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(m){var g=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return g?new Promise(function(y,b){g.call(navigator,m,y,b)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function c(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var h=(function(p){o(m,p);function m(g){var y=p.call(this,g)||this;return y.canvas=null,y.ctx=null,y.requestUserMediaId=0,y.unmounted=!1,y.state={hasUserMedia:!1},y}return m.prototype.componentDidMount=function(){var g=this,y=g.state,b=g.props;if(this.unmounted=!1,!c()){b.onUserMediaError("getUserMedia not supported");return}y.hasUserMedia||this.requestUserMedia(),b.children&&typeof b.children!="function"&&console.warn("children must be a function")},m.prototype.componentDidUpdate=function(g){var y=this.props;if(!c()){y.onUserMediaError("getUserMedia not supported");return}var b=JSON.stringify(g.audioConstraints)!==JSON.stringify(y.audioConstraints),v=JSON.stringify(g.videoConstraints)!==JSON.stringify(y.videoConstraints),w=g.minScreenshotWidth!==y.minScreenshotWidth,S=g.minScreenshotHeight!==y.minScreenshotHeight;(v||w||S)&&(this.canvas=null,this.ctx=null),(b||v)&&(this.stopAndCleanup(),this.requestUserMedia())},m.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},m.stopMediaStream=function(g){g&&(g.getVideoTracks&&g.getAudioTracks?(g.getVideoTracks().map(function(y){g.removeTrack(y),y.stop()}),g.getAudioTracks().map(function(y){g.removeTrack(y),y.stop()})):g.stop())},m.prototype.stopAndCleanup=function(){var g=this.state;g.hasUserMedia&&(m.stopMediaStream(this.stream),g.src&&window.URL.revokeObjectURL(g.src))},m.prototype.getScreenshot=function(g){var y=this,b=y.state,v=y.props;if(!b.hasUserMedia)return null;var w=this.getCanvas(g);return w&&w.toDataURL(v.screenshotFormat,v.screenshotQuality)},m.prototype.getCanvas=function(g){var y=this,b=y.state,v=y.props;if(!this.video||!b.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var w=this.video.videoWidth,S=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var k=w/S;w=v.minScreenshotWidth||this.video.clientWidth,S=w/k,v.minScreenshotHeight&&S<v.minScreenshotHeight&&(S=v.minScreenshotHeight,w=S*k)}this.canvas=document.createElement("canvas"),this.canvas.width=g?.width||w,this.canvas.height=g?.height||S,this.ctx=this.canvas.getContext("2d")}var I=this,T=I.ctx,E=I.canvas;return T&&E&&(E.width=g?.width||E.width,E.height=g?.height||E.height,v.mirrored&&(T.translate(E.width,0),T.scale(-1,1)),T.imageSmoothingEnabled=v.imageSmoothing,T.drawImage(this.video,0,0,g?.width||E.width,g?.height||E.height),v.mirrored&&(T.scale(-1,1),T.translate(-E.width,0))),E},m.prototype.requestUserMedia=function(){var g=this,y=this.props,b=function(S,k){var I={video:typeof k<"u"?k:!0};y.audio&&(I.audio=typeof S<"u"?S:!0),g.requestUserMediaId++;var T=g.requestUserMediaId;navigator.mediaDevices.getUserMedia(I).then(function(E){g.unmounted||T!==g.requestUserMediaId?m.stopMediaStream(E):g.handleUserMedia(null,E)}).catch(function(E){g.handleUserMedia(E)})};if("mediaDevices"in navigator)b(y.audioConstraints,y.videoConstraints);else{var v=function(S){return{optional:[{sourceId:S}]}},w=function(S){var k=S.deviceId;return typeof k=="string"?k:Array.isArray(k)&&k.length>0?k[0]:typeof k=="object"&&k.ideal?k.ideal:null};MediaStreamTrack.getSources(function(S){var k=null,I=null;S.forEach(function(R){R.kind==="audio"?k=R.id:R.kind==="video"&&(I=R.id)});var T=w(y.audioConstraints);T&&(k=T);var E=w(y.videoConstraints);E&&(I=E),b(v(k),v(I))})}},m.prototype.handleUserMedia=function(g,y){var b=this.props;if(g||!y){this.setState({hasUserMedia:!1}),b.onUserMediaError(g);return}this.stream=y;try{this.video&&(this.video.srcObject=y),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(y)})}b.onUserMedia(y)},m.prototype.render=function(){var g=this,y=this,b=y.state,v=y.props,w=v.audio;v.forceScreenshotSourceSize;var S=v.disablePictureInPicture;v.onUserMedia,v.onUserMediaError,v.screenshotFormat,v.screenshotQuality,v.minScreenshotWidth,v.minScreenshotHeight,v.audioConstraints,v.videoConstraints,v.imageSmoothing;var k=v.mirrored,I=v.style,T=I===void 0?{}:I,E=v.children,R=u(v,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),D=k?l(l({},T),{transform:(T.transform||"")+" scaleX(-1)"}):T,O={getScreenshot:this.getScreenshot.bind(this)};return i.createElement(i.Fragment,null,i.createElement("video",l({autoPlay:!0,disablePictureInPicture:S,src:b.src,muted:!w,playsInline:!0,ref:function($){g.video=$},style:D},R)),E&&E(O))},m.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},m})(i.Component);r.default=h}),react:(function(a,r){a.exports=n})}).default})})(II)),II.exports}var Uce=Vce();const i2=n2(Uce);const Wce=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),Gce=e=>e.replace(/^([A-Z])|[\s-_]+(\w)/g,(t,n,a)=>a?a.toUpperCase():n.toLowerCase()),bG=e=>{const t=Gce(e);return t.charAt(0).toUpperCase()+t.slice(1)},b5=(...e)=>e.filter((t,n,a)=>!!t&&t.trim()!==""&&a.indexOf(t)===n).join(" ").trim(),Hce=e=>{for(const t in e)if(t.startsWith("aria-")||t==="role"||t==="title")return!0};var jce={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const qce=Ae.forwardRef(({color:e="currentColor",size:t=24,strokeWidth:n=2,absoluteStrokeWidth:a,className:r="",children:s,iconNode:i,...o},l)=>Ae.createElement("svg",{ref:l,...jce,width:t,height:t,stroke:e,strokeWidth:a?Number(n)*24/Number(t):n,className:b5("lucide",r),...!s&&!Hce(o)&&{"aria-hidden":"true"},...o},[...i.map(([u,c])=>Ae.createElement(u,c)),...Array.isArray(s)?s:[s]]));const Ea=(e,t)=>{const n=Ae.forwardRef(({className:a,...r},s)=>Ae.createElement(qce,{ref:s,iconNode:t,className:b5(`lucide-${Wce(bG(e))}`,`lucide-${e}`,a),...r}));return n.displayName=bG(e),n};const Kce=[["path",{d:"m12 19-7-7 7-7",key:"1l729n"}],["path",{d:"M19 12H5",key:"x3x0zl"}]],Xce=Ea("arrow-left",Kce);const Yce=[["path",{d:"m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526",key:"1yiouv"}],["circle",{cx:"12",cy:"8",r:"6",key:"1vp47v"}]],Qce=Ea("award",Yce);const Zce=[["path",{d:"M12 7v14",key:"1akyts"}],["path",{d:"M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z",key:"ruj8y"}]],Jce=Ea("book-open",Zce);const ehe=[["path",{d:"M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z",key:"18u6gg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]],the=Ea("camera",ehe);const nhe=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]],x5=Ea("circle-alert",nhe);const ahe=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],v5=Ea("circle-check",ahe);const rhe=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["circle",{cx:"12",cy:"10",r:"3",key:"ilqhr7"}],["path",{d:"M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662",key:"154egf"}]],w5=Ea("circle-user",rhe);const she=[["path",{d:"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",key:"1nclc0"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]],ihe=Ea("eye",she);const ohe=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",key:"13o1zl"}],["path",{d:"M2 12h20",key:"9i4pu4"}]],lhe=Ea("globe",ohe);const uhe=[["path",{d:"M21 12a9 9 0 1 1-6.219-8.56",key:"13zald"}]],dF=Ea("loader-circle",uhe);const che=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],A5=Ea("lock",che);const hhe=[["path",{d:"m10 17 5-5-5-5",key:"1bsop3"}],["path",{d:"M15 12H3",key:"6jk70r"}],["path",{d:"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4",key:"u53s6r"}]],dhe=Ea("log-in",hhe);const phe=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],S5=Ea("log-out",phe);const fhe=[["path",{d:"M12 19v3",key:"npa21l"}],["path",{d:"M15 9.34V5a3 3 0 0 0-5.68-1.33",key:"1gzdoj"}],["path",{d:"M16.95 16.95A7 7 0 0 1 5 12v-2",key:"cqa7eg"}],["path",{d:"M18.89 13.23A7 7 0 0 0 19 12v-2",key:"16hl24"}],["path",{d:"m2 2 20 20",key:"1ooewy"}],["path",{d:"M9 9v3a3 3 0 0 0 5.12 2.12",key:"r2i35w"}]],mhe=Ea("mic-off",fhe);const ghe=[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]],k5=Ea("refresh-cw",ghe);const yhe=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}]],bhe=Ea("rotate-ccw",yhe);const xhe=[["path",{d:"M3 7V5a2 2 0 0 1 2-2h2",key:"aa7l1z"}],["path",{d:"M17 3h2a2 2 0 0 1 2 2v2",key:"4qcy5o"}],["path",{d:"M21 17v2a2 2 0 0 1-2 2h-2",key:"6vwrx8"}],["path",{d:"M7 21H5a2 2 0 0 1-2-2v-2",key:"ioqczr"}],["path",{d:"M8 14s1.5 2 4 2 4-2 4-2",key:"1y1vjs"}],["path",{d:"M9 9h.01",key:"1q5me6"}],["path",{d:"M15 9h.01",key:"x1ddxp"}]],vhe=Ea("scan-face",xhe);const whe=[["path",{d:"M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",key:"oel41y"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],pF=Ea("shield-check",whe);const Ahe=[["path",{d:"M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",key:"oel41y"}],["path",{d:"M9 12h6",key:"1c52cq"}],["path",{d:"M12 9v6",key:"199k2o"}]],She=Ea("shield-plus",Ahe);const khe=[["rect",{width:"14",height:"20",x:"5",y:"2",rx:"2",ry:"2",key:"1yt0o3"}],["path",{d:"M12 18h.01",key:"mhygvu"}]],I5=Ea("smartphone",khe);const Ihe=[["line",{x1:"10",x2:"14",y1:"2",y2:"2",key:"14vaq8"}],["line",{x1:"12",x2:"15",y1:"14",y2:"11",key:"17fdiu"}],["circle",{cx:"12",cy:"14",r:"8",key:"1e1u0o"}]],Nhe=Ea("timer",Ihe);const Che=[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]],fF=Ea("user",Che);const The=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["path",{d:"M16 3.128a4 4 0 0 1 0 7.744",key:"16gr8j"}],["path",{d:"M22 21v-2a4 4 0 0 0-3-3.87",key:"kshegd"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}]],Ehe=Ea("users",The);const $he=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],_he=Ea("zap",$he),Rhe=({onDone:e})=>{const[t,n]=Ae.useState({username:"",password:"",name:""}),[a,r]=Ae.useState(null),[s,i]=Ae.useState(!1),[o,l]=Ae.useState({type:"",text:""}),u=Ae.useRef(null),c=Ae.useCallback(()=>{const p=u.current.getScreenshot();r(p),i(!0)},[u]),h=p=>{if(p.preventDefault(),!a){l({type:"error",text:"Wajib mengambil foto wajah untuk verifikasi!"});return}const m=JSON.parse(localStorage.getItem("users")||"[]");if(m.find(y=>y.username===t.username)){l({type:"error",text:"Username sudah digunakan!"});return}const g={...t,photo:a};m.push(g),localStorage.setItem("users",JSON.stringify(m)),l({type:"success",text:"Akun berhasil dibuat! Mengalihkan..."}),setTimeout(()=>e(),2e3)};return ce.jsx("div",{className:"min-h-screen flex items-center justify-center bg-[radial-gradient(ellipse_at_top_right,_var(--tw-gradient-stops))] from-indigo-100 via-slate-50 to-slate-200 p-4 md:p-10",children:ce.jsxs("div",{className:"bg-white/80 backdrop-blur-2xl rounded-[2.5rem] shadow-[0_20px_50px_rgba(79,70,229,0.15)] border border-white flex flex-col md:flex-row max-w-5xl w-full overflow-hidden",children:[ce.jsxs("div",{className:"md:w-1/2 bg-slate-900 p-8 md:p-12 flex flex-col justify-center relative text-white",children:[ce.jsxs("div",{className:"relative z-10 mb-8",children:[ce.jsx("div",{className:"bg-indigo-500 w-fit p-3 rounded-2xl mb-4 shadow-lg shadow-indigo-500/20",children:ce.jsx(She,{size:28})}),ce.jsx("h2",{className:"text-3xl font-bold tracking-tight",children:"Biometric Registration"}),ce.jsx("p",{className:"text-slate-400 mt-2",children:"Pastikan wajah terlihat jelas untuk proses verifikasi AI nanti."})]}),ce.jsxs("div",{className:"relative group aspect-video rounded-3xl overflow-hidden border-2 border-slate-700 bg-black shadow-2xl transition-all duration-500 hover:border-indigo-500/50",children:[s?ce.jsx("img",{src:a,alt:"Captured",className:"w-full h-full object-cover border-4 border-indigo-500/30"}):ce.jsx(i2,{audio:!1,ref:u,screenshotFormat:"image/jpeg",className:"w-full h-full object-cover grayscale-[0.2]"}),!s&&ce.jsx("div",{className:"absolute inset-0 border-[1px] border-white/10 pointer-events-none animate-pulse"})]}),ce.jsx("button",{type:"button",onClick:s?()=>i(!1):c,className:`mt-6 flex items-center justify-center gap-3 py-4 rounded-2xl font-bold transition-all active:scale-95 shadow-lg ${s?"bg-slate-800 hover:bg-slate-700 text-slate-300":"bg-indigo-600 hover:bg-indigo-500 text-white shadow-indigo-500/20"}`,children:s?ce.jsxs(ce.Fragment,{children:[ce.jsx(bhe,{size:20})," Ambil Ulang"]}):ce.jsxs(ce.Fragment,{children:[ce.jsx(the,{size:20})," Ambil Foto Wajah"]})})]}),ce.jsxs("div",{className:"md:w-1/2 p-8 md:p-12 flex flex-col justify-center bg-white/40",children:[ce.jsxs("button",{onClick:e,className:"group flex items-center gap-2 text-slate-400 hover:text-indigo-600 font-semibold text-sm mb-10 transition-colors w-fit",children:[ce.jsx(Xce,{size:18,className:"group-hover:-translate-x-1 transition-transform"})," Kembali ke Login"]}),ce.jsx("h3",{className:"text-2xl font-extrabold text-slate-900 mb-2",children:"Lengkapi Data"}),ce.jsx("p",{className:"text-slate-500 mb-8 font-medium",children:"Buat akun untuk mulai ujian online."}),o.text&&ce.jsxs("div",{className:`mb-6 p-4 rounded-2xl flex items-center gap-3 text-sm font-bold border animate-in fade-in slide-in-from-top-4 ${o.type==="error"?"bg-red-50 text-red-600 border-red-100":"bg-green-50 text-green-600 border-green-100"}`,children:[o.type==="success"?ce.jsx(v5,{size:18}):null,o.text]}),ce.jsxs("form",{onSubmit:h,className:"space-y-5",children:[ce.jsxs("div",{className:"group relative",children:[ce.jsx(w5,{className:"absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-600 transition-colors",size:20}),ce.jsx("input",{type:"text",placeholder:"Nama Lengkap",className:"w-full pl-12 pr-4 py-4 rounded-2xl border border-slate-200 bg-white focus:ring-4 focus:ring-indigo-500/10 focus:border-indigo-500 outline-none transition-all font-medium",value:t.name,onChange:p=>n({...t,name:p.target.value}),required:!0})]}),ce.jsxs("div",{className:"group relative",children:[ce.jsx(fF,{className:"absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-600 transition-colors",size:20}),ce.jsx("input",{type:"text",placeholder:"Username",className:"w-full pl-12 pr-4 py-4 rounded-2xl border border-slate-200 bg-white focus:ring-4 focus:ring-indigo-500/10 focus:border-indigo-500 outline-none transition-all font-medium",value:t.username,onChange:p=>n({...t,username:p.target.value}),required:!0})]}),ce.jsxs("div",{className:"group relative",children:[ce.jsx(A5,{className:"absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-600 transition-colors",size:20}),ce.jsx("input",{type:"password",placeholder:"Password",className:"w-full pl-12 pr-4 py-4 rounded-2xl border border-slate-200 bg-white focus:ring-4 focus:ring-indigo-500/10 focus:border-indigo-500 outline-none transition-all font-medium",value:t.password,onChange:p=>n({...t,password:p.target.value}),required:!0})]}),ce.jsx("button",{type:"submit",className:"w-full bg-slate-900 hover:bg-indigo-600 text-white py-4 rounded-2xl font-black text-lg transition-all duration-300 shadow-xl hover:shadow-indigo-500/30 active:scale-[0.98] mt-4",children:"Daftar Akun"})]})]})]})})},Dhe=({onLoginSuccess:e,onGoToRegister:t})=>{const[n,a]=Ae.useState({username:"",password:""}),[r,s]=Ae.useState(""),i=o=>{o.preventDefault();const u=JSON.parse(localStorage.getItem("users")||"[]").find(c=>c.username===n.username&&c.password===n.password);u?(sessionStorage.setItem("loggedInUser",JSON.stringify(u)),e(u)):s("Username atau password tidak sesuai.")};return ce.jsx("div",{className:"min-h-screen flex items-center justify-center bg-[radial-gradient(ellipse_at_top_left,_var(--tw-gradient-stops))] from-slate-200 via-slate-50 to-indigo-100 p-6",children:ce.jsxs("div",{className:"w-full max-w-md",children:[ce.jsx("div",{className:"flex justify-center mb-8",children:ce.jsx("div",{className:"bg-indigo-600 p-3 rounded-2xl shadow-xl shadow-indigo-200",children:ce.jsx(pF,{className:"text-white",size:32})})}),ce.jsxs("div",{className:"bg-white/80 backdrop-blur-xl rounded-3xl shadow-[0_20px_50px_rgba(79,70,229,0.1)] border border-white overflow-hidden",children:[ce.jsxs("div",{className:"p-8 text-center",children:[ce.jsx("h1",{className:"text-3xl font-extrabold text-slate-900 tracking-tight",children:"Selamat Datang"}),ce.jsx("p",{className:"text-slate-500 mt-2 text-sm font-medium",children:"Silakan masuk untuk memulai ujian"})]}),ce.jsxs("form",{onSubmit:i,className:"px-8 pb-8 space-y-5",children:[r&&ce.jsx("div",{className:"bg-red-50 text-red-600 p-3 rounded-xl text-xs font-semibold border border-red-100 flex items-center justify-center gap-2 animate-shake",children:r}),ce.jsxs("div",{className:"space-y-4",children:[ce.jsxs("div",{className:"group relative",children:[ce.jsx(fF,{className:"absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-600 transition-colors",size:20}),ce.jsx("input",{type:"text",placeholder:"Username",className:"w-full pl-12 pr-4 py-4 rounded-2xl border border-slate-200 bg-slate-50/50 focus:bg-white focus:ring-4 focus:ring-indigo-500/10 focus:border-indigo-500 outline-none transition-all font-medium placeholder:text-slate-400",onChange:o=>a({...n,username:o.target.value}),required:!0})]}),ce.jsxs("div",{className:"group relative",children:[ce.jsx(A5,{className:"absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-600 transition-colors",size:20}),ce.jsx("input",{type:"password",placeholder:"Password",className:"w-full pl-12 pr-4 py-4 rounded-2xl border border-slate-200 bg-slate-50/50 focus:bg-white focus:ring-4 focus:ring-indigo-500/10 focus:border-indigo-500 outline-none transition-all font-medium placeholder:text-slate-400",onChange:o=>a({...n,password:o.target.value}),required:!0})]})]}),ce.jsxs("button",{className:"w-full bg-slate-900 hover:bg-indigo-600 text-white py-4 rounded-2xl font-bold flex items-center justify-center gap-2 transition-all duration-300 hover:shadow-2xl hover:shadow-indigo-500/40 active:scale-[0.98]",children:["Masuk Sekarang ",ce.jsx(dhe,{size:20})]}),ce.jsx("div",{className:"pt-4 text-center",children:ce.jsxs("p",{className:"text-sm text-slate-500 font-medium",children:["Belum terdaftar?"," ",ce.jsx("button",{type:"button",onClick:t,className:"text-indigo-600 font-bold hover:text-indigo-700 underline underline-offset-4 decoration-2 decoration-indigo-200",children:"Buat Akun Baru"})]})})]})]}),ce.jsx("p",{className:"mt-8 text-center text-slate-400 text-xs font-medium",children:" 2026 AI Proctoring System. Terlindungi Enkripsi End-to-End."})]})})};var Ohe=Object.defineProperty,Fhe=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),mF=(e,t)=>{for(var n in t)Ohe(e,n,{get:t[n],enumerable:!0})},gF={};mF(gF,{Abs:()=>Wy,Acos:()=>of,Acosh:()=>lf,AdadeltaOptimizer:()=>MM,AdagradOptimizer:()=>LM,AdamOptimizer:()=>zM,AdamaxOptimizer:()=>BM,Add:()=>Xh,AddN:()=>uf,All:()=>Gy,Any:()=>Hy,ArgMax:()=>jy,ArgMin:()=>qy,Asin:()=>cf,Asinh:()=>hf,Atan:()=>df,Atan2:()=>ff,Atanh:()=>pf,AvgPool:()=>mf,AvgPool3D:()=>Ky,AvgPool3DGrad:()=>Uw,AvgPoolGrad:()=>Vw,BackendWasm:()=>OZ,BatchMatMul:()=>gf,BatchToSpaceND:()=>Xy,Bincount:()=>Yy,BitwiseAnd:()=>Qy,BroadcastArgs:()=>Ww,BroadcastTo:()=>P5,Callback:()=>DX,CallbackList:()=>NK,Cast:()=>yf,Ceil:()=>bf,ClipByValue:()=>Yh,Complex:()=>h2,ComplexAbs:()=>Gw,Concat:()=>Zy,Conv2D:()=>xf,Conv2DBackpropFilter:()=>d2,Conv2DBackpropInput:()=>vf,Conv3D:()=>wf,Conv3DBackpropFilterV2:()=>Jy,Conv3DBackpropInputV2:()=>eb,Cos:()=>Af,Cosh:()=>Sf,CropAndResize:()=>nb,Cumprod:()=>tb,Cumsum:()=>kf,CustomCallback:()=>TK,DataStorage:()=>l2,DenseBincount:()=>Hw,DepthToSpace:()=>ab,DepthwiseConv2dNative:()=>If,DepthwiseConv2dNativeBackpropFilter:()=>p2,DepthwiseConv2dNativeBackpropInput:()=>f2,Diag:()=>jw,Dilation2D:()=>Nf,Dilation2DBackpropFilter:()=>cy,Dilation2DBackpropInput:()=>uy,Draw:()=>m2,ENV:()=>wF,EarlyStopping:()=>OX,Einsum:()=>g2,Elu:()=>Tf,EluGrad:()=>rb,Environment:()=>z5,Equal:()=>sb,Erf:()=>Ef,Exp:()=>$f,ExpandDims:()=>ib,Expm1:()=>_f,FFT:()=>y2,Fill:()=>qw,FlipLeftRight:()=>ob,Floor:()=>Rf,FloorDiv:()=>Df,FromPixels:()=>YI,FusedBatchNorm:()=>Of,FusedConv2D:()=>Sp,FusedDepthwiseConv2D:()=>kp,GPGPUContext:()=>DI,GatherNd:()=>ub,GatherV2:()=>lb,GraphModel:()=>IL,Greater:()=>cb,GreaterEqual:()=>Ff,History:()=>CK,IFFT:()=>b2,Identity:()=>Mf,Imag:()=>x2,InputSpec:()=>Qa,IsFinite:()=>Lf,IsInf:()=>zf,IsNan:()=>Bf,KernelBackend:()=>Bw,LRN:()=>Wf,LRNGrad:()=>yb,LayerVariable:()=>bK,LayersModel:()=>Xu,LeakyRelu:()=>Pf,Less:()=>hb,LessEqual:()=>db,LinSpace:()=>pb,Log:()=>Vf,Log1p:()=>Uf,LogSoftmax:()=>U5,LogicalAnd:()=>fb,LogicalNot:()=>mb,LogicalOr:()=>gb,LogicalXor:()=>V5,LowerBound:()=>Nde,MathBackendCPU:()=>TL,MathBackendWebGL:()=>nz,MatrixBandPart:()=>Cde,Max:()=>Gf,MaxPool:()=>jf,MaxPool3D:()=>bb,MaxPool3DGrad:()=>Xw,MaxPoolGrad:()=>Kw,MaxPoolWithArgmax:()=>Yw,Maximum:()=>Hf,Mean:()=>qf,Min:()=>Kf,Minimum:()=>Xf,MirrorPad:()=>Yf,Mod:()=>Qf,MomentumOptimizer:()=>PM,Multinomial:()=>xb,Multiply:()=>Zf,Neg:()=>vb,NonMaxSuppressionV3:()=>Ab,NonMaxSuppressionV4:()=>Sb,NonMaxSuppressionV5:()=>kb,NotEqual:()=>wb,OP_SCOPE_SUFFIX:()=>NF,OneHot:()=>Jf,OnesLike:()=>Ib,Optimizer:()=>dc,OptimizerConstructors:()=>Q8,Pack:()=>Nb,PadV2:()=>em,Pool:()=>Tde,Pow:()=>tm,Prelu:()=>nm,Prod:()=>am,RMSPropOptimizer:()=>VM,RNN:()=>pc,RaggedGather:()=>v2,RaggedRange:()=>w2,RaggedTensorToTensor:()=>A2,Range:()=>Qw,Rank:()=>nD,Real:()=>S2,RealDiv:()=>Cf,Reciprocal:()=>rm,Reduction:()=>Ss,Relu:()=>sm,Relu6:()=>lm,Reshape:()=>Cb,ResizeBilinear:()=>om,ResizeBilinearGrad:()=>Eb,ResizeNearestNeighbor:()=>im,ResizeNearestNeighborGrad:()=>Tb,Reverse:()=>um,RotateWithOffset:()=>Gb,Round:()=>cm,Rsqrt:()=>hm,SGDOptimizer:()=>sC,ScatterNd:()=>$b,SearchSorted:()=>Rb,Select:()=>Db,Selu:()=>dm,Sequential:()=>bC,Sigmoid:()=>gm,Sign:()=>mm,Sin:()=>pm,Sinh:()=>fm,Slice:()=>Ob,Softmax:()=>vm,Softplus:()=>ym,SpaceToBatchND:()=>Fb,SparseFillEmptyRows:()=>Zw,SparseReshape:()=>Lb,SparseSegmentMean:()=>Jw,SparseSegmentSum:()=>e1,SparseToDense:()=>zb,SplitV:()=>Mb,Sqrt:()=>bm,Square:()=>t1,SquaredDifference:()=>wm,StaticRegexReplace:()=>n1,Step:()=>Zh,StridedSlice:()=>Bb,StringNGrams:()=>a1,StringSplit:()=>r1,StringToHashBucketFast:()=>s1,Sub:()=>Am,Sum:()=>xm,SymbolicTensor:()=>fl,Tan:()=>Sm,Tanh:()=>km,Tensor:()=>Bt,TensorBuffer:()=>Za,TensorScatterUpdate:()=>_b,Tile:()=>Qh,TopK:()=>Pb,Transform:()=>Vb,Transpose:()=>Ku,Unique:()=>i1,Unpack:()=>Ub,UnsortedSegmentSum:()=>o1,UpperBound:()=>Ede,Variable:()=>Ip,ZerosLike:()=>Wb,_FusedMatMul:()=>Ap,abs:()=>Ka,acos:()=>_F,acosh:()=>RF,add:()=>Re,addN:()=>gq,all:()=>T2,any:()=>rw,argMax:()=>Ep,argMin:()=>DF,asin:()=>OF,asinh:()=>FF,atan:()=>MF,atan2:()=>LF,atanh:()=>zF,avgPool:()=>uc,avgPool3d:()=>PF,backend:()=>CF,backend_util:()=>G,basicLSTMCell:()=>vq,batchNorm:()=>Im,batchNorm2d:()=>VF,batchNorm3d:()=>UF,batchNorm4d:()=>WF,batchToSpaceND:()=>f1,bincount:()=>GF,bitwiseAnd:()=>wq,booleanMaskAsync:()=>c8,broadcastArgs:()=>Aq,broadcastTo:()=>pp,broadcast_util:()=>Hb,browser:()=>C1,buffer:()=>Wt,callbacks:()=>kIe,cast:()=>He,ceil:()=>HF,clipByValue:()=>hs,clone:()=>jl,complex:()=>Ju,concat:()=>Un,concat1d:()=>jF,concat2d:()=>qF,concat3d:()=>KF,concat4d:()=>XF,constraints:()=>AK,conv1d:()=>E2,conv2d:()=>Ts,conv2dTranspose:()=>$2,conv3d:()=>QF,conv3dTranspose:()=>ZF,copyRegisteredKernels:()=>Dde,cos:()=>m1,cosh:()=>_2,cosineWindow:()=>eC,cumprod:()=>ow,cumsum:()=>R2,customGrad:()=>nu,data:()=>r7,denseBincount:()=>JI,deprecationWarn:()=>nq,depthToSpace:()=>JF,depthwiseConv2d:()=>Nm,deregisterOp:()=>CIe,device_util:()=>h1,diag:()=>kq,dilation2d:()=>eM,disableDeprecationWarnings:()=>upe,dispose:()=>Ft,disposeVariables:()=>cpe,div:()=>st,divNoNan:()=>tM,dot:()=>nM,dropout:()=>_M,einsum:()=>ep,elu:()=>jb,enableDebugMode:()=>lpe,enableProdMode:()=>ope,enclosingPowerOfTwo:()=>RM,engine:()=>_o,ensureShape:()=>Nq,env:()=>xe,equal:()=>Ei,erf:()=>D2,euclideanNorm:()=>sM,exp:()=>ds,expandDims:()=>Tr,expm1:()=>iM,eye:()=>O2,fft:()=>I1,fill:()=>Ni,findBackend:()=>gpe,findBackendFactory:()=>ype,floor:()=>Kb,floorDiv:()=>C2,forceHalfFloat:()=>TY,fused:()=>by,gather:()=>Xb,gatherND:()=>f8,gather_util:()=>GM,getBackend:()=>aq,getGradient:()=>eD,getKernel:()=>tw,getKernelsForBackend:()=>QI,getThreadsCount:()=>_5e,gpgpu_util:()=>sY,grad:()=>Xme,grads:()=>Yme,greater:()=>Fs,greaterEqual:()=>cc,ifft:()=>yy,imag:()=>g1,image:()=>Xi,inTopKAsync:()=>m8,initializers:()=>SK,input:()=>UK,io:()=>Kr,irfft:()=>q2,isFinite:()=>oM,isInf:()=>lM,isNaN:()=>uM,keep:()=>cr,kernel_impls:()=>pu,layers:()=>kK,leakyRelu:()=>y1,less:()=>py,lessEqual:()=>ed,linalg:()=>FM,linspace:()=>_q,loadGraphModel:()=>DNe,loadGraphModelSync:()=>ONe,loadLayersModel:()=>xSe,localResponseNormalization:()=>cM,log:()=>$i,log1p:()=>b1,logSigmoid:()=>hM,logSoftmax:()=>M2,logSumExp:()=>x1,logicalAnd:()=>zo,logicalNot:()=>v1,logicalOr:()=>L2,logicalXor:()=>dM,losses:()=>C8,lowerBound:()=>Dq,matMul:()=>Vt,math:()=>z8,max:()=>to,maxPool:()=>kr,maxPool3d:()=>pM,maxPoolWithArgmax:()=>Oq,maximum:()=>du,mean:()=>wa,memory:()=>uD,meshgrid:()=>Fq,metrics:()=>$X,min:()=>dy,minimum:()=>Ch,mirrorPad:()=>fM,mod:()=>mM,model:()=>ASe,models:()=>_X,moments:()=>w1,movingAverage:()=>h8,mul:()=>le,multiRNNCell:()=>Mq,multinomial:()=>Lq,neg:()=>sa,nextFrame:()=>HM,norm:()=>qb,notEqual:()=>Rp,oneHot:()=>fy,ones:()=>js,onesLike:()=>_i,op:()=>ie,outerProduct:()=>zq,pad:()=>wl,pad1d:()=>Bq,pad2d:()=>Pq,pad3d:()=>Vq,pad4d:()=>Uq,pool:()=>gM,pow:()=>tu,prelu:()=>S1,print:()=>$F,prod:()=>yM,profile:()=>hpe,raggedGather:()=>Wq,raggedRange:()=>Gq,raggedTensorToTensor:()=>Hq,rand:()=>jq,randomGamma:()=>Yq,randomNormal:()=>B2,randomStandardNormal:()=>Qq,randomUniform:()=>td,randomUniformInt:()=>Zq,range:()=>Dp,ready:()=>fpe,real:()=>my,reciprocal:()=>AM,registerBackend:()=>N2,registerCallbackConstructor:()=>kSe,registerGradient:()=>W5,registerKernel:()=>l1,registerOp:()=>NIe,regularizers:()=>RX,relu:()=>_n,relu6:()=>P2,removeBackend:()=>mpe,reshape:()=>pe,reverse:()=>io,reverse1d:()=>Jq,reverse2d:()=>e8,reverse3d:()=>t8,reverse4d:()=>n8,rfft:()=>N1,round:()=>V2,rsqrt:()=>U2,scalar:()=>xt,scatterND:()=>d8,scatter_util:()=>Y2,searchSorted:()=>z2,selu:()=>W2,separableConv2d:()=>Yb,sequential:()=>SSe,serialization:()=>Pe,setBackend:()=>ppe,setPlatform:()=>bpe,setThreadsCount:()=>$5e,setWasmPath:()=>T5e,setWasmPaths:()=>E5e,setWebGLContext:()=>E9,setdiff1dAsync:()=>a8,shared:()=>EL,sigmoid:()=>Mo,sign:()=>SM,signal:()=>N8,sin:()=>G2,sinh:()=>H2,slice:()=>en,slice1d:()=>k1,slice2d:()=>j2,slice3d:()=>Qb,slice4d:()=>gy,slice_util:()=>mr,softmax:()=>nd,softplus:()=>Cm,spaceToBatchND:()=>A1,sparse:()=>T8,sparseToDense:()=>p8,spectral:()=>I8,split:()=>Ks,sqrt:()=>Or,square:()=>Pn,squaredDifference:()=>K2,squeeze:()=>ad,stack:()=>Ja,step:()=>Tm,stridedSlice:()=>kM,string:()=>E8,sub:()=>nt,sum:()=>ut,sumOutType:()=>I2,tan:()=>IM,tanh:()=>Nh,tensor:()=>Cs,tensor1d:()=>Nn,tensor2d:()=>ql,tensor3d:()=>X2,tensor4d:()=>Th,tensor5d:()=>r8,tensor6d:()=>s8,tensorScatterUpdate:()=>o8,tensor_util:()=>il,test_util:()=>qq,tidy:()=>fe,tile:()=>Ii,time:()=>dpe,topk:()=>CM,train:()=>Xd,transpose:()=>Ut,truncatedNormal:()=>Z2,unique:()=>TM,unregisterGradient:()=>Rde,unregisterKernel:()=>_de,unsortedSegmentSum:()=>J2,unstack:()=>Ra,upcastType:()=>ro,upperBound:()=>l8,util:()=>F,valueAndGrad:()=>Qme,valueAndGrads:()=>Zme,variable:()=>EM,variableGrads:()=>Rq,version:()=>z5e,version_converter:()=>MNe,version_core:()=>A0e,version_cpu:()=>LCe,version_layers:()=>f3,version_wasm:()=>R5e,version_webgl:()=>NFe,webgl:()=>CFe,webgl_util:()=>T9,where:()=>Dr,whereAsync:()=>$M,zeros:()=>Aa,zerosLike:()=>un});var Mhe=Object.create,yF=Object.defineProperty,Lhe=Object.getOwnPropertyDescriptor,zhe=Object.getOwnPropertyNames,Bhe=Object.getPrototypeOf,Phe=Object.prototype.hasOwnProperty,ar=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Lt=(e,t)=>{for(var n in t)yF(e,n,{get:t[n],enumerable:!0})},Vhe=(e,t,n,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of zhe(t))!Phe.call(e,r)&&r!==n&&yF(e,r,{get:()=>t[r],enumerable:!(a=Lhe(t,r))||a.enumerable});return e},Kh=(e,t,n)=>(n=e!=null?Mhe(Bhe(e)):{},Vhe(!e||!e.__esModule?yF(n,"default",{value:e,enumerable:!0}):n,e)),Uhe=ar((e,t)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function a(_,P,U){this.low=_|0,this.high=P|0,this.unsigned=!!U}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0});function r(_){return(_&&_.__isLong__)===!0}a.isLong=r;var s={},i={};function o(_,P){var U,W,B;return P?(_>>>=0,(B=0<=_&&_<256)&&(W=i[_],W)?W:(U=u(_,(_|0)<0?-1:0,!0),B&&(i[_]=U),U)):(_|=0,(B=-128<=_&&_<128)&&(W=s[_],W)?W:(U=u(_,_<0?-1:0,!1),B&&(s[_]=U),U))}a.fromInt=o;function l(_,P){if(isNaN(_))return P?k:S;if(P){if(_<0)return k;if(_>=b)return D}else{if(_<=-v)return O;if(_+1>=v)return R}return _<0?l(-_,P).neg():u(_%y|0,_/y|0,P)}a.fromNumber=l;function u(_,P,U){return new a(_,P,U)}a.fromBits=u;var c=Math.pow;function h(_,P,U){if(_.length===0)throw Error("empty string");if(_==="NaN"||_==="Infinity"||_==="+Infinity"||_==="-Infinity")return S;if(typeof P=="number"?(U=P,P=!1):P=!!P,U=U||10,U<2||36<U)throw RangeError("radix");var W;if((W=_.indexOf("-"))>0)throw Error("interior hyphen");if(W===0)return h(_.substring(1),P,U).neg();for(var B=l(c(U,8)),H=S,j=0;j<_.length;j+=8){var Z=Math.min(8,_.length-j),te=parseInt(_.substring(j,j+Z),U);if(Z<8){var V=l(c(U,Z));H=H.mul(V).add(l(te))}else H=H.mul(B),H=H.add(l(te))}return H.unsigned=P,H}a.fromString=h;function p(_,P){return typeof _=="number"?l(_,P):typeof _=="string"?h(_,P):u(_.low,_.high,typeof P=="boolean"?P:_.unsigned)}a.fromValue=p;var m=65536,g=1<<24,y=m*m,b=y*y,v=b/2,w=o(g),S=o(0);a.ZERO=S;var k=o(0,!0);a.UZERO=k;var I=o(1);a.ONE=I;var T=o(1,!0);a.UONE=T;var E=o(-1);a.NEG_ONE=E;var R=u(-1,2147483647,!1);a.MAX_VALUE=R;var D=u(-1,-1,!0);a.MAX_UNSIGNED_VALUE=D;var O=u(0,-2147483648,!1);a.MIN_VALUE=O;var $=a.prototype;$.toInt=function(){return this.unsigned?this.low>>>0:this.low},$.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},$.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(O)){var P=l(_),U=this.div(P),W=U.mul(P).sub(this);return U.toString(_)+W.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var B=l(c(_,6),this.unsigned),H=this,j="";;){var Z=H.div(B),te=H.sub(Z.mul(B)).toInt()>>>0,V=te.toString(_);if(H=Z,H.isZero())return V+j;for(;V.length<6;)V="0"+V;j=""+V+j}},$.getHighBits=function(){return this.high},$.getHighBitsUnsigned=function(){return this.high>>>0},$.getLowBits=function(){return this.low},$.getLowBitsUnsigned=function(){return this.low>>>0},$.getNumBitsAbs=function(){if(this.isNegative())return this.eq(O)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,P=31;P>0&&!(_&1<<P);P--);return this.high!=0?P+33:P+1},$.isZero=function(){return this.high===0&&this.low===0},$.eqz=$.isZero,$.isNegative=function(){return!this.unsigned&&this.high<0},$.isPositive=function(){return this.unsigned||this.high>=0},$.isOdd=function(){return(this.low&1)===1},$.isEven=function(){return(this.low&1)===0},$.equals=function(_){return r(_)||(_=p(_)),this.unsigned!==_.unsigned&&this.high>>>31===1&&_.high>>>31===1?!1:this.high===_.high&&this.low===_.low},$.eq=$.equals,$.notEquals=function(_){return!this.eq(_)},$.neq=$.notEquals,$.ne=$.notEquals,$.lessThan=function(_){return this.comp(_)<0},$.lt=$.lessThan,$.lessThanOrEqual=function(_){return this.comp(_)<=0},$.lte=$.lessThanOrEqual,$.le=$.lessThanOrEqual,$.greaterThan=function(_){return this.comp(_)>0},$.gt=$.greaterThan,$.greaterThanOrEqual=function(_){return this.comp(_)>=0},$.gte=$.greaterThanOrEqual,$.ge=$.greaterThanOrEqual,$.compare=function(_){if(r(_)||(_=p(_)),this.eq(_))return 0;var P=this.isNegative(),U=_.isNegative();return P&&!U?-1:!P&&U?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},$.comp=$.compare,$.negate=function(){return!this.unsigned&&this.eq(O)?O:this.not().add(I)},$.neg=$.negate,$.add=function(_){r(_)||(_=p(_));var P=this.high>>>16,U=this.high&65535,W=this.low>>>16,B=this.low&65535,H=_.high>>>16,j=_.high&65535,Z=_.low>>>16,te=_.low&65535,V=0,Q=0,ee=0,ae=0;return ae+=B+te,ee+=ae>>>16,ae&=65535,ee+=W+Z,Q+=ee>>>16,ee&=65535,Q+=U+j,V+=Q>>>16,Q&=65535,V+=P+H,V&=65535,u(ee<<16|ae,V<<16|Q,this.unsigned)},$.subtract=function(_){return r(_)||(_=p(_)),this.add(_.neg())},$.sub=$.subtract,$.multiply=function(_){if(this.isZero())return S;if(r(_)||(_=p(_)),n){var P=n.mul(this.low,this.high,_.low,_.high);return u(P,n.get_high(),this.unsigned)}if(_.isZero())return S;if(this.eq(O))return _.isOdd()?O:S;if(_.eq(O))return this.isOdd()?O:S;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(w)&&_.lt(w))return l(this.toNumber()*_.toNumber(),this.unsigned);var U=this.high>>>16,W=this.high&65535,B=this.low>>>16,H=this.low&65535,j=_.high>>>16,Z=_.high&65535,te=_.low>>>16,V=_.low&65535,Q=0,ee=0,ae=0,de=0;return de+=H*V,ae+=de>>>16,de&=65535,ae+=B*V,ee+=ae>>>16,ae&=65535,ae+=H*te,ee+=ae>>>16,ae&=65535,ee+=W*V,Q+=ee>>>16,ee&=65535,ee+=B*te,Q+=ee>>>16,ee&=65535,ee+=H*Z,Q+=ee>>>16,ee&=65535,Q+=U*V+W*te+B*Z+H*j,Q&=65535,u(ae<<16|de,Q<<16|ee,this.unsigned)},$.mul=$.multiply,$.divide=function(_){if(r(_)||(_=p(_)),_.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var P=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high);return u(P,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?k:S;var U,W,B;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return k;if(_.gt(this.shru(1)))return T;B=k}else{if(this.eq(O)){if(_.eq(I)||_.eq(E))return O;if(_.eq(O))return I;var H=this.shr(1);return U=H.div(_).shl(1),U.eq(S)?_.isNegative()?I:E:(W=this.sub(_.mul(U)),B=U.add(W.div(_)),B)}else if(_.eq(O))return this.unsigned?k:S;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();B=S}for(W=this;W.gte(_);){U=Math.max(1,Math.floor(W.toNumber()/_.toNumber()));for(var j=Math.ceil(Math.log(U)/Math.LN2),Z=j<=48?1:c(2,j-48),te=l(U),V=te.mul(_);V.isNegative()||V.gt(W);)U-=Z,te=l(U,this.unsigned),V=te.mul(_);te.isZero()&&(te=I),B=B.add(te),W=W.sub(V)}return B},$.div=$.divide,$.modulo=function(_){if(r(_)||(_=p(_)),n){var P=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high);return u(P,n.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},$.mod=$.modulo,$.rem=$.modulo,$.not=function(){return u(~this.low,~this.high,this.unsigned)},$.and=function(_){return r(_)||(_=p(_)),u(this.low&_.low,this.high&_.high,this.unsigned)},$.or=function(_){return r(_)||(_=p(_)),u(this.low|_.low,this.high|_.high,this.unsigned)},$.xor=function(_){return r(_)||(_=p(_)),u(this.low^_.low,this.high^_.high,this.unsigned)},$.shiftLeft=function(_){return r(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?u(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):u(0,this.low<<_-32,this.unsigned)},$.shl=$.shiftLeft,$.shiftRight=function(_){return r(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?u(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):u(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},$.shr=$.shiftRight,$.shiftRightUnsigned=function(_){if(r(_)&&(_=_.toInt()),_&=63,_===0)return this;var P=this.high;if(_<32){var U=this.low;return u(U>>>_|P<<32-_,P>>>_,this.unsigned)}else return _===32?u(P,0,this.unsigned):u(P>>>_-32,0,this.unsigned)},$.shru=$.shiftRightUnsigned,$.shr_u=$.shiftRightUnsigned,$.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},$.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},$.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},$.toBytesLE=function(){var _=this.high,P=this.low;return[P&255,P>>>8&255,P>>>16&255,P>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},$.toBytesBE=function(){var _=this.high,P=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,P>>>24,P>>>16&255,P>>>8&255,P&255]},a.fromBytes=function(_,P,U){return U?a.fromBytesLE(_,P):a.fromBytesBE(_,P)},a.fromBytesLE=function(_,P){return new a(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,P)},a.fromBytesBE=function(_,P){return new a(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],P)}}),Whe=ar(()=>{}),Ghe=ar(()=>{}),Hhe=ar((e,t)=>{(function(n,a,r){function s(u){var c=this,h=l();c.next=function(){var p=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=p-(c.c=p|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(u),c.s0<0&&(c.s0+=1),c.s1-=h(u),c.s1<0&&(c.s1+=1),c.s2-=h(u),c.s2<0&&(c.s2+=1),h=null}function i(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var h=new s(u),p=c&&c.state,m=h.next;return m.int32=function(){return h.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,h),m.state=function(){return i(h,{})}),m}function l(){var u=4022871197,c=function(h){h=String(h);for(var p=0;p<h.length;p++){u+=h.charCodeAt(p);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),jhe=ar((e,t)=>{(function(n,a,r){function s(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var p=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^p^p>>>8},l===(l|0)?u.x=l:c+=l;for(var h=0;h<c.length+64;h++)u.x^=c.charCodeAt(h)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var c=new s(l),h=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(typeof h=="object"&&i(h,c),p.state=function(){return i(c,{})}),p}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),qhe=ar((e,t)=>{(function(n,a,r){function s(l){var u=this,c="";u.next=function(){var p=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(p^p<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:c+=l;for(var h=0;h<c.length+64;h++)u.x^=c.charCodeAt(h)|0,h==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var c=new s(l),h=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(typeof h=="object"&&i(h,c),p.state=function(){return i(c,{})}),p}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Khe=ar((e,t)=>{(function(n,a,r){function s(l){var u=this;u.next=function(){var h=u.x,p=u.i,m,g;return m=h[p],m^=m>>>7,g=m^m<<24,m=h[p+1&7],g^=m^m>>>10,m=h[p+3&7],g^=m^m>>>3,m=h[p+4&7],g^=m^m<<7,m=h[p+7&7],m=m^m<<13,g^=m^m<<9,h[p]=g,u.i=p+1&7,g};function c(h,p){var m,g=[];if(p===(p|0))g[0]=p;else for(p=""+p,m=0;m<p.length;++m)g[m&7]=g[m&7]<<15^p.charCodeAt(m)+g[m+1&7]<<13;for(;g.length<8;)g.push(0);for(m=0;m<8&&g[m]===0;++m);for(m==8?g[7]=-1:g[m],h.x=g,h.i=0,m=256;m>0;--m)h.next()}c(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var c=new s(l),h=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(h.x&&i(h,c),p.state=function(){return i(c,{})}),p}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Xhe=ar((e,t)=>{(function(n,a,r){function s(l){var u=this;u.next=function(){var h=u.w,p=u.X,m=u.i,g,y;return u.w=h=h+1640531527|0,y=p[m+34&127],g=p[m=m+1&127],y^=y<<13,g^=g<<17,y^=y>>>15,g^=g>>>12,y=p[m]=y^g,u.i=m,y+(h^h>>>16)|0};function c(h,p){var m,g,y,b,v,w=[],S=128;for(p===(p|0)?(g=p,p=null):(p=p+"\0",g=0,S=Math.max(S,p.length)),y=0,b=-32;b<S;++b)p&&(g^=p.charCodeAt((b+32)%p.length)),b===0&&(v=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,b>=0&&(v=v+1640531527|0,m=w[b&127]^=g+v,y=m==0?y+1:0);for(y>=128&&(w[(p&&p.length||0)&127]=-1),y=127,b=512;b>0;--b)g=w[y+34&127],m=w[y=y+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,w[y]=g^m;h.w=v,h.X=w,h.i=y}c(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var c=new s(l),h=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(h.X&&i(h,c),p.state=function(){return i(c,{})}),p}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Yhe=ar((e,t)=>{(function(n,a,r){function s(l){var u=this,c="";u.next=function(){var p=u.b,m=u.c,g=u.d,y=u.a;return p=p<<25^p>>>7^m,m=m-g|0,g=g<<24^g>>>8^y,y=y-p|0,u.b=p=p<<20^p>>>12^m,u.c=m=m-g|0,u.d=g<<16^m>>>16^y,u.a=y-p|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):c+=l;for(var h=0;h<c.length+20;h++)u.b^=c.charCodeAt(h)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var c=new s(l),h=u&&u.state,p=function(){return(c.next()>>>0)/4294967296};return p.double=function(){do var m=c.next()>>>11,g=(c.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=c.next,p.quick=p,h&&(typeof h=="object"&&i(h,c),p.state=function(){return i(c,{})}),p}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Qhe=ar(()=>{}),Zhe=ar((e,t)=>{(function(n,a,r){var s=256,i=6,o=52,l="random",u=r.pow(s,i),c=r.pow(2,o),h=c*2,p=s-1,m;function g(I,T,E){var R=[];T=T==!0?{entropy:!0}:T||{};var D=w(v(T.entropy?[I,k(a)]:I??S(),3),R),O=new y(R),$=function(){for(var _=O.g(i),P=u,U=0;_<c;)_=(_+U)*s,P*=s,U=O.g(1);for(;_>=h;)_/=2,P/=2,U>>>=1;return(_+U)/P};return $.int32=function(){return O.g(4)|0},$.quick=function(){return O.g(4)/4294967296},$.double=$,w(k(O.S),a),(T.pass||E||function(_,P,U,W){return W&&(W.S&&b(W,O),_.state=function(){return b(O,{})}),U?(r[l]=_,P):_})($,D,"global"in T?T.global:this==r,T.state)}function y(I){var T,E=I.length,R=this,D=0,O=R.i=R.j=0,$=R.S=[];for(E||(I=[E++]);D<s;)$[D]=D++;for(D=0;D<s;D++)$[D]=$[O=p&O+I[D%E]+(T=$[D])],$[O]=T;(R.g=function(_){for(var P,U=0,W=R.i,B=R.j,H=R.S;_--;)P=H[W=p&W+1],U=U*s+H[p&(H[W]=H[B=p&B+P])+(H[B]=P)];return R.i=W,R.j=B,U})(s)}function b(I,T){return T.i=I.i,T.j=I.j,T.S=I.S.slice(),T}function v(I,T){var E=[],R=typeof I,D;if(T&&R=="object")for(D in I)try{E.push(v(I[D],T-1))}catch{}return E.length?E:R=="string"?I:I+"\0"}function w(I,T){for(var E=I+"",R,D=0;D<E.length;)T[p&D]=p&(R^=T[p&D]*19)+E.charCodeAt(D++);return k(T)}function S(){try{var I;return m&&(I=m.randomBytes)?I=I(s):(I=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(I)),k(I)}catch{var T=n.navigator,E=T&&T.plugins;return[+new Date,n,E,n.screen,k(a)]}}function k(I){return String.fromCharCode.apply(0,I)}if(w(r.random(),a),typeof t=="object"&&t.exports){t.exports=g;try{m=Qhe()}catch{}}else typeof define=="function"&&define.amd?define(function(){return g}):r["seed"+l]=g})(typeof self<"u"?self:e,[],Math)}),o2=ar((e,t)=>{var n=Hhe(),a=jhe(),r=qhe(),s=Khe(),i=Xhe(),o=Yhe(),l=Zhe();l.alea=n,l.xor128=a,l.xorwow=r,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),N5=ar(()=>{}),bF=ar(()=>{}),C5=ar(()=>{}),Jhe=ar(()=>{}),ede=ar(()=>{}),tde=ar(()=>{}),nde=ar((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};function s(){return j.buffer!=$e&&ot(j.buffer),Le}function i(){return j.buffer!=$e&&ot(j.buffer),Ge}function o(){return j.buffer!=$e&&ot(j.buffer),Ke}function l(){return j.buffer!=$e&&ot(j.buffer),at}function u(){return j.buffer!=$e&&ot(j.buffer),vt}var c=typeof r<"u"?r:{},h,p;c.ready=new Promise(function(ne,we){h=ne,p=we});var m;typeof process<"u"&&process.listeners&&(m={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var g=Object.assign({},c),y=(ne,we)=>{throw we},b=typeof window=="object",v=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",S=c.ENVIRONMENT_IS_PTHREAD||!1,k="";function I(ne){return c.locateFile?c.locateFile(ne,k):k+ne}var T,E,R;function D(ne){ne instanceof oi||W("exiting due to exception: "+ne)}if(w){var O=bF(),$=C5();v?k=$.dirname(k)+"/":k=__dirname+"/",T=(we,qe)=>(we=ba(we)?new URL(we):$.normalize(we),O.readFileSync(we,qe?void 0:"utf8")),R=we=>{var qe=T(we,!0);return qe.buffer||(qe=new Uint8Array(qe)),qe},E=(we,qe,Nt)=>{we=ba(we)?new URL(we):$.normalize(we),O.readFile(we,function(Rt,_t){Rt?Nt(Rt):qe(_t.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(we){if(!(we instanceof oi))throw we}),process.on("unhandledRejection",function(we){throw we}),y=(we,qe)=>{if(Dt())throw process.exitCode=we,qe;D(qe),process.exit(we)},c.inspect=function(){return"[Emscripten Module object]"};let ne;try{ne=Jhe()}catch(we){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),we}global.Worker=ne.Worker}else(b||v)&&(v?k=self.location.href:typeof document<"u"&&document.currentScript&&(k=document.currentScript.src),typeof a<"u"&&a&&(k=a),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",w||(T=ne=>{var we=new XMLHttpRequest;return we.open("GET",ne,!1),we.send(null),we.responseText},v&&(R=ne=>{var we=new XMLHttpRequest;return we.open("GET",ne,!1),we.responseType="arraybuffer",we.send(null),new Uint8Array(we.response)}),E=(ne,we,qe)=>{var Nt=new XMLHttpRequest;Nt.open("GET",ne,!0),Nt.responseType="arraybuffer",Nt.onload=()=>{if(Nt.status==200||Nt.status==0&&Nt.response){we(Nt.response);return}qe()},Nt.onerror=qe,Nt.send(null)}));w&&typeof performance>"u"&&(global.performance=ede().performance);var _=console.log.bind(console),P=console.warn.bind(console);w&&(_=ne=>O.writeSync(1,ne+`
`),P=ne=>O.writeSync(2,ne+`
`));var U=c.print||_,W=c.printErr||P;Object.assign(c,g),g=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(y=c.quit);var B;c.wasmBinary&&(B=c.wasmBinary);var H=c.noExitRuntime||!0;typeof WebAssembly!="object"&&Bs("no native wasm support detected");var j,Z,te=!1,V;function Q(ne,we){ne||Bs(we)}var ee=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ae(ne,we,qe){we>>>=0;for(var Nt=we+qe,Rt=we;ne[Rt]&&!(Rt>=Nt);)++Rt;if(Rt-we>16&&ne.buffer&&ee)return ee.decode(ne.buffer instanceof SharedArrayBuffer?ne.slice(we,Rt):ne.subarray(we,Rt));for(var _t="";we<Rt;){var Qe=ne[we++];if(!(Qe&128)){_t+=String.fromCharCode(Qe);continue}var yt=ne[we++]&63;if((Qe&224)==192){_t+=String.fromCharCode((Qe&31)<<6|yt);continue}var Tn=ne[we++]&63;if((Qe&240)==224?Qe=(Qe&15)<<12|yt<<6|Tn:Qe=(Qe&7)<<18|yt<<12|Tn<<6|ne[we++]&63,Qe<65536)_t+=String.fromCharCode(Qe);else{var Oa=Qe-65536;_t+=String.fromCharCode(55296|Oa>>10,56320|Oa&1023)}}return _t}function de(ne,we){return ne>>>=0,ne?ae(i(),ne,we):""}function ke(ne,we,qe,Nt){if(qe>>>=0,!(Nt>0))return 0;for(var Rt=qe,_t=qe+Nt-1,Qe=0;Qe<ne.length;++Qe){var yt=ne.charCodeAt(Qe);if(yt>=55296&&yt<=57343){var Tn=ne.charCodeAt(++Qe);yt=65536+((yt&1023)<<10)|Tn&1023}if(yt<=127){if(qe>=_t)break;we[qe++>>>0]=yt}else if(yt<=2047){if(qe+1>=_t)break;we[qe++>>>0]=192|yt>>6,we[qe++>>>0]=128|yt&63}else if(yt<=65535){if(qe+2>=_t)break;we[qe++>>>0]=224|yt>>12,we[qe++>>>0]=128|yt>>6&63,we[qe++>>>0]=128|yt&63}else{if(qe+3>=_t)break;we[qe++>>>0]=240|yt>>18,we[qe++>>>0]=128|yt>>12&63,we[qe++>>>0]=128|yt>>6&63,we[qe++>>>0]=128|yt&63}}return we[qe>>>0]=0,qe-Rt}function Te(ne,we,qe){return ke(ne,i(),we,qe)}var $e,Le,Ge,Ke,at,vt;S&&($e=c.buffer);function ot(ne){$e=ne,c.HEAP8=Le=new Int8Array(ne),c.HEAP16=new Int16Array(ne),c.HEAP32=Ke=new Int32Array(ne),c.HEAPU8=Ge=new Uint8Array(ne),c.HEAPU16=new Uint16Array(ne),c.HEAPU32=at=new Uint32Array(ne),c.HEAPF32=new Float32Array(ne),c.HEAPF64=vt=new Float64Array(ne)}var lt=c.INITIAL_MEMORY||16777216;if(S)j=c.wasmMemory,$e=c.buffer;else if(c.wasmMemory)j=c.wasmMemory;else if(j=new WebAssembly.Memory({initial:lt/65536,maximum:65536,shared:!0}),!(j.buffer instanceof SharedArrayBuffer))throw W("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&W("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");j&&($e=j.buffer),lt=$e.byteLength,ot($e);var tt,wt=[],It=[],jn=[];function Dt(){return H}function qn(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)nn(c.preRun.shift());Mn(wt)}function yn(){!S&&Mn(It)}function ca(){if(!S){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)ea(c.postRun.shift());Mn(jn)}}function nn(ne){wt.unshift(ne)}function ua(ne){It.unshift(ne)}function ea(ne){jn.unshift(ne)}var Cn=0,ta=null;function ys(ne){Cn++,c.monitorRunDependencies&&c.monitorRunDependencies(Cn)}function po(ne){if(Cn--,c.monitorRunDependencies&&c.monitorRunDependencies(Cn),Cn==0&&ta){var we=ta;ta=null,we()}}function Bs(ne){c.onAbort&&c.onAbort(ne),ne="Aborted("+ne+")",W(ne),te=!0,V=1,ne+=". Build with -sASSERTIONS for more info.";var we=new WebAssembly.RuntimeError(ne);throw p(we),we}var yu="data:application/octet-stream;base64,";function Ha(ne){return ne.startsWith(yu)}function ba(ne){return ne.startsWith("file://")}var Fn;Fn="tfjs-backend-wasm-threaded-simd.wasm",Ha(Fn)||(Fn=I(Fn));function Vr(ne){try{if(ne==Fn&&B)return new Uint8Array(B);if(R)return R(ne);throw"both async and sync fetching of the wasm failed"}catch(we){Bs(we)}}function Qm(){if(!B&&(b||v)){if(typeof fetch=="function"&&!ba(Fn))return fetch(Fn,{credentials:"same-origin"}).then(function(ne){if(!ne.ok)throw"failed to load wasm binary file at '"+Fn+"'";return ne.arrayBuffer()}).catch(function(){return Vr(Fn)});if(E)return new Promise(function(ne,we){E(Fn,function(qe){ne(new Uint8Array(qe))},we)})}return Promise.resolve().then(function(){return Vr(Fn)})}function Zm(){var ne={env:C0,wasi_snapshot_preview1:C0};function we(Qe,yt){var Tn=Qe.exports;if(c.asm=Tn,mo(c.asm._emscripten_tls_init),tt=c.asm.__indirect_function_table,ua(c.asm.__wasm_call_ctors),Z=yt,!S){var Oa=Ye.unusedWorkers.length;Ye.unusedWorkers.forEach(function(Bi){Ye.loadWasmModuleToWorker(Bi,function(){--Oa||po()})})}}S||ys();function qe(Qe){we(Qe.instance,Qe.module)}function Nt(Qe){return Qm().then(function(yt){return WebAssembly.instantiate(yt,ne)}).then(function(yt){return yt}).then(Qe,function(yt){W("failed to asynchronously prepare wasm: "+yt),Bs(yt)})}function Rt(){return!B&&typeof WebAssembly.instantiateStreaming=="function"&&!Ha(Fn)&&!ba(Fn)&&!w&&typeof fetch=="function"?fetch(Fn,{credentials:"same-origin"}).then(function(Qe){var yt=WebAssembly.instantiateStreaming(Qe,ne);return yt.then(qe,function(Tn){return W("wasm streaming compile failed: "+Tn),W("falling back to ArrayBuffer instantiation"),Nt(qe)})}):Nt(qe)}if(c.instantiateWasm)try{var _t=c.instantiateWasm(ne,we);return _t}catch(Qe){W("Module.instantiateWasm callback failed with error: "+Qe),p(Qe)}return Rt().catch(p),{}}var Jm={};function oi(ne){this.name="ExitStatus",this.message="Program terminated with exit("+ne+")",this.status=ne}function jo(ne){var we=Ye.pthreads[ne];delete Ye.pthreads[ne],we.terminate(),Cl(ne),Ye.runningWorkers.splice(Ye.runningWorkers.indexOf(we),1),we.pthread_ptr=0}function bu(ne){var we=Ye.pthreads[ne];we.postMessage({cmd:"cancel"})}function Ps(ne){var we=Ye.pthreads[ne];Q(we),Ye.returnWorkerToPool(we)}function fo(ne){var we=Ye.getNewWorker();if(!we)return 6;Ye.runningWorkers.push(we),Ye.pthreads[ne.pthread_ptr]=we,we.pthread_ptr=ne.pthread_ptr;var qe={cmd:"run",start_routine:ne.startRoutine,arg:ne.arg,pthread_ptr:ne.pthread_ptr};return we.runPthread=()=>{w&&we.ref(),we.postMessage(qe,ne.transferList),delete we.runPthread},we.loaded&&we.runPthread(),0}function Nl(ne){if(S)return Cc(1,1,ne);V=ne,Dt()||(Ye.terminateAllThreads(),c.onExit&&c.onExit(ne),te=!0),y(ne,new oi(ne))}function Me(ne,we){if(V=ne,!we&&S)throw Pt(ne),"unwind";Nl(ne)}var je=Me;function At(ne){if(ne instanceof oi||ne=="unwind")return V;y(1,ne)}var Ye={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){S?Ye.initWorker():Ye.initMainThread()},initMainThread:function(){for(var ne=8;ne--;)Ye.allocateUnusedWorker()},initWorker:function(){H=!1},setExitStatus:function(ne){V=ne},terminateAllThreads:function(){for(var ne of Object.values(Ye.pthreads))Ye.returnWorkerToPool(ne);for(var ne of Ye.unusedWorkers)ne.terminate();Ye.unusedWorkers=[]},returnWorkerToPool:function(ne){var we=ne.pthread_ptr;delete Ye.pthreads[we],Ye.unusedWorkers.push(ne),Ye.runningWorkers.splice(Ye.runningWorkers.indexOf(ne),1),ne.pthread_ptr=0,w&&ne.unref(),Cl(we)},receiveObjectTransfer:function(ne){},threadInitTLS:function(){Ye.tlsInitFunctions.forEach(ne=>ne())},loadWasmModuleToWorker:function(ne,we){ne.onmessage=_t=>{var Qe=_t.data,yt=Qe.cmd;if(ne.pthread_ptr&&(Ye.currentProxiedOperationCallerThread=ne.pthread_ptr),Qe.targetThread&&Qe.targetThread!=Tc()){var Tn=Ye.pthreads[Qe.targetThread];Tn?Tn.postMessage(Qe,Qe.transferList):W('Internal error! Worker sent a message "'+yt+'" to target pthread '+Qe.targetThread+", but that thread no longer exists!"),Ye.currentProxiedOperationCallerThread=void 0;return}yt==="processProxyingQueue"?S0(Qe.queue):yt==="spawnThread"?fo(Qe):yt==="cleanupThread"?Ps(Qe.thread):yt==="killThread"?jo(Qe.thread):yt==="cancelThread"?bu(Qe.thread):yt==="loaded"?(ne.loaded=!0,w&&ne.unref(),we&&we(ne),ne.runPthread&&ne.runPthread()):yt==="print"?U("Thread "+Qe.threadId+": "+Qe.text):yt==="printErr"?W("Thread "+Qe.threadId+": "+Qe.text):yt==="alert"?alert("Thread "+Qe.threadId+": "+Qe.text):Qe.target==="setimmediate"?ne.postMessage(Qe):yt==="callHandler"?c[Qe.handler](...Qe.args):yt&&W("worker sent an unknown command "+yt),Ye.currentProxiedOperationCallerThread=void 0},ne.onerror=_t=>{var Qe="worker sent an error!";throw W(Qe+" "+_t.filename+":"+_t.lineno+": "+_t.message),_t},w&&(ne.on("message",function(_t){ne.onmessage({data:_t})}),ne.on("error",function(_t){ne.onerror(_t)}),ne.on("detachedExit",function(){}));var qe=[],Nt=["onExit","onAbort","print","printErr"];for(var Rt of Nt)c.hasOwnProperty(Rt)&&qe.push(Rt);ne.postMessage({cmd:"load",handlers:qe,urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:j,wasmModule:Z})},allocateUnusedWorker:function(){var ne,we=I("tfjs-backend-wasm-threaded-simd.worker.js");ne=new Worker(we),Ye.unusedWorkers.push(ne)},getNewWorker:function(){return Ye.unusedWorkers.length==0&&(Ye.allocateUnusedWorker(),Ye.loadWasmModuleToWorker(Ye.unusedWorkers[0])),Ye.unusedWorkers.pop()}};c.PThread=Ye;function Mn(ne){for(;ne.length>0;)ne.shift()(c)}function Kn(){var ne=Tc(),we=o()[ne+52>>>2],qe=o()[ne+56>>>2],Nt=we-qe;$0(we,Nt),Ec(we)}c.establishStackSpace=Kn;function Pt(ne){if(S)return Cc(2,0,ne);try{je(ne)}catch(we){At(we)}}var Ot=[];function ha(ne){var we=Ot[ne];return we||(ne>=Ot.length&&(Ot.length=ne+1),Ot[ne]=we=tt.get(ne)),we}function as(ne,we){var qe=ha(ne)(we);Dt()?Ye.setExitStatus(qe):FS(qe)}c.invokeEntryPoint=as;function mo(ne){Ye.tlsInitFunctions.push(ne)}function Ad(ne){wu(ne,!v,1,!b),Ye.threadInitTLS()}function li(ne){S?postMessage({cmd:"cleanupThread",thread:ne}):Ps(ne)}function Da(ne,we,qe,Nt){return S?Cc(3,1,ne,we,qe,Nt):Sn(ne,we,qe,Nt)}function Sn(ne,we,qe,Nt){if(typeof SharedArrayBuffer>"u")return W("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Rt=[],_t=0;if(S&&(Rt.length===0||_t))return Da(ne,we,qe,Nt);var Qe={startRoutine:qe,pthread_ptr:ne,arg:Nt,transferList:Rt};return S?(Qe.cmd="spawnThread",postMessage(Qe,Rt),0):fo(Qe)}function Vs(){return 65536}var kc=!0;function QE(){return kc}function S0(ne){Atomics.store(o(),ne>>2,1),Tc()&&E0(ne),Atomics.compareExchange(o(),ne>>2,1,0)}c.executeNotifiedProxyingQueue=S0;function _S(ne,we,qe,Nt){if(ne==we)setTimeout(()=>S0(Nt));else if(S)postMessage({targetThread:ne,cmd:"processProxyingQueue",queue:Nt});else{var Rt=Ye.pthreads[ne];if(!Rt)return;Rt.postMessage({cmd:"processProxyingQueue",queue:Nt})}return 1}function Sd(ne,we,qe){return-1}function k0(){Bs("")}function go(ne){go.shown||(go.shown={}),go.shown[ne]||(go.shown[ne]=1,w&&(ne="warning: "+ne),W(ne))}function Ic(){w||v||go("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function kd(){return Date.now()}function xu(){return 4294901760}function sr(){return xu()}var eg;w?eg=()=>{var ne=process.hrtime();return ne[0]*1e3+ne[1]/1e6}:eg=()=>performance.timeOrigin+performance.now();function RS(ne,we,qe){i().copyWithin(ne>>>0,we>>>0,we+qe>>>0)}function vu(){return w?tde().cpus().length:navigator.hardwareConcurrency}function Nc(ne){var we=ig(),qe=ne();return Ec(we),qe}function Cc(ne,we){var qe=arguments.length-2,Nt=arguments;return Nc(()=>{for(var Rt=qe,_t=og(Rt*8),Qe=_t>>3,yt=0;yt<qe;yt++){var Tn=Nt[2+yt];u()[Qe+yt>>>0]=Tn}return T0(ne,Rt,_t,we)})}var tg=[];function DS(ne,we,qe){tg.length=we;for(var Nt=qe>>3,Rt=0;Rt<we;Rt++)tg[Rt]=u()[Nt+Rt>>>0];var _t=ne<0,Qe=_t?Jm[-ne-1]:N0[ne];return Qe.apply(null,tg)}function ZE(ne){try{return j.grow(ne-$e.byteLength+65535>>>16),ot(j.buffer),1}catch{}}function ng(ne){var we=i().length;if(ne=ne>>>0,ne<=we)return!1;var qe=xu();if(ne>qe)return!1;let Nt=(Tn,Oa)=>Tn+(Oa-Tn%Oa)%Oa;for(var Rt=1;Rt<=4;Rt*=2){var _t=we*(1+.2/Rt);_t=Math.min(_t,ne+100663296);var Qe=Math.min(qe,Nt(Math.max(ne,_t),65536)),yt=ZE(Qe);if(yt)return!0}return!1}function ag(){throw"unwind"}function yo(ne){return S?Cc(4,1,ne):52}function Us(ne,we,qe,Nt,Rt){return S?Cc(5,1,ne,we,qe,Nt,Rt):70}var OS=[null,[],[]];function JE(ne,we){var qe=OS[ne];we===0||we===10?((ne===1?U:W)(ae(qe,0)),qe.length=0):qe.push(we)}function rg(ne,we,qe,Nt){if(S)return Cc(6,1,ne,we,qe,Nt);for(var Rt=0,_t=0;_t<qe;_t++){var Qe=l()[we>>>2],yt=l()[we+4>>>2];we+=8;for(var Tn=0;Tn<yt;Tn++)JE(ne,i()[Qe+Tn>>>0]);Rt+=yt}return l()[Nt>>>2]=Rt,0}function I0(ne){var we=c["_"+ne];return we}function sg(ne,we){s().set(ne,we>>>0)}function e$(ne,we,qe,Nt,Rt){var _t={string:Ur=>{var Au=0;if(Ur!=null&&Ur!==0){var rs=(Ur.length<<2)+1;Au=og(rs),Te(Ur,Au,rs)}return Au},array:Ur=>{var Au=og(Ur.length);return sg(Ur,Au),Au}};function Qe(Ur){return we==="string"?de(Ur):we==="boolean"?!!Ur:Ur}var yt=I0(ne),Tn=[],Oa=0;if(Nt)for(var Bi=0;Bi<Nt.length;Bi++){var Nd=_t[qe[Bi]];Nd?(Oa===0&&(Oa=ig()),Tn[Bi]=Nd(Nt[Bi])):Tn[Bi]=Nt[Bi]}var ug=yt.apply(null,Tn);function cg(Ur){return Oa!==0&&Ec(Oa),Qe(Ur)}return ug=cg(ug),ug}function ui(ne,we,qe,Nt){qe=qe||[];var Rt=qe.every(Qe=>Qe==="number"||Qe==="boolean"),_t=we!=="string";return _t&&Rt&&!Nt?I0(ne):function(){return e$(ne,we,qe,arguments)}}Ye.init();var N0=[null,Nl,Pt,Da,yo,Us,rg],C0={__emscripten_init_main_thread_js:Ad,__emscripten_thread_cleanup:li,__pthread_create_js:Sn,_emscripten_default_pthread_stack_size:Vs,_emscripten_get_now_is_monotonic:QE,_emscripten_notify_task_queue:_S,_emscripten_set_offscreencanvas_size:Sd,abort:k0,emscripten_check_blocking_allowed:Ic,emscripten_date_now:kd,emscripten_get_heap_max:sr,emscripten_get_now:eg,emscripten_memcpy_big:RS,emscripten_num_logical_cores:vu,emscripten_receive_on_main_thread_js:DS,emscripten_resize_heap:ng,emscripten_unwind_to_js_event_loop:ag,exit:je,fd_close:yo,fd_seek:Us,fd_write:rg,memory:j||c.wasmMemory};Zm(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var Tc=c._pthread_self=function(){return(Tc=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var wu=c.__emscripten_thread_init=function(){return(wu=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var T0=c._emscripten_run_in_main_runtime_thread_js=function(){return(T0=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var E0=c.__emscripten_proxy_execute_task_queue=function(){return(E0=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Cl=c.__emscripten_thread_free_data=function(){return(Cl=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},FS=c.__emscripten_thread_exit=function(){return(FS=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},$0=c._emscripten_stack_set_limits=function(){return($0=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},ig=c.stackSave=function(){return(ig=c.stackSave=c.asm.stackSave).apply(null,arguments)},Ec=c.stackRestore=function(){return(Ec=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},og=c.stackAlloc=function(){return(og=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=Dt,c.wasmMemory=j,c.cwrap=ui,c.ExitStatus=oi,c.PThread=Ye;var lg;ta=function ne(){lg||Id(),lg||(ta=ne)};function Id(ne){if(Cn>0)return;if(S){h(c),yn(),startWorker(c);return}if(qn(),Cn>0)return;function we(){lg||(lg=!0,c.calledRun=!0,!te&&(yn(),h(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),ca()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),we()},1)):we()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();Id();var ci;m&&(ci={uncaughtException:process.listeners("uncaughtException").filter(function(ne){return!m.uncaughtException.indexOf(ne)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(ne){return!m.unhandledRejection.indexOf(ne)>-1})});var $c;if(typeof WasmBackendModule<"u")$c=WasmBackendModule;else if(typeof r<"u")$c=r;else throw new Error("Could not find wasm module in post.js");if(ci){var _0=$c._dispose;$c._dispose=function(){_0(),ci.uncaughtException.forEach(function(ne){process.removeListener("uncaughtException",ne)}),ci.unhandledRejection.forEach(function(ne){process.removeListener("unhandledRejection",ne)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),ade=ar((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),rde=ar((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};var s=typeof r<"u"?r:{},i,o;s.ready=new Promise(function(Me,je){i=Me,o=je});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var u=Object.assign({},s),c=typeof window=="object",h=typeof importScripts=="function",p=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",m="";function g(Me){return s.locateFile?s.locateFile(Me,m):m+Me}var y,b,v;if(p){var w=bF(),S=C5();h?m=S.dirname(m)+"/":m=__dirname+"/",y=(Me,je)=>(Me=lt(Me)?new URL(Me):S.normalize(Me),w.readFileSync(Me,je?void 0:"utf8")),v=Me=>{var je=y(Me,!0);return je.buffer||(je=new Uint8Array(je)),je},b=(Me,je,At)=>{Me=lt(Me)?new URL(Me):S.normalize(Me),w.readFile(Me,function(Ye,Mn){Ye?At(Ye):je(Mn.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Me){if(!(Me instanceof Dt))throw Me}),process.on("unhandledRejection",function(Me){throw Me}),s.inspect=function(){return"[Emscripten Module object]"}}else(c||h)&&(h?m=self.location.href:typeof document<"u"&&document.currentScript&&(m=document.currentScript.src),a&&(m=a),m.indexOf("blob:")!==0?m=m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):m="",y=Me=>{var je=new XMLHttpRequest;return je.open("GET",Me,!1),je.send(null),je.responseText},h&&(v=Me=>{var je=new XMLHttpRequest;return je.open("GET",Me,!1),je.responseType="arraybuffer",je.send(null),new Uint8Array(je.response)}),b=(Me,je,At)=>{var Ye=new XMLHttpRequest;Ye.open("GET",Me,!0),Ye.responseType="arraybuffer",Ye.onload=()=>{if(Ye.status==200||Ye.status==0&&Ye.response){je(Ye.response);return}At()},Ye.onerror=At,Ye.send(null)});var k=s.print||console.log.bind(console),I=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var T;s.wasmBinary&&(T=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&at("no native wasm support detected");var E,R=!1,D=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function O(Me,je,At){je>>>=0;for(var Ye=je+At,Mn=je;Me[Mn]&&!(Mn>=Ye);)++Mn;if(Mn-je>16&&Me.buffer&&D)return D.decode(Me.subarray(je,Mn));for(var Kn="";je<Mn;){var Pt=Me[je++];if(!(Pt&128)){Kn+=String.fromCharCode(Pt);continue}var Ot=Me[je++]&63;if((Pt&224)==192){Kn+=String.fromCharCode((Pt&31)<<6|Ot);continue}var ha=Me[je++]&63;if((Pt&240)==224?Pt=(Pt&15)<<12|Ot<<6|ha:Pt=(Pt&7)<<18|Ot<<12|ha<<6|Me[je++]&63,Pt<65536)Kn+=String.fromCharCode(Pt);else{var as=Pt-65536;Kn+=String.fromCharCode(55296|as>>10,56320|as&1023)}}return Kn}function $(Me,je){return Me>>>=0,Me?O(B,Me,je):""}function _(Me,je,At,Ye){if(At>>>=0,!(Ye>0))return 0;for(var Mn=At,Kn=At+Ye-1,Pt=0;Pt<Me.length;++Pt){var Ot=Me.charCodeAt(Pt);if(Ot>=55296&&Ot<=57343){var ha=Me.charCodeAt(++Pt);Ot=65536+((Ot&1023)<<10)|ha&1023}if(Ot<=127){if(At>=Kn)break;je[At++>>>0]=Ot}else if(Ot<=2047){if(At+1>=Kn)break;je[At++>>>0]=192|Ot>>6,je[At++>>>0]=128|Ot&63}else if(Ot<=65535){if(At+2>=Kn)break;je[At++>>>0]=224|Ot>>12,je[At++>>>0]=128|Ot>>6&63,je[At++>>>0]=128|Ot&63}else{if(At+3>=Kn)break;je[At++>>>0]=240|Ot>>18,je[At++>>>0]=128|Ot>>12&63,je[At++>>>0]=128|Ot>>6&63,je[At++>>>0]=128|Ot&63}}return je[At>>>0]=0,At-Mn}function P(Me,je,At){return _(Me,B,je,At)}var U,W,B,H;function j(Me){U=Me,s.HEAP8=W=new Int8Array(Me),s.HEAP16=new Int16Array(Me),s.HEAP32=new Int32Array(Me),s.HEAPU8=B=new Uint8Array(Me),s.HEAPU16=new Uint16Array(Me),s.HEAPU32=H=new Uint32Array(Me),s.HEAPF32=new Float32Array(Me),s.HEAPF64=new Float64Array(Me)}s.INITIAL_MEMORY;var Z=[],te=[],V=[];function Q(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)de(s.preRun.shift());qn(Z)}function ee(){qn(te)}function ae(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)Te(s.postRun.shift());qn(V)}function de(Me){Z.unshift(Me)}function ke(Me){te.unshift(Me)}function Te(Me){V.unshift(Me)}var $e=0,Le=null;function Ge(Me){$e++,s.monitorRunDependencies&&s.monitorRunDependencies($e)}function Ke(Me){if($e--,s.monitorRunDependencies&&s.monitorRunDependencies($e),$e==0&&Le){var je=Le;Le=null,je()}}function at(Me){s.onAbort&&s.onAbort(Me),Me="Aborted("+Me+")",I(Me),R=!0,Me+=". Build with -sASSERTIONS for more info.";var je=new WebAssembly.RuntimeError(Me);throw o(je),je}var vt="data:application/octet-stream;base64,";function ot(Me){return Me.startsWith(vt)}function lt(Me){return Me.startsWith("file://")}var tt;tt="tfjs-backend-wasm.wasm",ot(tt)||(tt=g(tt));function wt(Me){try{if(Me==tt&&T)return new Uint8Array(T);if(v)return v(Me);throw"both async and sync fetching of the wasm failed"}catch(je){at(je)}}function It(){if(!T&&(c||h)){if(typeof fetch=="function"&&!lt(tt))return fetch(tt,{credentials:"same-origin"}).then(function(Me){if(!Me.ok)throw"failed to load wasm binary file at '"+tt+"'";return Me.arrayBuffer()}).catch(function(){return wt(tt)});if(b)return new Promise(function(Me,je){b(tt,function(At){Me(new Uint8Array(At))},je)})}return Promise.resolve().then(function(){return wt(tt)})}function jn(){var Me={env:Qm,wasi_snapshot_preview1:Qm};function je(Pt,Ot){var ha=Pt.exports;s.asm=ha,E=s.asm.memory,j(E.buffer),s.asm.__indirect_function_table,ke(s.asm.__wasm_call_ctors),Ke()}Ge();function At(Pt){je(Pt.instance)}function Ye(Pt){return It().then(function(Ot){return WebAssembly.instantiate(Ot,Me)}).then(function(Ot){return Ot}).then(Pt,function(Ot){I("failed to asynchronously prepare wasm: "+Ot),at(Ot)})}function Mn(){return!T&&typeof WebAssembly.instantiateStreaming=="function"&&!ot(tt)&&!lt(tt)&&!p&&typeof fetch=="function"?fetch(tt,{credentials:"same-origin"}).then(function(Pt){var Ot=WebAssembly.instantiateStreaming(Pt,Me);return Ot.then(At,function(ha){return I("wasm streaming compile failed: "+ha),I("falling back to ArrayBuffer instantiation"),Ye(At)})}):Ye(At)}if(s.instantiateWasm)try{var Kn=s.instantiateWasm(Me,je);return Kn}catch(Pt){I("Module.instantiateWasm callback failed with error: "+Pt),o(Pt)}return Mn().catch(o),{}}function Dt(Me){this.name="ExitStatus",this.message="Program terminated with exit("+Me+")",this.status=Me}function qn(Me){for(;Me.length>0;)Me.shift()(s)}function yn(){at("")}function ca(){return 4294901760}function nn(){return ca()}function ua(Me,je,At){B.copyWithin(Me>>>0,je>>>0,je+At>>>0)}function ea(Me){try{return E.grow(Me-U.byteLength+65535>>>16),j(E.buffer),1}catch{}}function Cn(Me){var je=B.length;Me=Me>>>0;var At=ca();if(Me>At)return!1;let Ye=(ha,as)=>ha+(as-ha%as)%as;for(var Mn=1;Mn<=4;Mn*=2){var Kn=je*(1+.2/Mn);Kn=Math.min(Kn,Me+100663296);var Pt=Math.min(At,Ye(Math.max(Me,Kn),65536)),Ot=ea(Pt);if(Ot)return!0}return!1}function ta(Me){return 52}function ys(Me,je,At,Ye,Mn){return 70}var po=[null,[],[]];function Bs(Me,je){var At=po[Me];je===0||je===10?((Me===1?k:I)(O(At,0)),At.length=0):At.push(je)}function yu(Me,je,At,Ye){for(var Mn=0,Kn=0;Kn<At;Kn++){var Pt=H[je>>>2],Ot=H[je+4>>>2];je+=8;for(var ha=0;ha<Ot;ha++)Bs(Me,B[Pt+ha>>>0]);Mn+=Ot}return H[Ye>>>2]=Mn,0}function Ha(Me){var je=s["_"+Me];return je}function ba(Me,je){W.set(Me,je>>>0)}function Fn(Me,je,At,Ye,Mn){var Kn={string:Sn=>{var Vs=0;if(Sn!=null&&Sn!==0){var kc=(Sn.length<<2)+1;Vs=oi(kc),P(Sn,Vs,kc)}return Vs},array:Sn=>{var Vs=oi(Sn.length);return ba(Sn,Vs),Vs}};function Pt(Sn){return je==="string"?$(Sn):je==="boolean"?!!Sn:Sn}var Ot=Ha(Me),ha=[],as=0;if(Ye)for(var mo=0;mo<Ye.length;mo++){var Ad=Kn[At[mo]];Ad?(as===0&&(as=Zm()),ha[mo]=Ad(Ye[mo])):ha[mo]=Ye[mo]}var li=Ot.apply(null,ha);function Da(Sn){return as!==0&&Jm(as),Pt(Sn)}return li=Da(li),li}function Vr(Me,je,At,Ye){At=At||[];var Mn=At.every(Pt=>Pt==="number"||Pt==="boolean"),Kn=je!=="string";return Kn&&Mn&&!Ye?Ha(Me):function(){return Fn(Me,je,At,arguments)}}var Qm={abort:yn,emscripten_get_heap_max:nn,emscripten_memcpy_big:ua,emscripten_resize_heap:Cn,fd_close:ta,fd_seek:ys,fd_write:yu};jn(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var Zm=s.stackSave=function(){return(Zm=s.stackSave=s.asm.stackSave).apply(null,arguments)},Jm=s.stackRestore=function(){return(Jm=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},oi=s.stackAlloc=function(){return(oi=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=Vr;var jo;Le=function Me(){jo||bu(),jo||(Le=Me)};function bu(Me){if($e>0||(Q(),$e>0))return;function je(){jo||(jo=!0,s.calledRun=!0,!R&&(ee(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),ae()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),je()},1)):je()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();bu();var Ps;l&&(Ps={uncaughtException:process.listeners("uncaughtException").filter(function(Me){return!l.uncaughtException.indexOf(Me)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Me){return!l.unhandledRejection.indexOf(Me)>-1})});var fo;if(typeof r<"u")fo=r;else if(typeof WasmBackendModuleThreadedSimd<"u")fo=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Ps){var Nl=fo._dispose;fo._dispose=function(){Nl(),Ps.uncaughtException.forEach(function(Me){process.removeListener("uncaughtException",Me)}),Ps.unhandledRejection.forEach(function(Me){process.removeListener("unhandledRejection",Me)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),l2=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Bw=class{refCount(e){return gi("refCount")}incRef(e){return gi("incRef")}timerAvailable(){return!0}time(e){return gi("time")}read(e){return gi("read")}readSync(e){return gi("readSync")}readToGPU(e,t){return gi("readToGPU")}numDataIds(){return gi("numDataIds")}disposeData(e,t){return gi("disposeData")}write(e,t,n){return gi("write")}move(e,t,n,a,r){return gi("move")}createTensorFromGPUData(e,t,n){return gi("createTensorFromGPUData")}memory(){return gi("memory")}floatPrecision(){return gi("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return gi("dispose")}};function gi(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function T5(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,qI(e,t,n)}function sde(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,qI(e,n,a),qI(t,n,a)}function Jv(e,t,n){return Math.max(e,Math.min(t,n))}function ide(e){return e%2===0?e:e+1}function qI(e,t,n){let a=e[t];e[t]=e[n],e[n]=a}function ode(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function lde(e,t){let n=Math.random();return t*n+(1-n)*e}function ude(e,t){let n=0;for(let a=0;a<e.length;a++){let r=Number(e[a])-Number(t[a]);n+=r*r}return n}function J(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function Ds(e,t,n=""){J(oc(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function sf(e){J(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Rn(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function cde(e){return e.length===0}function E5(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function oc(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function ly(e){return e%1===0}function hde(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function dde(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function pde(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return T5(t),t}function jv(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function fde(e,t=r=>0,n,a){return new Promise((r,s)=>{let i=0,o=()=>{if(e()){r();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}a!=null?a(o,l):setTimeout(o,l)};o()})}function mde(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(a!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${s}`);a=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(a===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let r=e.slice();return r[a]=t/n,r}function Po(e,t){let n=t.length;return e=e==null?t.map((a,r)=>r):[].concat(e),J(e.every(a=>a>=-n&&a<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),J(e.every(a=>ly(a)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(a=>a<0?n+a:a)}function $5(e,t){let n=[],a=[],r=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||r?null:Po(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function _5(e,t){return xF(e,t)}function xF(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function R5(e,t){for(let n=0;n<e.length;n++){let a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function D5(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function gde(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function KI(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function O5(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function lh(e){return typeof e=="string"||e instanceof String}function F5(e){return typeof e=="boolean"}function M5(e){return typeof e=="number"}function Pw(e){return Array.isArray(e)?Pw(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":M5(e)?"float32":lh(e)?"string":F5(e)?"bool":"float32"}function wh(e){return!!(e&&e.constructor&&e.call&&e.apply)}function XI(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Uy(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function L5(e,t,n,a=!1){let r=new Array;if(t.length===1){let s=t[0]*(a?2:1);for(let i=0;i<s;i++)r[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(a?2:1);for(let l=0;l<s;l++)r[l]=L5(e+l*o,i,n,a)}return r}function Zg(e,t,n=!1){if(e.length===0)return t[0];let a=e.reduce((r,s)=>r*s)*(n?2:1);if(a===0)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return L5(0,e,t,n)}function yde(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function vF(e,t){let n=u2(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function u2(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function bde(e,t){let n=e.reduce((a,r)=>a*r,1);if(t==null||t==="float32")return Zg(e,new Float32Array(n));if(t==="int32")return Zg(e,new Int32Array(n));if(t==="bool")return Zg(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Li(e){e.forEach(t=>{J(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function xde(e,t,n){if(t===0)return 0;if(t===1)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function vde(e,t,n){if(t===0)return[];if(t===1)return[e];let a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function c2(e){return e&&e.then&&typeof e.then=="function"}var xG="tfjsflags",z5=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=wde,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let a=this.urlFlags[e];xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${a}.`),this.set(e,a)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(c2(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);xG in e&&e[xG].split(",").forEach(t=>{let[n,a]=t.split(":");this.urlFlags[n]=Sde(n,a)})}};function wde(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...a)=>(Ade(t,a[0],a[1]),a.join("="))),t}function Ade(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Sde(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function xe(){return wF}var wF=null;function kde(e){wF=e}var lR;function B5(){if(lR==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");lR=e}return lR}function Ide(){let e=B5();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function AF(e,t){let n=Ide();if(n.has(e))return n.get(e);{let a=t();return n.set(e,a),n.get(e)}}var Wy="Abs",of="Acos",lf="Acosh",Xh="Add",uf="AddN",Gy="All",Hy="Any",jy="ArgMax",qy="ArgMin",cf="Asin",hf="Asinh",df="Atan",pf="Atanh",ff="Atan2",mf="AvgPool",Vw="AvgPoolGrad",Ky="AvgPool3D",Uw="AvgPool3DGrad",gf="BatchMatMul",Xy="BatchToSpaceND",Yy="Bincount",Qy="BitwiseAnd",P5="BroadcastTo",Ww="BroadcastArgs",yf="Cast",bf="Ceil",Yh="ClipByValue",h2="Complex",Gw="ComplexAbs",Zy="Concat",xf="Conv2D",d2="Conv2DBackpropFilter",vf="Conv2DBackpropInput",wf="Conv3D",Jy="Conv3DBackpropFilterV2",eb="Conv3DBackpropInputV2",Af="Cos",Sf="Cosh",tb="Cumprod",kf="Cumsum",nb="CropAndResize",Hw="DenseBincount",ab="DepthToSpace",If="DepthwiseConv2dNative",p2="DepthwiseConv2dNativeBackpropFilter",f2="DepthwiseConv2dNativeBackpropInput",jw="Diag",Nf="Dilation2D",uy="Dilation2DBackpropInput",cy="Dilation2DBackpropFilter",m2="Draw",Cf="RealDiv",g2="Einsum",Tf="Elu",rb="EluGrad",Ef="Erf",sb="Equal",$f="Exp",ib="ExpandDims",_f="Expm1",y2="FFT",qw="Fill",ob="FlipLeftRight",Rf="Floor",Df="FloorDiv",Of="FusedBatchNorm",lb="GatherV2",ub="GatherNd",cb="Greater",Ff="GreaterEqual",Mf="Identity",b2="IFFT",x2="Imag",Lf="IsFinite",zf="IsInf",Bf="IsNan",Pf="LeakyRelu",hb="Less",db="LessEqual",pb="LinSpace",Vf="Log",Uf="Log1p",fb="LogicalAnd",mb="LogicalNot",gb="LogicalOr",V5="LogicalXor",U5="LogSoftmax",Nde="LowerBound",Wf="LRN",yb="LRNGrad",Cde="MatrixBandPart",Gf="Max",Hf="Maximum",jf="MaxPool",Kw="MaxPoolGrad",bb="MaxPool3D",Xw="MaxPool3DGrad",Yw="MaxPoolWithArgmax",qf="Mean",Kf="Min",Xf="Minimum",Yf="MirrorPad",Qf="Mod",xb="Multinomial",Zf="Multiply",vb="Neg",wb="NotEqual",Ab="NonMaxSuppressionV3",Sb="NonMaxSuppressionV4",kb="NonMaxSuppressionV5",Ib="OnesLike",Jf="OneHot",Nb="Pack",em="PadV2",Tde="Pool",tm="Pow",nm="Prelu",am="Prod",v2="RaggedGather",w2="RaggedRange",A2="RaggedTensorToTensor",Qw="Range",S2="Real",rm="Reciprocal",sm="Relu",Cb="Reshape",im="ResizeNearestNeighbor",Tb="ResizeNearestNeighborGrad",om="ResizeBilinear",Eb="ResizeBilinearGrad",lm="Relu6",um="Reverse",cm="Round",hm="Rsqrt",$b="ScatterNd",_b="TensorScatterUpdate",Rb="SearchSorted",Db="Select",dm="Selu",Ob="Slice",pm="Sin",fm="Sinh",mm="Sign",gm="Sigmoid",ym="Softplus",bm="Sqrt",xm="Sum",Fb="SpaceToBatchND",Mb="SplitV",vm="Softmax",Zw="SparseFillEmptyRows",Lb="SparseReshape",Jw="SparseSegmentMean",e1="SparseSegmentSum",zb="SparseToDense",wm="SquaredDifference",t1="Square",n1="StaticRegexReplace",Bb="StridedSlice",a1="StringNGrams",r1="StringSplit",s1="StringToHashBucketFast",Am="Sub",Sm="Tan",km="Tanh",Qh="Tile",Pb="TopK",Vb="Transform",Ku="Transpose",i1="Unique",Ub="Unpack",o1="UnsortedSegmentSum",Ede="UpperBound",Wb="ZerosLike",Zh="Step",YI="FromPixels",Gb="RotateWithOffset",Ap="_FusedMatMul",Sp="FusedConv2D",kp="FusedDepthwiseConv2D";function oh(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(...e)}function $de(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.log(...e)}var hy=AF("kernelRegistry",()=>new Map),ew=AF("gradRegistry",()=>new Map);function tw(e,t){let n=SF(e,t);return hy.get(n)}function eD(e){return ew.get(e)}function QI(e){let t=hy.entries(),n=[];for(;;){let{done:a,value:r}=t.next();if(a)break;let[s,i]=r,[o]=s.split("_");o===e&&n.push(i)}return n}function l1(e){let{kernelName:t,backendName:n}=e,a=SF(t,n);hy.has(a)&&oh(`The kernel '${t}' for backend '${n}' is already registered`),hy.set(a,e)}function W5(e){let{kernelName:t}=e;ew.has(t)&&xe().getBool("DEBUG")&&oh(`Overriding the gradient for '${t}'`),ew.set(t,e)}function _de(e,t){let n=SF(e,t);if(!hy.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);hy.delete(n)}function Rde(e){if(!ew.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ew.delete(e)}function Dde(e,t){QI(e).forEach(n=>{let a=Object.assign({},n,{backendName:t});l1(a)})}function SF(e,t){return`${t}_${e}`}var F={};Lt(F,{arraysEqual:()=>oc,arraysEqualWithNull:()=>E5,assert:()=>J,assertNonNegativeIntegerDimensions:()=>Li,assertNonNull:()=>sf,assertShapesMatch:()=>Ds,bytesFromStringArray:()=>O5,bytesPerElement:()=>KI,checkConversionForErrors:()=>R5,clamp:()=>Jv,computeStrides:()=>Uy,convertBackendValuesAndArrayBuffer:()=>yde,createScalarValue:()=>Bde,createShuffledIndices:()=>pde,decodeString:()=>ZI,distSquared:()=>ude,encodeString:()=>c1,fetch:()=>Vde,fingerPrint64:()=>zde,flatten:()=>Ah,getArrayFromDType:()=>xF,getTypedArrayFromDType:()=>_5,hasEncodingLoss:()=>gde,hexToLong:()=>u1,indexToLoc:()=>vde,inferDtype:()=>Pw,inferFromImplicitShape:()=>mde,isBoolean:()=>F5,isFunction:()=>wh,isInt:()=>ly,isNumber:()=>M5,isPromise:()=>c2,isScalarShape:()=>cde,isString:()=>lh,isTypedArray:()=>Cr,isValidDtype:()=>D5,locToIndex:()=>xde,makeOnesTypedArray:()=>vF,makeZerosNestedTypedArray:()=>bde,makeZerosTypedArray:()=>u2,nearestDivisor:()=>XI,nearestLargerEven:()=>ide,now:()=>nw,parseAxisParam:()=>Po,randUniform:()=>lde,repeatedTry:()=>fde,rightPad:()=>jv,shuffle:()=>T5,shuffleCombo:()=>sde,sizeFromShape:()=>Rn,sizeToSquarishShape:()=>dde,squeezeShape:()=>$5,sum:()=>ode,swap:()=>qI,tanh:()=>hde,toNestedArray:()=>Zg,toTypedArray:()=>k2});function G5(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var vG=Kh(Uhe()),Jd=vG.default||vG;function u1(e){return Jd.fromString(e,!0,16)}var H5=u1("c3a5c85c97cb3127"),Kd=u1("b492b66fbe98f273"),ws=u1("9ae16a3b2f90404f");function tD(e){return e.xor(e.shru(47))}function j5(e,t,n){let a=e.slice(t,t+n);return Jd.fromBytes(Array.from(a),!0,!0)}function aa(e,t){return j5(e,t,8)}function wG(e,t){return j5(e,t,4)}function Nr(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function mh(e,t,n=u1("9ddfea08eb382d69")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Ode(e,t,n,a,r,s){r=r.add(e),s=Nr(s.add(r).add(a),21);let i=r;return r=r.add(t),r=r.add(n),s=s.add(Nr(r,44)),[r.add(a),s.add(i)]}function Uk(e,t,n,a){return Ode(aa(e,t),aa(e,t+8),aa(e,t+16),aa(e,t+24),n,a)}function Fde(e,t=e.length){if(t>=8){let n=ws.add(t*2),a=aa(e,0).add(ws),r=aa(e,t-8),s=Nr(r,37).mul(n).add(a),i=Nr(a,25).add(r).mul(n);return mh(s,i,n)}if(t>=4){let n=ws.add(t*2),a=wG(e,0);return mh(a.shl(3).add(t),wG(e,t-4),n)}if(t>0){let n=e[0],a=e[t>>1],r=e[t-1],s=n+(a<<8),i=t+(r<<2);return tD(ws.mul(s).xor(H5.mul(i))).mul(ws)}return ws}function Mde(e,t=e.length){let n=ws.add(t*2),a=aa(e,0).mul(Kd),r=aa(e,8),s=aa(e,t-8).mul(n),i=aa(e,t-16).mul(ws);return mh(Nr(a.add(r),43).add(Nr(s,30)).add(i),a.add(Nr(r.add(ws),18)).add(s),n)}function Lde(e,t=e.length){let n=ws.add(t*2),a=aa(e,0).mul(ws),r=aa(e,8),s=aa(e,t-8).mul(n),i=aa(e,t-16).mul(ws),o=Nr(a.add(r),43).add(Nr(s,30)).add(i),l=mh(o,a.add(Nr(r.add(ws),18)).add(s),n),u=aa(e,16).mul(n),c=aa(e,24),h=o.add(aa(e,t-32)).mul(n),p=l.add(aa(e,t-24)).mul(n);return mh(Nr(u.add(c),43).add(Nr(h,30)).add(p),u.add(Nr(c.add(a),18)).add(h),n)}function zde(e,t=e.length){let n=Jd.fromNumber(81,!0);if(t<=32)return t<=16?Fde(e,t):Mde(e,t);if(t<=64)return Lde(e,t);let a=n,r=n.mul(Kd).add(113),s=tD(r.mul(ws).add(113)).mul(ws),i=[Jd.UZERO,Jd.UZERO],o=[Jd.UZERO,Jd.UZERO];a=a.mul(ws).add(aa(e,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do a=Nr(a.add(r).add(i[0]).add(aa(e,l+8)),37).mul(Kd),r=Nr(r.add(i[1]).add(aa(e,l+48)),42).mul(Kd),a=a.xor(o[1]),r=r.add(i[0]).add(aa(e,l+40)),s=Nr(s.add(o[0]),33).mul(Kd),i=Uk(e,l,i[1].mul(Kd),a.add(o[0])),o=Uk(e,l+32,s.add(o[1]),r.add(aa(e,l+16))),[s,a]=[a,s],l+=64;while(l!==u);let h=Kd.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=Nr(a.add(r).add(i[0]).add(aa(e,l+8)),37).mul(h),r=Nr(r.add(i[1]).add(aa(e,l+48)),42).mul(h),a=a.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(aa(e,l+40))),s=Nr(s.add(o[0]),33).mul(h),i=Uk(e,l,i[1].mul(h),a.add(o[0])),o=Uk(e,l+32,s.add(o[1]),r.add(aa(e,l+16))),[s,a]=[a,s],mh(mh(i[0],o[0],h).add(tD(r).mul(H5)).add(s),mh(i[1],o[1],h).add(a),h)}function Bde(e,t){return t==="string"?c1(e):k2([e],t)}function Pde(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function k2(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ah(e)),xe().getBool("DEBUG")&&R5(e,t),Pde(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let a=0;a<n.length;++a)Math.round(e[a])!==0&&(n[a]=1);return n}else throw new Error(`Unknown data type ${t}`)}function nw(){return xe().platform.now()}function Vde(e,t){return xe().platform.fetch(e,t)}function c1(e,t="utf-8"){return t=t||"utf-8",xe().platform.encode(e,t)}function ZI(e,t="utf-8"){return t=t||"utf-8",xe().platform.decode(e,t)}function Cr(e){return xe().platform.isTypedArray!=null?xe().platform.isTypedArray(e):G5(e)}function Ah(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||c2(e)||e==null||Cr(e)&&n)t.push(e);else if(Array.isArray(e)||Cr(e))for(let a=0;a<e.length;++a)Ah(e[a],t,n);else{let a=-1;for(let r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(a=Math.max(a,Number(r)));for(let r=0;r<=a;r++)Ah(e[r],t,n)}return t}var Ude=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Gde)}profileKernel(e,t,n){let a,r=()=>{a=n()},s,i=nw();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(let o of a)o.dataSync();s=Promise.resolve({kernelMs:nw()-i})}if(xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<a.length;o++){let l=a[o];l.data().then(u=>{Wde(u,l.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),a,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],r,o[2])})})}};function Wde(e,t,n){if(t!=="float32")return!1;for(let a=0;a<e.length;a++){let r=e[a];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var Gde=class{logKernelProfile(e,t,n,a,r,s){let i=typeof a=="number"?jv(`${a}ms`,9):a.error,o=jv(e,25),l=t.rank,u=t.size,c=jv(t.shape.toString(),14),h="";for(let p in r){let m=r[p];if(m!=null){let g=m.shape||t.shape,y=g.length;h+=`${p}: ${y}D ${y>0?g:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${c}	%c${u}	%c${h}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function Hde(e,t,n){let a={},r={};for(let l=0;l<t.length;l++)a[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let h in c){let p=c[h],m=!1;for(let g=0;g<t.length;g++)if(a[p.id]){u.outputs.forEach(y=>a[y.id]=!0),m=!0,r[u.id]=!0;break}if(m)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(s[u.outputs[h].id]){for(let p in c)s[c[p].id]=!0,i[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(r[u.id]&&i[u.id]){let c={};for(let p in u.inputs){let m=u.inputs[p];a[m.id]&&(c[p]=m)}let h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,o.push(h)}}return o}function jde(e,t,n,a){for(let r=t.length-1;r>=0;r--){let s=t[r],i=[];if(s.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[l];if(!oc(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{let h=e[c.id];e[c.id]=a(h,u),h.dispose()}}}}var AG=20,vv=3,uR=7;function qde(e,t,n,a){let r=Uy(t),s=Kde(e,t,n,r),i=t.length,o=NI(e,t,n,r,s),l=["Tensor"];return a&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function Kde(e,t,n,a){let r=Rn(t),s=a[a.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?$v(e):e;if(o>1)for(let u=0;u<r/s;u++){let c=u*s;for(let h=0;h<s;h++)i[h]=Math.max(i[h],Ev(l[c+h],0,n).length)}return i}function Ev(e,t,n){let a;return Array.isArray(e)?a=`${parseFloat(e[0].toFixed(uR))} + ${parseFloat(e[1].toFixed(uR))}j`:lh(e)?a=`'${e}'`:n==="bool"?a=q5(e):a=parseFloat(e.toFixed(uR)).toString(),jv(a,t)}function q5(e){return e===0?"false":"true"}function NI(e,t,n,a,r,s=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let y=$v(e);return[Ev(y[0],0,n)]}return n==="bool"?[q5(e[0])]:[e[0].toString()]}if(l===1){if(o>AG){let y=vv*i,b=Array.from(e.slice(0,y)),v=Array.from(e.slice((o-vv)*i,o*i));return n==="complex64"&&(b=$v(b),v=$v(v)),["["+b.map((w,S)=>Ev(w,r[S],n)).join(", ")+", ..., "+v.map((w,S)=>Ev(w,r[o-vv+S],n)).join(", ")+"]"]}return["["+(n==="complex64"?$v(e):Array.from(e)).map((y,b)=>Ev(y,r[b],n)).join(", ")+"]"]}let u=t.slice(1),c=a.slice(1),h=a[0]*i,p=[];if(o>AG){for(let y=0;y<vv;y++){let b=y*h,v=b+h;p.push(...NI(e.slice(b,v),u,n,c,r,!1))}p.push("...");for(let y=o-vv;y<o;y++){let b=y*h,v=b+h;p.push(...NI(e.slice(b,v),u,n,c,r,y===o-1))}}else for(let y=0;y<o;y++){let b=y*h,v=b+h;p.push(...NI(e.slice(b,v),u,n,c,r,y===o-1))}let m=l===2?",":"";p[0]="["+(o>0?p[0]+m:"");for(let y=1;y<p.length-1;y++)p[y]=" "+p[y]+m;let g=`,
`;for(let y=2;y<l;y++)g+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(s?"":g),p}function $v(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Za=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Rn(e),n!=null){let a=n.length;J(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||xF(t,this.size),this.strides=Uy(e)}set(e,...t){t.length===0&&(t=[0]),J(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let a of e){if(a<0||a>=this.shape[t]){let r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let n=e[e.length-1];for(let a=0;a<e.length-1;++a)n+=this.strides[a]*e[a];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return nl().makeTensor(this.values,this.shape,this.dtype)}},nl=null,Hg=null;function Xde(e){nl=e}function Yde(e){Hg=e}var Bt=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Rn(e),this.strides=Uy(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Hg.buffer(this.shape,this.dtype,e)}bufferSync(){return Hg.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Zg(this.shape,e,this.dtype==="complex64")}arraySync(){return Zg(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=nl().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>ZI(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),nl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=nl().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ZI(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await nl().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),nl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Hg.print(this,e)}clone(){return this.throwIfDisposed(),Hg.clone(this)}toString(e=!1){let t=this.dataSync();return qde(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Hg.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),nl().makeVariable(this,e,t,n)}};Object.defineProperty(Bt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Oe(){return AF("Tensor",()=>Bt)}Oe();var Ip=class extends Bt{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!oc(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);nl().disposeTensor(this),this.dataId=e.dataId,nl().incRef(this,null)}dispose(){nl().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ip,Symbol.hasInstance,{value:e=>e instanceof Bt&&e.assign!=null&&e.assign instanceof Function});var il={};Lt(il,{assertTypesMatch:()=>Y5,getTensorsInContainer:()=>kF,isTensorInList:()=>Zde,makeTypesMatch:()=>Ca});var nD;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(nD||(nD={}));var aD;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(aD||(aD={}));var rD;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(rD||(rD={}));var sD;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(sD||(sD={}));var iD;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(iD||(iD={}));var Qde={float32:sD,int32:aD,bool:rD,complex64:iD};function ro(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Qde[e][t]}function I2(e){return ro(e,"int32")}function K5(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function X5(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Ca(e,t){if(e.dtype===t.dtype)return[e,t];let n=ro(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Y5(e,t){J(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function Zde(e,t){return t.some(n=>n.id===e.id)}function kF(e){let t=[];return Q5(e,t,new Set),t}function Q5(e,t,n){if(e==null)return;if(e instanceof Bt){t.push(e);return}if(!Jde(e))return;let a=e;for(let r in a){let s=a[r];n.has(s)||(n.add(s),Q5(s,t,n))}}function Jde(e){return Array.isArray(e)||typeof e=="object"}function cR(e){return e.kernelName!=null}var SG=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},IF=class oD{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new SG}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n];if(await this.initializeBackend(a).success){await this.setBackend(a);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,a=1){return t in this.registryFactory?(oh(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:a},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:a}=this.initializeBackend(t);if(!(a?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Ude(this.backendInstance),!0}setupRegisteredKernels(){QI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){QI(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let a=n.factory();if(a&&!(a instanceof Bw)&&typeof a.then=="function"){let r=++this.pendingBackendInitId,s=a.then(i=>r<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,oh(`Initialization of backend ${t} failed`),oh(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(a){return oh(`Initialization of backend ${t} failed`),oh(a.stack||a.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n],{success:r,asyncInit:s}=this.initializeBackend(a);if(s||r)return{name:a,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let a=this.state.tensorInfo.get(n),r=a.backend,s=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),a.backend=t,t.move(n,s,a.shape,a.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=t}let r;return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,a){t();try{let r=a();return n(),r}catch(r){throw n(),r}}nextTensorId(){return oD.nextTensorId++}nextVariableId(){return oD.nextVariableId++}clone(t){let n=re.runKernel(Mf,{x:t}),a={x:t},r=i=>({x:()=>{let o="float32",l={x:i},u={dtype:o};return re.runKernel(yf,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,a,[n],r,s,{}),n}runKernel(t,n,a){if(this.backendName==null&&this.backend,tw(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:a})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,a){let r=this.backend.numDataIds(),s=0;a.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,a=[],r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,u=cR(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(cR(t)){let{kernelName:g,inputs:y,attrs:b}=t;this.backendName==null&&this.backend;let v=tw(g,this.backendName);J(v!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),o=()=>{let w=this.backend.numDataIds();l=v.kernelFunc({inputs:y,attrs:b,backend:this.backend});let S=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,w,S);let k=S.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(r){let I=this.getTensorsForGradient(g,y,k);a=this.saveTensorsForBackwardMode(I)}return k}}else{let{forwardFunc:g}=t,y=b=>{r&&(a=b.map(v=>this.keep(this.clone(v))))};o=()=>{let b=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,y));let v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,b,v),v}}let{inputs:c,attrs:h}=t,p=cR(t)?null:t.backwardsFunc,m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(m=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),n=m.outputs)}),r&&this.addTapeNode(u,c,n,p,a,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(g=>c[g]!=null?c[g].shape:null),outputShapes:n.map(g=>g.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,a){let r=eD(t);if(r!=null){let s=r.inputsToSave||[],i=r.outputsToSave||[],o;r.saveAllInputs?(J(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=s.map(u=>n[u]);let l=a.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(t,n,a,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");a=a||"float32",r=r||this.backend;let s=t;a==="string"&&lh(t[0])&&(s=t.map(l=>c1(l)));let i=r.write(s,n,a),o=new Bt(n,a,i,this.nextTensorId());if(this.trackTensor(o,r),a==="string"){let l=this.state.tensorInfo.get(i),u=O5(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,a,r){a=a||"float32";let s={dataId:t,shape:n,dtype:a};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,n){let{dataId:a,shape:r,dtype:s}=t,i=new Bt(r,s,a,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,a,r){a=a||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let s=new Ip(t,n,a,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let a=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(a=t.size*KI(t.dtype)),this.state.numBytes+=a,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:a})),t instanceof Ip||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let a=t.size*KI(t.dtype);this.state.numBytes-=a}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,a=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-a;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,a,r,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:a,saved:s},l=eD(t);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=u=>(u=u.map((c,h)=>{if(c==null){let p=a[h],m=u2(p.size,p.dtype);return this.makeTensor(m,p.shape,p.dtype)}return c}),r(u.length>1?u:u[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=kF(t),a=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!a.has(i.id)&&i.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(t,n,a,r=!1){if(J(n.length>0,()=>"gradients() received an empty list of xs."),a!=null&&a.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));J(s instanceof Bt,()=>"The result y returned by f() must be a tensor.");let i=Hde(this.state.activeTape,n,s);if(!r&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=a??epe(s.shape),jde(o,i,u=>this.tidy(u),tpe);let l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return J(wh(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{J(n.every(o=>o instanceof Bt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let a,r={};n.forEach((o,l)=>{r[l]=o});let s=(o,l)=>(a=t(...n,l),J(a.value instanceof Bt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),J(wh(a.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),a.value),i=(o,l)=>{let u=a.gradFunc(o,l),c=Array.isArray(u)?u:[u];J(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),J(c.every(p=>p instanceof Bt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let h={};return c.forEach((p,m)=>{h[m]=()=>p}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=nw(),a=await this.backend.time(t);return a.wallMs=nw()-n,a}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new SG;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};IF.nextTensorId=0;IF.nextVariableId=0;function epe(e){let t=vF(Rn(e),"float32");return re.makeTensor(t,e,"float32")}function Z5(){let e=B5();if(e._tfengine==null){let t=new z5(e);e._tfengine=new IF(t)}return kde(e._tfengine.ENV),Xde(()=>e._tfengine),e._tfengine}var re=Z5();function tpe(e,t){let n={a:e,b:t};return re.runKernel(Xh,n)}var h1={};Lt(h1,{isBrowser:()=>J5,isMobile:()=>rpe,mockIsMobile:()=>ape});function npe(){return typeof navigator<"u"&&navigator!=null}var lD;function ape(e){lD=e}function rpe(e){if(lD!==void 0)return lD;if(e||npe()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function J5(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Qs=xe();Qs.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Qs.registerFlag("IS_BROWSER",()=>J5());Qs.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Qs.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Qs.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Qs.registerFlag("PROD",()=>!1);Qs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Qs.getBool("DEBUG"));Qs.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Qs.registerFlag("IS_TEST",()=>!1);Qs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Qs.getBool("DEBUG"));Qs.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Qs.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Qs.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function eu(e,t){let n=e;if(Cr(e))return t==="string"?[]:[e.length];if(K5(e)){let r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(X5(e))return[e.buffer.size/(t==null?4:KI(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(n)||Cr(n)&&t!=="string";)a.push(n.length),n=n[0];return Array.isArray(e)&&xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&eq(e,a,[]),a}function eq(e,t,n){if(n=n||[],!Array.isArray(e)&&!Cr(e)){J(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}J(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),J(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let a=t.slice(1);for(let r=0;r<e.length;++r)eq(e[r],a,n.concat(r))}function kG(e,t,n,a){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function K(e,t,n,a="numeric"){if(e instanceof Oe())return kG(a,e.dtype,t,n),e;let r=Pw(e);if(r!=="string"&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),kG(a,r,t,n),e==null||!Cr(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=eu(e,r);!Cr(e)&&!Array.isArray(e)&&(e=[e]);let i=r!=="string"?k2(e,r):Ah(e,[],!0);return re.makeTensor(i,s,r)}function aw(e,t,n,a="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((r,s)=>K(r,`${t}[${s}]`,n,a))}var NF="__op";function ie(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+NF;let r=(...s)=>{re.startScope(n);try{let i=a(...s);return c2(i)&&console.error("Cannot return a Promise inside of tidy."),re.endScope(i),i}catch(i){throw re.endScope(null),i}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function spe(e,t){let n=K(e,"real","complex"),a=K(t,"imag","complex");Ds(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);let r={real:n,imag:a};return re.runKernel(h2,r)}var Ju=ie({complex_:spe});function Jh(e,t,n,a){if(a==null)a=Pw(e);else if(a==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(X5(e)||K5(e)){if(a!=="float32"&&a!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return re.backend.createTensorFromGPUData(e,t||n,a)}if(!Cr(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Li(t);let r=Rn(t),s=Rn(n);J(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==Rn(t.slice(i)):!0;J(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Cr(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=a!=="string"?k2(e,a):Ah(e,[],!0),re.makeTensor(e,t,a)}function Cs(e,t,n){let a=eu(e,n);return Jh(e,t,a,n)}var Np={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},lc=class tq{static join(t){return new tq(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(a=>Cr(a)?a.buffer:a),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let a=0;a<t.length;a++){let r=t[a];a!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+r.byteLength;this.shards.push({buffer:r,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let a=this.findShardForByte(t);if(a===-1)throw new Error(`Could not find start shard for byte ${t}`);let r=n-t,s=new ArrayBuffer(r),i=new Uint8Array(s),o=0;for(let l=a;l<this.shards.length;l++){let u=this.shards[l],c=t+o-u.start,h=o,p=Math.min(n,u.end)-u.start,m=new Uint8Array(u.buffer,c,p-c);if(i.set(m,h),o+=m.length,n<u.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let a=ipe(this.shards,n);return a===-1?-1:(this.previousShardIndex=a,this.previousShardIndex)}};function ipe(e,t){let n=0,a=e.length;for(;n<=a;){let r=Math.floor((a-n)/2)+n,s=t(e[r]);if(s===0)return r;s<0?a=r:n=r+1}return-1}function ope(){xe().set("PROD",!0)}function lpe(){xe().set("DEBUG",!0)}function upe(){xe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function nq(e){xe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function cpe(){re.disposeVariables()}function _o(){return re}function uD(){return re.memory()}function hpe(e){return re.profile(e)}function fe(e,t){return re.tidy(e,t)}function Ft(e){kF(e).forEach(t=>t.dispose())}function cr(e){return re.keep(e)}function dpe(e){return re.time(e)}function ppe(e){return re.setBackend(e)}function fpe(){return re.ready()}function aq(){return re.backendName}function mpe(e){re.removeBackend(e)}function gpe(e){return re.findBackend(e)}function ype(e){return re.findBackendFactory(e)}function N2(e,t,n=1){return re.registerBackend(e,t,n)}function CF(){return re.backend}function bpe(e,t){xe().setPlatform(e,t)}var Sh=4;async function xpe(e,t){let n=[],a=[],r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){let o=r[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async h=>{let p=await l.bytes(),m=p.reduce((b,v)=>b+v.length,0)+Sh*p.length,g=new Uint8Array(m),y=0;for(let b=0;b<p.length;b++){let v=p[b],w=new Uint8Array(new Uint32Array([v.length]).buffer);g.set(w,y),y+=Sh,g.set(v,y),y+=v.length}h(g)});a.push(c)}else a.push(l.data());t!=null&&(u.group=t),n.push(u)}let s=await Promise.all(a);return{data:Ape(s),specs:n}}function rq(e,t){let n=new lc(e),a={},r=0;for(let s of t){let i=vpe(s,(o,l)=>n.slice(r+o,r+l));a[s.name]=sq(s,n.slice(r,r+i)),r+=i}return a}function vpe(e,t){let n=Rn(e.shape),a;if("quantization"in e){let r=e.quantization;a=Np[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=Sh+new Uint32Array(t(r,r+Sh))[0];return r}else a=Np[e.dtype];return n*a}async function wpe(e,t){let n=Rn(e.shape),a;if("quantization"in e){let r=e.quantization;a=Np[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=Sh+new Uint32Array(await t(r,r+Sh))[0];return r}else a=Np[e.dtype];return n*a}function sq(e,t){let n=e.name,a=e.dtype,r=e.shape,s=Rn(r),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=Np[l.dtype],c=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(a==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let h=0;h<c.length;h++){let p=c[h];i[h]=p*l.scale+l.min}}else if(l.dtype==="float16")i=Epe()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(a==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let h=0;h<c.length;h++){let p=c[h];i[h]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*u}else if(a==="string"){let l=Rn(e.shape);i=[];for(let u=0;u<l;u++){let c=new Uint32Array(t.slice(o,o+Sh))[0];o+=Sh;let h=new Uint8Array(t.slice(o,o+c));i.push(h),o+=c}}else{let l=Np[a];if(a==="float32")i=new Float32Array(t);else if(a==="int32")i=new Int32Array(t);else if(a==="bool")i=new Uint8Array(t);else if(a==="complex64"){i=new Float32Array(t);let u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let g=0;g<u.length;g++)u[g]=i[g*2],c[g]=i[g*2+1];let h=Cs(u,r,"float32"),p=Cs(c,r,"float32"),m=Ju(h,p);return h.dispose(),p.dispose(),m}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*l}return Cs(i,r,a)}async function IG(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){let{done:r,value:s}=await e.read();if(r&&s==null){let o=n-a.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(a.length+s.byteLength);i.set(a,0),i.set(new Uint8Array(s),a.length),a=i}return a.buffer}async function iq(e,t){let n={},a=e.getReader(),r=new ArrayBuffer(0);for(let s of t){let i=await wpe(s,async(u,c)=>(r=await IG(a,r,c),r.slice(u,c)));r=await IG(a,r,i);let o=r.slice(0,i);r=r.slice(i);let l=sq(s,o);if(n[s.name]=l,aq()==="webgpu"){let u=CF();"uploadToGPU"in u&&Rn(l.shape)>=xe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function Ape(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let a=new Uint8Array(t),r=0;return n.forEach(s=>{a.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),a.buffer}var TF=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function NG(e){return TF?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Spe(e){if(TF)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}function kpe(e){if(TF){let a=Buffer.from(e,"base64");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}function Ipe(e){return lc.join(e)}function CG(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function oq(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function lq(e,t,n){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),a}async function EF(e,t){let n,a;return e.weightsManifest!=null&&([n,a]=await t(e.weightsManifest)),lq(e,n,a)}function d1(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:NG(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:NG(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new lc(e.weightData).byteLength}}function cD(e){let t=[];for(let n of e)t.push(...n.weights);return t}function Npe(){let e=n=>{let a=n<<13,r=0;for(;!(a&8388608);)r-=8388608,a<<=1;return a&=-8388609,r+=947912704,a|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Cpe(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function Tpe(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function Epe(){let e=Npe(),t=Cpe(),n=Tpe();return a=>{let r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){let o=a[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(r)}}var so=class Zo{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Zo.instance==null&&(Zo.instance=new Zo),Zo.instance}static registerSaveRouter(t){Zo.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Zo.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Zo.getHandlers(t,"save")}static getLoadHandlers(t,n){return Zo.getHandlers(t,"load",n)}static getHandlers(t,n,a){let r=[];return(n==="load"?Zo.getInstance().loadRouters:Zo.getInstance().saveRouters).forEach(s=>{let i=s(t,a);i!==null&&r.push(i)}),r}},$pe=e=>so.registerSaveRouter(e),_pe=e=>so.registerLoadRouter(e),Rpe=e=>so.getSaveHandlers(e),Dpe=(e,t)=>so.getLoadHandlers(e,t),hD="tensorflowjs",dD=1,up="models_store",uh="model_info_store";function uq(){if(!xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function pD(e){let t=e.result;t.createObjectStore(up,{keyPath:"modelPath"}),t.createObjectStore(uh,{keyPath:"modelPath"})}var Cp=class{constructor(e){if(this.indexedDB=uq(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,a)=>{let r=this.indexedDB.open(hD,dD);r.onupgradeneeded=()=>pD(r),r.onsuccess=()=>{let s=r.result;if(t==null){let i=s.transaction(up,"readonly"),o=i.objectStore(up).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),a(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=lc.join(t.weightData);let i=d1(t),o=s.transaction(uh,"readwrite"),l=o.objectStore(uh),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(h){return a(h)}let c;u.onsuccess=()=>{c=s.transaction(up,"readwrite");let h=c.objectStore(up),p;try{p=h.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(m){return a(m)}p.onsuccess=()=>n({modelArtifactsInfo:i}),p.onerror=m=>{l=o.objectStore(uh);let g=l.delete(this.modelPath);g.onsuccess=()=>(s.close(),a(p.error)),g.onerror=y=>(s.close(),a(p.error))}},u.onerror=h=>(s.close(),a(u.error)),o.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}}},r.onerror=s=>a(r.error)})}};Cp.URL_SCHEME="indexeddb://";var cq=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Cp.URL_SCHEME)?Ope(e.slice(Cp.URL_SCHEME.length)):null;so.registerSaveRouter(cq);so.registerLoadRouter(cq);function Ope(e){return new Cp(e)}function Fpe(e){return e.startsWith(Cp.URL_SCHEME)?e.slice(Cp.URL_SCHEME.length):e}var Mpe=class{constructor(){this.indexedDB=uq()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(hD,dD);n.onupgradeneeded=()=>pD(n),n.onsuccess=()=>{let a=n.result,r=a.transaction(uh,"readonly"),s=r.objectStore(uh).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=a=>t(n.error)})}async removeModel(e){return e=Fpe(e),new Promise((t,n)=>{let a=this.indexedDB.open(hD,dD);a.onupgradeneeded=()=>pD(a),a.onsuccess=()=>{let r=a.result,s=r.transaction(uh,"readwrite"),i=s.objectStore(uh),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=i.delete(e),c=()=>{l=r.transaction(up,"readwrite");let h=l.objectStore(up).delete(e);h.onsuccess=()=>t(o.result.modelArtifactsInfo),h.onerror=p=>n(o.error)};u.onsuccess=c,u.onerror=h=>(c(),r.close(),n(o.error))}},o.onerror=u=>(r.close(),n(o.error)),s.oncomplete=()=>{l==null?r.close():l.oncomplete=()=>r.close()}},a.onerror=r=>n(a.error)})}},Gu="/",jg="tensorflowjs_models",hq="info",Lpe="model_topology",zpe="weight_specs",Bpe="weight_data",Ppe="model_metadata";function dq(e){return{info:[jg,e,hq].join(Gu),topology:[jg,e,Lpe].join(Gu),weightSpecs:[jg,e,zpe].join(Gu),weightData:[jg,e,Bpe].join(Gu),modelMetadata:[jg,e,Ppe].join(Gu)}}function pq(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function Vpe(e){let t=e.split(Gu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Gu)}function Upe(e){return e.startsWith(Tp.URL_SCHEME)?e.slice(Tp.URL_SCHEME.length):e}var Tp=class{constructor(e){if(!xe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=dq(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=d1(e),r=lc.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Spe(r));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:a}}catch{throw pq(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;let r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){let i=JSON.parse(r);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=kpe(s),t}};Tp.URL_SCHEME="localstorage://";var fq=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Tp.URL_SCHEME)?Wpe(e.slice(Tp.URL_SCHEME.length)):null;so.registerSaveRouter(fq);so.registerLoadRouter(fq);function Wpe(e){return new Tp(e)}var Gpe=class{constructor(){J(xe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),J(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=jg+Gu,n=Gu+hq;for(let a=0;a<this.LS.length;++a){let r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){let s=Vpe(r);e[s]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=Upe(e);let t=dq(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return pq(t),n}},Jg="://",kh=class th{constructor(){this.managers={}}static getInstance(){return th.instance==null&&(th.instance=new th),th.instance}static registerManager(t,n){J(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Jg)&&(t=t.slice(0,t.indexOf(Jg))),J(t.length>0,()=>"scheme must not be an empty string.");let a=th.getInstance();J(a.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=n}static getManager(t){let n=th.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(th.getInstance().managers)}};function CI(e){if(e.indexOf(Jg)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${kh.getSchemes().join(",")}`);return{scheme:e.split(Jg)[0],path:e.split(Jg)[1]}}async function mq(e,t,n=!1){J(e!==t,()=>`Old path and new path are the same: '${e}'`);let a=so.getLoadHandlers(e);J(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),J(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);let r=a[0],s=so.getSaveHandlers(t);J(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),J(s.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);let i=s[0],o=CI(e).scheme,l=CI(e).path,u=o===CI(e).scheme,c=await r.load();n&&u&&await kh.getManager(o).removeModel(l);let h=await i.save(c);return n&&!u&&await kh.getManager(o).removeModel(l),h.modelArtifactsInfo}async function Hpe(){let e=kh.getSchemes(),t={};for(let n of e){let a=await kh.getManager(n).listModels();for(let r in a){let s=n+Jg+r;t[s]=a[r]}}return t}async function jpe(e){let t=CI(e);return kh.getManager(t.scheme).removeModel(t.path)}async function qpe(e,t){return mq(e,t,!1)}async function Kpe(e,t){return mq(e,t,!0)}var Xpe=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!xe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let a=this.functionRefs[n.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return G5(e)}};if(xe().get("IS_BROWSER")){xe().setPlatform("browser",new Xpe);try{kh.registerManager(Tp.URL_SCHEME,new Gpe)}catch{}try{kh.registerManager(Cp.URL_SCHEME,new Mpe)}catch{}}var Ype={importFetch:()=>Whe()},hR,Qpe=class{constructor(){this.util=Ghe(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return xe().global.fetch!=null?xe().global.fetch(e,t):(hR==null&&(hR=Ype.importFetch()),hR(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};xe().get("IS_NODE")&&!xe().get("IS_BROWSER")&&xe().setPlatform("node",new Qpe);function Wt(e,t="float32",n){return t=t||"float32",Li(e),new Za(e,t,n)}function Zpe(e,t){let n=K(e,"x","cast");if(!D5(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let a={x:n},r={dtype:t};return re.runKernel(yf,a,r)}var He=ie({cast_:Zpe});function Jpe(e){let t={x:K(e,"x","clone","string_or_numeric")};return re.runKernel(Mf,t)}var jl=ie({clone_:Jpe});function $F(e,t=!1){console.log(e.toString(t))}Z5();var efe={buffer:Wt,cast:He,clone:jl,print:$F};Yde(efe);function tfe(e,t){let n=K(e,"a","add"),a=K(t,"b","add");[n,a]=Ca(n,a);let r={a:n,b:a};return re.runKernel(Xh,r)}var Re=ie({add_:tfe});function nfe(e,t){let n=K(e,"a","floorDiv"),a=K(t,"b","floorDiv");[n,a]=Ca(n,a);let r={a:n,b:a};return re.runKernel(Df,r)}var C2=ie({floorDiv_:nfe});function afe(e,t){let n=K(e,"a","div"),a=K(t,"b","div");if([n,a]=Ca(n,a),n.dtype==="int32"&&a.dtype==="int32")return C2(n,a);let r={a:n,b:a},s={};return re.runKernel(Cf,r,s)}var st=ie({div_:afe});function rfe(e,t){let n=K(e,"a","mul"),a=K(t,"b","mul");[n,a]=Ca(n,a);let r={a:n,b:a};return re.runKernel(Zf,r)}var le=ie({mul_:rfe});function sfe(e){let t=K(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return re.runKernel(Gw,n)}else{let n={x:t};return re.runKernel(Wy,n)}}var Ka=ie({abs_:sfe});function ife(e){let t={x:K(e,"x","acos")};return re.runKernel(of,t)}var _F=ie({acos_:ife});function ofe(e){let t={x:K(e,"x","acosh")};return re.runKernel(lf,t)}var RF=ie({acosh_:ofe});function lfe(e){J(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),J(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((r,s)=>K(r,`tensors${s}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!oc(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let a=t;return re.runKernel(uf,a)}var gq=ie({addN_:lfe});function ufe(e,t=null,n=!1){let a={x:K(e,"x","all","bool")},r={axis:t,keepDims:n};return re.runKernel(Gy,a,r)}var T2=ie({all_:ufe});function cfe(e,t=null,n=!1){let a={x:K(e,"x","any","bool")},r={axis:t,keepDims:n};return re.runKernel(Hy,a,r)}var rw=ie({any_:cfe});function hfe(e,t=0){let n={x:K(e,"x","argMax")},a={axis:t};return re.runKernel(jy,n,a)}var Ep=ie({argMax_:hfe});function dfe(e,t=0){let n={x:K(e,"x","argMin")},a={axis:t};return re.runKernel(qy,n,a)}var DF=ie({argMin_:dfe});function pfe(e){let t={x:K(e,"x","asin")};return re.runKernel(cf,t)}var OF=ie({asin_:pfe});function ffe(e){let t={x:K(e,"x","asinh")};return re.runKernel(hf,t)}var FF=ie({asinh_:ffe});function mfe(e){let t={x:K(e,"x","atan")};return re.runKernel(df,t)}var MF=ie({atan_:mfe});function gfe(e,t){let n=K(e,"a","atan2"),a=K(t,"b","atan2");[n,a]=Ca(n,a);let r={a:n,b:a};return re.runKernel(ff,r)}var LF=ie({atan2_:gfe});function yfe(e){let t={x:K(e,"x","atanh")};return re.runKernel(pf,t)}var zF=ie({atanh_:yfe});function bfe(e,t,n,a,r="NHWC",s){let i=e[3],o=[...t,i],l=xq(r);return p1(e,o,n,s,a,null,null,l)}function yq(e,t,n,a,r,s,i="channelsLast"){let[o,l]=sw(t),u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return p1(e,u,n,a,r,s,!1,i)}function xfe(e,t,n,a,r,s,i="NDHWC"){let[o,l,u]=fD(t),c,h;if(i==="NDHWC")h="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")h="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return bq(e,c,n,a,r,!1,h,s)}function p1(e,t,n,a,r,s,i=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,h]=e;else if(o==="channelsFirst")[l,h,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);let[p,m,,g]=t,[y,b]=sw(n),[v,w]=sw(a),S=ey(p,v),k=ey(m,w),{padInfo:I,outHeight:T,outWidth:E}=Afe(r,u,c,y,b,S,k,s,o),R=i?g*h:g,D;return o==="channelsFirst"?D=[l,R,T,E]:o==="channelsLast"&&(D=[l,T,E,R]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:T,outWidth:E,outChannels:R,padInfo:I,strideHeight:y,strideWidth:b,filterHeight:p,filterWidth:m,effectiveFilterHeight:S,effectiveFilterWidth:k,dilationHeight:v,dilationWidth:w,inShape:e,outShape:D,filterShape:t}}function bq(e,t,n,a,r,s=!1,i="channelsLast",o){let[l,u,c,h,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,h,p]=e;else if(i==="channelsFirst")[l,p,u,c,h]=e;else throw new Error(`Unknown dataFormat ${i}`);let[m,g,y,,b]=t,[v,w,S]=fD(n),[k,I,T]=fD(a),E=ey(m,k),R=ey(g,I),D=ey(y,T),{padInfo:O,outDepth:$,outHeight:_,outWidth:P}=Sfe(r,u,c,h,v,w,S,E,R,D,o),U=s?b*p:b,W;return i==="channelsFirst"?W=[l,U,$,_,P]:i==="channelsLast"&&(W=[l,$,_,P,U]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:p,outDepth:$,outHeight:_,outWidth:P,outChannels:U,padInfo:O,strideDepth:v,strideHeight:w,strideWidth:S,filterDepth:m,filterHeight:g,filterWidth:y,effectiveFilterDepth:E,effectiveFilterHeight:R,effectiveFilterWidth:D,dilationDepth:k,dilationHeight:I,dilationWidth:T,inShape:e,outShape:W,filterShape:t}}function vfe(e,t,n,a,r){a==null&&(a=BF(e,t,n));let s=e[0],i=e[1],o=iw((s-t+2*a)/n+1,r),l=iw((i-t+2*a)/n+1,r);return[o,l]}function wfe(e,t,n,a,r,s){r==null&&(r=BF(e,t[0],a[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=iw((e[o]-t[o]+2*r)/a[o]+1,s));return i}function BF(e,t,n,a=1){let r=ey(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function sw(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function fD(e){return typeof e=="number"?[e,e,e]:e}function ey(e,t){return t<=1?e:e+(e-1)*(t-1)}function Afe(e,t,n,a,r,s,i,o,l){let u,c,h;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let p=vfe([t,n],s,a,e,o);c=p[0],h=p[1]}else if(e==="same"){c=Math.ceil(t/a),h=Math.ceil(n/r);let p=Math.max(0,(c-1)*a+s-t),m=Math.max(0,(h-1)*r+i-n),g=Math.floor(p/2),y=p-g,b=Math.floor(m/2),v=m-b;u={top:g,bottom:y,left:b,right:v,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/a),h=Math.ceil((n-i+1)/r);else if(typeof e=="object"){let p=l==="channelsLast"?e[1][0]:e[2][0],m=l==="channelsLast"?e[1][1]:e[2][1],g=l==="channelsLast"?e[2][0]:e[3][0],y=l==="channelsLast"?e[2][1]:e[3][1];u={top:p,bottom:m,left:g,right:y,type:p===0&&m===0&&g===0&&y===0?"VALID":"EXPLICIT"},c=iw((t-s+p+m)/a+1,o),h=iw((n-i+g+y)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:h}}function Sfe(e,t,n,a,r,s,i,o,l,u,c){let h,p,m,g;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let y=wfe([t,n,a,1],[o,l,u],1,[r,s,i],e,c);p=y[0],m=y[1],g=y[2]}else if(e==="same"){p=Math.ceil(t/r),m=Math.ceil(n/s),g=Math.ceil(a/i);let y=(p-1)*r+o-t,b=(m-1)*s+l-n,v=(g-1)*i+u-a,w=Math.floor(y/2),S=y-w,k=Math.floor(b/2),I=b-k,T=Math.floor(v/2),E=v-T;h={top:k,bottom:I,left:T,right:E,front:w,back:S,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:p,outHeight:m,outWidth:g}}function iw(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ih(e){let[t,n,a]=sw(e);return t===1&&n===1&&a===1}function hu(e,t){return Ih(e)||Ih(t)}function $p(e){return sw(e).every(t=>t>0)}function xq(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Os(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")J(ly(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(a=>{a.forEach(r=>{J(ly(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function kfe(e,t){let n={x:K(e,"x","reshape","string_or_numeric")},a={shape:t};return re.runKernel(Cb,n,a)}var pe=ie({reshape_:kfe});function Ife(e,t,n,a,r){let s=K(e,"x","avgPool","float32"),i=1;J(hu(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=pe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),J(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Os("avgPool",a,r);let u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},h=re.runKernel(mf,u,c);return h=He(h,s.dtype),l?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var uc=ie({avgPool_:Ife});function Nfe(e,t,n,a,r,s="NDHWC"){let i=K(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=pe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),J(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),J(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),J(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Os("avgPool3d",a,r);let u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=re.runKernel(Ky,u,c);return h=He(h,o.dtype),l?pe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var PF=ie({avgPool3d_:Nfe});function Cfe(e,t=0){J(e.length>=1,()=>"Pass at least one tensor to concat");let n=aw(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return jl(n[0]);let a=n,r={axis:t};return re.runKernel(Zy,a,r)}var Un=ie({concat_:Cfe});function Tfe(e,t,n=!1,a=!1){let r=K(e,"a","matMul"),s=K(t,"b","matMul");[r,s]=Ca(r,s);let i={a:r,b:s},o={transposeA:n,transposeB:a};return re.runKernel(gf,i,o)}var Vt=ie({matMul_:Tfe});function Efe(e){let t={x:K(e,"x","sigmoid","float32")};return re.runKernel(gm,t)}var Mo=ie({sigmoid_:Efe});function $fe(e,t,n){let a=K(e,"x","slice","string_or_numeric");if(a.rank===0)throw new Error("Slicing scalar is not possible");let r={x:a},s={begin:t,size:n};return re.runKernel(Ob,r,s)}var en=ie({slice_:$fe});function _fe(e){let t={x:K(e,"x","tanh","float32")};return re.runKernel(km,t)}var Nh=ie({tanh_:_fe});function Rfe(e,t,n,a,r,s){let i=K(e,"forgetBias","basicLSTMCell"),o=K(t,"lstmKernel","basicLSTMCell"),l=K(n,"lstmBias","basicLSTMCell"),u=K(a,"data","basicLSTMCell"),c=K(r,"c","basicLSTMCell"),h=K(s,"h","basicLSTMCell"),p=Un([u,h],1),m=Vt(p,o),g=Re(m,l),y=g.shape[0],b=g.shape[1]/4,v=[y,b],w=en(g,[0,0],v),S=en(g,[0,b],v),k=en(g,[0,b*2],v),I=en(g,[0,b*3],v),T=Re(le(Mo(w),Nh(S)),le(c,Mo(Re(i,k)))),E=le(Nh(T),Mo(I));return[T,E]}var vq=ie({basicLSTMCell_:Rfe});function Dfe(e,t,n){let a=K(e,"x","batchToSpaceND"),r=t.reduce((o,l)=>o*l);J(a.rank>=1+t.length,()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`),J(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),J(a.shape[0]%r===0,()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);let s={x:a},i={blockShape:t,crops:n};return re.runKernel(Xy,s,i)}var f1=ie({batchToSpaceND_:Dfe});function Ofe(e){let t;return e.rank===0||e.rank===1?t=pe(e,[1,1,1,e.size]):e.rank===2?t=pe(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function Ffe(e,t,n,a,r,s){s==null&&(s=.001);let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;r!=null&&(u=K(r,"scale","batchNorm"));let c;a!=null&&(c=K(a,"offset","batchNorm")),J(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let h={x:Ofe(i),scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:s},m=re.runKernel(Of,h,p);return pe(m,i.shape)}var Im=ie({batchNorm_:Ffe});function Mfe(e,t,n,a,r,s){let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;r!=null&&(u=K(r,"scale","batchNorm"));let c;return a!=null&&(c=K(a,"offset","batchNorm")),J(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),J(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),J(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Im(i,o,l,c,u,s)}var VF=ie({batchNorm2d_:Mfe});function Lfe(e,t,n,a,r,s){let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;r!=null&&(u=K(r,"scale","batchNorm"));let c;return a!=null&&(c=K(a,"offset","batchNorm")),J(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),J(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),J(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Im(i,o,l,c,u,s)}var UF=ie({batchNorm3d_:Lfe});function zfe(e,t,n,a,r,s){let i=K(e,"x","batchNorm"),o=K(t,"mean","batchNorm"),l=K(n,"variance","batchNorm"),u;r!=null&&(u=K(r,"scale","batchNorm"));let c;return a!=null&&(c=K(a,"offset","batchNorm")),J(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),J(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),J(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Im(i,o,l,c,u,s)}var WF=ie({batchNorm4d_:zfe});function Bfe(e,t,n){let a=K(e,"x","bincount"),r=K(t,"weights","bincount");J(a.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`),J(n>=0,()=>`size must be non-negative, but got ${n}.`),J(r.size===a.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);let s={x:a,weights:r},i={size:n};return re.runKernel(Yy,s,i)}var GF=ie({bincount_:Bfe});function Pfe(e,t){let n=K(e,"x","bitwiseAnd"),a=K(t,"y","bitwiseAnd");if(!oc(n.shape,a.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);if(n.dtype!=="int32"||a.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);let r={a:n,b:a};return re.runKernel(Qy,r)}var wq=ie({bitwiseAnd_:Pfe});function Vfe(e,t){let n=K(e,"s0","broadcastArgs","int32"),a=K(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(a.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);let r={s0:n,s1:a};return re.runKernel(Ww,r)}var Aq=ie({broadcastArgs_:Vfe});function Ufe(e,t){let n=K(e,"broadcastTo","x"),a=n.shape;if(Li(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=pe(n,l)}let r=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return jl(n);let i={x:n},o={reps:s};return re.runKernel(Qh,i,o)}var pp=ie({broadcastTo_:Ufe});function Wfe(e){let t={x:K(e,"x","ceil","float32")};return re.runKernel(bf,t)}var HF=ie({ceil_:Wfe});function Ni(e,t,n){Li(e),n=n||Pw(t);let a={shape:e,value:t,dtype:n};return re.runKernel(qw,{},a)}function Gfe(e,t,n){let a=K(e,"x","clipByValue");if(J(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Ni(a.shape,t,a.dtype);let r={x:a},s={clipValueMin:t,clipValueMax:n};return re.runKernel(Yh,r,s)}var hs=ie({clipByValue_:Gfe});function Hfe(e){return Un(e,0)}var jF=ie({concat1d_:Hfe});function jfe(e,t){return Un(e,t)}var qF=ie({concat2d_:jfe});function qfe(e,t){return Un(e,t)}var KF=ie({concat3d_:qfe});function Kfe(e,t){return Un(e,t)}var XF=ie({concat4d_:Kfe});function Xfe(e,t,n,a,r="NHWC",s=[1,1],i){let o=K(e,"x","conv2d","float32"),l=K(t,"filter","conv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),J(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Os("conv2d",a,i);let h=r==="NHWC"?u.shape[3]:u.shape[1];J(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),J(hu(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),J($p(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),J($p(n),()=>"Error in conv2D: Strides should be larger than 0.");let p={x:u,filter:l},m={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},g=re.runKernel(xf,p,m);return c?pe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Ts=ie({conv2d_:Xfe});function Yfe(e,t,n,a,r="NWC",s=1,i){let o=K(e,"x","conv1d"),l=K(t,"filter","conv1d"),u=o,c=!1;o.rank===2&&(c=!0,u=pe(o,[1,o.shape[0],o.shape[1]])),J(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),J(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Os("conv1d",a,i),J(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),J(hu(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),J($p(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),J($p(n),()=>"Error in conv1D: Stride should be larger than 0."),J(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let h=pe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=pe(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=Ts(p,h,[1,n],a,"NHWC",[1,s],i);return c?pe(m,[m.shape[2],m.shape[3]]):pe(m,[m.shape[0],m.shape[2],m.shape[3]])}var E2=ie({conv1d_:Yfe});function Qfe(e,t,n,a,r,s="NHWC",i){J(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),J(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),J(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),J(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=s==="NHWC"?o[3]:o[1],h=s==="NHWC"?l.shape[3]:l.shape[1];J(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),J(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),Os("conv2dDerInput",r,i);let p={dy:l,filter:n},m={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},g=re.runKernel(vf,p,m);return u?pe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var YF=ie({conv2DBackpropInput_:Qfe});function Zfe(e,t,n,a,r,s){let i=K(e,"x","conv2dTranspose"),o=K(t,"filter","conv2dTranspose");return YF(n,i,o,a,r,"NHWC",s)}var $2=ie({conv2dTranspose_:Zfe});function Jfe(e,t,n,a,r="NDHWC",s=[1,1,1]){let i=K(e,"x","conv3d"),o=K(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=pe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),J(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),J(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),J(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),J(hu(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),J(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),J($p(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),J($p(n),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:o},h={strides:n,pad:a,dataFormat:r,dilations:s},p=re.runKernel(wf,c,h);return u?pe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var QF=ie({conv3d_:Jfe});function eme(e,t,n,a,r){J(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=pe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];J(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),J(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),J(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),J(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),J(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let c={dy:i,filter:n},h={pad:r,strides:a,inputShape:s},p=re.runKernel(eb,c,h);return o?pe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Sq=ie({conv3DBackpropInput_:eme});function tme(e,t,n,a,r){let s=K(e,"x","conv3dTranspose"),i=K(t,"filter","conv3dTranspose");return Sq(n,s,i,a,r)}var ZF=ie({conv3dTranspose_:tme});function nme(e){let t={x:K(e,"x","cos","float32")};return re.runKernel(Af,t)}var m1=ie({cos_:nme});function ame(e){let t={x:K(e,"x","cosh","float32")};return re.runKernel(Sf,t)}var _2=ie({cosh_:ame});function rme(e,t=0,n=!1,a=!1){let r={x:K(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:a};return re.runKernel(tb,r,s)}var ow=ie({cumprod_:rme});function sme(e,t=0,n=!1,a=!1){let r={x:K(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return re.runKernel(kf,r,s)}var R2=ie({cumsum_:sme});function ime(e,t,n,a=!1){let r=K(e,"x","denseBincount"),s=K(t,"weights","denseBincount");J(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),J(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),J(n>=0,()=>`size must be non-negative, but got ${n}.`),J(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);let i={x:r,weights:s},o={size:n,binaryOutput:a};return re.runKernel(Hw,i,o)}var JI=ie({denseBincount_:ime});function ome(e,t,n="NHWC"){let a=K(e,"x","depthToSpace","float32"),r=n==="NHWC"?a.shape[1]:a.shape[2],s=n==="NHWC"?a.shape[2]:a.shape[3],i=n==="NHWC"?a.shape[3]:a.shape[1];J(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),J(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${a.shape}`),J(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${a.shape}`),J(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${a.shape}`);let o={x:a},l={blockSize:t,dataFormat:n};return re.runKernel(ab,o,l)}var JF=ie({depthToSpace_:ome});function lme(e,t,n,a,r="NHWC",s=[1,1],i){let o=K(e,"x","depthwiseConv2d","float32"),l=K(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),J(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let h=r==="NHWC"?u.shape[3]:u.shape[1];J(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Os("depthwiseConv2d",a,i);let p={x:u,filter:l},m={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},g=re.runKernel(If,p,m);return c?pe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Nm=ie({depthwiseConv2d_:lme});function ume(e){let t={x:K(e,"x","diag")};return re.runKernel(jw,t)}var kq=ie({diag_:ume});function cme(e,t,n,a,r=[1,1],s="NHWC"){let i=K(e,"x","dilation2d"),o=K(t,"filter","dilation2d");J(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),J(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),J(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),J(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let c={x:l,filter:o},h={strides:n,pad:a,dilations:r},p=re.runKernel(Nf,c,h);return u?pe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var eM=ie({dilation2d_:cme}),Hb={};Lt(Hb,{assertAndGetBroadcastShape:()=>Wn,getBroadcastDims:()=>Iq,getReductionAxes:()=>tr});function Iq(e,t){let n=e.length,a=[];for(let r=0;r<n;r++){let s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&i===1&&a.unshift(s)}return a}function tr(e,t){let n=[];for(let a=0;a<t.length;a++){let r=e[e.length-a-1],s=t.length-a-1,i=t[s];(r==null||r===1&&i>1)&&n.unshift(s)}return n}function Wn(e,t){let n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];s==null&&(s=1);let i=t[t.length-r-1];if(i==null&&(i=1),s===1)a[n-r-1]=i;else if(i===1)a[n-r-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else a[n-r-1]=s}return a}function hme(e,t){let n=K(e,"a","equal","string_or_numeric"),a=K(t,"b","equal","string_or_numeric");[n,a]=Ca(n,a),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(sb,r)}var Ei=ie({equal_:hme});function dme(e,t,n){let a=K(t,"a","where"),r=K(n,"b","where"),s=K(e,"condition","where","bool"),i=Wn(Wn(s.shape,a.shape),r.shape),o=pp(s,i),l=pp(a,i),u=pp(r,i),c={condition:o,t:l,e:u};return re.runKernel(Db,c)}var Dr=ie({where_:dme});function pme(e){let t={x:K(e,"x","zerosLike")};return re.runKernel(Wb,t)}var un=ie({zerosLike_:pme});function fme(e,t){let n=K(e,"a","div"),a=K(t,"b","div");[n,a]=Ca(n,a);let r=st(n,a),s=un(r),i=Ei(a,s);return Dr(i,s,r)}var tM=ie({divNoNan_:fme});function mme(e,t){let n=K(e,"t1","dot"),a=K(t,"t2","dot");J((n.rank===1||n.rank===2)&&(a.rank===1||a.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);let r=n.rank===1?n.size:n.shape[1],s=a.rank===1?a.size:a.shape[0];if(J(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),n.rank===1&&a.rank===1){let i=pe(n,[1,-1]),o=pe(a,[-1,1]),l=Vt(i,o);return pe(l,[])}else if(n.rank===1&&a.rank===2){let i=pe(n,[1,-1]),o=pe(a,[a.shape[0],a.shape[1]]),l=Vt(i,o);return pe(l,[l.size])}else if(n.rank===2&&a.rank===1){let i=pe(a,[-1,1]),o=Vt(n,i);return pe(o,[o.size])}else{let i=pe(a,[a.shape[0],a.shape[1]]);return Vt(n,i)}}var nM=ie({dot_:mme});function gme(e,...t){let n=t.map((r,s)=>K(r,`tensors${s}`,"einsum")),a={equation:e};return re.runKernel(g2,n,a)}var ep=ie({einsum_:gme});function yme(e){let t={x:K(e,"x","elu","float32")};return re.runKernel(Tf,t)}var jb=ie({elu_:yme});function bme(e,t){let n=K(e,"x","ensureShape","string_or_numeric");if(!E5(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var Nq=ie({ensureShape_:bme});function xme(e){let t=K(e,"x","erf");J(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=He(t,"float32"));let n={x:t};return re.runKernel(Ef,n)}var D2=ie({erf_:xme});function aM(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Cq(e,t,n){let a=e.length+t.length,r=[],s=0,i=0;for(let o=0;o<a;o++)n.indexOf(o)===-1?r.push(e[s++]):r.push(t[i++]);return r}function Tq(e,t){let n=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&n.push(e[s]);let r=t.map(s=>e[s]);return[n,r]}function _p(e,t){let n=t.map(a=>1);return Cq(e,n,t)}function vme(e,t,n){J(aM(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Eq(e,t){if(aM(e,t))return null;let n=[];for(let a=0;a<t;++a)e.indexOf(a)===-1&&n.push(a);return e.forEach(a=>n.push(a)),n}function rM(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function wme(e,t){let n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function Ame(e,t=null,n=!1){let a={x:K(e,"x","max")},r={reductionIndices:t,keepDims:n};return re.runKernel(Gf,a,r)}var to=ie({max_:Ame});function Sme(e,t=null,n=!1){let a={x:K(e,"x","min")},r={axis:t,keepDims:n};return re.runKernel(Kf,a,r)}var dy=ie({min_:Sme});function kme(e,t){let n=K(e,"base","pow"),a=K(t,"exp","pow");[n,a]=Ca(n,a);let r={a:n,b:a};return re.runKernel(tm,r)}var tu=ie({pow_:kme});function xt(e,t){if((Cr(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Cr(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Jh(e,[],[],t)}function Ime(e){let t={x:K(e,"x","sqrt","float32")};return re.runKernel(bm,t)}var Or=ie({sqrt_:Ime});function Nme(e){let t=K(e,"x","square"),n={};return re.runKernel("Square",{x:t},n)}var Pn=ie({square_:Nme});function Cme(e,t=null,n=!1){let a=K(e,"x","sum");a.dtype==="bool"&&(a=He(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return re.runKernel(xm,r,s)}var ut=ie({sum_:Cme});function Tme(e,t="euclidean",n=null,a=!1){e=K(e,"x","norm");let r=$q(e,t,n),s=r.shape;if(a){let i=Po(n,e.shape);s=_p(r.shape,i)}return pe(r,s)}function $q(e,t,n=null){if(e.rank===0)return Ka(e);if(e.rank!==1&&n===null)return $q(pe(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ut(Ka(e),n);if(t===1/0)return to(Ka(e),n);if(t===-1/0)return dy(Ka(e),n);if(t==="euclidean"||t===2)return Or(ut(tu(Ka(e),xt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return to(ut(Ka(e),n[0]),n[1]-1);if(t===1/0)return to(ut(Ka(e),n[1]),n[0]);if(t===-1/0)return dy(ut(Ka(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Or(ut(Pn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var qb=ie({norm_:Tme});function Eme(e,t=null,n=!1){return qb(e,"euclidean",t,n)}var sM=ie({euclideanNorm_:Eme});function $me(e){let t={x:K(e,"x","exp")};return re.runKernel($f,t)}var ds=ie({exp_:$me});function _me(e,t=0){let n=K(e,"x","expandDims","string_or_numeric");J(t<=n.rank,()=>"Axis must be <= rank of the tensor");let a={input:n},r={dim:t};return re.runKernel(ib,a,r)}var Tr=ie({expandDims_:_me});function Rme(e){let t={x:K(e,"x","expm1")};return re.runKernel(_f,t)}var iM=ie({expm1_:Rme});function Dme(e,t){let n=K(e,"x","tile","string_or_numeric");J(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let a={x:n},r={reps:t};return re.runKernel(Qh,a,r)}var Ii=ie({tile_:Dme});function Ome(e,t,n,a="float32"){t==null&&(t=e);let r=Wt([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);let i=pe(r.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Ii(Tr(i,0),[n[0],1,1]);if(n.length===2)return Ii(Tr(Tr(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ii(Tr(Tr(Tr(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var O2=ie({eye_:Ome});function Fme(e){let t={x:K(e,"x","floor","float32")};return re.runKernel(Rf,t)}var Kb=ie({floor_:Fme});function Mme(e,t,n=0,a=0){let r=K(e,"x","gather"),s=K(t,"indices","gather","int32"),i={x:r,indices:s},o={axis:n,batchDims:a};return re.runKernel(lb,i,o)}var Xb=ie({gather_:Mme});function Lme(e,t){let n=K(e,"a","greater","string_or_numeric"),a=K(t,"b","greater","string_or_numeric");[n,a]=Ca(n,a),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(cb,r)}var Fs=ie({greater_:Lme});function zme(e,t){let n=K(e,"a","greaterEqual","string_or_numeric"),a=K(t,"b","greaterEqual","string_or_numeric");[n,a]=Ca(n,a),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(Ff,r)}var cc=ie({greaterEqual_:zme});function Bme(e){let t={input:K(e,"input","imag")};return re.runKernel(x2,t)}var g1=ie({imag_:Bme});function Pme(e){let t={x:K(e,"x","isFinite")};return re.runKernel(Lf,t)}var oM=ie({isFinite_:Pme});function Vme(e){let t={x:K(e,"x","isInf")};return re.runKernel(zf,t)}var lM=ie({isInf_:Vme});function Ume(e){let t={x:K(e,"x","isNaN")};return re.runKernel(Bf,t)}var uM=ie({isNaN_:Ume});function Wme(e,t=.2){let n={x:K(e,"x","leakyRelu")},a={alpha:t};return re.runKernel(Pf,n,a)}var y1=ie({leakyRelu_:Wme});function Gme(e,t){let n=K(e,"a","less","string_or_numeric"),a=K(t,"b","less","string_or_numeric");[n,a]=Ca(n,a),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(hb,r)}var py=ie({less_:Gme});function Hme(e,t){let n=K(e,"a","lessEqual","string_or_numeric"),a=K(t,"b","lessEqual","string_or_numeric");[n,a]=Ca(n,a),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(db,r)}var ed=ie({lessEqual_:Hme});function _q(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let a={start:e,stop:t,num:n};return re.runKernel(pb,{},a)}function jme(e,t=5,n=1,a=1,r=.5){let s=K(e,"x","localResponseNormalization");J(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),J(ly(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=pe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:a,beta:r},c=re.runKernel(Wf,l,u);return o?pe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var cM=ie({localResponseNormalization_:jme});function qme(e){let t={x:K(e,"x","log","float32")};return re.runKernel(Vf,t)}var $i=ie({log_:qme});function Kme(e){let t={x:K(e,"x","log1p")};return re.runKernel(Uf,t)}var b1=ie({log1p_:Kme});function Xme(e){return J(wh(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let a=K(t,"x","tf.grad","string_or_numeric"),r=n!=null?K(n,"dy","tf.grad"):null;return re.tidy(()=>{let{value:s,grads:i}=re.gradients(()=>e(a),[a],r);return r!=null&&Ds(s.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),F2(i),i[0]})}}function Yme(e){return J(wh(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{J(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let a=aw(t,"args","tf.grads","string_or_numeric"),r=n!=null?K(n,"dy","tf.grads"):null;return re.tidy(()=>{let{value:s,grads:i}=re.gradients(()=>e(...a),a,r);return r!=null&&Ds(s.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),F2(i),i})}}function Qme(e){return J(wh(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{J(t instanceof Bt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),J(n==null||n instanceof Bt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:a,value:r}=re.gradients(()=>e(t),[t],n);return F2(a),{grad:a[0],value:r}}}function Zme(e){return J(wh(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{J(Array.isArray(t)&&t.every(r=>r instanceof Bt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),J(n==null||n instanceof Bt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let a=re.gradients(()=>e(...t),t,n);return n!=null&&Ds(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),F2(a.grads),a}}function Rq(e,t){J(wh(e),()=>"The f passed in variableGrads(f) must be a function"),J(t==null||Array.isArray(t)&&t.every(u=>u instanceof Ip),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let u in re.registeredVariables)t.push(re.registeredVariables[u])}let a=n?t.filter(u=>!u.trainable):null,r=t.length;t=t.filter(u=>u.trainable),J(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let s=!0,{value:i,grads:o}=re.gradients(e,t,null,s);J(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),J(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),a?.forEach(u=>l[u.name]=null),{value:i,grads:l}}function nu(e){return re.customGrad(e)}function F2(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Jme(e){let t={x:K(e,"x","neg")};return re.runKernel(vb,t)}var sa=ie({neg_:Jme});function ege(e){let t={x:K(e,"x","softplus")};return re.runKernel(ym,t)}var Cm=ie({softplus_:ege});function tge(e){let t=K(e,"x","logSigmoid");return nu(n=>({value:sa(Cm(sa(n))),gradFunc:a=>le(a,Mo(sa(n)))}))(t)}var hM=ie({logSigmoid_:tge});function nge(e,t){let n=K(e,"a","sub"),a=K(t,"b","sub");[n,a]=Ca(n,a);let r={a:n,b:a};return re.runKernel(Am,r)}var nt=ie({sub_:nge});function age(e,t=-1){let n=K(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return nu((a,r)=>{let s=to(a,t,!0),i=nt(a,s),o=nt(He(i,"float32"),$i(ut(ds(i),t,!0)));return r([o]),{value:o,gradFunc:(l,u)=>{let[c]=u,h=!0,p=ds(c);return nt(l,le(ut(l,t,h),p))}}})(n)}var M2=ie({logSoftmax_:age});function rge(e,t=null,n=!1){let a=K(e,"x","logSumExp"),r=Po(t,a.shape),s=to(a,r,!0),i=nt(a,s),o=ds(i),l=ut(o,r),u=$i(l),c=Re(pe(s,u.shape),u);if(n){let h=_p(c.shape,r);return pe(c,h)}return c}var x1=ie({logSumExp_:rge});function sge(e,t){let n=K(e,"a","logicalAnd","bool"),a=K(t,"b","logicalAnd","bool");Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(fb,r)}var zo=ie({logicalAnd_:sge});function ige(e){let t={x:K(e,"x","logicalNot","bool")};return re.runKernel(mb,t)}var v1=ie({logicalNot_:ige});function oge(e,t){let n=K(e,"a","logicalOr","bool"),a=K(t,"b","logicalOr","bool");Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(gb,r)}var L2=ie({logicalOr_:oge});function lge(e,t){let n=K(e,"a","logicalXor","bool"),a=K(t,"b","logicalXor","bool");return Wn(n.shape,a.shape),zo(L2(e,t),v1(zo(e,t)))}var dM=ie({logicalXor_:lge}),Wk=2147483648;function uge(e,t,n="left"){let a=K(e,"sortedSequence","searchSorted"),r=K(t,"values","searchSorted"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=pe(a,[-1,s]),l=pe(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Rn(l.shape)>=Wk)throw new Error(`values tensor size must less than ${Wk}`);if(o.shape[1]>=Wk)throw new Error(`trailing dim_size must less than ${Wk} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return re.runKernel(Rb,u,c)}var z2=ie({searchSorted_:uge});function Dq(e,t){return z2(e,t,"left")}function cge(e,t,n,a,r){let s=K(e,"x","maxPool"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=pe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),J(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),J(hu(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Os("maxPool",a,r);let u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},h=re.runKernel(jf,u,c);return l?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var kr=ie({maxPool_:cge});function hge(e,t=[1,1,1],n,a,r,s="NDHWC"){let i=K(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=pe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),J(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),J(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Os("maxPool3d",a,r);let u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=re.runKernel(bb,u,c);return l?pe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var pM=ie({maxPool3d_:hge});function dge(e,t,n,a,r=!1){let s={x:K(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},o=re.runKernel(Yw,s,i);return{result:o[0],indexes:o[1]}}var Oq=ie({maxPoolWithArgmax_:dge});function pge(e,t){let n=K(e,"a","maximum"),a=K(t,"b","maximum");[n,a]=Ca(n,a),n.dtype==="bool"&&(n=He(n,"int32"),a=He(a,"int32")),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(Hf,r)}var du=ie({maximum_:pge});function fge(e,t=null,n=!1){let a={x:K(e,"x","mean")},r={axis:t,keepDims:n};return re.runKernel(qf,a,r)}var wa=ie({mean_:fge});function Aa(e,t="float32"){if(Li(e),t==="complex64"){let a=Aa(e,"float32"),r=Aa(e,"float32");return Ju(a,r)}let n=u2(Rn(e),t);return re.makeTensor(n,e,t)}function js(e,t="float32"){if(Li(e),t==="complex64"){let a=js(e,"float32"),r=Aa(e,"float32");return Ju(a,r)}let n=vF(Rn(e),t);return re.makeTensor(n,e,t)}function Fq(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let a=K(e,"x","meshgrid",e instanceof Bt?e.dtype:"float32");if(t===void 0)return[a];let r=K(t,"y","meshgrid",t instanceof Bt?t.dtype:"float32"),s=Rn(a.shape),i=Rn(r.shape);return n==="xy"?(a=pe(a,[1,-1]),r=pe(r,[-1,1]),[Vt(js([i,1],a.dtype),a),Vt(r,js([1,s],r.dtype))]):(a=pe(a,[-1,1]),r=pe(r,[1,-1]),[Vt(a,js([1,i],a.dtype)),Vt(js([s,1],r.dtype),r)])}function mge(e,t){let n=K(e,"a","minimum"),a=K(t,"b","minimum");[n,a]=Ca(n,a),n.dtype==="bool"&&(n=He(n,"int32"),a=He(a,"int32")),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(Xf,r)}var Ch=ie({minimum_:mge});function gge(e,t,n){J(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let a=K(e,"x","mirrorPad");if(a.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");J(t.length===a.rank,()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);let r=n==="reflect"?1:0;for(let o=0;o<a.rank;o++)J(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),J(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${a.shape[o]-r} or less than 0 for input of shape ${a.shape}`);let s={paddings:t,mode:n},i={x:a};return re.runKernel(Yf,i,s)}var fM=ie({mirrorPad_:gge});function yge(e,t){let n=K(e,"a","mod"),a=K(t,"b","mod");[n,a]=Ca(n,a);let r={a:n,b:a};return re.runKernel(Qf,r)}var mM=ie({mod_:yge});function bge(e,t=null,n=!1){e=K(e,"x","moments");let a=Po(t,e.shape),r=wa(e,a,n),s=r.shape;n||(s=_p(r.shape,a));let i=Pn(nt(He(e,"float32"),pe(r,s))),o=wa(i,a,n);return{mean:r,variance:o}}var w1=ie({moments_:bge});function xge(e,t,n,a){let r=K(t,"data","multiRNNCell"),s=aw(n,"c","multiRNNCell"),i=aw(a,"h","multiRNNCell"),o=r,l=[];for(let h=0;h<e.length;h++){let p=e[h](o,s[h],i[h]);l.push(p[0]),l.push(p[1]),o=p[1]}let u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}var Mq=ie({multiRNNCell_:xge});function vge(e,t,n,a=!1){let r=K(e,"logits","multinomial"),s=r.size,i=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?pe(r,[1,-1]):r},l={numSamples:t,seed:n,normalized:a},u=re.runKernel(xb,o,l);return i===1?pe(u,[u.size]):u}var Lq=ie({multinomial_:vge});function wge(e,t){let n=K(e,"a","notEqual","string_or_numeric"),a=K(t,"b","notEqual","string_or_numeric");[n,a]=Ca(n,a),Wn(n.shape,a.shape);let r={a:n,b:a};return re.runKernel(wb,r)}var Rp=ie({notEqual_:wge});function Age(e,t,n=1,a=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:K(e,"indices","oneHot","int32")},i={dtype:r,depth:t,onValue:n,offValue:a};return re.runKernel(Jf,s,i)}var fy=ie({oneHot_:Age});function Sge(e){let t={x:K(e,"x","onesLike")};return re.runKernel(Ib,t)}var _i=ie({onesLike_:Sge});function kge(e,t){let n=K(e,"v1","outerProduct"),a=K(t,"v2","outerProduct");J(n.rank===1&&a.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);let r=pe(n,[-1,1]),s=pe(a,[1,-1]);return Vt(r,s)}var zq=ie({outerProduct_:kge});function Ige(e,t,n=0){let a=K(e,"x","pad");if(a.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let r={paddings:t,constantValue:n},s={x:a};return re.runKernel(em,s,r)}var wl=ie({pad_:Ige});function Nge(e,t,n=0){return J(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),wl(e,[t],n)}var Bq=ie({pad1d_:Nge});function Cge(e,t,n=0){return J(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wl(e,t,n)}var Pq=ie({pad2d_:Cge});function Tge(e,t,n=0){return J(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wl(e,t,n)}var Vq=ie({pad3d_:Tge});function Ege(e,t,n=0){return J(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wl(e,t,n)}var Uq=ie({pad4d_:Ege});function $ge(e,t,n){let a=K(e,"x","spaceToBatchND");J(a.rank>=1+t.length,()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`),J(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),J(a.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:a},s={blockShape:t,paddings:n};return re.runKernel(Fb,r,s)}var A1=ie({spaceToBatchND_:$ge});function _ge(e,t,n,a,r,s,i){r==null&&(r=[1,1]),s==null&&(s=1),a===0&&(a="valid");let o=K(e,"x","maxPool"),l=o,u=!1;o.rank===3&&(u=!0,l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(hu(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);let c=yq(l.shape,t,s,r,a),h=[c.dilationHeight,c.dilationWidth],p;a==="same"?p=Dge([c.filterHeight,c.filterWidth],h):p=[[0,0],[0,0]];let m=h[0]===1&&h[1]===1,[g,y]=Rge([c.inHeight,c.inWidth],h,p),b=m?a:"valid",v=m?l:A1(l,h,g),w=(n==="avg"?()=>uc(v,t,s,b,i):()=>kr(v,t,s,b,i))(),S=m?w:f1(w,h,y);return u?pe(S,[S.shape[1],S.shape[2],S.shape[3]]):S}function Rge(e,t,n){let a=n.map(c=>c[0]),r=n.map(c=>c[1]),s=e.concat(a,r),i=t.map((c,h)=>(c-s[h]%c)%c),o=r.map((c,h)=>c+i[h]),l=t.map((c,h)=>[a[h],o[h]]),u=t.map((c,h)=>[0,i[h]]);return[l,u]}function Dge(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),a=n.map(s=>Math.floor(s/2)),r=n.map((s,i)=>s-a[i]);return n.map((s,i)=>[a[i],r[i]])}var gM=ie({pool_:_ge});function Oge(e,t){let n=K(e,"x","prelu"),a=K(t,"alpha","prelu"),r={x:n,alpha:a};return re.runKernel(nm,r)}var S1=ie({prelu_:Oge});function Fge(e,t=null,n=!1){let a=K(e,"x","prod");a.dtype==="bool"&&(a=He(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return re.runKernel(am,r,s)}var yM=ie({prod_:Fge});function Mge(e,t,n,a){let r=e.map((c,h)=>K(c,`tensors${h}`,"raggedGather","int32")),s=K(t,"paramsDenseValues","raggedGather"),i=K(n,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:s,indices:i},l={outputRaggedRank:a},u=re.runKernel(v2,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var Wq=ie({raggedGather_:Mge});function Lge(e,t,n){let a=K(e,"starts","raggedRange"),r=K(t,"limits","raggedRange",a.dtype),s=K(n,"deltas","raggedRange",a.dtype),i={starts:a,limits:r,deltas:s},o=re.runKernel(w2,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var Gq=ie({raggedRange_:Lge});function zge(e,t,n,a,r){let s=K(e,"shape","raggedTensorToTensor","int32"),i=K(t,"values","raggedTensorToTensor"),o=K(n,"defaultValue","raggedTensorToTensor",i.dtype),l=a.map((h,p)=>K(h,`tensors${p}`,"raggedTensorToTensor","int32")),u={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:r};return re.runKernel(A2,u,c)}var Hq=ie({raggedTensorToTensor_:zge});function Bge(e,t,n){Li(e);let a=Rn(e),r=null;if(n==null||n==="float32")r=new Float32Array(a);else if(n==="int32")r=new Int32Array(a);else if(n==="bool")r=new Uint8Array(a);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<a;s++)r[s]=t();return re.makeTensor(r,e,n)}var jq=ie({rand_:Bge}),bM=Kh(o2()),qq={};Lt(qq,{TEST_EPSILON_FLOAT16:()=>Kq,createVideoElement:()=>qge,encodeStrings:()=>Xq,expectArrayBuffersEqual:()=>jge,expectArraysClose:()=>Vge,expectArraysEqual:()=>Wge,expectNumbersClose:()=>Gge,expectPromiseToFail:()=>Uge,expectValuesInRange:()=>Hge,play:()=>Kge,testEpsilon:()=>xM});var Pge=.001,Kq=.1;function Vge(e,t,n){return n==null&&(n=xM()),mD(e,t,(a,r)=>vM(a,r,n))}function xM(){return re.backend.floatPrecision()===32?Pge:Kq}function mD(e,t,n){let a=!0;if((Cr(e)||Cr(t))&&(a=!1),Cr(e)&&Cr(t)&&(a=!0),a){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=eu(e),o=eu(t);if(!oc(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let r=Cr(e)?e:Ah(e),s=Cr(t)?t:Ah(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.
Actual:   ${r}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=r[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${r}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function Uge(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function Wge(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return lh(e)||lh(e[0])||lh(t)||lh(t[0])?mD(e,n,(a,r)=>a==r):mD(e,t,(a,r)=>vM(a,r,0))}function Gge(e,t,n){if(n==null&&(n=xM()),!vM(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function vM(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Hge(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function jge(e,t){let n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`)}function Xq(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?Xq(n):e[t]=c1(n)}return e}function qge(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",a=>n(t)),t.load()})}async function Kge(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var wM=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=r||Math.random();this.random=bM.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let a=this.nextVal;return this.nextVal=NaN,a}let e,t,n=!1;for(;!n;){let a,r,s;do a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*r*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},Xge=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;let r=a||Math.random();this.randu=bM.alea(r.toString()),this.randn=new wM(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do a=this.randn.nextValue(),s=1+this.c*a;while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},Yge=class{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,a==null&&(a=Math.random()),typeof a=="number"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=bM.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function Qge(e,t,n=1,a="float32",r){if(Li(e),n==null&&(n=1),a==null&&(a="float32"),a!=="float32"&&a!=="int32")throw new Error(`Unsupported data type ${a}`);let s=new Xge(t,n,a,r),i=Wt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Yq=ie({randomGamma_:Qge});function Zge(e,t=0,n=1,a,r){if(Li(e),a!=null&&a==="bool")throw new Error(`Unsupported data type ${a}`);let s=new wM(t,n,a,!1,r),i=Wt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var B2=ie({randomNormal_:Zge});function Jge(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return B2(e,0,1,t,n)}var Qq=ie({randomStandardNormal_:Jge});function eye(e,t=0,n=1,a="float32",r){Li(e);let s=Wt(e,a),i=new Yge(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var td=ie({randomUniform_:eye});function tye(e,t,n,a){return td(e,t,n,"int32",a)}var Zq=ie({randomUniformInt_:tye});function Dp(e,t,n=1,a="float32"){if(n===0)throw new Error("Cannot have a step of zero");let r={start:e,stop:t,step:n,dtype:a};return re.runKernel(Qw,{},r)}function nye(e){let t={input:K(e,"input","real")};return re.runKernel(S2,t)}var my=ie({real_:nye});function aye(e){let t={x:K(e,"x","reciprocal")};return re.runKernel(rm,t)}var AM=ie({reciprocal_:aye});function rye(e){let t={x:K(e,"x","relu")};return re.runKernel(sm,t)}var _n=ie({relu_:rye});function sye(e){let t={x:K(e,"x","relu6")};return re.runKernel(lm,t)}var P2=ie({relu6_:sye});function iye(e,t){let n={x:K(e,"x","reverse")},a={dims:t};return re.runKernel(um,n,a)}var io=ie({reverse_:iye});function oye(e){let t=K(e,"x","reverse");return J(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),io(t,0)}var Jq=ie({reverse1d_:oye});function lye(e,t){let n=K(e,"x","reverse");return J(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),io(n,t)}var e8=ie({reverse2d_:lye});function uye(e,t){let n=K(e,"x","reverse");return J(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),io(n,t)}var t8=ie({reverse3d_:uye});function cye(e,t){let n=K(e,"x","reverse");return J(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),io(n,t)}var n8=ie({reverse4d_:cye});function hye(e){let t={x:K(e,"x","round")};return re.runKernel(cm,t)}var V2=ie({round_:hye});function dye(e){let t={x:K(e,"x","rsqrt","float32")};return re.runKernel(hm,t)}var U2=ie({rsqrt_:dye});function pye(e){let t={x:K(e,"x","selu")};return re.runKernel(dm,t)}var W2=ie({selu_:pye});function fye(e,t,n,a,r,s=[1,1],i="NHWC"){let o=K(e,"x","separableConv2d"),l=K(t,"depthwiseFilter","separableConv2d"),u=K(n,"pointwiseFilter","separableConv2d"),c=o,h=!1;if(o.rank===3&&(h=!0,c=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");J(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),J(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),J(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),J(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),J(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let p=l.shape[2],m=l.shape[3];J(u.shape[2]===p*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*m}, but got ${u.shape[2]}.`);let g=Nm(c,l,a,r,i,s),y=Ts(g,u,1,"valid",i);return h?pe(y,[y.shape[1],y.shape[2],y.shape[3]]):y}var Yb=ie({separableConv2d_:fye});async function mye(e,t){let n=K(e,"x","setdiff1d"),a=K(t,"y","setdiff1d");J(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),J(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),J(a.rank===1,()=>`y should be 1D tensor, but got y (${a.shape}).`);let r=await n.data(),s=await a.data(),i=new Set(s),o=0;for(let c=0;c<r.length;c++)i.has(r[c])||o++;let l=new Za([o],n.dtype),u=new Za([o],"int32");for(let c=0,h=0;c<r.length;c++)i.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}var a8=mye;function gye(e){let t={x:K(e,"x","sign")};return re.runKernel(mm,t)}var SM=ie({sign_:gye});function yye(e){let t={x:K(e,"x","sin","float32")};return re.runKernel(pm,t)}var G2=ie({sin_:yye});function bye(e){let t={x:K(e,"x","sinh")};return re.runKernel(fm,t)}var H2=ie({sinh_:bye});function xye(e,t,n){let a=K(e,"x","slice1d");return J(a.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`),en(a,[t],[n])}var k1=ie({slice1d_:xye});function vye(e,t,n){let a=K(e,"x","slice2d");return J(a.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`),en(a,t,n)}var j2=ie({slice2d_:vye});function wye(e,t,n){let a=K(e,"x","slice3d");return J(a.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`),en(a,t,n)}var Qb=ie({slice3d_:wye});function Aye(e,t,n){let a=K(e,"x","slice4d");return J(a.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`),en(a,t,n)}var gy=ie({slice4d_:Aye});function Sye(e,t=-1){let n=K(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let a={logits:n},r={dim:t};return re.runKernel(vm,a,r)}var nd=ie({softmax_:Sye});function kye(e){J(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return re.runKernel(y2,t)}var I1=ie({fft_:kye});function Iye(e){J(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return re.runKernel(b2,t)}var yy=ie({ifft_:Iye});function Nye(e){let t=e.shape[e.shape.length-1],n=e.size/t,a;if(t<=2){let r=pe(e,[n,t]);a=yy(r)}else{let r=[n,2*(t-1)],s=pe(my(e),[n,t]),i=pe(g1(e),[n,t]),o=io(en(s,[0,1],[n,t-2]),1),l=le(io(en(i,[0,1],[n,t-2]),1),xt(-1)),u=Un([s,o],1),c=Un([i,l],1),h=pe(Ju(u,c),[r[0],r[1]]);a=yy(h)}if(a=my(a),e.rank===3&&e.shape[0]!==0){let r=a,s=e.shape[0];a=pe(a,[s,a.shape[0]/s,a.shape[1]]),r.dispose()}return a}var q2=ie({irfft_:Nye});function Cye(e,t,n=0){let a={x:K(e,"x","split")},r={numOrSizeSplits:t,axis:n};return re.runKernel(Mb,a,r)}var Ks=ie({split_:Cye});function Tye(e,t){J(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n,r;if(t!=null&&t<n){let g=e.shape.map(b=>0),y=e.shape.map(b=>b);y[e.shape.length-1]=t,r=en(e,g,y),n=t}else if(t!=null&&t>n){let g=e.shape.map(y=>y);g[e.shape.length-1]=t-n,r=Un([e,Aa(g)],e.shape.length-1),n=t}else r=e;let s=un(r),i=pe(Ju(r,s),[a,n]),o=I1(i),l=Math.floor(n/2)+1,u=my(o),c=g1(o),h=Ks(u,[l,n-l],u.shape.length-1),p=Ks(c,[l,n-l],c.shape.length-1),m=r.shape.slice();return m[r.shape.length-1]=l,pe(Ju(h[0],p[0]),m)}var N1=ie({rfft_:Tye});function Eye(e,t){let n=K(e,"a","squaredDifference"),a=K(t,"b","squaredDifference");[n,a]=Ca(n,a),Wn(n.shape,a.shape);let r={a:n,b:a},s={};return re.runKernel(wm,r,s)}var K2=ie({squaredDifference_:Eye});function $ye(e,t){let n=K(e,"x","squeeze","string_or_numeric");return pe(n,$5(n.shape,t).newShape)}var ad=ie({squeeze_:$ye});function _ye(e,t=0){let n=aw(e,"tensors","stack","string_or_numeric");J(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&J(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let a=n,r={axis:t};return re.runKernel(Nb,a,r)}var Ja=ie({stack_:_ye});function Rye(e,t=0){let n={x:K(e,"x","step")},a={alpha:t};return re.runKernel(Zh,n,a)}var Tm=ie({step_:Rye});function Dye(e,t,n,a,r=0,s=0,i=0,o=0,l=0){let u={x:K(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return re.runKernel(Bb,u,c)}var kM=ie({stridedSlice_:Dye});function Oye(e){let t={x:K(e,"x","tan","float32")};return re.runKernel(Sm,t)}var IM=ie({tan_:Oye});function Nn(e,t){sf(e);let n=eu(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Jh(e,null,n,t)}function ql(e,t,n){if(sf(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let a=eu(e,n);if(a.length!==2&&a.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Jh(e,t,a,n)}function X2(e,t,n){if(sf(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let a=eu(e,n);if(a.length!==3&&a.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Jh(e,t,a,n)}function Th(e,t,n){if(sf(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let a=eu(e,n);if(a.length!==4&&a.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Jh(e,t,a,n)}function r8(e,t,n){if(sf(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let a=eu(e,n);if(a.length!==5&&a.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Jh(e,t,a,n)}function s8(e,t,n){if(sf(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let a=eu(e,n);if(a.length!==6&&a.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||a,Jh(e,t,a,n)}var Y2={};Lt(Y2,{calculateShapes:()=>i8,validateInput:()=>Q2,validateUpdateShape:()=>NM});function NM(e,t,n){let a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+` update.rank != ${r+e.length-a}`);for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function Q2(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}NM(n,t,e)}function i8(e,t,n){let a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length,i=1;for(let h=r;h<s;++h)i*=n[h];let o=r<1?1:r,l=Rn(t.shape)/o,u=[...Uy(n.slice(0,r)),1],c=Rn(n);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}function Fye(e,t,n){let a=K(e,"tensor","tensorScatterupdate"),r=K(t,"indices","tensorScatterupdate","int32"),s=K(n,"updates","tensorScatterupdate");if(Q2(s,r,a.shape),a.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${s.dtype}.`);let i={tensor:a,indices:r,updates:s},o={};return re.runKernel(_b,i,o)}var o8=ie({tensorScatterUpdate_:Fye});function Mye(e,t=1,n=!0){let a=K(e,"x","topk");if(a.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let s={x:a},i={k:t,sorted:n},[o,l]=re.runKernel(Pb,s,i);return{values:o,indices:l}}var CM=ie({topk_:Mye});function Lye(e,t=0,n=1,a,r){if(Li(e),a!=null&&a==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new wM(t,n,a,!0,r),i=Wt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Z2=ie({truncatedNormal_:Lye});function zye(e,t=0){let n=K(e,"x","unique","string_or_numeric");J(n.rank>0,()=>"The input tensor must be at least 1D");let a={x:n},r={axis:t},[s,i]=re.runKernel(i1,a,r);return{values:s,indices:i}}var TM=ie({unique_:zye});function Bye(e,t,n){let a=K(e,"x","unsortedSegmentSum"),r=K(t,"segmentIds","unsortedSegmentSum","int32");J(ly(n),()=>"numSegments must be of dtype int");let s={x:a,segmentIds:r},i={numSegments:n};return re.runKernel(o1,s,i)}var J2=ie({unsortedSegmentSum_:Bye});function Pye(e,t=0){let n=K(e,"x","unstack","string_or_numeric");J(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let a={value:n},r={axis:t};return re.runKernel(Ub,a,r)}var Ra=ie({unstack_:Pye});function l8(e,t){return z2(e,t,"right")}function EM(e,t=!0,n,a){return re.makeVariable(e,t,n,a)}function u8(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let a=Wt(e,"int32"),r=Wt([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=a.indexToLoc(n[s]),o=s*e.length;r.values.set(i,o)}return r.toTensor()}async function Vye(e){let t=K(e,"condition","whereAsync","bool"),n=await t.data(),a=u8(t.shape,n);return e!==t&&t.dispose(),a}var $M=Vye;async function Uye(e,t,n){let a=K(e,"tensor","boolMask"),r=K(t,"mask","boolMask","bool"),s=n??0,i=r.rank,o=a.shape;J(i>0,()=>"mask cannot be scalar"),Ds(o.slice(s,s+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let y=s;y<s+i;y++)l*=o[y];let u=o.slice(0,s).concat([l],o.slice(s+i)),c=pe(a,u),h=pe(r,[-1]),p=await $M(h),m=ad(p,[1]),g=Xb(c,m,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),m.dispose(),c.dispose(),h.dispose(),p.dispose(),g}var c8=Uye;function Wye(e,t,n){let a=K(e,"x","transpose");if(t==null&&(t=a.shape.map((i,o)=>o).reverse()),J(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`),t.forEach(i=>{J(i>=0&&i<a.rank,()=>`All entries in 'perm' must be between 0 and ${a.rank-1} but got ${t}`)}),a.rank<=1)return a.clone();let r={x:a},s={perm:t};return a.dtype==="complex64"?fe(()=>{let i=my(a),o=g1(a);return i=re.runKernel(Ku,{x:i},s),o=re.runKernel(Ku,{x:o},s),n&&(o=sa(o)),Ju(i,o)}):re.runKernel(Ku,r,s)}var Ut=ie({transpose_:Wye});function Gye(e,t,n,a,r=!0){let s=K(e,"v","movingAverage"),i=K(t,"x","movingAverage"),o=K(n,"decay","movingAverage");Y5(s,i),J(oc(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=xt(1),u=nt(l,o),c=le(nt(i,s),u);if(r){J(a!=null,()=>"When using zeroDebias: true, step is required.");let h=K(a,"step","movingAverage");c=st(c,nt(l,tu(o,h)))}return Re(s,c)}var h8=ie({movingAverage_:Gye});function Hye(e,t,n){Li(n);let a=K(e,"indices","scatterND","int32"),r=K(t,"updates","scatterND");Q2(r,a,n);let s={indices:a,updates:r},i={shape:n};return re.runKernel($b,s,i)}var d8=ie({scatterND_:Hye});function jye(e,t,n,a){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function qye(e,t,n,a=0){Li(n);let r=K(e,"sparseIndices","sparseToDense","int32"),s=K(t,"sparseValues","sparseToDense","string_or_numeric"),i=K(a,"defaultValue","sparseToDense",s.dtype);jye(r,s,n,i);let o={sparseIndices:r,sparseValues:s,defaultValue:i},l={outputShape:n};return re.runKernel(zb,o,l)}var p8=ie({sparseToDense_:qye});function Kye(e,t){let n=K(t,"indices","gatherND","int32"),a={params:K(e,"x","gatherND","string_or_numeric"),indices:n};return re.runKernel(ub,a)}var f8=ie({gatherND_:Kye});function Xye(e,t){if(t==null)return e.shape.slice();if(oc(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let a=0;a<e.shape.length;a++)t[a]==null&&e.shape[a]!=null?n.push(e.shape[a]):n.push(t[a]);return n}return t}function Yye(e,t,n,a){let r=K(e,"x","dropout");if(J(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),J(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Bt?r.clone():r;let s=Xye(r,n),i=1-t,o=st(Kb(Re(td(s,0,1,"float32",a),i)),i);return le(r,o)}var _M=ie({dropout_:Yye});function RM(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function eC(e,t,n){let a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return Nn(r,"float32")}async function Qye(e,t,n=1){let a=K(e,"predictions","inTopK"),r=K(t,"targets","inTopK");J(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),J(a.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`),Ds(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=a.shape[a.shape.length-1];J(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await a.data(),o=await r.data(),[l,u]=[i.length/s,s],c=_5("bool",l);for(let h=0;h<l;h++){let p=h*u,m=i.subarray(p,p+u),g=[];for(let y=0;y<m.length;y++)g.push({value:m[y],index:y});g.sort((y,b)=>b.value-y.value),c[h]=0;for(let y=0;y<n;y++)if(g[y].index===o[h]){c[h]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),Cs(c,r.shape,"bool")}var m8=Qye,by={};Lt(by,{conv2d:()=>ebe,depthwiseConv2d:()=>rbe,matMul:()=>ibe});function Zye(e,t,n,a,r,s="NHWC",i){let o=e;e.rank===3&&(o=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),J(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),J(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),J(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=s==="NHWC"?o.shape[3]:o.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];J(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),J(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Os("conv2dDerFilter",r,i);let h={x:o,dy:l},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:n};return re.runKernel(d2,h,p)}var DM=ie({conv2DBackpropFilter_:Zye});function tC(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return le(e,Tm(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function nC(e,t){let n=t,a=tr(e.shape,t.shape);return a.length>0&&(n=ut(n,a)),pe(n,e.shape)}function aC(e,t,n,a){if(t==="linear")return e;if(t==="relu")return _n(e);if(t==="elu")return jb(e);if(t==="relu6")return P2(e);if(t==="prelu")return S1(e,n);if(t==="leakyrelu")return y1(e,a);if(t==="sigmoid")return Mo(e);throw new Error(`Unknown fused activation ${t}.`)}var rC=(e,t)=>!(e>0)||t==="linear";function Jye({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",rC(re.state.gradientDepth,l)===!1){J(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let T=Ts(e,t,n,a,r,s,i);return o!=null&&(T=Re(T,o)),aC(T,l,u,c)}let h=K(e,"x","conv2d","float32"),p=K(t,"filter","conv2d","float32"),m=h,g=!1;h.rank===3&&(g=!0,m=pe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),J(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),J(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Os("fused conv2d",a,i);let y=r==="NHWC"?m.shape[3]:m.shape[1];J(p.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${p.shape[2]}.`),J(hu(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let b=p1(m.shape,p.shape,n,s,a,i),v;o!=null&&(v=K(o,"bias","fused conv2d"),[v]=Ca(v,h),r==="NHWC"?Wn(b.outShape,v.shape):(J(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),J(v.shape.length===0||v.shape[0]===b.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${b.outChannels})`)));let w;if(u!=null){let T=u.shape;if(J(T.length<=1||T.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${T.length}.`),T.length===1)J(T[0]===1||T[0]===b.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the number of output channels (${b.outChannels}).`);else if(T.length===3)try{Wn(T,b.outShape)}catch{let R=`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(R)}w=K(u,"prelu weights","fused conv2d")}let S=(T,E)=>{J(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);let[R,D,O,$]=E,_=tC(T,O,l);J(Ih(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let P=YF(D.shape,_,R,n,a),U=DM(D,_,R.shape,n,a),W=[P,U];if($!=null){let B=nC($,_);W.push(B)}return W},k={x:m,filter:p,bias:v,preluActivationWeights:w},I={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?nu((T,E,R)=>{let D=re.runKernel(Sp,k,I);return R([E,T,D]),g&&(D=pe(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:S}})(m,p):nu((T,E,R,D)=>{let O=re.runKernel(Sp,k,I);return D([E,T,O,R]),g&&(O=pe(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:S}})(m,p,v)}var ebe=ie({fusedConv2d_:Jye});function tbe(e,t,n,a,r,s=[1,1],i){let o=e;e.rank===3&&(o=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:a,pad:r,dimRoundingMode:i,dilations:s,filterShape:n};return re.runKernel(p2,u,c)}var g8=ie({depthwiseConv2dNativeBackpropFilter_:tbe});function nbe(e,t,n,a,r,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:a,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},h=re.runKernel(f2,u,c);return l?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var y8=ie({depthwiseConv2dNativeBackpropInput_:nbe});function abe({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(rC(re.state.gradientDepth,l)===!1){let I=Nm(e,t,n,a,r,s,i);return o!=null&&(I=Re(I,o)),aC(I,l,u,c)}let h=K(e,"x","depthwiseConv2d","float32"),p=K(t,"filter","depthwiseConv2d","float32"),m=h,g=!1;h.rank===3&&(g=!0,m=pe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),J(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),J(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),J(m.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),s==null&&(s=[1,1]),J(hu(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),Os("fused depthwiseConv2d",a,i);let y=p1(m.shape,p.shape,n,s,a,i,!0),b;o!=null&&(b=K(o,"bias","fused conv2d"),[b]=Ca(b,h),Wn(y.outShape,b.shape));let v;u!=null&&(v=K(u,"prelu weights","fused depthwiseConv2d"));let w=(I,T)=>{J(Ih(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[E,R,D,O]=T,$=tC(I,D,l),_=y8(R.shape,$,E,n,a,s,i),P=g8(R,$,E.shape,n,a,s,i);if(O!=null){let U=nC(b,$);return[_,P,U]}return[_,P]},S={x:m,filter:p,bias:b,preluActivationWeights:v},k={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?nu((I,T,E)=>{let R=re.runKernel(kp,S,k);return E([T,I,R]),g&&(R=pe(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:w}})(m,p):nu((I,T,E,R)=>{let D=re.runKernel(kp,S,k);return R([T,I,D,E]),g&&(D=pe(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:w}})(m,p,b)}var rbe=ie({fusedDepthwiseConv2d_:abe});function sbe({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(rC(re.state.gradientDepth,s)===!1){let O=Vt(e,t,n,a);return r!=null&&(O=Re(O,r)),aC(O,s,i,o)}let l=K(e,"a","fused matMul"),u=K(t,"b","fused matMul");[l,u]=Ca(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),y=u.shape.slice(0,-2),b=Rn(g),v=Rn(y);J(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${a} must match.`);let w=Wn(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,m]),S=n?pe(l,[b,c,p]):pe(l,[b,p,c]),k=a?pe(u,[v,m,h]):pe(u,[v,h,m]),I;r!=null&&(I=K(r,"bias","fused matMul"),[I]=Ca(I,l),Wn(w,I.shape));let T;i!=null&&(T=K(i,"prelu weights","fused matMul"));let E=(O,$)=>{let[_,P,U,W]=$,B=tC(pe(O,U.shape),U,s),H,j;if(!n&&!a?(H=Vt(B,P,!1,!0),j=Vt(_,B,!0,!1)):!n&&a?(H=Vt(B,P,!1,!1),j=Vt(B,_,!0,!1)):n&&!a?(H=Vt(P,B,!1,!0),j=Vt(_,B,!1,!1)):(H=Vt(P,B,!0,!0),j=Vt(B,_,!0,!0)),r!=null){let Z=nC(W,B);return[H,j,Z]}else return[H,j]},R={a:S,b:k,bias:I,preluActivationWeights:T},D={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:o};return r==null?nu((O,$,_)=>{let P=re.runKernel(Ap,R,D);return _([O,$,P]),{value:pe(P,w),gradFunc:E}})(S,k):nu((O,$,_,P)=>{let U=re.runKernel(Ap,R,D);return P([O,$,U,_]),{value:pe(U,w),gradFunc:E}})(S,k,I)}var ibe=ie({fusedMatMul_:sbe});function obe(e){return eC(e,.54,.46)}var lbe=ie({hammingWindow_:obe});function ube(e){return eC(e,.5,.5)}var b8=ie({hannWindow_:ube});function cbe(e,t,n,a=!1,r=0){let s=0,i=[];for(;s+t<=e.size;)i.push(en(e,s,t)),s+=n;if(a)for(;s<e.size;){let o=s+t-e.size,l=Un([en(e,s,t-o),Ni([o],r)]);i.push(l),s+=n}return i.length===0?ql([],[0,t]):pe(Un(i),[i.length,t])}var x8=ie({frame_:cbe});function hbe(e,t,n,a,r=b8){a==null&&(a=RM(t));let s=x8(e,t,n),i=le(s,r(t));return N1(i,a)}var dbe=ie({stft_:hbe});function pbe(e,t,n,a,r="bilinear",s=0){let i=K(e,"image","cropAndResize"),o=K(t,"boxes","cropAndResize","float32"),l=K(n,"boxInd","cropAndResize","int32"),u=o.shape[0];J(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),J(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),J(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),J(a.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`),J(a[0]>=1&&a[1]>=1,()=>`cropSize must be atleast [1,1], but was ${a}`),J(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);let c={image:i,boxes:o,boxInd:l},h={method:r,extrapolationValue:s,cropSize:a};return re.runKernel(nb,c,h)}var fbe=ie({cropAndResize_:pbe});function mbe(e){let t=K(e,"image","flipLeftRight","float32");J(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return re.runKernel(ob,n,{})}var gbe=ie({flipLeftRight_:mbe});function ybe(e){let t=K(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];J(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),J(a===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);let r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Ii(t,r)}var bbe=ie({grayscaleToRGB_:ybe});function xbe(e){let t=K(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];J(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),J(a===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let r=t.dtype,s=He(t,"float32"),i=Nn([.2989,.587,.114]),o;switch(t.rank){case 2:o=ep("ij,j->i",s,i);break;case 3:o=ep("ijk,k->ij",s,i);break;case 4:o=ep("ijkl,l->ijk",s,i);break;case 5:o=ep("ijklm,m->ijkl",s,i);break;case 6:o=ep("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Tr(o,-1),He(o,r)}var vbe=ie({rgbToGrayscale_:xbe});function wbe(e,t,n=0,a=.5){let r=K(e,"image","rotateWithOffset","float32");J(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let s={image:r},i={radians:t,fillValue:n,center:a};return re.runKernel(Gb,s,i)}var Abe=ie({rotateWithOffset_:wbe});function Zb(e,t,n,a,r,s){a==null&&(a=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),J(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),J(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),J(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),J(t.rank===1,()=>"scores must be a 1D tensor"),J(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),J(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}function Sbe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=K(e,"boxes","nonMaxSuppression","float32"),i=K(t,"scores","nonMaxSuppression","float32"),o=Zb(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return re.runKernel(Ab,{boxes:s,scores:i},l)}var kbe=ie({nonMaxSuppression_:Sbe});function Ibe(e,t,n){let a=Nbe(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function Nbe(e,t,n){return Tbe(e,t,n||Cbe)}function Cbe(e,t){return e>t?1:e<t?-1:0}function Tbe(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);let o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}function v8(e,t,n,a,r){return OM(e,t,n,a,r,0)}function w8(e,t,n,a,r,s){return OM(e,t,n,a,r,0,!1,s,!0)}function A8(e,t,n,a,r,s){return OM(e,t,n,a,r,s,!0)}function OM(e,t,n,a,r,s,i=!1,o=!1,l=!1){let u=[];for(let b=0;b<t.length;b++)t[b]>r&&u.push({score:t[b],boxIndex:b,suppressBeginIndex:0});u.sort(TG);let c=s>0?-.5/s:0,h=[],p=[];for(;h.length<n&&u.length>0;){let b=u.pop(),{score:v,boxIndex:w,suppressBeginIndex:S}=b;if(v<r)break;let k=!1;for(let I=h.length-1;I>=S;--I){let T=Ebe(e,w,h[I]);if(T>=a){k=!0;break}if(b.score=b.score*$be(a,c,T),b.score<=r)break}b.suppressBeginIndex=h.length,k||(b.score===v?(h.push(w),p.push(b.score)):b.score>r&&Ibe(u,b,TG))}let m=h.length,g=n-m;o&&g>0&&(h.push(...new Array(g).fill(0)),p.push(...new Array(g).fill(0)));let y={selectedIndices:h};return i&&(y.selectedScores=p),l&&(y.validOutputs=m),y}function Ebe(e,t,n){let a=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),m=(o-s)*(l-i),g=(h-u)*(p-c);if(m<=0||g<=0)return 0;let y=Math.max(s,u),b=Math.max(i,c),v=Math.min(o,h),w=Math.min(l,p),S=Math.max(v-y,0)*Math.max(w-b,0);return S/(m+g-S)}function $be(e,t,n){let a=Math.exp(t*n*n);return n<=e?a:0}function TG(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function _be(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=K(e,"boxes","nonMaxSuppressionAsync"),i=K(t,"scores","nonMaxSuppressionAsync"),o=Zb(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=v8(u,c,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),Nn(h,"int32")}var Rbe=_be;function Dbe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=K(e,"boxes","nonMaxSuppression"),o=K(t,"scores","nonMaxSuppression"),l=Zb(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},h=re.runKernel(kb,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}var Obe=ie({nonMaxSuppressionWithScore_:Dbe});async function Fbe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=K(e,"boxes","nonMaxSuppressionAsync"),o=K(t,"scores","nonMaxSuppressionAsync"),l=Zb(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:p,selectedScores:m}=A8(c,h,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Nn(p,"int32"),selectedScores:Nn(m)}}var Mbe=Fbe;function Lbe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=K(e,"boxes","nonMaxSuppression"),o=K(t,"scores","nonMaxSuppression"),l=Zb(i,o,n,a,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,p={boxes:i,scores:o},m={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:s},g=re.runKernel(Sb,p,m);return{selectedIndices:g[0],validOutputs:g[1]}}var zbe=ie({nonMaxSuppressionPadded_:Lbe});async function Bbe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=K(e,"boxes","nonMaxSuppressionAsync"),o=K(t,"scores","nonMaxSuppressionAsync"),l=Zb(i,o,n,a,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[p,m]=await Promise.all([i.data(),o.data()]),{selectedIndices:g,validOutputs:y}=w8(p,m,u,c,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Nn(g,"int32"),validOutputs:xt(y,"int32")}}var Pbe=Bbe;function Vbe(e,t,n=!1,a=!1){let r=K(e,"images","resizeBilinear");J(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),J(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),J(a===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=re.runKernel(om,o,l);return i?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var S8=ie({resizeBilinear_:Vbe});function Ube(e,t,n=!1,a=!1){let r=K(e,"images","resizeNearestNeighbor");J(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),J(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),J(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),J(a===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=re.runKernel(im,o,l);return i?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var k8=ie({resizeNearestNeighbor_:Ube});function Wbe(e,t="binary",n=!1,a=.5){let r=K(e,"image","threshold"),s=.2989,i=.587,o=.114,l=r.shape[0]*r.shape[1],u=le(Nn([a]),255),c,h,p,m;if(J(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),J(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),J(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),J(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[c,h,p]=Ks(r,[1,1,1],-1);let y=le(c,s),b=le(h,i),v=le(p,o);m=Re(Re(y,b),v)}else m=e;if(t==="otsu"){let y=GF(He(V2(m),"int32"),Cs([]),256);u=Gbe(y,l)}let g=n?ed(m,u):Fs(m,u);return He(le(g,255),"int32")}function Gbe(e,t){let n=Nn([-1]),a=Nn([0]),r=Nn([0]),s,i,o,l,u,c;for(let h=0;h<e.size-1;h++){s=en(e,0,h+1),i=en(e,h+1),u=st(ut(s),t),c=st(ut(i),t);let p=ut(le(s,Dp(0,s.size)));o=st(p,ut(s));let m=Ni(i.shape,s.size),g=Re(Dp(0,i.size),m),y=le(i,g);l=st(ut(y),ut(i));let b=nt(o,l),v=nt(o,l),w=le(u,c);r=le(le(w,b),v);let S=Fs(r,a);a=Dr(S,r,a),n=Dr(S,Nn([h]),n)}return n}var Hbe=ie({threshold_:Wbe});function jbe(e,t,n="nearest",a="constant",r=0,s){let i=K(e,"image","transform","float32"),o=K(t,"transforms","transform","float32");J(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),J(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),J(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},u={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return re.runKernel(Vb,l,u)}var qbe=ie({transform_:jbe});function Kbe(e,t,n){let a=K(e,"a","bandPart");J(a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`);let r=a.shape,[s,i]=a.shape.slice(-2),o,l;typeof t=="number"?(J(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),J(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=K(t<0?s:t,"numLower","bandPart")):(J(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Dr(py(t,0),s,Ch(t,s))),typeof n=="number"?(J(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),J(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=K(n<0?i:n,"numUpper","bandPart")):(J(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Dr(py(n,0),i,Ch(n,i)));let u=pe(Dp(0,s,1,"int32"),[-1,1]),c=Dp(0,i,1,"int32"),h=nt(u,c),p=zo(ed(h,o),cc(h,sa(l))),m=Aa([s,i],a.dtype);return pe(Ja(Ra(pe(a,[-1,s,i])).map(g=>Dr(p,g,m))),r)}var Xbe=ie({bandPart_:Kbe});function Ybe(e){let t;if(Array.isArray(e)){t=!1,J(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let r=e[0].shape[0];for(let s=1;s<e.length;++s)J(e[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`)}else t=!0,e=Ks(e,e.shape[0],0).map(r=>ad(r,[0]));J(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],a=e;for(let r=0;r<e.length;++r)n.push(re.tidy(()=>{let s=a[r];if(r>0)for(let i=0;i<r;++i){let o=le(ut(le(n[i],s)),n[i]);s=nt(s,o)}return st(s,qb(s,"euclidean"))}));return t?Ja(n,0):n}var Qbe=ie({gramSchmidt_:Ybe});function Zbe(e,t=!1){if(J(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return EG(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),a=Ra(pe(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach(l=>{let[u,c]=EG(l,t);r.push(u),s.push(c)});let i=pe(Ja(r,0),e.shape),o=pe(Ja(s,0),e.shape);return[i,o]}}function EG(e,t=!1){return re.tidy(()=>{J(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],a=e.shape[1],r=O2(n),s=jl(e),i=ql([[1]],[1,1]),o=jl(i),l=n>=a?a:n;for(let u=0;u<l;++u){let c=s,h=o,p=r;[o,s,r]=re.tidy(()=>{let m=en(s,[u,u],[n-u,1]),g=qb(m),y=en(s,[u,u],[1,1]),b=Dr(Fs(y,0),ql([[-1]]),ql([[1]])),v=nt(y,le(b,g)),w=st(m,v);w.shape[0]===1?o=jl(i):o=Un([i,en(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);let S=sa(st(Vt(b,v),g)),k=en(s,[u,0],[n-u,a]),I=le(S,o),T=Ut(o);if(u===0)s=nt(k,Vt(I,Vt(T,k)));else{let D=nt(k,Vt(I,Vt(T,k)));s=Un([en(s,[0,0],[u,a]),D],0)}let E=Ut(I),R=en(r,[0,u],[n,r.shape[1]-u]);if(u===0)r=nt(R,Vt(Vt(R,o),E));else{let D=nt(R,Vt(Vt(R,o),E));r=Un([en(r,[0,0],[n,u]),D],1)}return[o,s,r]}),Ft([c,h,p])}return!t&&n>a&&(r=en(r,[0,0],[n,a]),s=en(s,[0,0],[a,a])),[r,s]})}var Jbe=ie({qr_:Zbe}),Ss;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ss||(Ss={}));function exe(e,t,n=Ss.SUM_BY_NONZERO_WEIGHTS){let a=K(e,"losses","computeWeightedLoss"),r=null;t!=null&&(r=K(t,"weights","computeWeightedLoss"));let s=r==null?a:le(a,r);if(n===Ss.NONE)return s;if(n===Ss.SUM)return ut(s);if(n===Ss.MEAN){if(r==null)return wa(s);{let i=a.size/r.size,o=st(ut(s),ut(r));return i>1?st(o,xt(i)):o}}if(n===Ss.SUM_BY_NONZERO_WEIGHTS){if(r==null)return st(ut(s),xt(a.size));{let i=le(r,js(a.shape)),o=He(ut(Rp(i,xt(0))),"float32");return st(ut(s),o)}}throw Error(`Unknown reduction: ${n}`)}var hc=ie({computeWeightedLoss_:exe});function txe(e,t,n,a=Ss.SUM_BY_NONZERO_WEIGHTS){let r=K(e,"labels","absoluteDifference"),s=K(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=K(n,"weights","absoluteDifference")),Ds(r.shape,s.shape,"Error in absoluteDifference: ");let o=Ka(nt(r,s));return hc(o,i,a)}var nxe=ie({absoluteDifference_:txe});function axe(e,t,n,a,r=Ss.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"labels","cosineDistance"),i=K(t,"predictions","cosineDistance"),o=null;a!=null&&(o=K(a,"weights","cosineDistance")),Ds(s.shape,i.shape,"Error in cosineDistance: ");let l=xt(1),u=nt(l,ut(le(s,i),n,!0));return hc(u,o,r)}var rxe=ie({cosineDistance_:axe});function sxe(e,t,n,a=Ss.SUM_BY_NONZERO_WEIGHTS){let r=K(e,"labels","hingeLoss"),s=K(t,"predictions","hingeLoss"),i=null;n!=null&&(i=K(n,"weights","hingeLoss")),Ds(r.shape,s.shape,"Error in hingeLoss: ");let o=xt(1);r=nt(le(xt(2),r),o);let l=_n(nt(o,le(r,s)));return hc(l,i,a)}var ixe=ie({hingeLoss_:sxe});function oxe(e,t,n,a=1,r=Ss.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"labels","huberLoss"),i=K(t,"predictions","huberLoss"),o=null;n!=null&&(o=K(n,"weights","huberLoss")),Ds(s.shape,i.shape,"Error in huberLoss: ");let l=xt(a),u=Ka(nt(i,s)),c=Ch(u,l),h=nt(u,c),p=Re(le(xt(.5),Pn(c)),le(l,h));return hc(p,o,r)}var lxe=ie({huberLoss_:oxe});function uxe(e,t,n,a=1e-7,r=Ss.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"labels","logLoss"),i=K(t,"predictions","logLoss"),o=null;n!=null&&(o=K(n,"weights","logLoss")),Ds(s.shape,i.shape,"Error in logLoss: ");let l=xt(1),u=xt(a),c=sa(le(s,$i(Re(i,u)))),h=le(nt(l,s),$i(Re(nt(l,i),u))),p=nt(c,h);return hc(p,o,r)}var cxe=ie({logLoss_:uxe});function hxe(e,t,n,a=Ss.SUM_BY_NONZERO_WEIGHTS){let r=K(e,"labels","meanSquaredError"),s=K(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=K(n,"weights","meanSquaredError")),Ds(r.shape,s.shape,"Error in meanSquaredError: ");let o=K2(r,s);return hc(o,i,a)}var dxe=ie({meanSquaredError_:hxe});function pxe(e,t){let n=K(e,"labels","sigmoidCrossEntropyWithLogits"),a=K(t,"logits","sigmoidCrossEntropyWithLogits");Ds(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");let r=_n(a),s=le(a,n),i=b1(ds(sa(Ka(a))));return Re(nt(r,s),i)}function fxe(e,t,n,a=0,r=Ss.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"multiClassLabels","sigmoidCrossEntropy"),i=K(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=K(n,"weights","sigmoidCrossEntropy")),Ds(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){let u=xt(a),c=xt(1),h=xt(.5);s=Re(le(s,nt(c,u)),le(h,u))}let l=pxe(s,i);return hc(l,o,r)}var mxe=ie({sigmoidCrossEntropy_:fxe});function gxe(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return nu((a,r,s)=>{let i=x1(r,[n],!0),o=nt(He(r,"float32"),i);s([a,o]);let l=sa(le(o,a));return{value:ut(l,[n]),gradFunc:(u,c)=>{let[h,p]=c,m=_p(u.shape,[n]);return[le(pe(u,m),nt(He(h,"float32"),ds(p))),le(pe(u,m),nt(ds(p),He(h,"float32")))]}}})(e,t)}function yxe(e,t,n,a=0,r=Ss.SUM_BY_NONZERO_WEIGHTS){let s=K(e,"onehotLabels","softmaxCrossEntropy"),i=K(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=K(n,"weights","softmaxCrossEntropy")),Ds(s.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){let u=xt(a),c=xt(1),h=xt(s.shape[1]);s=Re(le(s,nt(c,u)),st(u,h))}let l=gxe(s,i);return hc(l,o,r)}var bxe=ie({softmaxCrossEntropy_:yxe});function xxe(e,t,n,a){let r=K(e,"indices","sparseFillEmptyRows","int32"),s=K(t,"values","sparseFillEmptyRows"),i=K(n,"denseShape","sparseFillEmptyRows","int32"),o=K(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:r,values:s,denseShape:i,defaultValue:o},u=re.runKernel(Zw,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var vxe=ie({sparseFillEmptyRows_:xxe});function wxe(e,t,n){let a=K(e,"inputIndices","sparseReshape","int32"),r=K(t,"inputShape","sparseReshape","int32"),s=K(n,"newShape","sparseReshape","int32");if(a.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${a.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:a,inputShape:r,newShape:s},o=re.runKernel(Lb,i);return{outputIndices:o[0],outputShape:o[1]}}var Axe=ie({sparseReshape_:wxe});function Sxe(e,t,n){let a=K(e,"data","sparseSegmentMean"),r=K(t,"indices","sparseSegmentMean","int32"),s=K(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return re.runKernel(Jw,i)}var kxe=ie({sparseSegmentMean_:Sxe});function Ixe(e,t,n){let a=K(e,"data","sparseSegmentSum"),r=K(t,"indices","sparseSegmentSum","int32"),s=K(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return re.runKernel(e1,i)}var Nxe=ie({sparseSegmentSum_:Ixe});function Cxe(e,t,n,a,r,s,i,o){let l=K(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=K(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:u},p=re.runKernel(a1,h,c);return{nGrams:p[0],nGramsSplits:p[1]}}var Txe=ie({stringNGrams_:Cxe});function Exe(e,t,n=!0){let a=K(e,"input","stringSplit","string"),r=K(t,"delimiter","stringSplit","string");if(a.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);let s={skipEmpty:n},i={input:a,delimiter:r},o=re.runKernel(r1,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var $xe=ie({stringSplit_:Exe});function _xe(e,t){let n=K(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let r={input:n};return re.runKernel(s1,r,a)}var Rxe=ie({stringToHashBucketFast_:_xe});function Dxe(e,t,n,a=!0){let r=K(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:a};return re.runKernel(n1,{x:r},s)}var Oxe=ie({staticRegexReplace_:Dxe}),I8={fft:I1,ifft:yy,rfft:N1,irfft:q2},N8={hammingWindow:lbe,hannWindow:b8,frame:x8,stft:dbe},Xi={flipLeftRight:gbe,grayscaleToRGB:bbe,resizeNearestNeighbor:k8,resizeBilinear:S8,rgbToGrayscale:vbe,rotateWithOffset:Abe,cropAndResize:fbe,nonMaxSuppression:kbe,nonMaxSuppressionAsync:Rbe,nonMaxSuppressionWithScore:Obe,nonMaxSuppressionWithScoreAsync:Mbe,nonMaxSuppressionPadded:zbe,nonMaxSuppressionPaddedAsync:Pbe,threshold:Hbe,transform:qbe},FM={bandPart:Xbe,gramSchmidt:Qbe,qr:Jbe},C8={absoluteDifference:nxe,computeWeightedLoss:hc,cosineDistance:rxe,hingeLoss:ixe,huberLoss:lxe,logLoss:cxe,meanSquaredError:dxe,sigmoidCrossEntropy:mxe,softmaxCrossEntropy:bxe},T8={sparseFillEmptyRows:vxe,sparseReshape:Axe,sparseSegmentMean:kxe,sparseSegmentSum:Nxe},E8={stringNGrams:Txe,stringSplit:$xe,stringToHashBucketFast:Rxe,staticRegexReplace:Oxe},Pe={};Lt(Pe,{Serializable:()=>$8,SerializationMap:()=>_8,getRegisteredName:()=>Mxe,registerClass:()=>R8});var Fxe=new Map,gD=new Map,$8=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},_8=class qg{constructor(){this.classNameMap={}}static getMap(){return qg.instance==null&&(qg.instance=new qg),qg.instance}static register(t){qg.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function R8(e,t,n){J(e.className!=null,()=>"Class being registered does not have the static className property defined."),J(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),J(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let a=n,r=t+">"+a;return _8.register(e),Fxe.set(r,e),gD.set(e,r),e}function Mxe(e){return gD.has(e)?gD.get(e):e.className}var dc=class extends $8{minimize(e,t=!1,n){let{value:a,grads:r}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:r[i.name]}));this.applyGradients(s)}else this.applyGradients(r);return Ft(r),t?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Rq(e,t)}dispose(){this.iterations_!=null&&Ft(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:xt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(dc,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var MM=class extends dc{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=re.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=re.registeredVariables[t],r=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:fe(()=>un(a).variable(r))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:fe(()=>un(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;fe(()=>{let l=Re(le(i,this.rho),le(Pn(s),1-this.rho)),u=le(st(Or(Re(o,this.epsilon)),Or(Re(i,this.epsilon))),s),c=Re(le(o,this.rho),le(Pn(u),1-this.rho));i.assign(l),o.assign(c);let h=Re(le(u,-this.learningRate),a);a.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ft(this.accumulatedGrads.map(e=>e.variable)),Ft(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},LM=class extends dc{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=re.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:fe(()=>Ni(a.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=this.accumulatedGrads[n].variable;fe(()=>{let i=Re(s,Pn(r));s.assign(i);let o=Re(le(st(r,Or(Re(i,re.backend.epsilon()))),-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ft(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},zM=class extends dc{static get className(){return"Adam"}constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],fe(()=>{this.accBeta1=xt(t).variable(),this.accBeta2=xt(n).variable()}),a==null&&(this.epsilon=re.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);fe(()=>{let n=nt(1,this.accBeta1),a=nt(1,this.accBeta2);t.forEach((r,s)=>{let i=re.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:fe(()=>un(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${r}/v`,variable:fe(()=>un(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,c=this.accumulatedSecondMoment[s].variable,h=Re(le(u,this.beta1),le(l,1-this.beta1)),p=Re(le(c,this.beta2),le(Pn(l),1-this.beta2)),m=st(h,n),g=st(p,a);u.assign(h),c.assign(p);let y=Re(le(st(m,Re(Or(g),this.epsilon)),-this.learningRate),i);i.assign(y)}),this.accBeta1.assign(le(this.accBeta1,this.beta1)),this.accBeta2.assign(le(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ft(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),fe(()=>{this.accBeta1.assign(tu(this.beta1,this.iterations_+1)),this.accBeta2.assign(tu(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},BM=class extends dc{static get className(){return"Adamax"}constructor(e,t,n,a=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],fe(()=>{this.iteration=xt(0).variable(),this.accBeta1=xt(t).variable()}),a==null&&(this.epsilon=re.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);fe(()=>{let n=nt(1,this.accBeta1),a=st(-this.learningRate,Re(le(this.iteration,this.decay),1));t.forEach((r,s)=>{let i=re.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:un(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${r}/v`,variable:un(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,c=this.accumulatedWeightedInfNorm[s].variable,h=Re(le(u,this.beta1),le(l,1-this.beta1)),p=le(c,this.beta2),m=Ka(l),g=du(p,m);u.assign(h),c.assign(g);let y=Re(le(st(a,n),st(h,Re(g,this.epsilon))),i);i.assign(y)}),this.iteration.assign(Re(this.iteration,1)),this.accBeta1.assign(le(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ft(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},sC=class extends dc{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let r=re.registeredVariables[t];fe(()=>{let s=Re(le(this.c,a),r);r.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=cr(xt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},PM=class extends sC{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=xt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=re.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:fe(()=>un(a).variable(!1))});let r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&fe(()=>{let i,o=Re(le(this.m,r),s);this.useNesterov?i=Re(le(this.c,Re(s,le(o,this.m))),a):i=Re(le(this.c,o),a),r.assign(o),a.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ft(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},VM=class extends dc{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,a=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,a==null&&(this.epsilon=re.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=re.registeredVariables[t],r=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:fe(()=>un(a).variable(r))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:fe(()=>un(a).variable(r))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:fe(()=>un(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;fe(()=>{let l=Re(le(i,this.decay),le(Pn(s),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,c=Re(le(u,this.decay),le(s,1-this.decay)),h=st(le(s,this.learningRate),Or(nt(l,Re(Pn(c),this.epsilon)))),p=Re(le(o,this.momentum),h);i.assign(l),u.assign(c),o.assign(p);let m=nt(a,p);a.assign(m)}else{let u=Re(le(i,this.decay),le(Pn(s),1-this.decay)),c=Re(le(o,this.momentum),st(le(s,this.learningRate),Or(Re(u,this.epsilon))));i.assign(u),o.assign(c);let h=nt(a,c);a.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ft(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ft(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ft(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Lxe=[MM,LM,zM,BM,PM,VM,sC];function zxe(){for(let e of Lxe)R8(e)}var Kr={};Lt(Kr,{CompositeArrayBuffer:()=>lc,browserFiles:()=>Hxe,browserHTTPRequest:()=>Qxe,concatenateArrayBuffers:()=>Ipe,copyModel:()=>qpe,decodeWeights:()=>rq,decodeWeightsStream:()=>iq,encodeWeights:()=>xpe,fromMemory:()=>Jxe,fromMemorySync:()=>L8,getLoadHandlers:()=>Dpe,getModelArtifactsForJSON:()=>EF,getModelArtifactsForJSONSync:()=>lq,getModelArtifactsInfoForJSON:()=>d1,getSaveHandlers:()=>Rpe,getWeightSpecs:()=>cD,http:()=>WM,isHTTPScheme:()=>bD,listModels:()=>Hpe,loadWeights:()=>qxe,moveModel:()=>Kpe,registerLoadRouter:()=>_pe,registerSaveRouter:()=>$pe,removeModel:()=>jpe,weightsLoaderFactory:()=>O8,withSaveHandler:()=>e0e,withSaveHandlerSync:()=>t0e});var Bxe="model",Pxe=".json",Vxe=".weights.bin";function $G(e){return new Promise(t=>setTimeout(t)).then(e)}var eN=class yD{constructor(t){if(!xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(yD.URL_SCHEME)&&(t=t.slice(yD.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Bxe),this.modelJsonFileName=t+Pxe,this.weightDataFileName=t+Vxe}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=lc.join(t.weightData),a=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=oq(t,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await $G(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=a,await $G(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:d1(t)}}}};eN.URL_SCHEME="downloads://";var Uxe=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=a=>{let r=JSON.parse(a.target.result),s=r.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=EF(r,o=>this.loadWeights(o));e(i)},n.onerror=a=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let a=this.checkManifestAndWeightFiles(e),r=n.map(s=>this.loadWeightsFile(s,a[s]));return Promise.all(r).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,a)=>{let r=new FileReader;r.onload=s=>{let i=s.target.result;n(i)},r.onerror=s=>a(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(r=>CG(r.name)),a={};for(let r of e)r.paths.forEach(s=>{let i=CG(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);a[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}},Wxe=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(eN.URL_SCHEME)?Gxe(e.slice(eN.URL_SCHEME.length)):null;so.registerSaveRouter(Wxe);function Gxe(e="model"){return new eN(e)}function Hxe(e){return new Uxe(e)}function _G(e,t,n,a){i(e),n=n??0,a=a??1,o(n,a);let r=0,s=l=>(l.then(u=>{let c=n+ ++r/e.length*(a-n);return t(c),u}),l);function i(l){J(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){J(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),J(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),J(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(s))}async function D8(e,t){t==null&&(t={});let n=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,a=e.map(s=>n(s,t.requestInit,{isBinary:!0})),r=(t.onProgress==null?await Promise.all(a):await _G(a,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(r):await _G(r,t.onProgress,.5,1)}function jxe(e,t){var n;let a=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,r=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;r<e.length;){s||(s=(await a(e[r],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=await s.read();if(l){r++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}i.enqueue(u);return}i.close()}})}async function qxe(e,t="",n,a){return O8(r=>D8(r,{requestInit:a}))(e,t,n)}function O8(e){return async(t,n="",a)=>{let r=t.map(()=>!1),s={},i=a!=null?a.map(()=>!1):[],o=[];if(t.forEach((m,g)=>{let y=0;m.weights.forEach(b=>{let v="quantization"in b?b.quantization.dtype:b.dtype,w=Np[v]*Rn(b.shape),S=()=>{r[g]=!0,s[g]==null&&(s[g]=[]),s[g].push({manifestEntry:b,groupOffset:y,sizeBytes:w})};a!=null?a.forEach((k,I)=>{k===b.name&&(S(),i[I]=!0)}):S(),o.push(b.name),y+=w})}),!i.every(m=>m)){let m=a.filter((g,y)=>!i[y]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=r.reduce((m,g,y)=>(g&&m.push(y),m),[]),u=[];l.forEach(m=>{t[m].paths.forEach(g=>{let y=n+(n.endsWith("/")?"":"/")+g;u.push(y)})});let c=await e(u),h={},p=0;return l.forEach(m=>{let g=t[m].paths.length,y=new lc(c.slice(p,p+g));s[m].forEach(b=>{let v=y.slice(b.groupOffset,b.groupOffset+b.sizeBytes),w=rq(v,[b.manifestEntry]);for(let S in w)h[S]=w[S]}),p+=g}),h}}var Kxe="application/octet-stream",Xxe="application/json",UM=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(J(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=xe().platform.fetch,J(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&J(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],a=oq(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(a)],{type:Xxe}),"model.json"),e.weightData!=null){let s=lc.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:Kxe}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:d1(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,a=t.weightsManifest;if(n==null&&a==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return EF(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=cD(e.weightsManifest),a=()=>jxe(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:a})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=Yxe(t),r=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(r+l+a);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=cD(e),a=await D8(t,this.loadOptions);return[n,a]}};UM.URL_SCHEME_REGEX=/^https?:\/\//;function Yxe(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}function bD(e){return e.match(UM.URL_SCHEME_REGEX)!=null}var F8=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(a=>bD(a)):n=bD(e),n)return WM(e,t)}return null};so.registerSaveRouter(F8);so.registerLoadRouter(F8);function WM(e,t){return new UM(e,t)}function Qxe(e,t){return WM(e,t)}var dR=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},M8=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},Zxe=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function Jxe(e,t,n,a){let r=arguments;return new Zxe(L8(...r))}function L8(e,t,n,a){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new dR(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new dR({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new dR({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function e0e(e){return new M8(e)}function t0e(e){return new M8(e)}var z8={};Lt(z8,{confusionMatrix:()=>a0e});function n0e(e,t,n){let a=K(e,"labels","confusionMatrix"),r=K(t,"predictions","confusionMatrix");J(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),J(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),J(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),J(a.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),J(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=fy(He(a,"int32"),n),i=fy(He(r,"int32"),n),o=Ut(s),l=Vt(o,i);return He(l,"int32")}var a0e=ie({confusionMatrix_:n0e}),C1={};Lt(C1,{draw:()=>h0e,fromPixels:()=>d0e,fromPixelsAsync:()=>l0e,toPixels:()=>c0e});var Wd,RG=!1;function B8(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)a=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(tw(YI,re.backendName)!=null){let p={pixels:e},m={numChannels:t};return re.runKernel(YI,p,m)}let[l,u]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height],c;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(a||n)c=e.data;else if(s||r||o){if(Wd==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Wd=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Wd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Wd.canvas.width=l,Wd.canvas.height=u,Wd.drawImage(e,0,0,l,u),c=Wd.getImageData(0,0,l,u).data}let h;if(t===4)h=new Int32Array(c);else{let p=l*u;h=new Int32Array(p*t);for(let m=0;m<p;m++)for(let g=0;g<t;++g)h[m*t+g]=c[m*4+g]}return X2(h,[u,l,t],"int32")}function r0e(e){return e!=null&&e.data instanceof Uint8Array}function s0e(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function i0e(e){return e!=null&&e.width!==0&&e.height!==0}function o0e(e){return s0e()&&!(e instanceof ImageBitmap)&&i0e(e)&&!r0e(e)}async function l0e(e,t=3){let n=null;if(xe().getBool("WRAP_TO_IMAGEBITMAP")&&o0e(e)){let a;try{a=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{a=null}a!=null&&a.width===e.width&&a.height===e.height?n=a:n=e}else n=e;return B8(n,t)}function P8(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function u0e(e){let t=e?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function c0e(e,t){let n=K(e,"img","toPixels");if(!(e instanceof Bt)){let u=n;n=He(u,"int32"),u.dispose()}P8(n);let[a,r]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*a*4);for(let u=0;u<a*r;++u){let c=[0,0,0,255];for(let p=0;p<s;p++){let m=i[u*s+p];if(n.dtype==="float32"){if(m<0||m>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${m}.`)}else if(n.dtype==="int32"&&(m<0||m>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${m}.`);s===1?(c[0]=m*o,c[1]=m*o,c[2]=m*o):c[p]=m*o}let h=u*4;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(t!=null){RG||tw(m2,re.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),RG=!0),t.width=r,t.height=a;let u=t.getContext("2d"),c=new ImageData(l,r,a);u.putImageData(c,0,0)}return n!==e&&n.dispose(),l}function h0e(e,t,n){let a=K(e,"img","draw");if(!(e instanceof Bt)){let i=a;a=He(i,"int32"),i.dispose()}P8(a),u0e(n?.imageOptions);let r={image:a},s={canvas:t,options:n};re.runKernel(m2,r,s)}var d0e=ie({fromPixels_:B8}),GM={};Lt(GM,{prepareAndValidate:()=>V8});function V8(e,t){let n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(Rn(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let r=t.shape,s=r[r.length-1],i=1;for(let h=0;h<r.length-1;++h)i*=r[h];let o=e.shape,l=r.slice();l.pop();let u=1;for(let h=s;h<n;++h)u*=o[h],l.push(o[h]);let c=[...Uy(e.shape).map(h=>h/u),1].slice(0,s);return[l,i,u,c]}var mr={};Lt(mr,{assertParamsValid:()=>f0e,computeFlatOffset:()=>x0e,computeOutShape:()=>g0e,getNormalizedAxes:()=>y0e,isSliceContinous:()=>b0e,maskToAxes:()=>m0e,parseSliceParams:()=>Y8,sliceInfo:()=>v0e,startForAxis:()=>K8,startIndicesWithElidedDims:()=>H8,stopForAxis:()=>X8,stopIndicesWithElidedDims:()=>j8,stridesForAxis:()=>q8,stridesWithElidedDims:()=>U8});var xD=-2,p0e=-1;function f0e(e,t,n){let a=e.shape.length;J(a===t.length,()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`),J(a===n.length,()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);for(let r=0;r<a;++r)J(t[r]+n[r]<=e.shape[r],()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function m0e(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function g0e(e,t,n){let a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function U8(e,t,n,a){let r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)s===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function W8(e,t,n){return n<=e?n:n-(t-1)}function G8(e,t){let n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function y0e(e,t,n,a,r,s,i,o,l){let u=e.length,c=new Array(u),h=new Array(u),p=new Array(u);if(t.length&&n>0){let m=t[0],g=n+1;c=H8(i,m,g,a,e),h=j8(o,m,g,r,e),p=U8(s,m,g,e)}else for(let m=0;m<u;m++)c[m]=K8(i,a,s,e,m,l),h[m]=X8(o,r,s,e,m,l),p[m]=q8(s,m,l);return{begin:c,end:h,strides:p}}function H8(e,t,n,a,r){let s=[...r],i=G8(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=W8(t,n,o),u=a[l];e&1<<l&&(u=0),s[o]=u}return s}function j8(e,t,n,a,r){let s=[...r],i=G8(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=W8(t,n,o),u=a[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[o]=u}for(let o=0;o<s.length;o++){let l=r[o];s[o]<0&&(s[o]+=l),s[o]=Jv(0,s[o],r[o])}return s}function q8(e,t,n){let a=e[t];return(n&1<<t||a==null)&&(a=1),a}function K8(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),i=Jv(0,i,l-1),i}function X8(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),o>0?i=Jv(0,i,l):i=Jv(-1,i,l-1),i}function b0e(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function x0e(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function Y8(e,t,n){let a,r=e.shape.length;typeof t=="number"?a=[t,...new Array(r-1).fill(0)]:t.length<r?a=t.concat(new Array(r-t.length).fill(0)):a=t.slice(),a.forEach(i=>{J(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(r).fill(-1):typeof n=="number"?s=[n,...new Array(r-1).fill(-1)]:n.length<r?s=n.concat(new Array(r-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(J(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-a[o])),[a,s]}function v0e(e,t,n,a,r,s,i,o,l){let u;if(a==null?(u=new Array(t.length),u.fill(1)):u=a,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let w=0;w<h.dims;w++)c&&1<<w&o&&h.numAddAxisAfterEllipsis++,1<<w&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);let p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};w0e(h,p);let m=!0,g=!0,y=!0,b=[],v=[];for(let w=0;w<e.length;++w){if(p.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let S=!!(p.shrinkAxisMask&1<<w),k=e[w];if(k===-1){b.push(S?1:-1);continue}let I=[p.beginMask&1<<w,p.endMask&1<<w],T=[p.strides[w]>0?0:-1,p.strides[w]>0?k:k-1];if(S&&p.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&p.strides[w]===1;let E=!!(p.beginMask&1<<w&&p.endMask&1<<w);if(p.beginValid&&p.endValid){if(S){let $=p.begin[w]<0?k+p.begin[w]:p.begin[w];if(p.begin[w]=$,p.end[w]=p.begin[w]+1,$<0||$>=k)throw Error(`slice index ${p.begin[w]} of dimension ${w} out of bounds.`)}else p.begin[w]=DG(p.begin[w],0,p.strides[w],k,I,T),p.end[w]=DG(p.end[w],1,p.strides[w],k,I,T);let O=p.strides[w]===1&&p.begin[w]===0&&p.end[w]===k;m=m&&O,g=g&&(w===0&&p.strides[w]===1||O)}else m=m&&p.strides[w]===1&&E,g=g&&(w===0&&p.strides[w]===1||E);let R,D=!1;if(p.beginValid&&p.endValid?(R=p.end[w]-p.begin[w],D=!0):S?(R=1,D=!0):E&&k>=0&&(p.strides[w]<0?R=-k:R=k,D=!0),D){let O;R===0||R<0!=p.strides[w]<0?O=0:O=Math.trunc(R/p.strides[w])+(R%p.strides[w]!==0?1:0),b.push(O)}else b.push(-1)}for(let w=0;w<p.finalShapeGatherIndices.length;++w){let S=p.finalShapeGatherIndices[w];S>=0?v.push(b[S]):S===xD&&v.push(1)}return{finalShapeSparse:v.filter((w,S)=>p.finalShapeGatherIndices[S]!==xD),finalShape:v,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:p.begin,end:p.end,strides:p.strides}}function w0e(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(xD),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[a]),e.end!=null&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(p0e),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function DG(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{let i=e<0?a+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var A0e="4.22.0",Q8=class{static sgd(e){return new sC(e)}static momentum(e,t,n=!1){return new PM(e,t,n)}static rmsprop(e,t=.9,n=0,a=null,r=!1){return new VM(e,t,n,a,r)}static adam(e=.001,t=.9,n=.999,a=null){return new zM(e,t,n,a)}static adadelta(e=.001,t=.95,n=null){return new MM(e,t,n)}static adamax(e=.002,t=.9,n=.999,a=null,r=0){return new BM(e,t,n,a,r)}static adagrad(e,t=.1){return new LM(e,t)}},Xd=Q8,S0e=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function HM(){return new Promise(e=>S0e(()=>e()))}var G={};Lt(G,{ERF_A1:()=>z0e,ERF_A2:()=>B0e,ERF_A3:()=>P0e,ERF_A4:()=>V0e,ERF_A5:()=>U0e,ERF_P:()=>L0e,PARALLELIZE_THRESHOLD:()=>jM,RowPartitionType:()=>Ml,SELU_SCALE:()=>J8,SELU_SCALEALPHA:()=>Z8,applyActivation:()=>aC,assertAndGetBroadcastShape:()=>Wn,assertAxesAreInnerMostDims:()=>vme,assertParamsConsistent:()=>k0e,assignToTypedArray:()=>K0e,axesAreInnerMostDims:()=>aM,calculateShapes:()=>i8,checkEinsumDimSizes:()=>eve,checkPadOnDimRoundingMode:()=>Os,combineLocations:()=>Cq,combineRaggedTensorToTensorShapes:()=>N0e,complexWithEvenIndex:()=>H0e,complexWithOddIndex:()=>j0e,computeConv2DInfo:()=>p1,computeConv3DInfo:()=>bq,computeDefaultPad:()=>BF,computeDilation2DInfo:()=>bfe,computeOptimalWindowSize:()=>$0e,computeOutAndReduceShapes:()=>Tq,computeOutShape:()=>I0e,computePool2DInfo:()=>yq,computePool3DInfo:()=>xfe,convertConv2DDataFormat:()=>xq,decodeEinsumEquation:()=>Z0e,eitherStridesOrDilationsAreOne:()=>hu,expandShapeToKeepDim:()=>_p,exponent:()=>Y0e,exponents:()=>X0e,fromStringArrayToUint8:()=>wve,fromUint8ToStringArray:()=>vve,getAxesPermutation:()=>Eq,getBroadcastDims:()=>Iq,getComplexWithIndex:()=>q0e,getEinsumComputePath:()=>tve,getEinsumPermutation:()=>J0e,getFusedBiasGradient:()=>nC,getFusedDyActivation:()=>tC,getImageCenter:()=>_0e,getInnerMostAxes:()=>wme,getPermuted:()=>D0e,getRaggedRank:()=>T0e,getReductionAxes:()=>tr,getReshaped:()=>R0e,getReshapedPermuted:()=>O0e,getRowPartitionTypesHelper:()=>C0e,getSliceBeginCoords:()=>F0e,getSliceSize:()=>M0e,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>sve,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>ive,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>ove,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>cve,getSparseReshapeInputOutputMismatchErrorMessage:()=>dve,getSparseReshapeInputOutputMultipleErrorMessage:()=>hve,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>lve,getSparseReshapeNegativeOutputDimErrorMessage:()=>uve,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>gve,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>pve,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>fve,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>mve,getUndoAxesPermutation:()=>rM,isIdentityPermutation:()=>nve,log:()=>$de,mergeRealAndImagArrays:()=>W0e,prepareAndValidate:()=>V8,prepareSplitSize:()=>rve,segment_util:()=>eK,shouldFuse:()=>rC,slice_util:()=>mr,splitRealAndImagArrays:()=>G0e,stridesOrDilationsArePositive:()=>$p,tupleValuesAreOne:()=>Ih,upcastType:()=>ro,validateDefaultValueShape:()=>E0e,validateInput:()=>Q2,validateUpdateShape:()=>NM,warn:()=>oh});function k0e(e,t){let n=e[0].length;e.forEach((r,s)=>{J(r.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),J(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let a=e[0];e.forEach((r,s)=>{for(let i=0;i<n;i++)J(i===t||r[i]===a[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`)})}function I0e(e,t){let n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var Ml;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Ml||(Ml={}));function N0e(e,t,n){let a=new Array;if(n==null&&t==null)return a;if(t==null)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(n==null)return a;if(e+n.length!==a.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${a.length}`);for(let r=1;r<n.length;++r){let s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${s} but shape[${r+e}] = ${o}`)}else a[i]=s}return a}function C0e(e){let t={FIRST_DIM_SIZE:Ml.FIRST_DIM_SIZE,VALUE_ROWIDS:Ml.VALUE_ROWIDS,ROW_LENGTHS:Ml.ROW_LENGTHS,ROW_SPLITS:Ml.ROW_SPLITS,ROW_LIMITS:Ml.ROW_LIMITS,ROW_STARTS:Ml.ROW_STARTS},n=[];for(let a of e)if(a in t)n.push(t[a]);else break;return n}function T0e(e){return e.length===0?0:e[0]===Ml.FIRST_DIM_SIZE?e.length-1:e.length}function E0e(e,t){if(e==null||t==null)return;let n=e.length,a=t.length;if(n>=a)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);for(let r=0;r<Math.min(n,a-1);++r){let s=e[r],i=t[r+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${s} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}var jM=30;function $0e(e){return e<=jM?e:XI(e,Math.floor(Math.sqrt(e)))}function _0e(e,t,n){let a=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[a,r]}function R0e(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)r=r.concat([e[i+1]/t[i],t[i]]);r=r.concat(e.slice(s+1))}return r}function D0e(e,t,n=!0){let a=[];if(n){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{let r=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):r.push(i);a.push(...r),a.push(0),a.push(...s)}return a}function O0e(e,t,n,a=!0){let r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function F0e(e,t){let n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function M0e(e,t,n){let a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var Z8=1.7580993408473768,J8=1.0507009873554805,L0e=.3275911,z0e=.254829592,B0e=-.284496736,P0e=1.421413741,V0e=-1.453152027,U0e=1.061405429;function W0e(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function G0e(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function H0e(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function j0e(e){let t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function q0e(e,t){let n=e[t*2],a=e[t*2+1];return{real:n,imag:a}}function K0e(e,t,n,a){e[a*2]=t,e[a*2+1]=n}function X0e(e,t){let n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function Y0e(e,t,n){let a=(n?2:-2)*Math.PI*(e/t),r=Math.cos(a),s=Math.sin(a);return{real:r,imag:s}}var pR="->",Q0e=/->/g,OG=",",FG="...";function Z0e(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(Q0e,"").length)/pR.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${pR}").`);let[a,r]=e.split(pR);J(a.indexOf(FG)===-1,()=>`The ellipsis notation ("${FG}") is not supported yet.`);let s=a.split(OG),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let p=0;p<r.length;++p){let m=r[p];if(!s.some(g=>g.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);o.indexOf(m)===-1&&o.push(m)}for(let p=0;p<a.length;++p){let m=a[p];o.indexOf(m)===-1&&m!==OG&&o.push(m)}let l=new Array(s.length);for(let p=0;p<i;++p){if(new Set(s[p].split("")).size!==s[p].length)throw new Error(`Found duplicate axes in input component ${s[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let m=0;m<s[p].length;++m)l[p].push(o.indexOf(s[p][m]))}let u=o.length,c=r.length,h=[];for(let p=c;p<u;++p)h.push(p);return{allDims:o,summedDims:h,idDims:l}}function J0e(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;let a=[];for(let r=0;r<e;++r)n[r]===-1&&a.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:a}}function eve(e,t,n){let a=new Array(e);for(let r=0;r<n.length;++r){let s=n[r].shape;for(let i=0;i<t[r].length;++i)a[t[r][i]]===void 0?a[t[r][i]]=s[i]:J(a[t[r][i]]===s[i],()=>`Expected dimension ${a[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function tve(e,t){let n=e,a=[],r=0;e.length===0&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=ave(t,o);for(let u of l)s.indexOf(u)===-1&&(a[i].push(u),s.push(u))}return{path:n,steps:a}}function nve(e){return e.every((t,n)=>t===n)}function ave(e,t){let n=[];for(let a=0;a<e.length;++a)(e[a].length===0||e[a].indexOf(t)!==-1||t===-1)&&n.push(a);return n}function rve(e,t,n=0){let a=[];if(typeof t=="number")J(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{let r=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);J(r<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}J(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function sve(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function ive(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function ove(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function lve(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function uve(e,t){return`size ${e} must be non-negative, not ${t}`}function cve(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function hve(e,t){let n=Rn(e),a=Rn(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function dve(e,t){let n=Rn(e),a=Rn(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function pve(){return"segment ids must be >= 0"}function fve(){return"segment ids are not increasing"}function mve(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function gve(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var eK={};Lt(eK,{collectGatherOpShapeInfo:()=>xve,computeOutShape:()=>bve,segOpComputeOptimalWindowSize:()=>yve});function yve(e,t){let n=!1,a;for(e<=jM?(a=e,n=!0):a=XI(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=XI(e,a+1);return a}function bve(e,t,n){let a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function xve(e,t,n,a){let r=t.shape.length,s=e.shape.length;if(a!==0&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (
    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let h=0;h<a;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=a;h<r;h++)o.push(t.shape[h]);for(let h=n+1;h<s;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function vve(e){try{return e.map(t=>ZI(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function wve(e){return e.map(t=>c1(t))}var pu={};Lt(pu,{nonMaxSuppressionV3Impl:()=>v8,nonMaxSuppressionV4Impl:()=>w8,nonMaxSuppressionV5Impl:()=>A8,whereImpl:()=>u8});zxe();var tK={kernelName:Wy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,Tm(He(n,"float32"),-1))}}},Ave={kernelName:of,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Pn(He(n,"float32")),r=Or(nt(xt(1),a));return sa(st(e,r))}}}},Sve={kernelName:lf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Or(nt(Pn(He(n,"float32")),1));return st(e,a)}}}},kve={kernelName:Xh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Wn(n.shape,a.shape);return{a:()=>{let s=e,i=tr(n.shape,r);return i.length>0&&(s=ut(s,i)),pe(s,n.shape)},b:()=>{let s=e,i=tr(a.shape,r);return i.length>0&&(s=ut(s,i)),pe(s,a.shape)}}}},Ive={kernelName:uf,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((a,r)=>{n[r]=()=>e.clone()}),n}},Nve={kernelName:jy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>un(n)}}},Cve={kernelName:qy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>un(n)}}},Tve={kernelName:cf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,Or(nt(xt(1),Pn(He(n,"float32")))))}}},Eve={kernelName:hf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Or(Re(xt(1),Pn(He(n,"float32"))));return st(e,a)}}}},$ve={kernelName:ff,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Wn(n.shape,a.shape);return{a:()=>{let s=Re(Pn(n),Pn(a)),i=le(e,st(a,s)),o=tr(n.shape,r);return o.length>0&&(i=ut(i,o)),pe(i,n.shape)},b:()=>{let s=Re(Pn(n),Pn(a)),i=sa(le(e,st(n,s))),o=tr(a.shape,r);return o.length>0&&(i=ut(i,o)),pe(i,a.shape)}}}},_ve={kernelName:df,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,Re(Pn(He(n,"float32")),1))}}},Rve={kernelName:pf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,nt(xt(1),Pn(He(n,"float32"))))}}};function Dve(e,t,n,a,r,s){let i=K(e,"dy","avgPool3dGrad"),o=K(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;o.rank===4&&(c=!0,l=pe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),J(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Os("avgPool3dGrad",r,s);let h={dy:l,input:u},p={filterSize:n,strides:a,pad:r,dimRoundingMode:s},m=re.runKernel(Uw,h,p);return c?pe(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Ove=ie({avgPool3dGrad_:Dve}),Fve={kernelName:Ky,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>Ove(e,a,r,s,i,o)}}};function Mve(e,t,n,a,r){let s=K(e,"dy","avgPoolGrad"),i=K(t,"input","avgPoolGrad");J(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,u=!1;i.rank===3&&(u=!0,o=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=pe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),J(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),J(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:l,input:o},h={filterSize:n,strides:a,pad:r},p=re.runKernel(Vw,c,h);return u?pe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Lve=ie({avgPoolGrad_:Mve}),zve={kernelName:mf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>Lve(e,a,r,s,i)}}},Bve={kernelName:gf,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[a,r]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>Vt(e,r,!1,!0),b:()=>Vt(a,e,!0,!1)}:!s&&i?{a:()=>Vt(e,r,!1,!1),b:()=>Vt(e,a,!0,!1)}:s&&!i?{a:()=>Vt(r,e,!1,!0),b:()=>Vt(a,e,!1,!1)}:{a:()=>Vt(r,e,!0,!0),b:()=>Vt(e,a,!0,!0)}}},Pve={kernelName:Xy,gradFunc:(e,t,n)=>{let{blockShape:a,crops:r}=n;return{x:()=>A1(e,a,r)}}},Vve={kernelName:P5,gradFunc:(e,t,n)=>{let a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let l=r.length-1;l>=0;l--)if(r[l]===s[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ut(e,o,!0)}}},Uve={kernelName:yf,gradFunc:e=>({x:()=>e.clone()})},Wve={kernelName:bf,gradFunc:e=>({x:()=>un(e)})},Gve={kernelName:Yh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>Dr(zo(cc(a,r),ed(a,s)),e,un(e))}}},Hve={kernelName:Gw,inputsToSave:["x"],gradFunc:tK.gradFunc},jve={kernelName:Zy,saveAllInputs:!0,gradFunc:(e,t,n)=>{let a=t.map(o=>o.shape),{axis:r}=n,s=Po(r,t[0].shape)[0],i=a.map(o=>o[s]);return Ks(e,i,s).map(o=>()=>o)}},qve={kernelName:xf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return J(Ih(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>YF(a.shape,e,r,i,o,l),filter:()=>DM(a,e,r.shape,i,o,l)}}},Kve={kernelName:vf,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Ts(e,r,s,i,o,1,l),filter:()=>DM(e,a,r.shape,s,i,o,l)}}};function Xve(e,t,n,a,r){let s=e;e.rank===4&&(s=pe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=pe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),J(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),J(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),J(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),J(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),J(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:a,pad:r,filterShape:n};return re.runKernel(Jy,o,l)}var Yve=ie({conv3DBackpropFilter_:Xve}),Qve={kernelName:wf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s}=n;J(Ih(a),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let[i,o]=t;return{x:()=>Sq(i.shape,e,o,r,s),filter:()=>Yve(i,e,o.shape,r,s)}}},Zve={kernelName:Af,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(sa(G2(He(n,"float32"))),e)}}},Jve={kernelName:Sf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(H2(He(n,"float32")),e)}}},ewe={kernelName:kf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{let o=Eq([r],a.rank),l=R2(e,r,s,!i);return o!=null&&(l=Ut(l,o)),l}}}},twe={kernelName:If,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=a??[1,1];J(Ih(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return J(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),J(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),J(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),J(hu(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Os("depthwiseConv2d",s,i),{x:()=>y8(l.shape,e,u,r,s,o,i),filter:()=>g8(l,e,u.shape,r,s,o,i)}}},nwe={kernelName:Nf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,s={x:a,filter:r,dy:e},i={x:a,filter:r,dy:e};return{x:()=>re.runKernel(uy,s,n),filter:()=>re.runKernel(cy,i,n)}}},awe={kernelName:Tf,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,a={dy:e,y:n};return{x:()=>re.runKernel(rb,a)}}},rwe={kernelName:Ef,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=le(ds(sa(Pn(n))),2/Math.sqrt(Math.PI));return{x:()=>le(e,a)}}},swe={kernelName:$f,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,n)}}},iwe={kernelName:ib,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>pe(e,n.shape)}}},owe={kernelName:_f,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,ds(n))}}},lwe={kernelName:Rf,gradFunc:e=>({x:()=>un(e)})},uwe={kernelName:Df,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Wn(n.shape,a.shape);return{a:()=>{let s=st(e,He(a,"float32")),i=tr(n.shape,r);return i.length>0?pe(ut(s,i),n.shape):s},b:()=>{let s=le(e,He(n,"float32")),i=tr(a.shape,r);i.length>0&&(s=pe(ut(s,i),a.shape));let o=Pn(a);return sa(st(s,He(o,"float32")))}}}},cwe={kernelName:Of,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:a}=n,[r,s,i,o]=t,l=o??xt(1),u=tr(s.shape,r.shape),c=[];if(s.rank===1){for(let y=0;y<r.shape.length-1;++y)c.push(r.shape[y]);c.push(1)}let h=nt(r,s),p=le(e,l),m=U2(Re(i,xt(a))),g=le(le(le(m,m),m),xt(-.5));return{x:()=>s.rank===1?pe(le(le(e,Ii(pe(m,[1,1,1,s.shape[0]]),c)),l),r.shape):pe(le(le(e,m),l),r.shape),mean:()=>{let y=le(le(m,xt(-1)),p);return s.rank===1&&(y=ut(y,u)),pe(y,s.shape)},variance:()=>{let y=le(le(g,h),p);return s.rank===1&&(y=ut(y,u)),pe(y,s.shape)},scale:()=>{let y=le(h,m),b=le(e,y);return s.rank===1&&(b=ut(b,u)),pe(b,s.shape)},offset:()=>{let y=e;return s.rank===1&&(y=ut(y,u)),pe(y,s.shape)}}}},hwe={kernelName:lb,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[a,r]=t,{axis:s,batchDims:i}=n,o=Po(s,a.shape)[0],l=(u,c,h)=>()=>{let p=u.shape,m=c.size,g=p.slice(0,o),y=g.length,b=p.slice(s,p.length).slice(1),v=b.length,w=MG(0,y),S=MG(y+1,y+1+v),k=LG([g,[m],b]),I=pe(h,k),T=pe(c,[m]),E=LG([[y],w,S]),R=Ut(I,E),D=J2(R,T,u.shape[o]),O=rM(E);return D=Ut(D,O),D};if(i===1){let u=a.shape[0],c=a.split(u,0);return{x:()=>Ja(c.map((h,p)=>l(h,r.slice(p,1),e.slice(p,1))())).reshape(a.shape),indices:()=>r}}else return{x:l(a,r,e),indices:()=>r}}};function MG(e,t){let n=[];for(let a=e;a<t;++a)n.push(a);return n}function LG(e){let t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var dwe={kernelName:Ff,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>un(n),b:()=>un(a)}}},pwe={kernelName:Mf,gradFunc:e=>({x:()=>He(e,"float32")})},fwe={kernelName:Lf,gradFunc:e=>({x:()=>un(e)})},mwe={kernelName:zf,gradFunc:e=>({x:()=>un(e)})},gwe={kernelName:Bf,gradFunc:e=>({x:()=>un(e)})},ywe={kernelName:Pf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{alpha:r}=n,s=Fs(a,0);return{x:()=>Dr(s,e,le(e,r))}}},bwe={kernelName:Uf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,Re(n,1))}}},xwe={kernelName:Vf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,He(n,"float32"))}}},vwe={kernelName:U5,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n;return{logits:()=>{let s=ds(a);return nt(e,le(ut(e,r,!0),s))}}}};function wwe(e,t,n,a=5,r=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:a,bias:r,alpha:s,beta:i};return re.runKernel(yb,o,l)}var Awe=ie({localResponseNormalizationBackprop_:wwe}),Swe={kernelName:Wf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>Awe(a,r,e,s,i,o,l)}}};function nK(e,t,n,a){return t.rank<n.rank&&(t=pe(t,_p(t.shape,a))),e.rank<n.rank&&(e=pe(e,_p(e.shape,a))),{x:()=>le(e,He(Ei(n,t),e.dtype))}}var zG={kernelName:Gf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{reductionIndices:r}=a,s=t[0],i=t[1],o=Po(r,s.shape),l=nK(e,i,s,o);return{x:()=>l.x()}}},kwe={kernelName:Hf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>le(e,He(cc(n,a),"float32")),b:()=>le(e,He(py(n,a),"float32"))}}};function Iwe(e,t,n,a,r,s,i){let o=K(e,"dy","maxPool3dGrad"),l=K(t,"input","maxPool3dGrad"),u=K(n,"output","maxPool3dGrad"),c=o,h=l,p=u,m=!1;l.rank===4&&(m=!0,c=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=pe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=pe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),J(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),J(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),J(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),Os("maxPool3dGrad",s,i);let g={dy:c,input:h,output:p},y={filterSize:a,strides:r,pad:s,dimRoundingMode:i},b=re.runKernel(Xw,g,y);return m?pe(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}var Nwe=ie({maxPool3dGrad_:Iwe}),Cwe={kernelName:bb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>Nwe(e,a,r,s,i,o,l)}}};function Twe(e,t,n,a,r,s,i){let o=K(e,"dy","maxPoolGrad"),l=K(t,"input","maxPoolGrad"),u=K(n,"output","maxPoolGrad");J(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),J(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),J(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Os("maxPoolGrad",s,i);let c={dy:o,input:l,output:u},h={filterSize:a,strides:r,pad:s,dimRoundingMode:i};return re.runKernel(Kw,c,h)}var Ewe=ie({maxPoolGrad_:Twe}),$we={kernelName:jf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>Ewe(e,a,r,s,i,o)}}},_we={kernelName:qf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=Po(r,a.shape),i=Tq(a.shape,s)[1],o=Rn(i);return{x:()=>{let l=a.shape.slice();s.forEach(c=>{l[c]=1});let u=pe(e,l);return st(le(u,js(a.shape,"float32")),o)}}}},Rwe={kernelName:Kf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{axis:r}=a,[s,i]=t,o=Po(r,s.shape),l=nK(e,i,s,o);return{x:()=>l.x()}}},Dwe={kernelName:Xf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>le(e,He(ed(n,a),"float32")),b:()=>le(e,He(Fs(n,a),"float32"))}}},Owe={kernelName:Yf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>en(e,s,a.shape)}}},Fwe={kernelName:Qf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Wn(n.shape,a.shape);return{a:()=>{let s=tr(n.shape,r);return s.length>0?pe(ut(e,s),n.shape):e},b:()=>{let s=le(e,sa(Kb(st(n,a)))),i=tr(a.shape,r);return i.length>0?pe(ut(s,i),a.shape):s}}}},Mwe={kernelName:Zf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Wn(n.shape,a.shape);return{a:()=>{let s=le(e,He(a,"float32")),i=tr(n.shape,r);return i.length>0?pe(ut(s,i),n.shape):s},b:()=>{let s=le(e,He(n,"float32")),i=tr(a.shape,r);return i.length>0?pe(ut(s,i),a.shape):s}}}},Lwe={kernelName:vb,gradFunc:e=>({x:()=>sa(e)})},zwe={kernelName:Jf,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>Aa(n.shape,"float32")}}},Bwe={kernelName:Ib,gradFunc:e=>({x:()=>un(e)})},Pwe={kernelName:Nb,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:a}=n;return Ra(e,a).map(r=>()=>r)}},BG={kernelName:em,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>en(e,s,a.shape)}}},Vwe={kernelName:tm,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,a,r]=t,s=n,i=a,o=Wn(s.shape,i.shape);return{a:()=>{let l=He(i,"float32"),u=le(e,le(l,tu(s,nt(l,xt(1))))),c=tr(s.shape,o);return c.length>0&&(u=ut(u,c)),pe(u,s.shape)},b:()=>{let l=Fs(s,0),u=Dr(l,$i(s),un(s)),c=le(e,le(r,u)),h=tr(i.shape,o);return h.length>0&&(c=ut(c,h)),pe(c,i.shape)}}}},Uwe={kernelName:nm,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,a]=t,r=Fs(n,0);return{x:()=>Dr(r,e,le(e,a)),alpha:()=>{let s=Dr(r,un(e),le(e,n)),i=tr(a.shape,e.shape);return i.length>0&&(s=ut(s,i)),pe(s,a.shape)}}}};function Wwe(e,t,n){let a=e.shape.slice();a[n]=1;let r=pe(t,a),s=ow(e,n,!0,!1),i=ow(e,n,!0,!0),o=le(s,i);return le(r,o)}function Gwe(e,t,n){let a=e.shape.length,r=a-n.length,s=G.getAxesPermutation(n,a),i=e;s!=null&&(i=Ut(e,s));let o=i.shape.slice(),l=o.splice(a-n.length,n.length).reduce((h,p)=>h*p,1);o.push(l);let u=i.reshape(o),c=Wwe(u,t,r);if(c=c.reshape(i.shape),s!=null){let h=G.getUndoAxesPermutation(s);c=Ut(c,h)}return c}var Hwe={kernelName:am,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=[];return r==null?s=a.shape.map((i,o)=>o):typeof r=="number"?s=[r]:s=r,{x:()=>Gwe(a,e,s)}}},jwe={kernelName:Cf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Wn(n.shape,a.shape);return{a:()=>{let s=st(e,He(a,"float32")),i=tr(n.shape,r);return i.length>0?pe(ut(s,i),n.shape):s},b:()=>{let s=le(e,He(n,"float32")),i=tr(a.shape,r);i.length>0&&(s=pe(ut(s,i),a.shape));let o=Pn(a);return sa(st(s,He(o,"float32")))}}}},qwe={kernelName:rm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,sa(Pn(n)))}}},Kwe={kernelName:lm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=le(ed(n,6),Tm(n));return{x:()=>le(e,He(a,"float32"))}}},Xwe={kernelName:sm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,He(Tm(n),"float32"))}}},Ywe={kernelName:Cb,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pe(e,n.shape)}}},Qwe={kernelName:om,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>re.runKernel(Eb,r,n)}}},Zwe={kernelName:im,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>re.runKernel(Tb,r,n)}}},Jwe={kernelName:um,gradFunc:(e,t,n)=>{let{dims:a}=n,r=Po(a,e.shape);return{x:()=>io(e,r)}}},e1e={kernelName:cm,gradFunc:e=>({x:()=>un(e)})},t1e={kernelName:hm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sa(st(e,le(tu(n,1.5),2)))}}},n1e={kernelName:Db,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>He(un(n),"float32"),t:()=>le(e,He(n,e.dtype)),e:()=>le(e,He(v1(n),e.dtype))}}},a1e={kernelName:dm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Fs(n,xt(0)),r=xt(Z8),s=xt(J8),i=le(e,s),o=le(le(e,r),ds(He(n,"float32")));return Dr(a,i,o)}}}},r1e={kernelName:gm,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,le(n,nt(xt(1),n)))}}},s1e={kernelName:mm,gradFunc:e=>({x:()=>un(e)})},i1e={kernelName:pm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(m1(He(n,"float32")),e)}}},o1e={kernelName:fm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(_2(He(n,"float32")),e)}}},l1e={kernelName:Ob,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{begin:r,size:s}=n,i=a.shape,[o,l]=Y8(a,r,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>wl(e,u)}}},u1e={kernelName:vm,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{dim:r}=n,s=!0,i=le(e,a);return{logits:()=>nt(i,le(ut(i,[r],s),a))}}},c1e={kernelName:ym,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,Mo(n))}}},PG={kernelName:Fb,gradFunc:(e,t,n)=>{let{blockShape:a,paddings:r}=n;return{x:()=>f1(e,a,r)}}},VG={kernelName:Mb,gradFunc:(e,t,n)=>{let{axis:a}=n;return{x:()=>Un(e,a)}}},h1e={kernelName:bm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,le(Or(He(n,"float32")),2))}}},d1e={kernelName:t1,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,le(He(n,"float32"),2))}}},p1e={kernelName:wm,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=xt(2);return{a:()=>le(e,le(r,nt(n,a))),b:()=>le(e,le(r,nt(a,n)))}}},f1e={kernelName:Zh,gradFunc:e=>({x:()=>un(e)})},m1e={kernelName:Am,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Wn(n.shape,a.shape);return{a:()=>{let s=e,i=tr(n.shape,r);return i.length>0&&(s=ut(s,i)),pe(s,n.shape)},b:()=>{let s=e,i=tr(a.shape,r);return i.length>0&&(s=ut(s,i)),pe(sa(s),a.shape)}}}},g1e={kernelName:xm,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,r=a.shape.slice(),{axis:s}=n;Po(s,a.shape).forEach(l=>{r[l]=1});let i=pe(e,r),o=le(i,js(a.shape,"float32"));return{x:()=>o}}},y1e={kernelName:Sm,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>st(e,Pn(m1(n)))}}},b1e={kernelName:km,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(nt(xt(1),Pn(n)),e)}}},x1e={kernelName:Qh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{reps:r}=n;return{x:()=>{let s=un(a);if(a.rank===1)for(let i=0;i<r[0];++i)s=Re(s,en(e,[i*a.shape[0]],[a.shape[0]]));else if(a.rank===2)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)s=Re(s,en(e,[i*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(a.rank===3)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)s=Re(s,en(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else if(a.rank===4)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)for(let u=0;u<r[3];++u)s=Re(s,en(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2],u*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);return s}}}},v1e={kernelName:Ku,gradFunc:(e,t,n)=>{let a=n,{perm:r}=a,s=rM(r);return{x:()=>Ut(e,s)}}},w1e={kernelName:Ub,gradFunc:(e,t,n)=>{let a=n,{axis:r}=a;return{value:()=>Ja(e,r)}}},A1e={kernelName:o1,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>S1e(e,n)}}};function S1e(e,t){let n=du(t,un(t)),a=Xb(e,n),r=cc(t,xt(0,"int32")),s=a.rank-r.rank;for(let o=0;o<s;++o)r=Tr(r,o+1);r=zo(r,js(a.shape,"bool"));let i=un(a);return Dr(r,a,i)}var k1e={kernelName:Wb,gradFunc:e=>({x:()=>un(e)})},I1e=[tK,Ave,Sve,kve,Ive,Nve,Cve,Tve,Eve,$ve,_ve,Rve,Fve,zve,Bve,Pve,Vve,Uve,Wve,Gve,Hve,jve,Kve,qve,Qve,Zve,Jve,ewe,twe,nwe,jwe,awe,rwe,swe,iwe,owe,uwe,lwe,cwe,hwe,dwe,pwe,fwe,mwe,gwe,ywe,bwe,xwe,vwe,Swe,zG,zG,kwe,Cwe,$we,_we,Rwe,Dwe,Owe,Fwe,Mwe,Lwe,zwe,Bwe,Pwe,BG,BG,Vwe,Uwe,Hwe,qwe,Kwe,Xwe,Ywe,Qwe,Zwe,Jwe,e1e,t1e,n1e,a1e,r1e,s1e,i1e,o1e,l1e,u1e,c1e,PG,PG,VG,VG,h1e,p1e,d1e,f1e,m1e,g1e,y1e,b1e,x1e,v1e,w1e,A1e,k1e];for(let e of I1e)W5(e);Oe().prototype.abs=function(){return this.throwIfDisposed(),Ka(this)};Oe().prototype.acos=function(){return this.throwIfDisposed(),_F(this)};Oe().prototype.acosh=function(){return this.throwIfDisposed(),RF(this)};Oe().prototype.add=function(e){return this.throwIfDisposed(),Re(this,e)};Oe().prototype.all=function(e,t){return this.throwIfDisposed(),T2(this,e,t)};Oe().prototype.any=function(e,t){return this.throwIfDisposed(),rw(this,e,t)};Oe().prototype.argMax=function(e){return this.throwIfDisposed(),Ep(this,e)};Oe().prototype.argMin=function(e){return this.throwIfDisposed(),DF(this,e)};Oe().prototype.asScalar=function(){return this.throwIfDisposed(),J(this.size===1,()=>"The array must have only 1 element."),pe(this,[])};Oe().prototype.asType=function(e){return this.throwIfDisposed(),He(this,e)};Oe().prototype.as1D=function(){return this.throwIfDisposed(),pe(this,[this.size])};Oe().prototype.as2D=function(e,t){return this.throwIfDisposed(),pe(this,[e,t])};Oe().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),pe(this,[e,t,n])};Oe().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),pe(this,[e,t,n,a])};Oe().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),pe(this,[e,t,n,a,r])};Oe().prototype.asin=function(){return this.throwIfDisposed(),OF(this)};Oe().prototype.asinh=function(){return this.throwIfDisposed(),FF(this)};Oe().prototype.atan=function(){return this.throwIfDisposed(),MF(this)};Oe().prototype.atan2=function(e){return this.throwIfDisposed(),LF(this,e)};Oe().prototype.atanh=function(){return this.throwIfDisposed(),zF(this)};Oe().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),uc(this,e,t,n,a)};Oe().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),f1(this,e,t)};Oe().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Im(this,e,t,n,a,r)};Oe().prototype.broadcastTo=function(e){return this.throwIfDisposed(),pp(this,e)};Oe().prototype.cast=function(e){return this.throwIfDisposed(),He(this,e)};Oe().prototype.ceil=function(){return this.throwIfDisposed(),HF(this)};Oe().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),hs(this,e,t)};Oe().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Bt&&(e=[e]),Un([this,...e],t)};Oe().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),E2(this,e,t,n,a,r,s)};Oe().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),$2(this,e,t,n,a,r)};Oe().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Ts(this,e,t,n,a,r,s)};Oe().prototype.cos=function(){return this.throwIfDisposed(),m1(this)};Oe().prototype.cosh=function(){return this.throwIfDisposed(),_2(this)};Oe().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),ow(this,e,t,n)};Oe().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),R2(this,e,t,n)};Oe().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),JF(this,e,t)};Oe().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Nm(this,e,t,n,a,r,s)};Oe().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),eM(this,e,t,n,a,r)};Oe().prototype.divNoNan=function(e){return this.throwIfDisposed(),tM(this,e)};Oe().prototype.div=function(e){return this.throwIfDisposed(),st(this,e)};Oe().prototype.dot=function(e){return this.throwIfDisposed(),nM(this,e)};Oe().prototype.elu=function(){return this.throwIfDisposed(),jb(this)};Oe().prototype.equal=function(e){return this.throwIfDisposed(),Ei(this,e)};Oe().prototype.erf=function(){return this.throwIfDisposed(),D2(this)};Oe().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),sM(this,e,t)};Oe().prototype.exp=function(){return this.throwIfDisposed(),ds(this)};Oe().prototype.expandDims=function(e){return this.throwIfDisposed(),Tr(this,e)};Oe().prototype.expm1=function(){return this.throwIfDisposed(),iM(this)};Oe().prototype.fft=function(){return this.throwIfDisposed(),I1(this)};Oe().prototype.flatten=function(){return this.throwIfDisposed(),pe(this,[this.size])};Oe().prototype.floor=function(){return this.throwIfDisposed(),Kb(this)};Oe().prototype.floorDiv=function(e){return this.throwIfDisposed(),C2(this,e)};Oe().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Xb(this,e,t,n)};Oe().prototype.greaterEqual=function(e){return this.throwIfDisposed(),cc(this,e)};Oe().prototype.greater=function(e){return this.throwIfDisposed(),Fs(this,e)};Oe().prototype.ifft=function(){return this.throwIfDisposed(),yy(this)};Oe().prototype.irfft=function(){return this.throwIfDisposed(),q2(this)};Oe().prototype.isFinite=function(){return this.throwIfDisposed(),oM(this)};Oe().prototype.isInf=function(){return this.throwIfDisposed(),lM(this)};Oe().prototype.isNaN=function(){return this.throwIfDisposed(),uM(this)};Oe().prototype.leakyRelu=function(e){return this.throwIfDisposed(),y1(this,e)};Oe().prototype.lessEqual=function(e){return this.throwIfDisposed(),ed(this,e)};Oe().prototype.less=function(e){return this.throwIfDisposed(),py(this,e)};Oe().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),cM(this,e,t,n,a)};Oe().prototype.logSigmoid=function(){return this.throwIfDisposed(),hM(this)};Oe().prototype.logSoftmax=function(e){return this.throwIfDisposed(),M2(this,e)};Oe().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),x1(this,e,t)};Oe().prototype.log=function(){return this.throwIfDisposed(),$i(this)};Oe().prototype.log1p=function(){return this.throwIfDisposed(),b1(this)};Oe().prototype.logicalAnd=function(e){return this.throwIfDisposed(),zo(this,e)};Oe().prototype.logicalNot=function(){return this.throwIfDisposed(),v1(this)};Oe().prototype.logicalOr=function(e){return this.throwIfDisposed(),L2(this,e)};Oe().prototype.logicalXor=function(e){return this.throwIfDisposed(),dM(this,e)};Oe().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Vt(this,e,t,n)};Oe().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),kr(this,e,t,n,a)};Oe().prototype.max=function(e,t){return this.throwIfDisposed(),to(this,e,t)};Oe().prototype.maximum=function(e){return this.throwIfDisposed(),du(this,e)};Oe().prototype.mean=function(e,t){return this.throwIfDisposed(),wa(this,e,t)};Oe().prototype.min=function(e,t){return this.throwIfDisposed(),dy(this,e,t)};Oe().prototype.minimum=function(e){return this.throwIfDisposed(),Ch(this,e)};Oe().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),fM(this,e,t)};Oe().prototype.mod=function(e){return this.throwIfDisposed(),mM(this,e)};Oe().prototype.mul=function(e){return this.throwIfDisposed(),le(this,e)};Oe().prototype.neg=function(){return this.throwIfDisposed(),sa(this)};Oe().prototype.norm=function(e,t,n){return this.throwIfDisposed(),qb(this,e,t,n)};Oe().prototype.notEqual=function(e){return this.throwIfDisposed(),Rp(this,e)};Oe().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),fy(this,e,t,n)};Oe().prototype.onesLike=function(){return this.throwIfDisposed(),_i(this)};Oe().prototype.pad=function(e,t){return this.throwIfDisposed(),wl(this,e,t)};Oe().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),gM(this,e,t,n,a,r,s)};Oe().prototype.pow=function(e){return this.throwIfDisposed(),tu(this,e)};Oe().prototype.prelu=function(e){return this.throwIfDisposed(),S1(this,e)};Oe().prototype.prod=function(e,t){return this.throwIfDisposed(),yM(this,e,t)};Oe().prototype.reciprocal=function(){return this.throwIfDisposed(),AM(this)};Oe().prototype.relu=function(){return this.throwIfDisposed(),_n(this)};Oe().prototype.relu6=function(){return this.throwIfDisposed(),P2(this)};Oe().prototype.reshapeAs=function(e){return this.throwIfDisposed(),pe(this,e.shape)};Oe().prototype.reshape=function(e){return this.throwIfDisposed(),pe(this,e)};Oe().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),S8(this,e,t,n)};Oe().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),k8(this,e,t,n)};Oe().prototype.reverse=function(e){return this.throwIfDisposed(),io(this,e)};Oe().prototype.rfft=function(){return this.throwIfDisposed(),N1(this)};Oe().prototype.round=function(){return this.throwIfDisposed(),V2(this)};Oe().prototype.rsqrt=function(){return this.throwIfDisposed(),U2(this)};Oe().prototype.selu=function(){return this.throwIfDisposed(),W2(this)};Oe().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Yb(this,e,t,n,a,r,s)};Oe().prototype.sigmoid=function(){return this.throwIfDisposed(),Mo(this)};Oe().prototype.sign=function(){return this.throwIfDisposed(),SM(this)};Oe().prototype.sin=function(){return this.throwIfDisposed(),G2(this)};Oe().prototype.sinh=function(){return this.throwIfDisposed(),H2(this)};Oe().prototype.slice=function(e,t){return this.throwIfDisposed(),en(this,e,t)};Oe().prototype.softmax=function(e){return this.throwIfDisposed(),nd(this,e)};Oe().prototype.softplus=function(){return this.throwIfDisposed(),Cm(this)};Oe().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),A1(this,e,t)};Oe().prototype.split=function(e,t){return this.throwIfDisposed(),Ks(this,e,t)};Oe().prototype.sqrt=function(){return this.throwIfDisposed(),Or(this)};Oe().prototype.square=function(){return this.throwIfDisposed(),Pn(this)};Oe().prototype.squaredDifference=function(e){return this.throwIfDisposed(),K2(this,e)};Oe().prototype.squeeze=function(e){return this.throwIfDisposed(),ad(this,e)};Oe().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Bt?[this,e]:[this,...e];return Ja(n,t)};Oe().prototype.step=function(e){return this.throwIfDisposed(),Tm(this,e)};Oe().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),kM(this,e,t,n,a,r,s,i,o)};Oe().prototype.sub=function(e){return this.throwIfDisposed(),nt(this,e)};Oe().prototype.sum=function(e,t){return this.throwIfDisposed(),ut(this,e,t)};Oe().prototype.tan=function(){return this.throwIfDisposed(),IM(this)};Oe().prototype.tanh=function(){return this.throwIfDisposed(),Nh(this)};Oe().prototype.tile=function(e){return this.throwIfDisposed(),Ii(this,e)};Oe().prototype.toBool=function(){return this.throwIfDisposed(),He(this,"bool")};Oe().prototype.toFloat=function(){return this.throwIfDisposed(),He(this,"float32")};Oe().prototype.toInt=function(){return this.throwIfDisposed(),He(this,"int32")};Oe().prototype.topk=function(e,t){return this.throwIfDisposed(),CM(this,e,t)};Oe().prototype.transpose=function(e){return this.throwIfDisposed(),Ut(this,e)};Oe().prototype.unique=function(e){return this.throwIfDisposed(),TM(this,e)};Oe().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),J2(this,e,t)};Oe().prototype.unstack=function(e){return this.throwIfDisposed(),Ra(this,e)};Oe().prototype.where=function(e,t){return this.throwIfDisposed(),Dr(e,this,t)};Oe().prototype.zerosLike=function(){return this.throwIfDisposed(),un(this)};var rh=class aK extends Error{constructor(t){super(t),Object.setPrototypeOf(this,aK.prototype)}},Ul=class rK extends Error{constructor(t){super(t),Object.setPrototypeOf(this,rK.prototype)}},ge=class sK extends Error{constructor(t){super(t),Object.setPrototypeOf(this,sK.prototype)}},Xt=class iK extends Error{constructor(t){super(t),Object.setPrototypeOf(this,iK.prototype)}},N1e=class oK extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oK.prototype)}},lK=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Op(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function Ll(e,t){if(!e)throw new N1e(t)}function UG(e,t){let n=0;for(let a of e)a===t&&n++;return n}function Gs(e){return e.length===1?e[0]:e}function En(e){return Array.isArray(e)?e:[e]}function zu(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function tp(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var No={};function qM(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function vD(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>vD(t));else{let t=Object.keys(e);for(let n of t){let a=e[n];a!=null&&typeof a=="object"&&(!Array.isArray(a)&&a.type==="ndarray"&&typeof a.value=="number"?e[n]=a.value:vD(a))}}}function T1(e,t={},n={},a="object",r=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in No)i=No[s];else if(i=t[s],i==null)throw new ge(`Unknown ${a}: ${e}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new ge(`${a}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in No?[o,l]=No.className:i in t&&([o,l]=t[i]),o==null)throw new ge(`Unknown ${a}: ${i}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let m of Object.keys(No))u[m]=No[m];for(let m of Object.keys(n))u[m]=n[m];let c=s.config;c.customObjects=u;let h=Object.assign({},No);for(let m of Object.keys(n))No[m]=n[m];vD(s.config);let p=l(o,s.config,n,r);return No=Object.assign({},h),p}else{let u=Object.assign({},No);for(let h of Object.keys(n))No[h]=n[h];let c=new o(s.config);return No=Object.assign({},u),c}}}function C1e(e,t){return e<t?-1:e>t?1:0}function Gk(e,t){return-1*C1e(e,t)}function gh(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function T1e(e){if(e==null)throw new ge(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Em(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new ge(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function KM(e,t,n=0,a=1/0){return Ll(n>=0),Ll(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(r=>typeof r===t)}function _r(e,t){Array.isArray(e)?(F.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,a)=>_r(n,`element ${a+1} of ${t}`))):F.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${uK(e)}.`)}function uK(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>uK(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function E1e(e,t,n){let a=n!=null?n():F.now(),r;return(...s)=>{let i=n!=null?n():F.now();return i-a<t||(a=i,r=e(...s)),r}}function cK(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var $1e=0;function hK(){return $1e++}var Hk={};function iC(e=""){return e in Hk||(Hk[e]=0),Hk[e]+=1,e+Hk[e].toString()}var _1e=["channelsFirst","channelsLast"],R1e=["nearest","bilinear"],D1e=["valid","same","causal"],O1e=["max","avg"],F1e=["sum","mul","concat","ave"],Pg=new Map;function Pa(e){Em(_1e,"DataFormat",e)}function M1e(e){Em(R1e,"InterpolationFormat",e)}function co(e){Em(D1e,"PaddingMode",e)}function dK(e){Em(O1e,"PoolMode",e)}var qv=[],WG="/";function fp(e,t){qv.push(e);try{let n=t();return qv.pop(),n}catch(n){throw qv.pop(),n}}function L1e(){return qv.length===0?"":qv.join(WG)+WG}function pK(e){if(!mK(e))throw new Error("Not a valid tensor name: '"+e+"'");return L1e()+e}function fK(e){if(!mK(e))throw new Error("Not a valid tensor name: '"+e+"'");Pg.has(e)||Pg.set(e,0);let t=Pg.get(e);if(Pg.set(e,Pg.get(e)+1),t>0){let n=`${e}_${t}`;return Pg.set(n,1),n}else return e}var z1e=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function mK(e){return!!e.match(z1e)}function B1e(e){return e===parseInt(e.toString(),10)}function yh(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function xy(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a<t&&(t=a)}return t}function Eh(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a>t&&(t=a)}return t}function dl(e,t){if(t<e)throw new ge(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let a=e;a<t;++a)n.push(a);return n}var fR;function hr(){return fR==null&&(fR=CF().epsilon()),fR}function pl(){return"channelsLast"}function ec(e,t){return He(e,t)}function E1(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),pe(e,n)}function P1e(e,t){return fe(()=>{if(e.shape.length!==2)throw new ge(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=E1(e,1);return wD(n,[1,t,1])})}function V1e(e){let t=[yh(e.shape)];return pe(e,t)}function U1e(e){if(e.rank<=1)throw new ge(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],yh(e.shape,1)];return pe(e,t)}function mp(e,t,n){return fe(()=>{switch(e.rank){case 1:return k1(e,t,n);case 2:return j2(e,[t,0],[n,e.shape[1]]);case 3:return Qb(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return gy(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return en(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return en(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new ge(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function mR(e,t,n){return fe(()=>{switch(e.rank){case 1:return k1(e,t,n);case 2:return j2(e,[0,t],[e.shape[0],n]);case 3:return Qb(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return gy(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ge(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function jk(e,t,n,a){return fe(()=>{switch(e.rank){case 1:return k1(e,t,n);case 2:switch(a){case 1:return mp(e,t,n);case 2:return mR(e,t,n);default:throw new ge(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return mp(e,t,n);case 2:return Qb(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return mR(e,t,n);default:throw new ge(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return mp(e,t,n);case 2:return gy(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return gy(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return mR(e,t,n);default:throw new ge(`The axis is not within the rank of the tensor ${a}`)}default:throw new ge(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function XM(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),Un(e,t)}function GG(e,t){switch(e.rank){case 1:return jF([e,t]);case 2:return qF([e,t],0);case 3:return KF([e,t],0);case 4:return XF([e,t],0);default:throw new ge(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function wD(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ge(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ii(e,t)}function oC(e,t=0,n=1,a,r){return B2(e,t,n,a,r)}function Kl(e,t,n,a){if(e.rank<2||t.rank<2)throw new Xt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(r!==s)throw new Xt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return by.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?AD(e.rank,a,pl()):null,activation:n});{let r=e.shape.slice(),s=r.pop();e=pe(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(p,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=pe(Ut(t,c),[l,-1]);let h=[...r,...u];return pe(by.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?AD(e.rank,a,pl()):null,activation:n}),h)}}function gK(e,t,n){return fe(()=>(Array.isArray(t)?t=Nn(t,"int32"):t=He(t,"int32"),Xb(e,t,n)))}function $1(e){return le(e,e)}function AD(e,t,n){let a=t.shape;if(t.rank!==1&&t.rank!==e)throw new ge(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return a.length===1?pe(t,[1,a[0],1,1,1]):pe(t,[1,a[3],a[0],a[1],a[2]]);if(n==="channelsLast")return a.length===1?pe(t,[1,1,1,1,a[0]]):pe(t,[1].concat(a))}else if(e===4){if(n==="channelsFirst")return a.length===1?pe(t,[1,a[0],1,1]):pe(t,[1,a[2],a[0],a[1]]);if(n==="channelsLast")return a.length===1?pe(t,[1,1,1,a[0]]):pe(t,[1].concat(a))}else if(e===3){if(n==="channelsFirst")return a.length===1?pe(t,[1,a[0],1]):pe(t,[1,a[1],a[0]]);if(n==="channelsLast")return a.length===1?pe(t,[1,1,a[0]]):pe(t,[1].concat(a))}else if(e<3)return t;throw new ge(`Unsupported input rank by biasAdd: ${t.rank}`)}function Al(e,t,n){return fe(()=>(n==null&&(n=pl()),Pa(n),Re(e,AD(e.rank,t,n))))}function W1e(e,t=1){if(t!==1)throw new Xt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return jb(e)}function G1e(e){return fe(()=>st(e,Re(Ka(e),1)))}function yK(e,t,n,a){return fe(()=>_M(e,t,n,a))}function H1e(e){return fe(()=>{let t=Re(.5,le(.2,e));return hs(t,0,1)})}function _1(e,t,n=!1){return n?e():t()}var j1e=["fanIn","fanOut","fanAvg"],q1e=["normal","uniform","truncatedNormal"];function K1e(e){Em(j1e,"FanMode",e)}function X1e(e){Em(q1e,"Distribution",e)}var Vo=class extends Pe.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},YM=class extends Vo{apply(e,t){return Aa(e,t)}};YM.className="Zeros";Pe.registerClass(YM);var lC=class extends Vo{apply(e,t){return js(e,t)}};lC.className="Ones";Pe.registerClass(lC);var QM=class extends Vo{constructor(e){if(super(),typeof e!="object")throw new ge(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ge(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return fe(()=>le(xt(this.value),js(e,t)))}getConfig(){return{value:this.value}}};QM.className="Constant";Pe.registerClass(QM);var ZM=class extends Vo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return td(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};ZM.className="RandomUniform";Pe.registerClass(ZM);var JM=class extends Vo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xt(`randomNormal does not support dType ${t}.`);return oC(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};JM.className="RandomNormal";Pe.registerClass(JM);var e3=class extends Vo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xt(`truncatedNormal does not support dType ${t}.`);return Z2(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};e3.className="TruncatedNormal";Pe.registerClass(e3);var t3=class extends Vo{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return fe(()=>{if(e.length!==2||e[0]!==e[1])throw new ge("Identity matrix initializer can only be used for 2D square matrices.");return le(this.gain,O2(e[0]))})}getConfig(){return{gain:this.gain}}};t3.className="Identity";Pe.registerClass(t3);function Y1e(e,t="channelsLast"){let n,a;if(Pa(t),e.length===2)n=e[0],a=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let r=yh(e,2);n=e[1]*r,a=e[0]*r}else if(t==="channelsLast"){let r=yh(e,0,e.length-2);n=e[e.length-2]*r,a=e[e.length-1]*r}}else{let r=yh(e);n=Math.sqrt(r),a=Math.sqrt(r)}return[n,a]}var Zs=class extends Vo{constructor(e){if(super(),e.scale<0)throw new ge(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,K1e(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,X1e(this.distribution),this.seed=e.seed}apply(e,t){let n=Y1e(e),a=n[0],r=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,a):this.mode==="fanOut"?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xt(`${this.getClassName()} does not support dType ${t}.`);return Z2(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return td(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Zs.className="VarianceScaling";Pe.registerClass(Zs);var uC=class extends Zs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Zs.className}};uC.className="GlorotUniform";Pe.registerClass(uC);var cC=class extends Zs{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Zs.className}};cC.className="GlorotNormal";Pe.registerClass(cC);var hC=class extends Zs{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Zs.className}};hC.className="HeNormal";Pe.registerClass(hC);var dC=class extends Zs{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Zs.className}};dC.className="HeUniform";Pe.registerClass(dC);var pC=class extends Zs{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Zs.className}};pC.className="LeCunNormal";Pe.registerClass(pC);var fC=class extends Zs{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Zs.className}};fC.className="LeCunUniform";Pe.registerClass(fC);var n3=class extends Vo{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return fe(()=>{if(e.length<2)throw new Xt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=F.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);let s=[Math.max(a,n),Math.min(a,n)],i=oC(s,0,1,t,this.seed),o=FM.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return l=le(l,u.sign()),n<a&&(l=l.transpose()),le(xt(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};n3.className="Orthogonal";Pe.registerClass(n3);var HG={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function jG(e,t={}){return T1(e,Pe.SerializationMap.getMap().classNameMap,t,"initializer")}function ka(e){return qM(e)}function fa(e){if(typeof e=="string"){let t=e in HG?HG[e]:e;if(t==="GlorotNormal")return new cC;if(t==="GlorotUniform")return new uC;if(t==="HeNormal")return new hC;if(t==="HeUniform")return new dC;if(t==="LeCunNormal")return new pC;if(t==="LeCunUniform")return new fC;{let n={};return n.className=t,n.config={},jG(n)}}else return e instanceof Vo?e:jG(e)}function SD(e){return Array.isArray(e)&&Array.isArray(e[0])}function tN(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Et(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new ge(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function bn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new ge(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function nN(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((a,r)=>a*r);return t}var qG="Variable",bK=class{constructor(t,n="float32",a=qG,r=!0,s=null){this.dtype=n??"float32",this.shape=t.shape,this.id=hK(),a=a??qG,this.originalName=pK(a),this.name=fK(this.originalName),this.trainable_=r,this.constraint=s,this.val=EM(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),Q1e(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function Q1e(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function kD(e){return e.map(t=>t.read())}function a3(e){e.forEach(t=>{t[0].write(t[1])})}var Qa=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},fl=class{constructor(e,t,n,a,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=i,this.id=hK(),s!=null&&(this.originalName=pK(s),this.name=fK(this.originalName)),this.rank=t.length}},Z1e=0,mC=class{constructor(e,t){this.callArgs=t,this.id=Z1e++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},J1e=0,Qt=class extends Pe.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=J1e++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=zu(n)+"_"+iC(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),n=[r].concat(e.inputShape)}this.batchInputShape=n;let a=e.dtype;a==null&&(a=e.inputDType),a==null&&(a="float32"),this.dtype=a}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Ul(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ge(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Gs(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Gs(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new rh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new rh(`Layer ${this.name} is not connected, no input to return.`);return Gs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new rh(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new rh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Gs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=En(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=En(this.inputSpec);if(t.length!==n.length)throw new ge(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let a=0;a<t.length;a++){let r=t[a],s=n[a];if(s==null)continue;let i=r.rank;if(s.ndim!=null&&i!==s.ndim)throw new ge(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new ge(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new ge(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new ge(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let l in s.axes){let u=Number(l),c=s.axes[l],h=u>=0?o[u]:o[o.length+u];if(c!=null&&[c,null].indexOf(h)===-1)throw new ge(`Input ${a} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],u=r.shape[o];if(l!=null&&u!=null&&l!==u)throw new ge(`Input ${a} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=En(e),a=nAe(e),r=aAe(e);if(a===r)throw new ge("Arguments to apply() must be all SymbolicTensors or all Tensors");return fp(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of En(e))s.push(i.shape);this.build(Gs(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=En(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=Gs(o),this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=eAe(e),i=this.computeOutputShape(s),o,l=tAe(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((u,c)=>new fl(l,u,this,En(e),t,this.name,c)):o=new fl(l,i,this,En(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,a)=>{n!=null&&e[a]!=null&&e[a]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new rh(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new rh(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ul(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return nN(this.weights)}build(e){this.built=!0}getWeights(e=!1){return kD(e?this.trainableWeights:this.weights)}setWeights(e){fe(()=>{let t=this.weights;if(t.length!==e.length)throw new ge(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],a=kD(t);for(let r=0;r<a.length;++r){let s=a[r],i=t[r],o=e[r];if(!F.arraysEqual(s.shape,o.shape))throw new ge(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}a3(n)})}addWeight(e,t,n,a,r,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new ge(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(a=o!=null?o():fa("zeros"));let l=a.apply(t,n),u=new bK(l,n,e,s,i);return l.dispose(),r!=null&&this.addLoss(()=>r.apply(u.read())),s==null&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=En(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let a=this.computeMask(e,n),r=En(t),s=En(a);if(r.length!==s.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let i=0;i<r.length;i++)r[i].kerasMask=s[i]}addInboundNode(e,t,n,a,r,s,i=null){let o=En(e);t=En(t),n=En(n),a=En(a),r=tN(r),s=tN(s);let l=[],u=[],c=[];for(let h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new mC({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function eAe(e){e=En(e);let t=[];for(let n of e)t.push(n.shape);return Gs(t)}function tAe(e){return"float32"}function xK(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let a=t.inboundNodes[n];if(a.inboundLayers.length===0)return a.inputTensors;{let r=[];for(let s=0;s<a.inboundLayers.length;s++){let i=a.inputTensors[s],o=a.inboundLayers[s],l=a.nodeIndices[s],u=xK(i,o,l);for(let c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}function nAe(e){let t=!0;for(let n of En(e))if(!(n instanceof fl)){t=!1;break}return t}function aAe(e){let t=!0;for(let n of En(e))if(n instanceof fl){t=!1;break}return t}var Jb=class extends Qt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:iC("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ge("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ge("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ge("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let a=new fl(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new mC({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ge(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Jb.className="InputLayer";Pe.registerClass(Jb);function vK(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new ge("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Jb({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function rAe(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return He(t,e.dtype)}catch{throw new ge(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Yg=class wK{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof wK)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,a){if(this.id2Value[t.id]==null)this.id2Value[t.id]=rAe(t,n),this.name2Id[t.name]=t.id,a!=null&&(this.id2Mask[t.id]=a);else throw new ge(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof fl){if(this.id2Value[t.id]==null)throw new ge(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new ge(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof fl){if(this.id2Value[t.id]==null)throw new ge(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new ge(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Ft(this.id2Mask)}},aN=new lK,rN=new lK;function sAe(e){aN?.setMaxEntries(e),rN?.setMaxEntries(e)}function _v(e,t,n,a){let r=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(g=>g.name),l=[],u=t.names();for(let g of o)u.indexOf(g)!==-1?l.push(t.getValue(g)):l.push(null);let c=o.join(",")+"|"+t.names().sort().join(","),h=aN.get(c),p;if(h==null){let g=iAe(i,t);h=g.sorted,p=g.recipientCounts,aN.put(c,h),rN.put(c,p)}p={},r||Object.assign(p,rN.get(c));let m=new Yg(t);for(let g=0;g<h.length;++g){let y=h[g],b=y.sourceLayer;if(b instanceof Jb)continue;let v=[],w=[],S=[],k=!1;for(let D of y.inputs){let O=m.getValue(D),$=m.getMask(D);v.push(O),w.push($),$!=null&&(k=!0),r||(p[D.name]--,p[D.name]===0&&!t.hasKey(D)&&o.indexOf(D.name)===-1&&!O.isDisposed&&D.sourceLayer.stateful!==!0&&S.push(O))}k&&(n=n||{},n.mask=w[0]);let I=En(b.apply(v,n)),T=null;b.supportsMasking&&(T=b.computeMask(v,w));let E=lAe(y),R=Array.isArray(E)?E:[E];for(let D=0;D<R.length;++D){m.hasKey(R[D])||m.add(R[D],I[D],Array.isArray(T)?T[0]:T);let O=o.indexOf(R[D].name);O!==-1&&(l[O]=I[D])}r||Ft(S)}return m.disposeMasks(),s?l:l[0]}function iAe(e,t){F.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(e.length===1){let r=KG(e[0],t);n=r.sorted,a=r.recipientMap}else{let r=new Set;for(let s of e){let{sorted:i,recipientMap:o}=KG(s,t);for(let l of i)r.has(l.name)||(n.push(l),r.add(l.name));for(let l in o)a[l]==null&&(a[l]=new Set),o[l].forEach(u=>a[l].add(u))}}return{sorted:n,recipientCounts:oAe(a)}}function oAe(e){let t={};for(let n in e)t[n]=e[n].size;return t}function KG(e,t){let n=new Set,a=[],r={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),a.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let u of o.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(o.name),!n.has(u.name)&&s.push(u)}}return{sorted:a,recipientMap:r}}function lAe(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let a=0;a<e.sourceLayer.inboundNodes.length;++a)for(let r of e.sourceLayer.inboundNodes[a].outputTensors)if(r.id===e.id){n=a;break}t=e.sourceLayer.getOutputAt(n)}return t}var uAe=xe();uAe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,sAe);var AK={};Lt(AK,{maxNorm:()=>cAe,minMaxNorm:()=>pAe,nonNeg:()=>dAe,unitNorm:()=>hAe});function r3(e,t){return fe(()=>Or(ut(le(e,e),t,!0)))}var R1=class extends Pe.Serializable{getConfig(){return{}}},s3=class extends R1{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return fe(()=>{let t=r3(e,this.axis),n=hs(t,0,this.maxValue);return le(e,st(n,Re(hr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};s3.className="MaxNorm";Pe.registerClass(s3);var i3=class extends R1{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return fe(()=>st(e,Re(hr(),r3(e,this.axis))))}getConfig(){return{axis:this.axis}}};i3.className="UnitNorm";Pe.registerClass(i3);var o3=class extends R1{apply(e){return _n(e)}};o3.className="NonNeg";Pe.registerClass(o3);var l3=class extends R1{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return fe(()=>{let t=r3(e,this.axis),n=Re(le(this.rate,hs(t,this.minValue,this.maxValue)),le(1-this.rate,t));return le(e,st(n,Re(hr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};l3.className="MinMaxNorm";Pe.registerClass(l3);var XG={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function gr(e){return qM(e)}function YG(e,t={}){return T1(e,Pe.SerializationMap.getMap().classNameMap,t,"constraint")}function yr(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in XG?XG[e]:e,config:{}};return YG(t)}else return e instanceof R1?e:YG(e)}function cAe(e){return new s3(e)}function hAe(e){return new i3(e)}function dAe(){return new o3}function pAe(e){return new l3(e)}var SK={};Lt(SK,{constant:()=>gAe,glorotNormal:()=>SAe,glorotUniform:()=>AAe,heNormal:()=>kAe,heUniform:()=>IAe,identity:()=>vAe,leCunNormal:()=>NAe,leCunUniform:()=>CAe,ones:()=>mAe,orthogonal:()=>TAe,randomNormal:()=>bAe,randomUniform:()=>yAe,truncatedNormal:()=>xAe,varianceScaling:()=>wAe,zeros:()=>fAe});function fAe(){return new YM}function mAe(){return new lC}function gAe(e){return new QM(e)}function yAe(e){return new ZM(e)}function bAe(e){return new JM(e)}function xAe(e){return new e3(e)}function vAe(e){return new t3(e)}function wAe(e){return new Zs(e)}function AAe(e){return new uC(e)}function SAe(e){return new cC(e)}function kAe(e){return new hC(e)}function IAe(e){return new dC(e)}function NAe(e){return new pC(e)}function CAe(e){return new fC(e)}function TAe(e){return new n3(e)}var kK={};Lt(kK,{Layer:()=>Qt,RNN:()=>pc,RNNCell:()=>O1,activation:()=>ske,add:()=>fke,alphaDropout:()=>Qke,average:()=>mke,averagePooling1d:()=>vL,averagePooling2d:()=>wL,averagePooling3d:()=>AL,avgPool1d:()=>kke,avgPool2d:()=>Nke,avgPool3d:()=>Tke,avgPooling1d:()=>Ike,avgPooling2d:()=>Cke,avgPooling3d:()=>Eke,batchNormalization:()=>wke,bidirectional:()=>Wke,categoryEncoding:()=>nIe,centerCrop:()=>eIe,concatenate:()=>gke,conv1d:()=>YSe,conv2d:()=>QSe,conv2dTranspose:()=>ZSe,conv3d:()=>JSe,conv3dTranspose:()=>eke,convLstm2d:()=>Bke,convLstm2dCell:()=>Pke,cropping2D:()=>nke,dense:()=>ike,depthwiseConv2d:()=>rke,dot:()=>vke,dropout:()=>oke,elu:()=>GSe,embedding:()=>pke,flatten:()=>uke,gaussianDropout:()=>Yke,gaussianNoise:()=>Xke,globalAveragePooling1d:()=>$ke,globalAveragePooling2d:()=>_ke,globalMaxPool1d:()=>Hke,globalMaxPool2d:()=>jke,globalMaxPooling1d:()=>NX,globalMaxPooling2d:()=>CX,gru:()=>Dke,gruCell:()=>Oke,input:()=>UK,inputLayer:()=>WSe,layerNormalization:()=>Ake,leakyReLU:()=>jSe,lstm:()=>Fke,lstmCell:()=>Mke,masking:()=>Zke,maxPool1d:()=>qke,maxPool2d:()=>Kke,maxPooling1d:()=>TX,maxPooling2d:()=>EX,maxPooling3d:()=>Rke,maximum:()=>yke,minimum:()=>bke,multiply:()=>xke,permute:()=>dke,prelu:()=>qSe,randomWidth:()=>aIe,reLU:()=>HSe,repeatVector:()=>cke,rescaling:()=>Jke,reshape:()=>hke,resizing:()=>tIe,rnn:()=>Vke,separableConv2d:()=>tke,simpleRNN:()=>Lke,simpleRNNCell:()=>zke,softmax:()=>KSe,spatialDropout1d:()=>lke,stackedRNNCells:()=>Uke,thresholdedReLU:()=>XSe,timeDistributed:()=>Gke,upSampling2d:()=>ake,zeroPadding2d:()=>Ske});async function nh(e){if(e==null)return;let t=[],n=[],a=[];for(let r in e){let s=e[r];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(r),a.push(i)}}if(t.length>0){let r=await Promise.all(t);for(let s=0;s<r.length;++s)e[n[s]]=r[s][0];Ft(a)}}function IK(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var QG;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(QG||(QG={}));var EAe=125,vy=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},NK=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},$Ae=class extends vy{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let a in t){let r=t[a];if(typeof r=="number")this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+r*n;else{let s;a in this.totals?s=this.totals[a]:this.totals[a]=0;let i=fe(()=>Re(this.totals[a],le(r,n)));this.totals[a]=i,s?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:fe(()=>{let a=le(st(1,this.seen),this.totals[n]);t[n]=a,this.totals[n].dispose(),cr(t[n])}))}},CK=class extends vy{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let s=this.history[r];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(r),n.push(i)}}let a=await Promise.all(e);for(let r=0;r<a.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}},TK=class extends vy{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||HM,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=EAe),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");F.isNumber(this.yieldEvery)&&(this.maybeWait=E1e(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let a=[];this.yield!=null&&(await nh(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await nh(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await nh(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await nh(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await nh(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):F.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await nh(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await nh(e),await this.trainEnd(e))}};function EK(e,t){return e==null&&(e={}),e instanceof vy?[e]:Array.isArray(e)&&e[0]instanceof vy?e:En(e).map(n=>new TK(n,t))}var u3=class Dl{constructor(){}static registerCallbackConstructor(t,n){F.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Dl.checkForDuplicate(n),Dl.constructors[t]==null&&(Dl.constructors[t]=[]),Dl.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Dl.constructors)Dl.constructors[+n].forEach(a=>{if(a===t)throw new ge("Duplicate callback constructor.")})}static clear(){Dl.constructors={}}static createCallbacks(t){let n=[];for(let a in Dl.constructors){let r=+a;t>=r&&n.push(...Dl.constructors[r])}return n.map(a=>new a)}};u3.constructors={};function $K(e,t,n,a,r,s,i,o,l){let u=new CK,c=[new $Ae,...u3.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);let h=new NK(c);return h.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function ol(e,t={},n=!1){return T1(e,Pe.SerializationMap.getMap().classNameMap,t,"layer",n)}function sN(e,t){return fe(()=>{e.dtype!=="float32"&&(e=He(e,"float32"));let n=ut($1(e),t,!0),a=Ni(n.shape,hr()),r=Or(du(n,a));return st(e,r)})}function $m(e,t){return fe(()=>wa($1(nt(t,e)),-1))}function gC(e,t){return fe(()=>wa(Ka(nt(t,e)),-1))}function ex(e,t){return fe(()=>{let n=nt(e,t),a=hs(Ka(e),hr(),Number.MAX_VALUE),r=Ka(st(n,a));return le(100,wa(r,-1))})}function _Ae(e,t){return fe(()=>{let n=hs(t,hr(),Number.MAX_VALUE),a=$i(Re(1,n)),r=hs(e,hr(),Number.MAX_VALUE),s=$i(Re(1,r));return wa($1(nt(a,s)),-1)})}function RAe(e,t){return fe(()=>{let n=du(0,nt(1,le(e,t)));return wa($1(n),-1)})}function DAe(e,t){return fe(()=>{let n=du(0,nt(1,le(e,t)));return wa(n,-1)})}function OAe(e,t){return fe(()=>{let n=ut(le(e,t),-1),a=to(le(nt(1,e),t),-1);return du(0,Re(1,nt(a,n)))})}function FAe(e,t){return fe(()=>{let n=Math.log(2),a=nt(t,e),r=nt(Re(a,Cm(le(-2,a))),n);return wa(r,-1)})}function lw(e,t,n=!1){return fe(()=>{if(n)t=nd(t);else{let a=ut(t,t.shape.length-1,!0);t=st(t,a)}return t=hs(t,hr(),1-hr()),sa(ut(le(He(e,"float32"),$i(t)),t.shape.length-1))})}function iN(e,t,n=!1){return fe(()=>{let a=He(Kb(V1e(e)),"int32");t=hs(t,hr(),1-hr());let r=t.shape,s=pe(fy(a,r[r.length-1]),r);return lw(s,t,n)})}function MAe(e,t){if(!F.arraysEqual(e.shape,t.shape))throw new ge(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return fe(()=>{let n=_n(t),a=sa(Ka(t));return Re(nt(n,le(t,e)),b1(ds(a)))})}function yC(e,t){return fe(()=>{let n;return n=hs(t,hr(),1-hr()),n=$i(st(n,nt(1,n))),wa(MAe(e,n),-1)})}function LAe(e,t){return fe(()=>{let n=hs(e,hr(),1),a=hs(t,hr(),1);return ut(le(e,$i(st(n,a))),-1)})}function zAe(e,t){return fe(()=>{let n=$i(Re(hr(),t));return wa(nt(t,le(e,n)),-1)})}function c3(e,t){return fe(()=>{let n=sN(e,-1),a=sN(t,-1),r=le(n,a);return sa(ut(r,-1))})}var oN={meanSquaredError:$m,meanAbsoluteError:gC,meanAbsolutePercentageError:ex,meanSquaredLogarithmicError:_Ae,squaredHinge:RAe,hinge:DAe,categoricalHinge:OAe,logcosh:FAe,categoricalCrossentropy:lw,sparseCategoricalCrossentropy:iN,binaryCrossentropy:yC,kullbackLeiblerDivergence:LAe,poisson:zAe,cosineProximity:c3};function gR(e){if(typeof e=="string"){if(e in oN)return oN[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ge(t)}else return e}function h3(e,t){return fe(()=>{let n=le(.5,_i(t)),a=ec(Fs(t,n),e.dtype);return wa(Ei(e,a),-1)})}function d3(e,t){return fe(()=>ec(Ei(Ep(e,-1),Ep(t,-1)),"float32"))}function _K(e,t){return fe(()=>He(ut(zo(Ei(e,1),Ei(t,1))),"float32"))}function BAe(e,t){return fe(()=>He(ut(zo(Ei(e,1),Ei(t,0))),"float32"))}function PAe(e,t){return fe(()=>He(ut(zo(Ei(e,0),Ei(t,1))),"float32"))}function RK(e,t){return fe(()=>{let n=_K(e,t),a=PAe(e,t),r=Re(n,a);return He(Dr(Fs(r,0),st(n,r),0),"float32")})}function VAe(e,t){return fe(()=>{let n=_K(e,t),a=BAe(e,t),r=Re(n,a);return He(Dr(Fs(r,0),st(n,r),0),"float32")})}function DK(e,t){return yC(e,t)}function OK(e,t){return e.rank===t.rank&&(e=ad(e,[e.rank-1])),t=Ep(t,-1),t.dtype!==e.dtype&&(t=He(t,e.dtype)),He(Ei(e,t),"float32")}function UAe(e,t){return fe(()=>{let n=e.sub(t).square().sum(),a=e.sub(e.mean()).square().sum();return xt(1).sub(n.div(a))})}var WAe=$m,GAe=$m,HAe=gC,jAe=gC,qAe=ex,KAe=ex,p3=lw,XAe=c3,FK=iN,lN={binaryAccuracy:h3,categoricalAccuracy:d3,precision:RK,categoricalCrossentropy:p3,sparseCategoricalCrossentropy:FK,mse:WAe,MSE:GAe,mae:HAe,MAE:jAe,mape:qAe,MAPE:KAe,cosine:XAe};function YAe(e){if(typeof e=="string"&&e in lN)return lN[e];if(typeof e!="string"&&e!=null)return e;throw new ge(`Unknown metric ${e}`)}function qk(e){if(Ll(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(oN))if(oN[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(lN))if(lN[n]===e){t=n;break}return t!==void 0?t:e.name}}function QAe(e){let t={Adagrad:()=>Xd.adagrad(.01),Adadelta:()=>Xd.adadelta(1,.95,hr()),Adam:()=>Xd.adam(.001,.9,.999,hr()),Adamax:()=>Xd.adamax(.002,.9,.999,hr(),0),RMSProp:()=>Xd.rmsprop(.001,.9,0,hr()),SGD:()=>Xd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ge(`Unknown Optimizer ${e}`)}function ZG(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!ID(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let a=JSON.stringify(e);a.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${a.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function ID(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!ID(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!ID(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function ZAe(e,t,n,a=console.log){let r=eSe(e),s=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!r){s.push("Receives inputs"),i=[];for(let c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}a("_".repeat(t)),uN(s,n,a),a("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)r?tSe(o[c],n,a):nSe(o[c],n,i,a),a((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=JAe(e),u=nN(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a("_".repeat(t))}function JAe(e){let t;return e.collectedTrainableWeights!=null?t=nN(e.collectedTrainableWeights):t=nN(e.trainableWeights),t}function eSe(e){let t=!0,n=[],a=[];for(let r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(let r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(let r of e.layers){let s=!1;for(let i of r.inboundNodes)if(a.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function uN(e,t,n=console.log){let a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function tSe(e,t,n){let a,r;try{r=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,r,a,e.countParams().toString()];uN(o,t,n)}function nSe(e,t,n,a){let r,s;try{s=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let i=[];for(let h of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let p=0;p<h.inboundLayers.length;++p){let m=h.inboundLayers[p].name,g=h.nodeIndices[p],y=h.tensorIndices[p];i.push(`${m}[${g}][${y}]`)}let o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,s,r,e.countParams().toString(),u];uN(c,t,a);for(let h=1;h<i.length;++h)uN(["","","","",i[h]],t,a)}function MK(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function uw(e,t){if(e===null)return null;if(typeof e=="string")return tp(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];MK(t,r,s)?n.push(s):n.push(uw(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a];if(a==="name"&&typeof r=="string")n[a]=r;else{let s=tp(a);n[s]=uw(r,s)}}return n}}function ND(e,t){if(e==null)return null;if(typeof e=="string")return zu(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];MK(t,r,s)?n.push(s):n.push(ND(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a],s=zu(a);(a==="name"||a==="className")&&typeof r=="string"?n[s]=r:n[s]=ND(r,a)}return n}}var f3="4.22.0",aSe=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},rSe=class Ol extends Qt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let w=this.getClassName().toLowerCase();this.name=iC(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],gh(this.inputs).length!==this.inputs.length)throw new ge(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);gh(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let w of this.outputs){let S=w.sourceLayer,k=w.nodeIndex,I=w.tensorIndex;this.outputLayers.push(S),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(I)}for(let w of this.inputs){let S=w.sourceLayer,k=w.nodeIndex,I=w.tensorIndex;Ll(k===0,"input layer has >1 nodes"),Ll(I===0,"input layer has >1 tensors"),this.inputLayers.push(S),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){let S=this.inputLayers[w];if(!(S instanceof Jb))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${w} (0-based) originates from layer type ${S.getClassName()}.`);this.inputNames.push(S.name),this.feedInputShapes.push(S.batchInputShape),this.feedInputNames.push(S.name)}for(let w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);let n={},a={},r={},s={},i={},o=[],l=(w,S,k,I,T,E)=>{(I==null||T==null||E==null)&&(I=w.sourceLayer,T=w.nodeIndex,E=w.tensorIndex);let R=I.inboundNodes[T];if(k.indexOf(R)!==-1)throw new Ul(`The tensor ${w.name} at layer "${I.name}" is part of a cycle.`);if(S.indexOf(R)!==-1)return;this.containerNodes.add(Ol.nodeKey(I,T)),I.id in i||(i[I.id]=Object.keys(i).length),k.indexOf(R)===-1&&k.push(R);let D=R.inboundLayers.length;for(let O=0;O<D;O++){let $=R.inputTensors[O],_=R.inboundLayers[O],P=R.nodeIndices[O],U=R.tensorIndices[O];l($,S,k,_,P,U)}for(S.push(R);k.indexOf(R)>=0;)k.splice(k.indexOf(R),1);o.push(R)},u=[],c=[];for(let w of this.outputs)l(w,u,c);let h=o.slice().reverse();for(let w of h){a[w.id]=w,w.id in n||(n[w.id]=0);let S=n[w.id],k=r[w.outboundLayer.id]==null?0:r[w.outboundLayer.id];S=Math.max(S,k),r[w.outboundLayer.id]=S,s[w.outboundLayer.id]=w.outboundLayer,n[w.id]=S;for(let I=0;I<w.inboundLayers.length;I++){let T=w.inboundLayers[I],E=w.nodeIndices[I],R=T.inboundNodes[E],D=n[R.id]==null?0:n[R.id];n[R.id]=Math.max(S+1,D),a[R.id]=R}}let p={};for(let w in n){let S=n[w];S in p||(p[S]=[]),p[S].push(a[w])}let m={};for(let w in r){let S=r[w];S in m||(m[S]=[]),m[S].push(s[w])}let g=Object.keys(m).map(w=>parseInt(w,10)).sort(Gk);this.layers=[];for(let w of g){let S=m[w];S.sort((k,I)=>{let T=i[k.id],E=i[I.id];return T<E?-1:T>E?1:0});for(let k of S)k instanceof Ol&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=m,g=Object.keys(p).map(w=>parseInt(w,10)).sort(Gk);let y=this.inputs.slice(),b=[];for(let w of g)for(let S of p[w]){let k=S.outboundLayer;if(k!=null){for(let I of S.inputTensors)if(y.indexOf(I)===-1)throw new Ul(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${k.name}". The following previous layers were accessed without issue: ${b}`);for(let I of S.outputTensors)y.push(I);b.push(k.name)}}this.nodesByDepth=p;let v=this.layers.map(w=>w.name);for(let w of v){let S=v.filter(k=>k===w).length;if(S!==1)throw new Ul(`The name "${w}" is used ${S} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new mC({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(a=>a.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ge("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let a of this.layers)n.push(...a.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let a={},r=0,s=aSe(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let c=s?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(a[c]!=null)throw new ge(`Duplicate weight name: ${c}`);a[c]=u,r++}let i=[];for(let o in t){let l=o;if(a[o]==null){let u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(a[l]!=null)i.push([a[l],t[o]]);else if(n)throw new ge(`Provided weight data has no target variable: ${o}`);delete a[l]}if(n){let o=[];for(let l in a)o.push(l);if(o.length>0)throw new ge(`${o.length} of ${r} weights are not set: ${o}`)}a3(i)}parseWeights(t){for(let n in Object.keys(t)){let a=n.split("/"),r=["vars","layer_checkpoint_dependencies"],s=a.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${f3}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let a=ND(this.updatedConfig());return n?JSON.stringify(a):a}call(t,n){return fe(()=>{t=En(t);let a=new Yg;for(let r=0;r<this.inputs.length;++r)a.add(this.inputs[r],t[r]);return _v(this.outputs,a,n)})}computeMask(t,n){return fe(()=>{t=En(t);let a;return n==null?a=Op(null,t.length):a=En(n),this.runInternalGraph(t,a)[1]})}computeOutputShape(t){let n=tN(t);if(n.length!==this.inputLayers.length)throw new ge(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let a={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";a[c]=u}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Gk);if(r.length>1)for(let o of r){let l=this.nodesByDepth[o];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(y=>y.id).indexOf(c.id)!==-1)continue;let h=[];for(let y=0;y<u.inboundLayers.length;y++){let b=u.inboundLayers[y],v=u.nodeIndices[y],w=u.tensorIndices[y],S=`${b.name}_${v}_${w}`,k=a[S];h.push(k)}let p=c.computeOutputShape(Gs(h)),m=tN(p),g=c.inboundNodes.indexOf(u);for(let y=0;y<m.length;y++){let b=`${c.name}_${g}_${y}`;a[b]=m[y]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],h=`${l.name}_${u}_${c}`;i.push(h)}for(let o=0;o<i.length;o++){let l=i[o];Ll(l in a),s.push(a[l])}return Gs(s)}runInternalGraph(t,n){n==null&&(n=Op(null,t.length));let a={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=t[l],h=n[l];a[u.id]=[c,h]}let r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Gk);for(let l of r){let u=this.nodesByDepth[l];for(let c of u){let h=c.outboundLayer,p=c.inputTensors,m=c.outputTensors,g=new Array;for(let y of p)y.id in a&&g.push(a[y.id]);if(g.length===p.length){let y={},b,v,w,S;if(c.callArgs!=null&&(y=c.callArgs),g.length===1){let[k,I]=g[0];y.mask==null&&(y.mask=I),w=En(h.call(k,y)),S=En(h.computeMask(k,I)),b=[k],v=[I]}else b=g.map(k=>k[0]),v=g.map(k=>k[1]),y.mask==null&&(y.mask=v),w=En(h.call(b,y)),S=En(h.computeMask(b,v));if(h.activityRegularizer)throw new Xt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<m.length;++k){let I=m[k],T=w[k],E=S[k];a[I.id]=[T,E]}}}}let s=[],i=[],o=[];for(let l of this.outputs){Ll(l.id in a,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=a[l.id];o.push(u.shape),s.push(u),i.push(c)}return[s,i,o]}buildNodeConversionMap(t){let n={},a;for(let r of this.layers){a=r instanceof Ol?1:0;for(let s=0;s<r.inboundNodes.length;s++){let i=Ol.nodeKey(r,s);this.containerNodes.has(i)&&(n[i]=a,a+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new ge("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let a of this.layers)if(a.name===t)return a;throw new ge(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new ge(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return fe(()=>{let t=[];for(let n of this.layers)for(let a=0;a<n.inboundNodes.length;++a){let r=Ol.nodeKey(n,a);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),a=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),u=[];for(let h=0;h<i.inboundNodes.length;h++){let p=i.inboundNodes[h],m=Ol.nodeKey(i,h),g={};if(this.containerNodes.has(m)){if(p.callArgs)try{JSON.stringify(p.callArgs),g=p.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(p.inboundLayers.length>0){let y=[];for(let b=0;b<p.inboundLayers.length;b++){let v=p.inboundLayers[b],w=p.nodeIndices[b],S=p.tensorIndices[b],k=Ol.nodeKey(v,w),I=n[k];I==null&&(I=0),y.push([v.name,I,S,g])}u.push(y)}}}let c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,a.push(c)}t.layers=a;let r=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Ol.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let h=this.inputLayersTensorIndices[i];r.push([o.name,c,h])}t.inputLayers=r;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Ol.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let h=this.outputLayersTensorIndices[i];s.push([o.name,c,h])}return t.outputLayers=s,t}static fromConfig(t,n,a={},r=!1){let s={},i={};function o(b,v){b.name in i?i[b.name].push(v):i[b.name]=[v]}function l(b,v){let w=[],S;for(let k of v){let I=k[0],T=k[1],E=k[2];if(S=k[3]==null?{}:k[3],!(I in s)){o(b,v);return}let R=s[I];if(R.inboundNodes.length<=T){o(b,v);return}let D=R.inboundNodes[T];w.push(D.outputTensors[E])}w.length>0&&b.apply(Gs(w),S)}function u(b){let v=b.name,w=ol(b,n.customObjects!=null?n.customObjects:{});w.setFastWeightInitDuringBuild(r),s[v]=w,b.inboundNodes.forEach(S=>{if(!(S instanceof Array))throw new ge(`Corrupted configuration, expected array for nodeData: ${S}`);o(w,S)})}let c=n.name,h=n.layers;for(let b of h)u(b);for(;!T1e(i);)for(let b of h){let v=s[b.name];if(v.name in i){let w=i[v.name];delete i[v.name];for(let S of w)l(v,S)}}let p=[],m=[],g=n.inputLayers;for(let b of g){let v=b[0],w=b[1],S=b[2];Ll(v in s);let k=s[v].inboundNodes[w].outputTensors;p.push(k[S])}let y=n.outputLayers;for(let b of y){let v=b[0],w=b[1],S=b[2];Ll(v in s);let k=s[v].inboundNodes[w].outputTensors;m.push(k[S])}return new t({inputs:p,outputs:m,name:c})}get stateful(){if(this._stateful)throw new ge("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){fe(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function sSe(e,t,n){let a=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(a===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let r=[];return t.forEach(s=>{s in e?r.push(e[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function LK(e,t){return sSe(e,t,"classWeight")}async function zK(e,t,n,a){if(n!=null){let r=fe(()=>{if(e.shape.length===1)return jl(e);if(e.shape.length===2){if(e.shape[1]>1)return Ep(e,1);if(e.shape[1]===1)return pe(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());Ft(r);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Nn(i,"float32")}else return null}function iSe(e,t){return le(e,t)}var oSe=32;function BK(e,t){let n,a,r=t;n=r.xs,a=r.ys,F.assert(n!=null&&a!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=JG("input",e.inputNames,n),i=JG("output",e.outputNames,a),o=s[0].shape[0];F.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),F.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)F.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)F.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function JG(e,t,n){if(n instanceof Bt)return[n];if(Array.isArray(n))return F.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let a=[];for(let r of t){if(n[r]==null)throw new ge(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function lSe(e){if(e.length===3)throw new Xt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function uSe(e,t,n){let a=n.batchesPerEpoch!=null;if(F.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),F.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),F.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),F.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),F.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let r=n.validationData!=null,s,i;if(r)if(eH(n.validationData))F.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let b=lSe(n.validationData);s=b.xs,i=b.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;r?u=l.slice().concat(l.map(b=>"val_"+b)):u=l.slice();let c=EK(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:p,history:m}=$K(c,h,n.epochs,null,null,cSe(t,n),null,r,u);p.setModel(e),e.history=m,await p.onTrainBegin(),e.stopTraining_=!1;let g=n.initialEpoch==null?0:n.initialEpoch,y=await t.iterator();for(;g<n.epochs;){let b={};await p.onEpochBegin(g);let v=0,w=0;for(a||(y=await t.iterator());!a||v<n.batchesPerEpoch;){let S=await y.next();if(a&&S.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(S.value!=null){let{xs:k,ys:I}=BK(e,S.value),T={};T.batch=w,T.size=k[0].shape[0],await p.onBatchBegin(w,T);let E=[];if(n.classWeight!=null){let O=LK(n.classWeight,e.outputNames);for(let $=0;$<O.length;++$)E.push(await zK(I[$],null,O[$]))}let R=k.concat(I).concat(E),D=o(R);Ft(R);for(let O=0;O<l.length;++O){let $=l[O],_=D[O];T[$]=_,cr(_)}await p.onBatchEnd(w,T),IK(T),w++,v++}if(a?v>=n.batchesPerEpoch:S.done){if(r){let k;eH(n.validationData)?k=En(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):k=En(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?oSe:n.validationBatchSize,verbose:0}));for(let I=0;I<e.metricsNames.length;++I)b[`val_${e.metricsNames[I]}`]=k[I]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(g,b),g++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function cSe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function eH(e){return typeof e.iterator=="function"}function hSe(e){return typeof e.next=="function"}async function dSe(e,t,n){n=n||{};let a=n.batches!=null,r=e.testFunction,s=[];if(n.verbose>0)throw new Xt("Verbose mode is not implemented yet.");F.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=hSe(t)?t:await t.iterator(),o=0,l=0;for(;!a||l<n.batches;){let u=await i.next();if(s=fe(()=>{if(u.value){let{xs:c,ys:h}=BK(e,u.value),p=c.concat(h),m=fe(()=>r(p));if(Ft(p),l===0)for(let y=0;y<m.length;++y)s.push(xt(0));let g=p[0].shape[0];for(let y=0;y<m.length;++y){let b=m[y],v=s[y];s[y]=fe(()=>Re(s[y],le(g,b))),l>0&&Ft(v)}Ft(m),o+=g,++l}return s}),u.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let c=s[u];s[u]=st(s[u],o),Ft(c)}return Gs(s)}function yR(e){F.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function wv(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(a=>mp(a,t,n-t)):mp(e,t,n-t)}function CD(e,t){return fe(()=>e==null?null:Array.isArray(e)?e.map(n=>CD(n,t)):gK(e,t.dtype==="int32"?t:He(t,"int32")))}function bR(e,t){let n=[],a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function PK(e){let t=[];e instanceof Bt&&(e=[e]);for(let n=0;n<e.length;++n){let a=e[n];if(a.rank===1)t.push(E1(a,1));else{if(a.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Yo(e,t){if(e==null)return;let n=[];if(t instanceof Bt)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(let r in t){let s=t[r];n.push(s.id)}let a=[];if(e instanceof Bt)n.indexOf(e.id)===-1&&a.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&a.push(r)});else if(e!=null)for(let r in e){let s=e[r];n.indexOf(s.id)===-1&&a.push(s)}a.forEach(r=>{r.isDisposed||r.dispose()})}function pSe(e){return e instanceof Bt}function TD(e){return Array.isArray(e)}function tH(e){return!pSe(e)&&!TD(e)}function nH(e,t,n,a=!0,r=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(TD(e)&&e.length>0)i=!0;else if(tH(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new ge(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(tH(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new ge(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(TD(e)){if(e=e,e.length!==t.length)throw new ge(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new ge(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=PK(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new ge(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new ge(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function fSe(e,t,n){let a=gh(e.map(s=>s.shape[0]));a.sort();let r=gh(t.map(s=>s.shape[0]));if(r.sort(),a.length>1)throw new ge(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>1)throw new ge(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(a.length>0&&r.length>0&&!F.arraysEqual(a,r))throw new ge(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function mSe(e,t,n){let a=[$m,yC,lw];for(let r=0;r<e.length;++r){let s=e[r],i=t[r],o=n[r];if(i!=null){if(i===lw&&s.shape[s.shape.length-1]===1)throw new ge(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(a.indexOf(i)!==-1){let l=s.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){let h=l[c],p=u[c];if(p!=null&&h!==p)throw new ge(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function aH(e,t,n,a=!0,r=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new ge(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new ge(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new ge(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new ge(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function gSe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(a=>n);{let a=[];for(let r of t){let s=n.hasOwnProperty(r)?n[r]:[];Array.isArray(s)||(s=[s]),a.push(s)}return a}}var ySe="layers-model",Xu=class extends rSe{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new ge("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");ZAe(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=QAe(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof dc))throw new ge("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new ge(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(gR(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ge(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>gR(s))}else{let s=gR(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fp("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let a=gSe(e.metrics,this.outputNames),r=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};fp("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=a[s];(o=>{let l="",u,c,h;for(let p of o){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){let g=this.internalOutputShapes[s];g[g.length-1]===1||this.lossFunctions[s]===yC?["accuracy","acc"].indexOf(p)!==-1?c=h3:["crossentropy","ce"].indexOf(p)!==-1&&(c=DK):this.lossFunctions[s]===iN?["accuracy","acc"].indexOf(p)!==-1?c=OK:["crossentropy","ce"].indexOf(p)!==-1&&(c=FK):["accuracy","acc"].indexOf(p)!==-1?c=d3:["crossentropy","ce"].indexOf(p)!==-1&&(c=p3);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),h=c,u=l+y}else h=YAe(p),u=l+qk(p);let m;fp(u,()=>{m=h}),r(s,u,m)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let a=n.batchSize==null?32:n.batchSize;yR(a);let r=this.standardizeUserDataXY(e,t,!0,a);try{let s=r[0].concat(r[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,a,n.verbose,n.steps);return Gs(o)}finally{Yo(r[0],e),Yo(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),dSe(this,e,t)}checkNumSamples(e,t,n,a="steps"){let r;if(n!=null){if(r=null,t!=null)throw new ge(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new ge(`Either the input data should have a defined shape, or ${a} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ge("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new Yg;if(e instanceof Bt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ge(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new ge(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=_v(r,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Op(null,e.length),n=e.length;for(let a of this.layers){let r=Array.isArray(a.output)?a.output:[a.output],s=r.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=r[o],n--),n===0)break}if(n===0)break}if(n>0){let a=[];throw t.forEach((r,s)=>{r==null&&a.push(e[s])}),new ge(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return t}predictLoop(e,t=32,n=!1){return fe(()=>{let a=this.checkNumSamples(e);if(n)throw new Xt("Verbose predictLoop() is not implemented yet.");let r=bR(a,t),s=this.outputs.map(i=>[]);for(let i=0;i<r.length;++i)fe(()=>{let o=r[i][0],l=r[i][1],u=wv(e,o,l),c=[];if(Array.isArray(u))for(let p=0;p<u.length;++p)c.push({key:this.inputs[p],value:u[p]});else c.push({key:this.inputs[0],value:u});let h=new Yg(c);return _v(this.outputs,h)}).forEach((o,l)=>s[l].push(o));return Gs(s.map(i=>Un(i,0)))})}predict(e,t={}){let n=PK(e);aH(n,this.inputNames,this.feedInputShapes,!1);try{let a=t.batchSize==null?32:t.batchSize;return yR(a),this.predictLoop(n,a)}finally{Yo(n,e)}}predictOnBatch(e){aH(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,a){if(this.optimizer_==null)throw new Ul("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===iN?r.push(i.slice(0,i.length-1).concat([1])):r.push(i)}if(e=nH(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=nH(t,this.feedOutputNames,r,!1,"target"),fSe(e,t),mSe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&a!=null&&a>0&&e[0].shape[0]%a!==0)throw new ge(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,a,r=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,r,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(a!=null){let u=LK(a,this.outputNames);l=[];for(let c=0;c<u.length;++c)l.push(await zK(o[c],null,u[c]))}return[i,o,l]}testLoop(e,t,n,a=0,r){return fe(()=>{let s=this.checkNumSamples(t,n,r,"steps"),i=[];if(a>0)throw new Xt("Verbose mode is not implemented yet.");if(r!=null)throw new Xt("steps mode in testLoop() is not implemented yet");{let o=bR(s,n),l=Nn(dl(0,s));for(let u=0;u<o.length;++u){let c=o[u][0],h=o[u][1],p=mp(l,c,h-c),m=CD(t,p),g=e(m);if(u===0)for(let y=0;y<g.length;++y)i.push(xt(0));for(let y=0;y<g.length;++y){let b=g[y];i[y]=Re(i[y],le(h-c,b))}}for(let u=0;u<i.length;++u)i[u]=st(i[u],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let a=e[n],r=a;if(UG(e,a)>1){let s=UG(e.slice(0,n),a);r+=`_${s}`}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let p=0;p<this.inputs.length;++p)l.push({key:this.inputs[p],value:n[p]});let u=new Yg(l),c=_v(this.outputs,u,{training:!0}),h;for(let p=0;p<this.lossFunctions.length;++p){let m=this.lossFunctions[p],g=m(a[p],c[p]);r[p]!=null&&(g=iSe(g,r[p]));let y=wa(g);t.push(y),p===0?h=g:h=Re(h,g)}for(let p=0;p<this.metricsTensors.length;++p){let m;if(this.outputs.length>1&&p<this.outputs.length)m=t[p];else{let g=this.metricsTensors[p][0],y=this.metricsTensors[p][1];m=wa(g(a[y],c[y]))}cr(m),s.push(m)}return h=wa(h),this.calculateLosses().forEach(p=>{h=Re(h,p)}),h},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>fe(()=>{let t=[],n,a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:a[l]});let i=new Yg(s),o=_v(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],c=wa(u(r[l],o[l]));l===0?n=c:n=Re(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],c=this.metricsTensors[l][1],h=wa(u(r[c],o[c]));t.push(h)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,r,s,i,o,l,u,c,h;try{let p=n.batchSize==null?32:n.batchSize;yR(p);let m=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,p);a=m[0],r=m[1],h=m[2];let g=!1,y;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Xt("validationData including sample weights is not supported yet."):new ge(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let T=await this.standardizeUserData(o,l,null,null,!0,p);u=T[0],c=T[1],y=u.concat(c)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let T=Math.floor(a[0].shape[0]*(1-n.validationSplit)),E=a[0].shape[0];u=wv(a,T,E),s=a,a=wv(a,0,T),c=wv(r,T,E),i=r,r=wv(r,0,T),y=u.concat(c)}else n.validationSteps!=null&&(g=!0);let b=a.concat(r).concat(h);this.checkTrainableWeightsConsistency();let v=this.makeTrainFunction(),w=this.getDedupedMetricsNames(),S,k;g?(this.makeTestFunction(),S=this.testFunction,k=w.slice().concat(w.map(T=>"val_"+T))):(S=null,y=[],k=w.slice());let I=EK(n.callbacks,n.yieldEvery);return await this.fitLoop(v,b,w,p,n.epochs,n.verbose,I,S,y,n.shuffle,k,n.initialEpoch,null,null)}finally{this.isTraining=!1,Yo(a,e),Yo(r,t),Yo(s,e),Yo(i,t),Yo(u,o),Yo(c,l),h!=null&&Ft(h)}}async fitLoop(e,t,n,a,r,s,i,o,l,u,c,h,p,m){a==null&&(a=32),r==null&&(r=1),u==null&&(u=!0),h==null&&(h=0);let g=!1;if(o!=null&&l!=null&&(g=!0),m!=null&&(g=!0,p==null))throw new ge("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let y=this.checkNumSamples(t,a,p,"steps_per_epoch"),b;y!=null&&(b=dl(0,y)),s==null&&(s=1);let{callbackList:v,history:w}=$K(i,s,r,h,y,p,a,g,c);v.setModel(this),this.history=w,await v.onTrainBegin(),this.stopTraining_=!1;for(let S=h;S<r;++S){await v.onEpochBegin(S);let k={};if(p!=null)throw new Xt("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Xt("batch shuffling is not implemneted yet");u&&F.shuffle(b);let I=Nn(b),T=bR(y,a);for(let E=0;E<T.length;++E){let R={};if(await v.onBatchBegin(E,R),fe(()=>{let D=T[E][0],O=T[E][1],$=mp(I,D,O-D);R.batch=E,R.size=O-D;let _=CD(t,$),P=e(_);for(let U=0;U<n.length;++U){let W=n[U],B=P[U];R[W]=B,cr(B)}if(E===T.length-1&&g){let U=this.testLoop(o,l,a);for(let W=0;W<n.length;++W){let B=n[W],H=U[W];cr(H),k["val_"+B]=H}}}),await v.onBatchEnd(E,R),IK(R),this.stopTraining_)break}I.dispose()}if(await v.onEpochEnd(S,k),this.stopTraining_)break}return await v.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return uSe(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return Ft(s),Yo(n[0],e),Yo(n[1],t),Gs(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=uD().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-uD().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=zu(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>zu(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let a of t)if(typeof n[a]=="string")e[a]=zu(n[a]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[zu(qk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>zu(qk(e)));{let e={};for(let t in this.metrics)e[t]=zu(qk(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=uw(e.optimizer_config),n=ol(t),a;if(typeof e.loss=="string")a=tp(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(s=>tp(s));else if(e.loss!=null){a={};for(let s in e.loss)a[s]=tp(e.loss[s])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(s=>tp(s));else if(e.metrics!=null){r={};for(let s in e.metrics)r[s]=tp(e.metrics[s])}this.compile({loss:a,metrics:r,optimizer:n})}async save(e,t){if(typeof e=="string"){let r=Kr.getSaveHandlers(e);if(r.length===0)throw new ge(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new ge(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new ge("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Kr.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:ySe,generatedBy:`TensorFlow.js tfjs-layers v${f3}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let r="optimizer",{data:s,specs:i}=await Kr.encodeWeights(await this.optimizer.getWeights(),r);n.specs.push(...i),n.data=Kr.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(ZG(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){ZG(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Xu.className="Model";Pe.registerClass(Xu);var VK=class extends Xu{};VK.className="Functional";Pe.registerClass(VK);async function bSe(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let a=uw(n),r=ol(a,t);if(e.weightsManifest!=null){let s=await Kr.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(o=>o.originalName)),i={};for(let o of r.weights)i[o.originalName]=s[o.originalName];r.loadWeights(i),Ft(s)}return r}async function xSe(e,t){if(t==null&&(t={}),typeof e=="string"){let n=Kr.getLoadHandlers(e,t);if(n.length===0)n.push(Kr.browserHTTPRequest(e,t));else if(n.length>1)throw new ge(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return vSe(e,void 0,t)}async function vSe(e,t,n){if(n==null&&(n={}),e.load==null)throw new ge("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let a=await e.load(),r=a.modelTopology;r.model_config!=null&&(r=r.model_config);let s=n.strict==null?!0:n.strict,i=a.weightData!=null&&a.weightSpecs!=null&&s,o=ol(uw(r),t,i),l=a.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),a.userDefinedMetadata!=null&&o.setUserDefinedMetadata(a.userDefinedMetadata),a.weightData!=null){if(a.weightSpecs==null)throw new ge("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=wSe(a.weightData,a.weightSpecs);o.loadWeights(u,s),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),Ft(u),Ft(c.map(h=>h.tensor))}return o}function wSe(e,t){let n=Kr.decodeWeights(e,t),a={},r=[];return t.forEach(s=>{s.group==="optimizer"?r.push({name:s.name,tensor:n[s.name]}):a[s.name]=n[s.name]}),{modelWeights:a,optimizerWeights:r}}var bC=class ED extends Xu{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:iC("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new ge(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof ED||t instanceof Xu,a;if(n){if(a=t,a.outputs.length!==1)throw new ge("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(a.inputs.length!==1)throw new ge("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ge("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=vK({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(n)this.outputs=a.outputs,this.inputs=a.inputs;else{if(t.inboundNodes.length!==1)throw new ge(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ge("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=xK(this.outputs[0])}this.inboundNodes=[],new mC({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Op(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(bn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Xu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,a=console.log){this.built||this.build(),super.summary(t,n,a)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,a={}){if(!this.built)throw new Ul("The model needs to be compiled before being used.");return this.model.evaluate(t,n,a)}async evaluateDataset(t,n){if(!this.built)throw new Ul("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,a={}){if(!this.built)throw new Ul("The model needs to be compiled before being used.");return this.model.fit(t,n,a)}async fitDataset(t,n){if(!this.built)throw new Ul("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,a={},r=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new ge("Legacy serialization format not supported yet.");s=n}else F.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof ED))throw new Xt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let u=ol(l,void 0,r);r&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(t){if(this.model==null)throw new ge("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ge("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let a={};a.className=n.getClassName(),a.config=n.getConfig(),t.push(a)}return{name:this.name,layers:t}}};bC.className="Sequential";Pe.registerClass(bC);function ASe(e){return new Xu(e)}function SSe(e){return new bC(e)}function UK(e){return vK(e)}function kSe(e,t){u3.registerCallbackConstructor(e,t)}var ps=class extends Pe.Serializable{getConfig(){return{}}},WK=class extends ps{apply(e,t=1){return W1e(e,t)}};WK.className="elu";Pe.registerClass(WK);var GK=class extends ps{apply(e){return W2(e)}};GK.className="selu";Pe.registerClass(GK);var HK=class extends ps{apply(e){return _n(e)}};HK.className="relu";Pe.registerClass(HK);var jK=class extends ps{apply(e){return fe(()=>Ch(6,_n(e)))}};jK.className="relu6";Pe.registerClass(jK);var qK=class extends ps{apply(e){return e}};qK.className="linear";Pe.registerClass(qK);var KK=class extends ps{apply(e){return Mo(e)}};KK.className="sigmoid";Pe.registerClass(KK);var XK=class extends ps{apply(e){return H1e(e)}};XK.className="hardSigmoid";Pe.registerClass(XK);var YK=class extends ps{apply(e){return Cm(e)}};YK.className="softplus";Pe.registerClass(YK);var QK=class extends ps{apply(e){return G1e(e)}};QK.className="softsign";Pe.registerClass(QK);var ZK=class extends ps{apply(e){return Nh(e)}};ZK.className="tanh";Pe.registerClass(ZK);var m3=class extends ps{apply(e,t=-1){return nd(e,t)}};m3.className="softmax";Pe.registerClass(m3);var JK=class extends ps{apply(e,t=-1){return M2(e,t)}};JK.className="logSoftmax";Pe.registerClass(JK);var eX=class extends ps{apply(e){return fe(()=>fe(()=>{let t=Math.sqrt(2),n=le(.5,Re(1,D2(st(e,t))));return le(e,n)}))}};eX.className="gelu";Pe.registerClass(eX);var tX=class extends ps{apply(e){return fe(()=>le(.5,le(e,Re(1,Nh(le(Or(st(2,Math.PI)),Re(e,le(.044715,tu(e,3)))))))))}};tX.className="gelu_new";Pe.registerClass(tX);var nX=class extends ps{apply(e){return fe(()=>le(e,Nh(Cm(e))))}};nX.className="mish";Pe.registerClass(nX);var aX=class extends ps{apply(e,t=1){return fe(()=>le(Mo(le(e,t)),e))}};aX.className="swish";Pe.registerClass(aX);function $h(e){return e.getClassName()}function xR(e,t={}){return T1(e,Pe.SerializationMap.getMap().classNameMap,t,"activation")}function _h(e){if(e==null){let t={};return t.className="linear",t.config={},xR(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},xR(t)}else return e instanceof ps?e:xR(e)}function g3(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var rX=class extends Pe.Serializable{},D1=class extends rX{constructor(e){super(),g3(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return fe(()=>{let t=Aa([1]);return this.hasL1&&(t=Re(t,ut(le(this.l1,Ka(e))))),this.hasL2&&(t=Re(t,ut(le(this.l2,$1(e))))),pe(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};D1.className="L1L2";Pe.registerClass(D1);function ISe(e){return g3(e),new D1({l1:e!=null?e.l1:null,l2:0})}function NSe(e){return g3(e),new D1({l2:e!=null?e.l2:null,l1:0})}var rH={l1l2:"L1L2"};function Zn(e){return qM(e)}function sH(e,t={}){return T1(e,Pe.SerializationMap.getMap().classNameMap,t,"regularizer")}function ga(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in rH?rH[e]:e,config:{}};return sH(t)}else return e instanceof rX?e:sH(e)}var y3=class extends Qt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Et(e);let n=_n(e);return this.maxValue!=null&&(n=hs(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};y3.className="ReLU";Pe.registerClass(y3);var b3=class extends Qt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Et(e);return y1(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};b3.className="LeakyReLU";Pe.registerClass(b3);var x3=class extends Qt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=fa(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ga(e.alphaRegularizer),this.alphaConstraint=yr(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ge(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=bn(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new Qa({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Et(e),S1(e,this.alpha.read())}getConfig(){let e={alphaInitializer:ka(this.alphaInitializer),alphaRegularizer:Zn(this.alphaRegularizer),alphaConstraint:gr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};x3.className="PReLU";Pe.registerClass(x3);var v3=class extends Qt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Xt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Et(e);return jb(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};v3.className="ELU";Pe.registerClass(v3);var w3=class extends Qt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Et(e);return le(n,He(Fs(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};w3.className="ThresholdedReLU";Pe.registerClass(w3);var A3=class extends Qt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new m3().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return fe(()=>{let n=Et(e),a=t.mask;if(a!=null){let r=le(nt(js(n.shape),He(a,n.dtype)),xt(-1e9));n=Re(n,r)}return this.axis instanceof Array?this.axis.length>1?ds(nt(n,x1(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};A3.className="Softmax";Pe.registerClass(A3);function ty(e,t,n){if(typeof e=="number")return Op(e,t);if(e.length!==t)throw new ge(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){let r=e[a];if(!B1e(r))throw new ge(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function ll(e,t,n,a,r=1){if(e==null)return e;let s=t+(t-1)*(r-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+a-1)/a)}function zl(e,t,n,a){if(e==null)return null;if(a==="valid")e=e*t+Eh([n-t,0]);else if(a==="same")e=e*t;else throw new ge(`Unsupport padding mode: ${a}.`);return e}function S3(e,t){return fe(()=>(Pa(t),t==="channelsFirst"?Ut(e,[0,2,3,1]):e))}function sX(e,t){return fe(()=>(Pa(t),t==="channelsFirst"?Ut(e,[0,2,3,4,1]):e))}function CSe(e,t,n,a=1,r="valid",s,i=1){return fe(()=>{if(s==null&&(s=pl()),Pa(s),e.shape.length!==3)throw new ge(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new ge(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new ge(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=Ut(e,[0,2,1])),r==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=E2(e,t,a,r==="same"?"same":"valid","NWC",i);return n!=null&&(o=Al(o,n)),o})}function iH(e,t,n,a=[1,1],r="valid",s,i,o=null){return fe(()=>{if(s==null&&(s=pl()),Pa(s),e.rank!==3&&e.rank!==4)throw new ge(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ge(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=S3(e,s);if(r==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=by.conv2d({x:l,filter:t,strides:a,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=Ut(l,[0,3,1,2])),l})}function TSe(e,t,n,a=[1,1,1],r="valid",s,i){return fe(()=>{if(s==null&&(s=pl()),Pa(s),e.rank!==4&&e.rank!==5)throw new ge(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ge(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=sX(e,s);if(r==="causal")throw new Xt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=QF(o,t,a,r==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Al(o,n)),s==="channelsFirst"&&(o=Ut(o,[0,4,1,2,3])),o})}var iX=class oX extends Qt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oX.verifyArgs(n),this.rank=t,_r(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Xt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ty(n.kernelSize,t,"kernelSize"),this.strides=ty(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,co(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Pa(this.dataFormat),this.activation=_h(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=fa(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=yr(n.biasConstraint),this.biasRegularizer=ga(n.biasRegularizer),this.activityRegularizer=ga(n.activityRegularizer),this.dilationRate=ty(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ge(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ge(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ge(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Ll("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!KM(t.kernelSize,"number",1,3))throw new ge(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:$h(this.activation),useBias:this.useBias,biasInitializer:ka(this.biasInitializer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),biasConstraint:gr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},xC=class lX extends iX{constructor(t,n){super(t,n),this.kernel=null,lX.verifyArgs(n),this.filters=n.filters,_r(this.filters,"filters"),this.kernelInitializer=fa(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=yr(n.kernelConstraint),this.kernelRegularizer=ga(n.kernelRegularizer)}build(t){t=bn(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ge(`The channel dimension of the input should be defined. Found ${t[n]}`);let a=t[n],r=this.kernelSize.concat([a,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:a}}],this.built=!0}call(t,n){return fe(()=>{t=Et(t);let a,r=this.bias==null?null:this.bias.read(),s=cK(this.activation.getClassName());if(s!=null&&this.rank===2)a=iH(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)a=CSe(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)a=iH(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)a=TSe(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Xt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(a=this.activation.apply(a))}return a})}computeOutputShape(t){t=bn(t);let n=[],a=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<a.length;++s){let i=ll(a[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){let t={filters:this.filters,kernelInitializer:ka(this.kernelInitializer),kernelRegularizer:Zn(this.kernelRegularizer),kernelConstraint:gr(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ge(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},vC=class uX extends xC{constructor(t){super(2,t),uX.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!KM(t.kernelSize,"number",1,2))throw new ge(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};vC.className="Conv2D";Pe.registerClass(vC);var wC=class cX extends xC{constructor(t){super(3,t),cX.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ge(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};wC.className="Conv3D";Pe.registerClass(wC);var k3=class extends vC{constructor(e){if(super(e),this.inputSpec=[new Qa({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ge(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=bn(e),e.length!==4)throw new ge("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ge("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qa({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return fe(()=>{let n=Et(e);if(n.shape.length!==4)throw new ge(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=a[s],l=a[i],u=this.kernelSize[0],c=this.kernelSize[1],h=this.strides[0],p=this.strides[1],m=zl(o,h,u,this.padding),g=zl(l,p,c,this.padding),y=[r,m,g,this.filters];this.dataFormat!=="channelsLast"&&(n=Ut(n,[0,2,3,1]));let b=$2(n,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=Ut(b,[0,3,1,2])),this.bias!=null&&(b=Al(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=bn(e);let t=e.slice(),n,a,r;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3):(n=3,a=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[a]=zl(t[a],o,s,this.padding),t[r]=zl(t[r],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};k3.className="Conv2DTranspose";Pe.registerClass(k3);var I3=class extends wC{constructor(e){if(super(e),this.inputSpec=[new Qa({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ge(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=bn(e),e.length!==5)throw new ge("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ge("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qa({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return fe(()=>{let n=Et(e);if(n.shape.length!==5)throw new ge(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=a[o],u=a[s],c=a[i],h=this.kernelSize[0],p=this.kernelSize[1],m=this.kernelSize[2],g=this.strides[0],y=this.strides[1],b=this.strides[2],v=zl(l,g,h,this.padding),w=zl(u,y,p,this.padding),S=zl(c,b,m,this.padding),k=[r,v,w,S,this.filters];this.dataFormat!=="channelsLast"&&(n=Ut(n,[0,2,3,4,1]));let I=ZF(n,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=Ut(I,[0,4,1,2,3])),this.bias!==null&&(I=Al(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=bn(e);let t=e.slice(),n,a,r,s;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=zl(t[a],u,i,this.padding),t[r]=zl(t[r],c,o,this.padding),t[s]=zl(t[s],h,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};I3.className="Conv3DTranspose";Pe.registerClass(I3);var hX=class extends xC{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ge("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ge("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ge(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=fa(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ga(t.depthwiseRegularizer),this.depthwiseConstraint=yr(t.depthwiseConstraint),this.pointwiseInitializer=fa(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ga(t.pointwiseRegularizer),this.pointwiseConstraint=yr(t.pointwiseConstraint)}build(e){if(e=bn(e),e.length<this.rank+2)throw new ge(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ge(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Qa({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return fe(()=>{e=Et(e);let n;if(this.rank===1)throw new Xt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ut(e,[0,2,3,1])),n=Yb(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Al(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Ut(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ka(this.depthwiseInitializer),e.pointwiseInitializer=ka(this.pointwiseInitializer),e.depthwiseRegularizer=Zn(this.depthwiseRegularizer),e.pointwiseRegularizer=Zn(this.pointwiseRegularizer),e.depthwiseConstraint=gr(this.depthwiseConstraint),e.pointwiseConstraint=gr(this.pointwiseConstraint),e}};hX.className="SeparableConv";var N3=class extends hX{constructor(e){super(2,e)}};N3.className="SeparableConv2D";Pe.registerClass(N3);var C3=class dX extends xC{constructor(t){super(1,t),dX.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!KM(t.kernelSize,"number",1,1))throw new ge(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};C3.className="Conv1D";Pe.registerClass(C3);var T3=class extends Qt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return fe(()=>{if(e=Et(e),this.dataFormat==="channelsLast"){let n=jk(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return jk(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=jk(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return jk(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};T3.className="Cropping2D";Pe.registerClass(T3);var E3=class extends Qt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pa(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,M1e(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return fe(()=>{let n=Et(e),a=n.shape;if(this.dataFormat==="channelsFirst"){n=Ut(n,[0,2,3,1]);let r=this.size[0]*a[2],s=this.size[1]*a[3],i=this.interpolation==="nearest"?Xi.resizeNearestNeighbor(n,[r,s]):Xi.resizeBilinear(n,[r,s]);return Ut(i,[0,3,1,2])}else{let r=this.size[0]*a[1],s=this.size[1]*a[2];return this.interpolation==="nearest"?Xi.resizeNearestNeighbor(n,[r,s]):Xi.resizeBilinear(n,[r,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};E3.className="UpSampling2D";Pe.registerClass(E3);function ESe(e,t,n=[1,1],a="valid",r,s){return fe(()=>{r==null&&(r=pl()),Pa(r);let i=S3(e,r);if(e.rank!==4)throw new ge(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new ge(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Nm(i,t,n,a==="same"?"same":"valid","NHWC",s),r==="channelsFirst"&&(i=Ut(i,[0,3,1,2])),i})}var $3=class extends iX{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=fa(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=yr(e.depthwiseConstraint),this.depthwiseRegularizer=ga(e.depthwiseRegularizer)}build(e){if(e=bn(e),e.length<4)throw new ge(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ge(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return fe(()=>{e=Et(e);let n=ESe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Al(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=bn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=ll(t,this.kernelSize[0],this.padding,this.strides[0]),s=ll(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ka(this.depthwiseInitializer),e.depthwiseRegularizer=Zn(this.depthwiseRegularizer),e.depthwiseConstraint=gr(this.depthwiseRegularizer),e}};$3.className="DepthwiseConv2D";Pe.registerClass($3);function pX(e,t,n,a){if(Array.isArray(e)){if(t!=null||n!=null)throw new ge("When inputs is an array, neither initialState or constants should be provided");a!=null&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function fX(e,t,n,a=!1,r,s,i=!1,o=!1){return fe(()=>{let l=t.shape.length;if(l<3)throw new ge(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(dl(2,l));t=Ut(t,u),s!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=He(He(r,"bool"),"float32"),r.rank===l-1&&(r=Tr(r,-1)),r=Ut(r,u)),a&&(t=io(t,0),r!=null&&(r=io(r,0)));let c=[],h,p=n,m=t.shape[0],g=Ra(t),y;r!=null&&(y=Ra(r));for(let v=0;v<m;++v){let w=g[v],S=fe(()=>e(w,p));if(r==null)h=S[0],p=S[1];else{let k=fe(()=>{let I=y[v],T=nt(_i(I),I),E=Re(le(S[0],I),le(p[0],T)),R=p.map((D,O)=>Re(le(S[1][O],I),le(D,T)));return{output:E,newStates:R}});h=k.output,p=k.newStates}o&&c.push(h)}let b;return o&&(b=Ja(c,1)),[h,b,p]})}var pc=class mX extends Qt{constructor(t){super(t);let n;if(t.cell==null)throw new ge("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new kC({cells:t.cell}):n=t.cell,n.stateSize==null)throw new ge("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Qa({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return dl(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){SD(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let a=n[0],r;if(this.returnSequences?r=[t[0],t[1],a]:r=[t[0],a],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[r].concat(s)}else return r}computeMask(t,n){return fe(()=>{Array.isArray(n)&&(n=n[0]);let a=this.returnSequences?n:null;if(this.returnState){let r=this.states.map(s=>null);return[a].concat(r)}else return a})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let a=0;a<t;++a)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Xt("Constants support is not implemented in RNN yet.");SD(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,a=t.slice(2);this.inputSpec[0]=new Qa({shape:[n,null,...a]});let r=[t[0]].concat(t.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!F.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new ge(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new Qa({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){fe(()=>{if(!this.stateful)throw new rh("Cannot call resetStates() on an RNN Layer that is not stateful.");let a=this.inputSpec[0].shape[0];if(a==null)throw new ge("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Aa([a,r])):this.states_=[Aa([a,this.cell.stateSize])];else if(t==null)Ft(this.states_),this.keptStates!=null&&(Ft(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Aa([a,r])):this.states_[0]=Aa([a,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ge(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Ft(this.states_);for(let r=0;r<this.states_.length;++r){let s=t[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[a,i];if(!F.arraysEqual(s.shape,o))throw new ge(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>cr(r.clone()))})}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});let s=pX(t,a,r,this.numConstants);t=s.inputs,a=s.initialState,r=s.constants;let i=[],o=[];if(a!=null){n.initialState=a,i=i.concat(a),this.stateSpec=[];for(let l of a)this.stateSpec.push(new Qa({shape:l.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof fl){let l=[t].concat(i),u=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=u;let h=super.apply(l,n);return this.inputSpec=c,h}else return super.apply(t,n)}call(t,n){return fe(()=>{let a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;t=Et(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new ge(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},l=fX((m,g)=>{let y=this.cell.call([m].concat(g),o);return[y[0],y.slice(1)]},t,s,this.goBackwards,a,null,this.unroll,this.returnSequences),u=l[0],c=l[1],h=l[2];this.stateful&&this.resetStates(h,r);let p=this.returnSequences?c:u;return this.returnState?[p].concat(h):p})}getInitialState(t){return fe(()=>{let n=Aa(t.shape);return n=ut(n,[1,2]),n=E1(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?wD(n,[1,a]):n):this.cell.stateSize>1?[wD(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let a=this.cell.getConfig();return this.getClassName()===mX.className&&(n.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),t),n)}static fromConfig(t,n,a={}){let r=n.cell,s=ol(r,a);return new t(Object.assign(n,{cell:s}))}};pc.className="RNN";Pe.registerClass(pc);var O1=class extends Qt{},AC=class extends O1{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,_r(this.units,"units"),this.activation=_h(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=fa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ga(e.kernelRegularizer),this.recurrentRegularizer=ga(e.recurrentRegularizer),this.biasRegularizer=ga(e.biasRegularizer),this.kernelConstraint=yr(e.kernelConstraint),this.recurrentConstraint=yr(e.recurrentConstraint),this.biasConstraint=yr(e.biasConstraint),this.dropout=xy([1,Eh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xy([1,Eh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=bn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return fe(()=>{if(e=e,e.length!==2)throw new ge(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let a=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Rh({ones:()=>_i(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Rh({ones:()=>_i(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let r,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?r=Kl(le(e,s),this.kernel.read()):r=Kl(e,this.kernel.read()),this.bias!=null&&(r=Al(r,this.bias.read())),i!=null&&(n=le(n,i));let o=Re(r,Kl(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:$h(this.activation),useBias:this.useBias,kernelInitializer:ka(this.kernelInitializer),recurrentInitializer:ka(this.recurrentInitializer),biasInitializer:ka(this.biasInitializer),kernelRegularizer:Zn(this.kernelRegularizer),recurrentRegularizer:Zn(this.recurrentRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),recurrentConstraint:gr(this.recurrentConstraint),biasConstraint:gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};AC.className="SimpleRNNCell";Pe.registerClass(AC);var _3=class extends pc{constructor(e){e.cell=new AC(e),super(e)}call(e,t){return fe(()=>{this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}};_3.className="SimpleRNN";Pe.registerClass(_3);var SC=class extends O1{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ge("GRUCell does not support reset_after parameter set to true.");this.units=e.units,_r(this.units,"units"),this.activation=_h(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=_h(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=fa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ga(e.kernelRegularizer),this.recurrentRegularizer=ga(e.recurrentRegularizer),this.biasRegularizer=ga(e.biasRegularizer),this.kernelConstraint=yr(e.kernelConstraint),this.recurrentConstraint=yr(e.recurrentConstraint),this.biasConstraint=yr(e.biasConstraint),this.dropout=xy([1,Eh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xy([1,Eh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=bn(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return fe(()=>{if(e=e,e.length!==2)throw new ge(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Rh({ones:()=>_i(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Rh({ones:()=>_i(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let r=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=le(e,r[0]));let u=Kl(e,this.kernel.read());this.useBias&&(u=Al(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=le(a,s[0]));let c=this.recurrentKernel.read(),[h,p]=Ks(c,[2*this.units,this.units],c.rank-1),m=Kl(a,h),[g,y,b]=Ks(u,3,u.rank-1),[v,w]=Ks(m,2,m.rank-1);i=this.recurrentActivation.apply(Re(g,v)),o=this.recurrentActivation.apply(Re(y,w));let S=Kl(le(o,a),p);l=this.activation.apply(Re(b,S));let k=Re(le(i,a),le(Re(1,sa(i)),l));return[k,k]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:$h(this.activation),recurrentActivation:$h(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ka(this.kernelInitializer),recurrentInitializer:ka(this.recurrentInitializer),biasInitializer:ka(this.biasInitializer),kernelRegularizer:Zn(this.kernelRegularizer),recurrentRegularizer:Zn(this.recurrentRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),recurrentConstraint:gr(this.recurrentConstraint),biasConstraint:gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};SC.className="GRUCell";Pe.registerClass(SC);var R3=class extends pc{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new SC(e),super(e)}call(e,t){return fe(()=>{this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};R3.className="GRU";Pe.registerClass(R3);var F1=class extends O1{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,_r(this.units,"units"),this.activation=_h(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=_h(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=fa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ga(e.kernelRegularizer),this.recurrentRegularizer=ga(e.recurrentRegularizer),this.biasRegularizer=ga(e.biasRegularizer),this.kernelConstraint=yr(e.kernelConstraint),this.recurrentConstraint=yr(e.recurrentConstraint),this.biasConstraint=yr(e.biasConstraint),this.dropout=xy([1,Eh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xy([1,Eh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=bn(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let a;if(this.useBias){if(this.unitForgetBias){let r=this.biasInitializer,s=this.units;a=new(t=class extends Vo{apply(i,o){let l=r.apply([s]),u=new lC().apply([s]),c=r.apply([s*2]);return GG(GG(l,u),c)}},t.className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return fe(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ge(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Rh({ones:()=>_i(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Rh({ones:()=>_i(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,u,c;0<this.dropout&&this.dropout<1&&(e=le(e,s[0]));let h=Kl(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=le(a,i[0])),h=Re(h,Kl(a,this.recurrentKernel.read())),this.useBias&&(h=Al(h,this.bias.read()));let[p,m,g,y]=Ks(h,4,h.rank-1);o=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(m),u=Re(le(l,r),le(o,this.activation.apply(g))),c=this.recurrentActivation.apply(y);let b=le(c,this.activation.apply(u));return[b,b,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:$h(this.activation),recurrentActivation:$h(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ka(this.kernelInitializer),recurrentInitializer:ka(this.recurrentInitializer),biasInitializer:ka(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Zn(this.kernelRegularizer),recurrentRegularizer:Zn(this.recurrentRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),recurrentConstraint:gr(this.recurrentConstraint),biasConstraint:gr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};F1.className="LSTMCell";Pe.registerClass(F1);var D3=class extends pc{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new F1(e),super(e)}call(e,t){return fe(()=>{this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};D3.className="LSTM";Pe.registerClass(D3);var kC=class extends O1{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return fe(()=>{e=e;let n=e.slice(1),a=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?a.push(n.splice(0,i.stateSize.length)):a.push(n.splice(0,1));a.reverse();let r=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=a[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),r.push(s.slice(1))}n=[];for(let i of r.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){SD(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,a)=>{fp(`RNNCell_${a}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let a=[];for(let r of t.cells)a.push(ol(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return kD(e)}setWeights(e){let t=[];for(let n of this.cells){let a=n.weights.length,r=e.splice(a);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],r[s]])}a3(t)}};kC.className="StackedRNNCells";Pe.registerClass(kC);function Rh(e){let{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):yK(t(),n),o=()=>_1(i,t,a);return!r||r<=1?cr(o().clone()):Array(r).fill(void 0).map(o).map(l=>cr(l.clone()))}var $Se=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n},gX=class extends pc{constructor(e){if(e.unroll)throw new Xt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Xt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Qa({ndim:5})]}call(e,t){return fe(()=>{if(this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ge("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return fe(()=>{let{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)],s=Aa(r);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){fe(()=>{if(!this.stateful)throw new rh("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(n[0]==null)throw new ge("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Aa(r)):this.states_=[Aa(r)];else if(e==null)Ft(this.states_),this.keptStates!=null&&(Ft(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Aa(r)):this.states_[0]=Aa(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ge(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ft(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=r;if(!F.arraysEqual(i.shape,o))throw new ge(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>cr(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],u=e[o?4:3],c=ll(l,a[0],r,s[0],i[0]),h=ll(u,a[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}};gX.className="ConvRNN2D";var IC=class extends F1{constructor(e){let{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,_r(this.filters,"filters"),this.kernelSize=ty(n,2,"kernelSize"),this.kernelSize.forEach(o=>_r(o,"kernelSize")),this.strides=ty(a||1,2,"strides"),this.strides.forEach(o=>_r(o,"strides")),this.padding=r||"valid",co(this.padding),this.dataFormat=s||"channelsLast",Pa(this.dataFormat),this.dilationRate=ty(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>_r(o,"dilationRate"))}build(e){var t;e=bn(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new ge(`The channel dimension of the input should be defined. Found ${e[n]}`);let a=e[n],r=4,s=this.kernelSize.concat([a,this.filters*r]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(t=class extends Vo{apply(c,h){let p=l.apply([u]),m=js([u]),g=l.apply([u*2]);return XM([p,m,g])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return fe(()=>{if(e.length!==3)throw new ge(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,a=e[0],r=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Rh({ones:()=>_i(a),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(Z,te,V)=>!te||!te[V]?Z:le(te[V],Z),u=l(a,o,0),c=l(a,o,1),h=l(a,o,2),p=l(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Rh({ones:()=>_i(r),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let m=this.recurrentDropoutMask,g=l(r,m,0),y=l(r,m,1),b=l(r,m,2),v=l(r,m,3),w=3,[S,k,I,T]=Ks(this.kernel.read(),i,w),[E,R,D,O]=this.useBias?Ks(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,S,E,this.padding),c=this.inputConv(c,k,R,this.padding),h=this.inputConv(h,I,D,this.padding),p=this.inputConv(p,T,O,this.padding);let[$,_,P,U]=Ks(this.recurrentKernel.read(),i,w);g=this.recurrentConv(g,$),y=this.recurrentConv(y,_),b=this.recurrentConv(b,P),v=this.recurrentConv(v,U);let W=this.recurrentActivation.apply(Re(u,g)),B=this.recurrentActivation.apply(Re(c,y)),H=Re(le(B,s),le(W,this.activation.apply(Re(h,b)))),j=le(this.recurrentActivation.apply(Re(p,v)),this.activation.apply(H));return[j,j,H]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=$Se(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){let r=Ts(e,t,this.strides,a||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Al(r,n,this.dataFormat):r}recurrentConv(e,t){return Ts(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};IC.className="ConvLSTM2DCell";Pe.registerClass(IC);var O3=class extends gX{constructor(e){let t=new IC(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};O3.className="ConvLSTM2D";Pe.registerClass(O3);var NC=class extends Qt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(this.noiseShape[a]==null?t[a]:this.noiseShape[a]);return n}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e);if(0<this.rate&&this.rate<1){let a=t.training==null?!1:t.training,r=this.getNoiseShape(n);return _1(()=>yK(n,this.rate,r,this.seed),()=>n,a)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};NC.className="Dropout";Pe.registerClass(NC);var F3=class extends NC{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};F3.className="SpatialDropout1D";Pe.registerClass(F3);var M3=class extends Qt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,_r(this.units,"units"),this.activation=_h(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=fa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=fa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=yr(e.kernelConstraint),this.biasConstraint=yr(e.biasConstraint),this.kernelRegularizer=ga(e.kernelRegularizer),this.biasRegularizer=ga(e.biasRegularizer),this.activityRegularizer=ga(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=bn(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=bn(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e),a=cK(this.activation.getClassName()),r;return a!=null?r=Kl(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=Kl(n,this.kernel.read()),this.bias!=null&&(r=Al(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:$h(this.activation),useBias:this.useBias,kernelInitializer:ka(this.kernelInitializer),biasInitializer:ka(this.biasInitializer),kernelRegularizer:Zn(this.kernelRegularizer),biasRegularizer:Zn(this.biasRegularizer),activityRegularizer:Zn(this.activityRegularizer),kernelConstraint:gr(this.kernelConstraint),biasConstraint:gr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};M3.className="Dense";Pe.registerClass(M3);var L3=class extends Qt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=bn(e);for(let t of e.slice(1))if(t==null)throw new ge(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],yh(e,1)]}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let a=[0];for(let r=2;r<n.rank;++r)a.push(r);a.push(1),n=Ut(n,a)}return U1e(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};L3.className="Flatten";Pe.registerClass(L3);var z3=class extends Qt{constructor(e){super(e),this.supportsMasking=!0,this.activation=_h(e.activation)}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e);return this.activation.apply(n)})}getConfig(){let e={activation:$h(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};z3.className="Activation";Pe.registerClass(z3);var B3=class extends Qt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return fe(()=>(e=Et(e),P1e(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};B3.className="RepeatVector";Pe.registerClass(B3);var P3=class extends Qt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",a=t.slice(),r=1,s=null;for(let o=0;o<a.length;++o){let l=a[o];if(this.isUnknown(l))if(s===null)s=o;else throw new ge("Can only specifiy one unknown dimension.");else r*=l}let i=yh(e);if(s!==null){if(r===0||i%r!==0)throw new ge(n);a[s]=i/r}else if(i!==r)throw new ge(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return pe(n,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};P3.className="Reshape";Pe.registerClass(P3);var V3=class extends Qt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=dl(1,e.dims.length+1);if(!F.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Qa({ndim:this.dims.length+1})]}computeOutputShape(e){e=bn(e);let t=e.slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return Ut(Et(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};V3.className="Permute";Pe.registerClass(V3);var U3=class extends Qt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Et(e);return rw(Rp(n,this.maskValue),-1)}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e),a=rw(Rp(n,this.maskValue),-1,!0);return le(n,He(a,n.dtype))})}};U3.className="Masking";Pe.registerClass(U3);var W3=class extends Qt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(En(e.inputLength))}this.inputDim=e.inputDim,_r(this.inputDim,"inputDim"),this.outputDim=e.outputDim,_r(this.outputDim,"outputDim"),this.embeddingsInitializer=fa(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ga(e.embeddingsRegularizer),this.activityRegularizer=ga(e.activityRegularizer),this.embeddingsConstraint=yr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return fe(()=>this.maskZero?(e=Et(e),Rp(e,un(e))):null)}computeOutputShape(e){if(e=bn(e),this.inputLength==null)return[...e,this.outputDim];let t=En(this.inputLength);if(t.length!==e.length-1)throw new ge(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let a=0;a<t.length;++a){let r=t[a],s=e[a+1];if(r!=null&&s!=null&&r!==s)throw new ge(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e);n.dtype!=="int32"&&(n=ec(n,"int32"));let a=gK(this.embeddings.read(),pe(n,[n.size]));return pe(a,bn(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ka(this.embeddingsInitializer),embeddingsRegularizer:Zn(this.embeddingsRegularizer),activityRegularizer:Zn(this.activityRegularizer),embeddingsConstraint:gr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};W3.className="Embedding";Pe.registerClass(W3);var _m=class extends Qt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Xt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){let r=e[e.length-t.length+a],s=t[a];if(r==null||s==null||r<0||s<0)n.push(null);else if(r===1)n.push(s);else if(s===1)n.push(r);else{if(r!==s)throw new ge("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[bn(e)]),e=e,e.length<2)throw new ge(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=gh(t),t.length>1)throw new ge(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let a=e.map(r=>r.length);e.indexOf(null)===-1&&gh(a).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return fe(()=>{if(e=e,this.reshapeRequired){let n=[],a=e.map(r=>r.rank);if(a.indexOf(null)===-1){let r=Eh(a);for(let s of e){let i=s.rank;for(let o=0;o<r-i;++o)s=E1(s,1);n.push(s)}return this.mergeFunction(n)}else{let r=!1;for(let o of e){let l=o.rank;if(l==null){let u=o.shape,c=u[0],h=u.slice(1).concat([c]),p=pe(o,[c].concat(yh(u.slice(1))));p=Ut(p,[1,0]),p=pe(p,h),n.push(p),r=!0}else if(l>1){let u=dl(1,l).concat([0]);n.push(Ut(o,u)),r=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(r){if(i==null){let o=s.shape,l=o.length,u=o[l-1],c=[u].concat(o.slice(0,o.length-1));s=pe(Ut(pe(s,[-1,u]),[1,0]),c)}else if(i>1){let o=[i-1].concat(dl(0,i-1));s=Ut(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let a=1;a<e.length;++a){let r=e[a]==null?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let a of e)a!=null&&a[0]!==null&&n.push(a[0]);return n=gh(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return fe(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ge("`mask` should be an Array");if(!Array.isArray(e))throw new ge("`inputs` should be an Array");if(t.length!==e.length)throw new ge(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(a=>a==null))return null;t=t.map(a=>a==null?a:Tr(a,0));let n=t[0];for(let a=1;a<t.length-1;++a)n=zo(n,t[a]);return n})}},G3=class extends _m{constructor(e){super(e)}mergeFunction(e){return fe(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Re(t,e[n]);return t})}};G3.className="Add";Pe.registerClass(G3);var H3=class extends _m{constructor(e){super(e)}mergeFunction(e){return fe(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=le(t,e[n]);return t})}};H3.className="Multiply";Pe.registerClass(H3);var j3=class extends _m{constructor(e){super(e)}mergeFunction(e){return fe(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Re(t,e[n]);return le(1/e.length,t)})}};j3.className="Average";Pe.registerClass(j3);var q3=class extends _m{constructor(e){super(e)}mergeFunction(e){return fe(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=du(t,e[n]);return t})}};q3.className="Maximum";Pe.registerClass(q3);var K3=class extends _m{constructor(e){super(e)}mergeFunction(e){return fe(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ch(t,e[n]);return t})}};K3.className="Minimum";Pe.registerClass(K3);var X3=class extends _m{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ge("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let a of e)if(a!=null){t=!1;break}if(t)return;let n=[];for(let a=0;a<e.length;++a){let r=e[a].slice();r.splice(this.axis,1);let s=!1;for(let i of n)if(F.arraysEqual(i,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new ge("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return fe(()=>XM(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ge("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(let r of t.slice(1)){if(n[a]==null||r[a]==null){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ge("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ge("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ge(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return fe(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let a=[];for(let s=0;s<e.length;++s)t[s]==null?a.push(He(_i(e[s]),"bool")):t[s].rank<e[s].rank?a.push(Tr(t[s],-1)):a.push(t[s]);let r=Un(a,this.axis);return T2(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};X3.className="Concatenate";Pe.registerClass(X3);function Av(e,t){for(;e<0;)e+=t;return e}function _Se(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Xt("batchDot is not implemented for tensors of 4D or higher rank yet");if(F.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),F.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Xt("batchDot is not implemented for complex64-type Tensors yet.");let a=e.shape.length,r=t.shape.length;n==null&&(n=[a-1,r-2]);let s=n;return fe(()=>{let i;if(a>r){i=a-r;let l=[];for(let u=0;u<i;++u)l.push(1);t=pe(t,t.shape.concat(l))}else if(r>a){i=r-a;let l=[];for(let u=0;u<i;++u)l.push(1);e=pe(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=ut(le(e,t),s[0]):o=ut(le(Ut(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,u=s[1]===t.shape.length-1;o=Vt(e,t,l,u)}if(i>0){let l;a>r?l=a+r-3:l=a-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);o=ad(o,u)}return o.shape.length===1&&(o=Tr(o,1)),o})}var Y3=class extends _m{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){F.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new ge(`Dimension incompatibility: ${t[a[0]]} !== ${n[a[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ge(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],a;return Array.isArray(this.axes)?a=this.axes.map((r,s)=>Av(r,e[s].shape.length)):a=[Av(this.axes,t.shape.length),Av(this.axes,n.shape.length)],this.normalize&&(t=sN(t,a[0]),n=sN(n,a[1])),_Se(t,n,a)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Av(this.axes,e.length),Av(this.axes,t.length)],n}computeOutputShape(e){F.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);let r=t.concat(n);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};Y3.className="Dot";Pe.registerClass(Y3);var Q3=class extends Qt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return fe(()=>{this.invokeCallHook(t,n);let a=Et(t);return _1(()=>Re(oC(a.shape,0,this.stddev),a),()=>a,n.training||!1)})}};Q3.className="GaussianNoise";Pe.registerClass(Q3);var Z3=class extends Qt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return fe(()=>{this.invokeCallHook(e,t);let n=Et(e);return this.rate>0&&this.rate<1?_1(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return le(n,oC(n.shape,1,a))},()=>n,t.training||!1):n})}};Z3.className="GaussianDropout";Pe.registerClass(Z3);var J3=class extends Qt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Et(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return fe(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return _1(()=>{let a=Et(e),r=-1.6732632423543772*1.0507009873554805,s=cc(td(n),this.rate);s=ec(s,"float32");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate,l=Re(le(a,s),le(Re(s,-1),r));return Re(le(l,i),o)},()=>Et(e),t.training||!1)}return e})}};J3.className="AlphaDropout";Pe.registerClass(J3);function cw(e,t,n,a,r,s=.001){let i;if(e.rank===2)i=VF(e,t,n,a,r,s);else if(e.rank===3)i=UF(e,t,n,a,r,s);else if(e.rank===4)i=WF(e,t,n,a,r,s);else throw new Xt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function RSe(e,t,n,a,r=.001){return fe(()=>{let s=w1(e,a),i=s.mean,o=s.variance;return[cw(e,i,o,n,t,r),i,o]})}function DSe(e,t,n,a,r=.001){return fe(()=>{let s=w1(e,a),i=s.mean,o=s.variance,l=[];for(let m of dl(0,e.rank))a.indexOf(m)!==-1?l.push(1):l.push(e.shape[m]);let u=pe(i,l),c=pe(o,l),h=t==null?null:pe(t,l),p=n==null?null:pe(n,l);return[cw(e,u,c,p,h,r),i,o]})}function OSe(e,t,n,a,r=.001){return F.arraysEqual(a.slice().sort(),dl(0,e.rank-1))?RSe(e,t,n,a,r):DSe(e,t,n,a,r)}var eL=class extends Qt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=fa(e.betaInitializer||"zeros"),this.gammaInitializer=fa(e.gammaInitializer||"ones"),this.movingMeanInitializer=fa(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=fa(e.movingVarianceInitializer||"ones"),this.betaConstraint=yr(e.betaConstraint),this.gammaConstraint=yr(e.gammaConstraint),this.betaRegularizer=ga(e.betaRegularizer),this.gammaRegularizer=ga(e.gammaRegularizer)}build(e){e=bn(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new ge(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Qa({ndim:e.length,axes:{[t]:n}})];let a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return fe(()=>{let n=t.training==null?!1:t.training,a=Et(e),r=a.shape,s=r.length,i=dl(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=Op(1,s);l[o]=r[o];let u=i.slice();u.sort();let c=!F.arraysEqual(u,dl(0,s).slice(0,s-1)),h=()=>{if(c){let b=pe(this.movingMean.read(),l),v=pe(this.movingVariance.read(),l),w=this.center?pe(this.beta.read(),l):null,S=this.scale?pe(this.gamma.read(),l):null;return cw(a,b,v,w,S,this.epsilon)}else return cw(a,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return h();let[p,m,g]=OSe(a,this.gamma.read(),this.beta.read(),i,this.epsilon),y=(b,v,w)=>{fe(()=>{let S=1-w,k=b.read(),I=le(nt(k,v),S);b.write(nt(k,I))})};return y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum),p})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ka(this.betaInitializer),gammaInitializer:ka(this.gammaInitializer),movingMeanInitializer:ka(this.movingMeanInitializer),movingVarianceInitializer:ka(this.movingVarianceInitializer),betaRegularizer:Zn(this.betaRegularizer),gammaRegularizer:Zn(this.gammaRegularizer),betaConstraint:gr(this.betaConstraint),gammaConstraint:gr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};eL.className="BatchNormalization";Pe.registerClass(eL);var tL=class extends Qt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=fa(e.betaInitializer||"zeros"),this.gammaInitializer=fa(e.gammaInitializer||"ones"),this.betaRegularizer=ga(e.betaRegularizer),this.gammaRegularizer=ga(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=bn(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==gh(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(r=>e[r]),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){let n=Et(e),a=n.shape,r=a.length;return fe(()=>{let{mean:s,variance:i}=w1(n,this.axis,!0),o=Op(1,r);for(let m of this.axis)o[m]=a[m];let l=m=>m!=null&&m.shape.length!==r?pe(m,o):m,u=this.scale?l(this.gamma.read()):null,c=this.center?l(this.beta.read()):null,h=[],p=[];for(let m=0;m<r;++m)this.axis.indexOf(m)!==-1?(h.push(a[m]),p.push(1)):(h.push(1),p.push(a[m]));return s=Ii(s,h),i=Ii(i,h),u!=null&&(u=Ii(u,p)),c!=null&&(c=Ii(c,p)),cw(n,s,i,c,u,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ka(this.betaInitializer),gammaInitializer:ka(this.gammaInitializer),betaRegularizer:Zn(this.betaRegularizer),gammaRegularizer:Zn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};tL.className="LayerNormalization";Pe.registerClass(tL);function FSe(e,t,n){return fe(()=>{if(e.rank!==4)throw new ge(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ge("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=pl()),n!=="channelsLast"&&n!=="channelsFirst")throw new ge(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return n==="channelsFirst"?a=[[0,0],[0,0],t[0],t[1]]:a=[[0,0],t[0],t[1],[0,0]],wl(e,a)})}var nL=class extends Qt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?pl():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ge(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ge(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ge(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(e){e=bn(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return fe(()=>FSe(Et(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};nL.className="ZeroPadding2D";Pe.registerClass(nL);function CC(e,t,n,a,r,s){return fe(()=>{Pa(r),dK(s),co(a),n==null&&(n=[1,1]),a==null&&(a="valid"),r==null&&(r=pl()),s==null&&(s="max"),e=S3(e,r);let i,o=a==="same"?"same":"valid";return s==="max"?i=kr(e,t,n,o):i=uc(e,t,n,o),r==="channelsFirst"&&(i=Ut(i,[0,3,1,2])),i})}function yX(e,t,n,a,r,s){return fe(()=>{Pa(r),dK(s),co(a),n==null&&(n=[1,1,1]),a==null&&(a="valid"),r==null&&(r=pl()),s==null&&(s="max"),e=sX(e,r);let i,o=a==="same"?"same":"valid";return s==="max"?i=pM(e,t,n,o):i=PF(e,t,n,o),r==="channelsFirst"&&(i=Ut(i,[0,4,1,2,3])),i})}var bX=class extends Qt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ge(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(_r(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ge(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);_r(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,co(this.padding),this.inputSpec=[new Qa({ndim:3})]}computeOutputShape(e){e=bn(e);let t=ll(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return fe(()=>{this.invokeCallHook(e,t),e=E1(Et(e),2);let n=this.poolingFunction(Et(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ad(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},aL=class extends bX{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Pa(r),co(a),CC(e,t,n,a,r,"max")}};aL.className="MaxPooling1D";Pe.registerClass(aL);var rL=class extends bX{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Pa(r),co(a),CC(e,t,n,a,r,"avg")}};rL.className="AveragePooling1D";Pe.registerClass(rL);var xX=class extends Qt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ge(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pa(this.dataFormat),co(this.padding),this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(e){e=bn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=ll(t,this.poolSize[0],this.padding,this.strides[0]),n=ll(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return fe(()=>(this.invokeCallHook(e,t),this.poolingFunction(Et(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},sL=class extends xX{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Pa(r),co(a),CC(e,t,n,a,r,"max")}};sL.className="MaxPooling2D";Pe.registerClass(sL);var iL=class extends xX{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Pa(r),co(a),CC(e,t,n,a,r,"avg")}};iL.className="AveragePooling2D";Pe.registerClass(iL);var vX=class extends Qt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ge(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pa(this.dataFormat),co(this.padding),this.inputSpec=[new Qa({ndim:5})]}computeOutputShape(e){e=bn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=ll(t,this.poolSize[0],this.padding,this.strides[0]),n=ll(n,this.poolSize[1],this.padding,this.strides[1]),a=ll(a,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return fe(()=>(this.invokeCallHook(e,t),this.poolingFunction(Et(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},oL=class extends vX{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Pa(r),co(a),yX(e,t,n,a,r,"max")}};oL.className="MaxPooling3D";Pe.registerClass(oL);var lL=class extends vX{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Pa(r),co(a),yX(e,t,n,a,r,"avg")}};lL.className="AveragePooling3D";Pe.registerClass(lL);var wX=class extends Qt{constructor(e){super(e),this.inputSpec=[new Qa({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Xt}},uL=class extends wX{constructor(e){super(e||{})}call(e,t){return fe(()=>{let n=Et(e);return wa(n,1)})}};uL.className="GlobalAveragePooling1D";Pe.registerClass(uL);var cL=class extends wX{constructor(e){super(e||{})}call(e,t){return fe(()=>{let n=Et(e);return to(n,1)})}};cL.className="GlobalMaxPooling1D";Pe.registerClass(cL);var AX=class extends Qt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Pa(this.dataFormat),this.inputSpec=[new Qa({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Xt}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},hL=class extends AX{call(e,t){return fe(()=>{let n=Et(e);return this.dataFormat==="channelsLast"?wa(n,[1,2]):wa(n,[2,3])})}};hL.className="GlobalAveragePooling2D";Pe.registerClass(hL);var dL=class extends AX{call(e,t){return fe(()=>{let n=Et(e);return this.dataFormat==="channelsLast"?to(n,[1,2]):to(n,[2,3])})}};dL.className="GlobalMaxPooling2D";Pe.registerClass(dL);var SX=class extends Qt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let a=t.layer,r=ol(a,n);delete t.layer;let s={layer:r};return Object.assign(s,t),new e(s)}},pL=class extends SX{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=bn(e),e.length<3)throw new ge(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=bn(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return fe(()=>(e=Et(e),fX((n,a)=>[Et(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};pL.className="TimeDistributed";Pe.registerClass(pL);function MSe(e){Em(F1e,"BidirectionalMergeMode",e)}var LSe="concat",fL=class extends SX{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=ol(n),t.goBackwards=t.goBackwards!==!0;let a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=ol(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?LSe:e.mergeMode,MSe(this.mergeMode),e.weights)throw new Xt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,a,r;return this.returnState&&(r=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,a=[n]):this.mergeMode==null?a=[n,n.slice()]:a=[n],this.returnState?this.mergeMode==null?a.concat(r).concat(r.slice()):[n].concat(r).concat(r.slice()):Gs(a)}apply(e,t){let n=t==null?null:t.initialState,a=t==null?null:t.constants;t==null&&(t={});let r=pX(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&a==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new ge("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let u=n.map(c=>new Qa({shape:c.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),i.push(...u)}if(a!=null)throw new Xt("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof fl;for(let l of s)if(l instanceof fl!==o)throw new ge("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(s),u=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=u;let h=super.apply(l,t);return this.inputSpec=c,h}else return super.apply(e,t)}call(e,t){return fe(()=>{let n=t.initialState,a,r;if(n==null)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=io(r,1));let i;return this.mergeMode==="concat"?i=XM([a,r]):this.mergeMode==="sum"?i=Re(a,r):this.mergeMode==="ave"?i=le(.5,Re(a,r)):this.mergeMode==="mul"?i=le(a,r):this.mergeMode==null&&(i=[a,r]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){fp(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),fp(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let a=this.forwardLayer.states.map(r=>null);return Array.isArray(n)?n.concat(a).concat(a):[n].concat(a).concat(a)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=ol(t.layer);if(delete t.layer,t.numConstants!=null)throw new Xt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let a=t;return a.layer=n,new e(a)}};fL.className="Bidirectional";Pe.registerClass(fL);var mL=class extends Qt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return fe(()=>(e=Et(e),e.dtype!=="float32"&&(e=ec(e,"float32")),Re(le(e,this.scale),this.offset)))}};mL.className="Rescaling";Pe.registerClass(mL);var{resizeBilinear:zSe,cropAndResize:BSe}=Xi,gL=class extends Qt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,n,a,r,s,i,o,l){return fe(()=>{let u,c=!1,h=n/i,p=a/o,m=(r+n)/i,g=(s+a)/o,y=[h,p,m,g],b=[];t.rank===3?(c=!0,u=Ja([t])):u=t;for(let k=0;k<u.shape[0];k++)b.push(y);let v=Cs(b,[b.length,4]),w=Dp(0,b.length,1,"int32"),S=BSe(u,v,w,[r,s],"nearest");return ec(c?Et(Ra(S)):S,l)})}upsize(t,n,a,r){return fe(()=>{let s=zSe(t,[n,a]);return ec(s,r)})}call(t,n){return fe(()=>{let a=Et(t),r=a.dtype,s=a.shape,i=s[s.length-3],o=s[s.length-2],l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(a,l,u,this.height,this.width,i,o,r):this.upsize(t,this.height,this.width,r)})}getConfig(){let t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=bn(t);let n=t.length-3,a=t.length-2;return t[n]=this.height,t[a]=this.width,t}};gL.className="CenterCrop";Pe.registerClass(gL);function PSe(e,t,n,a){let r=Et(e);if(r.dtype!=="int32"&&(r=ec(r,"int32")),t==="int")return r;let s=r.shape;if(r.rank===0&&(r=Tr(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Tr(r,-1)),r.rank>2)throw new ge(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);let i=["multiHot","oneHot"].includes(t),o=r,l;if(typeof a<"u"&&t==="count"?l=JI(o,a,n,i):l=JI(o,[],n,i),t!=="tfIdf")return l;if(a)return le(l,a);throw new ge("When outputMode is 'tfIdf', weights must be provided.")}var yL=class extends Qt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=bn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return fe(()=>{e=Et(e),e.dtype!=="int32"&&(e=ec(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ge(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Et(t.countWeights)}let a=to(e),r=dy(e),s=Fs(this.numTokens,a).bufferSync().get(0),i=cc(r,0).bufferSync().get(0);if(!(s&&i))throw new ge(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return PSe(e,this.outputMode,this.numTokens,n)})}};yL.className="CategoryEncoding";Pe.registerClass(yL);var VSe=["bilinear","nearest"],oH=new Set(VSe),bL=class extends Qt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(oH.has(e.interpolation))this.interpolation=e.interpolation;else throw new ge(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=bn(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return fe(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Xi.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Xi.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...oH]} are supported`)})}};bL.className="Resizing";Pe.registerClass(bL);var kX=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};kX.className="RandomSeed";var IX=class extends Qt{constructor(e){super(e),this.randomGenerator=new kX(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};IX.className="BaseRandomLayer";var USe=["bilinear","nearest"],lH=new Set(USe),xL=class extends IX{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ge(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ge(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ge(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(lH.has(n))this.interpolation=n;else throw new ge(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=bn(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return fe(()=>{let n=Et(e);this.imgHeight=n.shape[n.shape.length-3];let a=n.shape[n.shape.length-2];this.widthFactor=td([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*a;r=Math.round(r);let s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Xi.resizeBilinear(e,s);case"nearest":return Xi.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...lH]} are supported`)}})}};xL.className="RandomWidth";Pe.registerClass(xL);function WSe(e){return new Jb(e)}function GSe(e){return new v3(e)}function HSe(e){return new y3(e)}function jSe(e){return new b3(e)}function qSe(e){return new x3(e)}function KSe(e){return new A3(e)}function XSe(e){return new w3(e)}function YSe(e){return new C3(e)}function QSe(e){return new vC(e)}function ZSe(e){return new k3(e)}function JSe(e){return new wC(e)}function eke(e){return new I3(e)}function tke(e){return new N3(e)}function nke(e){return new T3(e)}function ake(e){return new E3(e)}function rke(e){return new $3(e)}function ske(e){return new z3(e)}function ike(e){return new M3(e)}function oke(e){return new NC(e)}function lke(e){return new F3(e)}function uke(e){return new L3(e)}function cke(e){return new B3(e)}function hke(e){return new P3(e)}function dke(e){return new V3(e)}function pke(e){return new W3(e)}function fke(e){return new G3(e)}function mke(e){return new j3(e)}function gke(e){return new X3(e)}function yke(e){return new q3(e)}function bke(e){return new K3(e)}function xke(e){return new H3(e)}function vke(e){return new Y3(e)}function wke(e){return new eL(e)}function Ake(e){return new tL(e)}function Ske(e){return new nL(e)}function vL(e){return new rL(e)}function kke(e){return vL(e)}function Ike(e){return vL(e)}function wL(e){return new iL(e)}function Nke(e){return wL(e)}function Cke(e){return wL(e)}function AL(e){return new lL(e)}function Tke(e){return AL(e)}function Eke(e){return AL(e)}function $ke(e){return new uL(e)}function _ke(e){return new hL(e)}function NX(e){return new cL(e)}function CX(e){return new dL(e)}function TX(e){return new aL(e)}function EX(e){return new sL(e)}function Rke(e){return new oL(e)}function Dke(e){return new R3(e)}function Oke(e){return new SC(e)}function Fke(e){return new D3(e)}function Mke(e){return new F1(e)}function Lke(e){return new _3(e)}function zke(e){return new AC(e)}function Bke(e){return new O3(e)}function Pke(e){return new IC(e)}function Vke(e){return new pc(e)}function Uke(e){return new kC(e)}function Wke(e){return new fL(e)}function Gke(e){return new pL(e)}var Hke=NX,jke=CX,qke=TX,Kke=EX;function Xke(e){return new Q3(e)}function Yke(e){return new Z3(e)}function Qke(e){return new J3(e)}function Zke(e){return new U3(e)}function Jke(e){return new mL(e)}function eIe(e){return new gL(e)}function tIe(e){return new bL(e)}function nIe(e){return new yL(e)}function aIe(e){return new xL(e)}var $X={};Lt($X,{MAPE:()=>fIe,MSE:()=>yIe,binaryAccuracy:()=>rIe,binaryCrossentropy:()=>sIe,categoricalAccuracy:()=>oIe,categoricalCrossentropy:()=>lIe,cosineProximity:()=>hIe,mape:()=>mIe,meanAbsoluteError:()=>dIe,meanAbsolutePercentageError:()=>pIe,meanSquaredError:()=>gIe,mse:()=>bIe,precision:()=>uIe,r2Score:()=>xIe,recall:()=>cIe,sparseCategoricalAccuracy:()=>iIe});function rIe(e,t){return h3(e,t)}function sIe(e,t){return DK(e,t)}function iIe(e,t){return OK(e,t)}function oIe(e,t){return d3(e,t)}function lIe(e,t){return p3(e,t)}function uIe(e,t){return RK(e,t)}function cIe(e,t){return VAe(e,t)}function hIe(e,t){return c3(e,t)}function dIe(e,t){return gC(e,t)}function pIe(e,t){return ex(e,t)}function fIe(e,t){return ex(e,t)}function mIe(e,t){return ex(e,t)}function gIe(e,t){return $m(e,t)}function yIe(e,t){return $m(e,t)}function bIe(e,t){return $m(e,t)}function xIe(e,t){return UAe(e,t)}var _X={};Lt(_X,{modelFromJSON:()=>bSe});var RX={};Lt(RX,{l1:()=>wIe,l1l2:()=>vIe,l2:()=>AIe});function vIe(e){return new D1(e)}function wIe(e){return ISe(e)}function AIe(e){return NSe(e)}var DX=class extends vy{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Xu))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Kk(e,t){return e<t}function uH(e,t){return e>t}var OX=class extends DX{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Xt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Kk:this.mode==="max"?this.monitorFunc=uH:this.monitor.indexOf("acc")!==-1?this.monitorFunc=uH:this.monitorFunc=Kk,this.monitorFunc===Kk&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Kk?1/0:-1/0}async onEpochEnd(e,t){await nh(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function SIe(e){return new OX(e)}var kIe={earlyStopping:SIe},IIe=xe();IIe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var bi;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(bi||(bi={}));var cH;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(cH||(cH={}));var SL={};function NIe(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};SL[e]=n}function FX(e){return SL[e]}function CIe(e){delete SL[e]}function M(e,t,n,a,r){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return Gr(t.inputNames[u],n,a,r);if(s.type==="tensors"){let p=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((m,g)=>{var y;return((y=p[g])===null||y===void 0?void 0:y.op)!=="NoOp"}).map(m=>Gr(m,n,a,r))}let c=Gr(t.inputNames[u],n,a,r),h=c.dataSync();return s.type==="number"?h[0]:F.toNestedArray(c.shape,h)}let i=t.attrParams[e];return i&&i.value}function Gr(e,t,n,a){let[r,s]=wi(e,n);if(a!=null){let o=a.getHashTableHandleByName(r);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[cN(r,o)]);return i!==void 0?t[cN(r,i)][s]:void 0}function hH(e,t,n){return t[cN(e,n.currentContextId)]}function Bu(e,t){let[n,a,r]=wi(e,t);return[cN(n,t&&t.currentContextId),a,r]}function cN(e,t){return t?`${e}-${t}`:e}function wi(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let a=e.split(":"),r;if(a.length===1)r=[e,0,void 0];else{let s=a[0],i=a.length===3?a[1]:void 0,o=Number(a[a.length-1]);r=[s,o,i]}return n&&t.parseNodeNameCache.set(e,r),r}function TI(e,t,n){let a=M("pad",e,t,n);if(a==="explicit"){a=M("explicitPaddings",e,t,n);let r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=a[s*2],r[s][1]=a[s*2+1];return r}return a}function Pu(e){return e.kept?e:jl(e)}var MX={};Lt(MX,{json:()=>TIe});var TIe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LX={};Lt(LX,{json:()=>EIe});var EIe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zX={};Lt(zX,{json:()=>$Ie});var $Ie=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],BX={};Lt(BX,{json:()=>_Ie});var _Ie=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],PX={};Lt(PX,{json:()=>RIe});var RIe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],VX={};Lt(VX,{json:()=>DIe});var DIe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UX={};Lt(UX,{json:()=>OIe});var OIe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],WX={};Lt(WX,{json:()=>FIe});var FIe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],GX={};Lt(GX,{json:()=>MIe});var MIe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],HX={};Lt(HX,{json:()=>LIe});var LIe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],jX={};Lt(jX,{json:()=>zIe});var zIe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],qX={};Lt(qX,{json:()=>BIe});var BIe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],KX={};Lt(KX,{json:()=>PIe});var PIe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],XX={};Lt(XX,{json:()=>VIe});var VIe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],YX={};Lt(YX,{json:()=>UIe});var UIe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],QX={};Lt(QX,{json:()=>WIe});var WIe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],ZX={};Lt(ZX,{json:()=>GIe});var GIe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],JX={};Lt(JX,{json:()=>HIe});var HIe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],e7={};Lt(e7,{json:()=>jIe});var jIe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],dH=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[MX,LX,zX,BX,PX,VX,UX,WX,GX,HX,jX,qX,KX,XX,YX,QX,ZX,JX,e7],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,a)=>(n[a.tfOpName]=a,n),{})}transformGraph(e,t={}){let n=e.node,a=[],r=[],s=[],i=n.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?a.push(g[y.name]):y.op==="Const"?r.push(g[y.name]):(y.input==null||y.input.length===0)&&s.push(g[y.name]),g),{}),o=[],l=[],u={},c={};t!=null&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let h=Object.keys(i);h.forEach(g=>{let y=i[g];y.inputNames.forEach((b,v)=>{let[w,,S]=Bu(b),k=i[w];if(k.outputs!=null){let I=k.outputs.indexOf(S);if(I!==-1){let T=`${w}:${I}`;y.inputNames[v]=T}}y.inputs.push(k),k.children.push(y)})}),Object.keys(c).length===0?h.forEach(g=>{let y=i[g];y.children.length===0&&l.push(y)}):Object.keys(c).forEach(g=>{let[y]=Bu(g),b=i[y];b!=null&&(b.signatureKey=c[g],l.push(b))}),Object.keys(u).length>0?Object.keys(u).forEach(g=>{let[y]=Bu(g),b=i[y];b&&(b.signatureKey=u[g],o.push(b))}):o=a;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));let m={nodes:i,inputs:o,outputs:l,weights:r,placeholders:a,signature:t,functions:p};return s.length>0&&(m.initNodes=s),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=FX(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(a=>a.startsWith("^")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((a,r)=>(a[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},a),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((a,r)=>{let s=r.type,i;switch(r.type){case"string":i=$D(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=$D(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":i=LD(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=LD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":i=RD(e.attr,r.tfName,r.defaultValue||0),i===void 0&&r.tfDeprecatedName&&(i=RD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":i=MD(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=MD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":i=_D(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=_D(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":i=BD(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=BD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":i=FD(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=FD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":i=zD(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=zD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":i=DD(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=DD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":i=OD(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=OD(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":i=pH(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=pH(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return a[r.name]={value:i,type:s},a},{})),n}mapFunction(e){let t=e.nodeDef,n=[],a=[],r={};t!=null&&(r=t.reduce((u,c)=>(u[c.name]=this.mapNode(c),c.op==="Const"&&a.push(u[c.name]),u),{}));let s=[],i=[];e.signature.inputArg.forEach(u=>{let[c]=Bu(u.name),h={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:kL(u.type),type:"dtype"}},children:[]};h.signatureKey=u.name,s.push(h),r[c]=h}),Object.keys(r).forEach(u=>{let c=r[u];c.inputNames.forEach((h,p)=>{let[m,,g]=Bu(h),y=r[m];if(y.outputs!=null){let b=y.outputs.indexOf(g);if(b!==-1){let v=`${m}:${b}`;c.inputNames[p]=v}}c.inputs.push(y),y.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[c,h]=Bu(o[u.name]),p=r[c];p!=null&&(p.defaultOutput=h,i.push(p))});let l=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:i,weights:a,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function qIe(e){let t=xe().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function t7(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):qIe(e);return t?n:n.toLowerCase()}function $D(e,t,n,a=!1){let r=e[t];return r!=null?t7(r.s,a):n}function _D(e,t,n){let a=e[t];return a?a.b:n}function RD(e,t,n){let a=e[t]||{},r=a.i!=null?a.i:a.f!=null?a.f:n;return typeof r=="number"?r:parseInt(r,10)}function kL(e){switch(typeof e=="string"&&(e=bi[e]),e){case bi.DT_FLOAT:case bi.DT_HALF:return"float32";case bi.DT_INT32:case bi.DT_INT64:case bi.DT_INT8:case bi.DT_UINT8:return"int32";case bi.DT_BOOL:return"bool";case bi.DT_DOUBLE:return"float32";case bi.DT_STRING:return"string";case bi.DT_COMPLEX64:case bi.DT_COMPLEX128:return"complex64";default:return null}}function pH(e,t,n){let a=e[t];return a&&a.func?a.func.name:n}function DD(e,t,n){let a=e[t];return a&&a.type?kL(a.type):n}function OD(e,t,n){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(r=>kL(r)):n}function n7(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function FD(e,t,n){let a=e[t];return a&&a.shape?n7(a.shape):n}function MD(e,t,n){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function LD(e,t,n,a=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(s=>t7(s,a)):n}function zD(e,t,n){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(r=>n7(r)):n}function BD(e,t,n){let a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var KIe=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(a=>this.getInput(a)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((a,r)=>(a[r]=this.getAttr(r),a),{}))}getInput(e){return Gr(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return Gr(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return RD(this.node.rawAttrs,e,t);if(n.s!=null)return $D(this.node.rawAttrs,e,t);if(n.b!=null)return _D(this.node.rawAttrs,e,t);if(n.shape!=null)return FD(this.node.rawAttrs,e,t);if(n.type!=null)return DD(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return MD(this.node.rawAttrs,e,t);if(n.list.s!=null)return LD(this.node.rawAttrs,e,t);if(n.list.shape!=null)return zD(this.node.rawAttrs,e,t);if(n.list.b!=null)return BD(this.node.rawAttrs,e,t);if(n.list.type!=null)return OD(this.node.rawAttrs,e,t)}return t}},zr={};Lt(zr,{OP_SCOPE_SUFFIX:()=>NF,abs:()=>Ka,acos:()=>_F,acosh:()=>RF,add:()=>Re,addN:()=>gq,all:()=>T2,any:()=>rw,argMax:()=>Ep,argMin:()=>DF,asin:()=>OF,asinh:()=>FF,atan:()=>MF,atan2:()=>LF,atanh:()=>zF,avgPool:()=>uc,avgPool3d:()=>PF,basicLSTMCell:()=>vq,batchNorm:()=>Im,batchNorm2d:()=>VF,batchNorm3d:()=>UF,batchNorm4d:()=>WF,batchToSpaceND:()=>f1,bincount:()=>GF,bitwiseAnd:()=>wq,booleanMaskAsync:()=>c8,broadcastArgs:()=>Aq,broadcastTo:()=>pp,buffer:()=>Wt,cast:()=>He,ceil:()=>HF,clipByValue:()=>hs,clone:()=>jl,complex:()=>Ju,concat:()=>Un,concat1d:()=>jF,concat2d:()=>qF,concat3d:()=>KF,concat4d:()=>XF,conv1d:()=>E2,conv2d:()=>Ts,conv2dTranspose:()=>$2,conv3d:()=>QF,conv3dTranspose:()=>ZF,cos:()=>m1,cosh:()=>_2,cosineWindow:()=>eC,cumprod:()=>ow,cumsum:()=>R2,denseBincount:()=>JI,depthToSpace:()=>JF,depthwiseConv2d:()=>Nm,diag:()=>kq,dilation2d:()=>eM,div:()=>st,divNoNan:()=>tM,dot:()=>nM,dropout:()=>_M,einsum:()=>ep,elu:()=>jb,enclosingPowerOfTwo:()=>RM,ensureShape:()=>Nq,equal:()=>Ei,erf:()=>D2,euclideanNorm:()=>sM,exp:()=>ds,expandDims:()=>Tr,expm1:()=>iM,eye:()=>O2,fft:()=>I1,fill:()=>Ni,floor:()=>Kb,floorDiv:()=>C2,fused:()=>by,gather:()=>Xb,gatherND:()=>f8,greater:()=>Fs,greaterEqual:()=>cc,ifft:()=>yy,imag:()=>g1,image:()=>Xi,inTopKAsync:()=>m8,irfft:()=>q2,isFinite:()=>oM,isInf:()=>lM,isNaN:()=>uM,leakyRelu:()=>y1,less:()=>py,lessEqual:()=>ed,linalg:()=>FM,linspace:()=>_q,localResponseNormalization:()=>cM,log:()=>$i,log1p:()=>b1,logSigmoid:()=>hM,logSoftmax:()=>M2,logSumExp:()=>x1,logicalAnd:()=>zo,logicalNot:()=>v1,logicalOr:()=>L2,logicalXor:()=>dM,losses:()=>C8,lowerBound:()=>Dq,matMul:()=>Vt,max:()=>to,maxPool:()=>kr,maxPool3d:()=>pM,maxPoolWithArgmax:()=>Oq,maximum:()=>du,mean:()=>wa,meshgrid:()=>Fq,min:()=>dy,minimum:()=>Ch,mirrorPad:()=>fM,mod:()=>mM,moments:()=>w1,movingAverage:()=>h8,mul:()=>le,multiRNNCell:()=>Mq,multinomial:()=>Lq,neg:()=>sa,norm:()=>qb,notEqual:()=>Rp,oneHot:()=>fy,ones:()=>js,onesLike:()=>_i,op:()=>ie,outerProduct:()=>zq,pad:()=>wl,pad1d:()=>Bq,pad2d:()=>Pq,pad3d:()=>Vq,pad4d:()=>Uq,pool:()=>gM,pow:()=>tu,prelu:()=>S1,print:()=>$F,prod:()=>yM,raggedGather:()=>Wq,raggedRange:()=>Gq,raggedTensorToTensor:()=>Hq,rand:()=>jq,randomGamma:()=>Yq,randomNormal:()=>B2,randomStandardNormal:()=>Qq,randomUniform:()=>td,randomUniformInt:()=>Zq,range:()=>Dp,real:()=>my,reciprocal:()=>AM,relu:()=>_n,relu6:()=>P2,reshape:()=>pe,reverse:()=>io,reverse1d:()=>Jq,reverse2d:()=>e8,reverse3d:()=>t8,reverse4d:()=>n8,rfft:()=>N1,round:()=>V2,rsqrt:()=>U2,scalar:()=>xt,scatterND:()=>d8,searchSorted:()=>z2,selu:()=>W2,separableConv2d:()=>Yb,setdiff1dAsync:()=>a8,sigmoid:()=>Mo,sign:()=>SM,signal:()=>N8,sin:()=>G2,sinh:()=>H2,slice:()=>en,slice1d:()=>k1,slice2d:()=>j2,slice3d:()=>Qb,slice4d:()=>gy,softmax:()=>nd,softplus:()=>Cm,spaceToBatchND:()=>A1,sparse:()=>T8,sparseToDense:()=>p8,spectral:()=>I8,split:()=>Ks,sqrt:()=>Or,square:()=>Pn,squaredDifference:()=>K2,squeeze:()=>ad,stack:()=>Ja,step:()=>Tm,stridedSlice:()=>kM,string:()=>E8,sub:()=>nt,sum:()=>ut,tan:()=>IM,tanh:()=>Nh,tensor:()=>Cs,tensor1d:()=>Nn,tensor2d:()=>ql,tensor3d:()=>X2,tensor4d:()=>Th,tensor5d:()=>r8,tensor6d:()=>s8,tensorScatterUpdate:()=>o8,tile:()=>Ii,topk:()=>CM,transpose:()=>Ut,truncatedNormal:()=>Z2,unique:()=>TM,unsortedSegmentSum:()=>J2,unstack:()=>Ra,upperBound:()=>l8,variable:()=>EM,where:()=>Dr,whereAsync:()=>$M,zeros:()=>Aa,zerosLike:()=>un});var XIe=(e,t,n,a=zr)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(M("a",e,t,n),M("b",e,t,n))];case"AddN":return[a.addN(M("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(M("a",e,t,n),M("b",e,t,n))];case"Mul":return[a.mul(M("a",e,t,n),M("b",e,t,n))];case"RealDiv":case"Div":return[a.div(M("a",e,t,n),M("b",e,t,n))];case"DivNoNan":return[a.divNoNan(M("a",e,t,n),M("b",e,t,n))];case"FloorDiv":return[a.floorDiv(M("a",e,t,n),M("b",e,t,n))];case"Sub":return[a.sub(M("a",e,t,n),M("b",e,t,n))];case"Minimum":return[a.minimum(M("a",e,t,n),M("b",e,t,n))];case"Maximum":return[a.maximum(M("a",e,t,n),M("b",e,t,n))];case"Pow":return[a.pow(M("a",e,t,n),M("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(M("a",e,t,n),M("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},YIe=(e,t,n,a=zr)=>{switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(M("x",e,t,n))];case"Acos":return[a.acos(M("x",e,t,n))];case"Acosh":return[a.acosh(M("x",e,t,n))];case"Asin":return[a.asin(M("x",e,t,n))];case"Asinh":return[a.asinh(M("x",e,t,n))];case"Atan":return[a.atan(M("x",e,t,n))];case"Atan2":return[a.atan2(M("x",e,t,n),M("y",e,t,n))];case"Atanh":return[a.atanh(M("x",e,t,n))];case"Ceil":return[a.ceil(M("x",e,t,n))];case"Complex":return[a.complex(M("real",e,t,n),M("imag",e,t,n))];case"Cos":return[a.cos(M("x",e,t,n))];case"Cosh":return[a.cosh(M("x",e,t,n))];case"Elu":return[a.elu(M("x",e,t,n))];case"Erf":return[a.erf(M("x",e,t,n))];case"Exp":return[a.exp(M("x",e,t,n))];case"Expm1":return[a.expm1(M("x",e,t,n))];case"Floor":return[a.floor(M("x",e,t,n))];case"Log":return[a.log(M("x",e,t,n))];case"Log1p":return[a.log1p(M("x",e,t,n))];case"Imag":return[a.imag(M("x",e,t,n))];case"Neg":return[a.neg(M("x",e,t,n))];case"Reciprocal":return[a.reciprocal(M("x",e,t,n))];case"Real":return[a.real(M("x",e,t,n))];case"Relu":return[a.relu(M("x",e,t,n))];case"Round":return[a.round(M("x",e,t,n))];case"Selu":return[a.selu(M("x",e,t,n))];case"Sigmoid":return[a.sigmoid(M("x",e,t,n))];case"Sin":return[a.sin(M("x",e,t,n))];case"Sign":return[a.sign(M("x",e,t,n))];case"Sinh":return[a.sinh(M("x",e,t,n))];case"Softplus":return[a.softplus(M("x",e,t,n))];case"Sqrt":return[a.sqrt(M("x",e,t,n))];case"Square":return[a.square(M("x",e,t,n))];case"Tanh":return[a.tanh(M("x",e,t,n))];case"Tan":return[a.tan(M("x",e,t,n))];case"ClipByValue":return[a.clipByValue(M("x",e,t,n),M("clipValueMin",e,t,n),M("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(M("x",e,t,n))];case"Rsqrt":return[a.rsqrt(Gr(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(M("x",e,t,n),M("alpha",e,t,n))];case"Prelu":return[a.prelu(M("x",e,t,n),M("alpha",e,t,n))];case"IsNan":return[a.isNaN(Gr(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(Gr(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(Gr(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ro(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){F.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){let r=e[a],s=t[a];F.assert(r<0||s<0||r===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function fH(e){return!(typeof e=="number"||e.some(t=>t<0))}function Sv(e,t,n){let a=PD(e,n),r=!fH(a);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach(s=>{a=PD(s.shape,a)}),!fH(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function PD(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let a=0;a<e.length;++a){let r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}var QIe=class{constructor(e,t,n,a,r,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=xt(0),cr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ro(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,cr(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,a)=>this.write(n,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let a=0;a<this.size();a++)e.push(a)}if(e.length===0)return Cs([],[0].concat(this.elementShape));let n=this.readMany(e);return Ro(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ja(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Cs([],[0].concat(this.elementShape));let t=[];for(let a=0;a<this.size();a++)t.push(a);let n=this.readMany(t);return Ro(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Un(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Ra(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,a=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=n===0?0:t.size/n,s=[];fe(()=>{t=pe(t,[1,n,r]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:a[o-1],0],u=[1,e[o],r];s[o]=pe(en(t,l,u),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},TC=class VD{get id(){return this.idTensor.id}constructor(t,n,a,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=a,t?.forEach(s=>{if(a!==s.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${s.dtype}`);Ro(n,s.shape,"TensorList shape mismatch: "),cr(s)}),this.idTensor=xt(0),this.maxNumElements=r,cr(this.idTensor)}copy(){return new VD([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,a=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(a!==-1&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Ro(t,this.elementShape,"TensorList shape mismatch: ");let r=Sv(this.elementShape,this.tensors,t);return fe(()=>{let s=this.tensors.map(i=>pe(i,r));return Ja(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let a=Sv(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Ro(r.shape,t,"TensorList shape mismatch: "),pe(r,a)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Ro(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");cr(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new VD([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let a=0;a<Math.min(this.tensors.length,t);++a)n.tensors[a]=this.tensors[a];return n}getItem(t,n,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Ro(this.tensors[t].shape,n,"TensorList shape mismatch: ");let r=Sv(this.elementShape,this.tensors,n);return pe(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Ro(this.elementShape,n.shape,"TensorList shape mismatch: "),cr(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,a){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Ro(this.elementShape,a,"TensorList shape mismatch: "),t=t.slice(0,this.size());let r=Sv(this.elementShape,this.tensors,a);return t.length===0?Cs([],[0].concat(r)):fe(()=>{let s=t.map(i=>pe(this.tensors[i],r));return Ja(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Ro(this.elementShape,n,"TensorList shape mismatch: ");let a=Sv(this.elementShape,this.tensors,n);return this.size()===0?Cs([],[0].concat(a)):fe(()=>{let r=this.tensors.map(s=>pe(s,a));return Un(r,0)})}};function ZIe(e,t,n){let a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let r=e.shape.slice(1);Ro(r,t,"TensorList shape mismatch: ");let s=Ra(e);return new TC(s,t,a)}function JIe(e,t,n,a){return new TC([],e,t,a)}function eNe(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(a!=null&&a!==-1&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);let s=new TC([],n,e.dtype,a),i=Ra(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function tNe(e,t,n){let a=0,r=t.map(c=>(a+=c,a));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=PD(s,n),o=a===0?0:e.size/a,l=fe(()=>{let c=[];e=pe(e,[1,a,o]);for(let h=0;h<t.length;++h){let p=[0,h===0?0:r[h-1],0],m=[1,t[h],o];c[h]=pe(en(e,p,m),i)}return e.dispose(),c}),u=new TC([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var nNe=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let a=M("thenBranch",e,t,n),r=M("elseBranch",e,t,n),s=M("cond",e,t,n),i=M("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let a=M("body",e,t,n),r=M("cond",e,t,n),s=M("args",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(c=>c.id),l=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){let c=u;u=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let h=u.map(m=>m.id);c.forEach(m=>{!m.kept&&o.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()});let p=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(m=>{!m.kept&&o.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()})}return u}case"LoopCond":{let a=M("pred",e,t,n);return[Pu(a)]}case"Switch":{let a=M("pred",e,t,n),r=M("data",e,t,n);return r.kept||(r=Pu(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let a=e.inputNames.find(r=>Gr(r,t,n)!==void 0);if(a){let r=Gr(a,t,n);return[Pu(r)]}return}case"Enter":{let a=M("frameName",e,t,n),r=M("tensor",e,t,n);return n.enterFrame(a),[Pu(r)]}case"Exit":{let a=M("tensor",e,t,n);return n.exitFrame(),[Pu(a)]}case"NextIteration":{let a=M("tensor",e,t,n);return n.nextIteration(),[Pu(a)]}case"TensorArrayV3":{let a=M("size",e,t,n),r=M("dtype",e,t,n),s=M("elementShape",e,t,n),i=M("dynamicSize",e,t,n),o=M("clearAfterRead",e,t,n),l=M("identicalElementShapes",e,t,n),u=M("name",e,t,n),c=new QIe(u,r,a,s,l,i,o);return n.addTensorArray(c),[c.idTensor,xt(1)]}case"TensorArrayWriteV3":{let a=M("tensorArrayId",e,t,n),r=M("index",e,t,n),s=M("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case"TensorArrayReadV3":{let a=M("tensorArrayId",e,t,n),r=M("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{let a=M("tensorArrayId",e,t,n),r=M("indices",e,t,n),s=M("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{let a=M("tensorArrayId",e,t,n),r=M("indices",e,t,n),s=M("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case"TensorArrayConcatV3":{let a=M("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=M("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{let a=M("tensorArrayId",e,t,n),r=M("tensor",e,t,n),s=M("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case"TensorArraySizeV3":{let a=M("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return[xt(r.size(),"int32")]}case"TensorArrayCloseV3":{let a=M("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let a=M("tensorListId",e,t,n),r=M("index",e,t,n),s=M("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case"TensorListGetItem":{let a=M("tensorListId",e,t,n),r=M("index",e,t,n),s=M("elementShape",e,t,n),i=M("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let a=M("indices",e,t,n),r=M("tensor",e,t,n),s=M("elementShape",e,t,n),i=M("numElements",e,t,n),o=eNe(r,a,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let a=M("elementShape",e,t,n),r=M("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=M(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=JIe(a,r,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let a=M("tensorListId",e,t,n),r=M("indices",e,t,n),s=M("elementShape",e,t,n),i=M("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case"TensorListStack":{let a=M("tensorListId",e,t,n),r=M("elementShape",e,t,n),s=M("elementDType",e,t,n),i=M("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case"TensorListFromTensor":{let a=M("tensor",e,t,n),r=M("elementShape",e,t,n),s=M("elementDType",e,t,n),i=ZIe(a,r,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let a=M("tensorListId",e,t,n),r=n.getTensorList(a.id),s=M("dtype",e,t,n),i=M("elementShape",e,t,n);return[r.concat(s,i)]}case"TensorListPushBack":{let a=M("tensorListId",e,t,n),r=M("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{let a=M("tensorListId",e,t,n),r=M("elementShape",e,t,n),s=M("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{let a=M("tensor",e,t,n),r=M("elementShape",e,t,n),s=M("lengths",e,t,n),i=tNe(a,s,r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let a=M("tensorListId",e,t,n),r=n.getTensorList(a.id);return[xt(r.size(),"int32")]}case"TensorListResize":{let a=M("tensorListId",e,t,n),r=M("size",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function mH(e,t,n){let[a,r]=M("fusedOps",e,t,n),s=a==="biasadd",i=!s,o=r==="prelu",l=a==="fusedbatchnorm",u=M("numArgs",e,t,n);if(s){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=M("strides",e,t,n),h=TI(e,t,n),p=M("dataFormat",e,t,n).toUpperCase(),m=M("dilations",e,t,n),[g,y]=M("args",e,t,n);i&&(y=g,g=void 0);let b=M("leakyreluAlpha",e,t,n);return{stride:c,pad:h,dataFormat:p,dilations:m,biasArg:g,preluArg:y,activationFunc:r,leakyreluAlpha:b}}var aNe=(e,t,n,a=zr)=>{switch(e.op){case"Conv1D":{let r=M("stride",e,t,n),s=M("pad",e,t,n),i=M("dataFormat",e,t,n).toUpperCase(),o=M("dilation",e,t,n);return[a.conv1d(M("x",e,t,n),M("filter",e,t,n),r,s,i,o)]}case"Conv2D":{let r=M("strides",e,t,n),s=TI(e,t,n),i=M("dataFormat",e,t,n).toUpperCase(),o=M("dilations",e,t,n);return[a.conv2d(M("x",e,t,n),M("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=mH(e,t,n);return[a.fused.conv2d({x:M("x",e,t,n),filter:M("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=mH(e,t,n);return[a.fused.depthwiseConv2d({x:M("x",e,t,n),filter:M("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=M("outputShape",e,t,n),s=M("strides",e,t,n),i=TI(e,t,n);return[a.conv2dTranspose(M("x",e,t,n),M("filter",e,t,n),r,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=M("strides",e,t,n),s=TI(e,t,n),i=M("dilations",e,t,n),o=M("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(M("input",e,t,n),M("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let r=M("strides",e,t,n),s=M("pad",e,t,n),i=M("dataFormat",e,t,n).toUpperCase(),o=M("dilations",e,t,n);return[a.conv3d(M("x",e,t,n),M("filter",e,t,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let r=M("strides",e,t,n),s=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[a.avgPool(M("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=M("strides",e,t,n),s=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[a.maxPool(M("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=M("strides",e,t,n),s=M("pad",e,t,n),i=M("kernelSize",e,t,n),o=M("includeBatchInIndex",e,t,n),{result:l,indexes:u}=a.maxPoolWithArgmax(M("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s,o);return[l,u]}case"AvgPool3D":{let r=M("strides",e,t,n),s=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[a.avgPool3d(M("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=M("strides",e,t,n),s=M("pad",e,t,n),i=M("kernelSize",e,t,n);return[a.maxPool3d(M("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=M("strides",e,t,n),s=M("pad",e,t,n),i=M("dilations",e,t,n),o=r[1],l=r[2],u=i[1],c=i[2];return[a.dilation2d(M("x",e,t,n),M("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},rNe=(e,t,n,a=zr)=>{switch(e.op){case"Fill":{let r=M("shape",e,t,n),s=M("dtype",e,t,n),i=M("value",e,t,n);return[a.fill(r,i,s)]}case"LinSpace":{let r=M("start",e,t,n),s=M("stop",e,t,n),i=M("num",e,t,n);return[a.linspace(r,s,i)]}case"Multinomial":{let r=M("logits",e,t,n),s=M("numSamples",e,t,n),i=M("seed",e,t,n);return[a.multinomial(r,s,i)]}case"OneHot":{let r=M("indices",e,t,n),s=M("depth",e,t,n),i=M("onValue",e,t,n),o=M("offValue",e,t,n),l=M("dtype",e,t,n);return[a.oneHot(r,s,i,o,l)]}case"Ones":return[a.ones(M("shape",e,t,n),M("dtype",e,t,n))];case"OnesLike":return[a.onesLike(M("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(M("shape",e,t,n),M("dtype",e,t,n),M("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(M("shape",e,t,n),M("minval",e,t,n),M("maxval",e,t,n),M("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(M("shape",e,t,n),M("minval",e,t,n),M("maxval",e,t,n),M("seed",e,t,n))];case"Range":{let r=M("start",e,t,n),s=M("stop",e,t,n),i=M("step",e,t,n);return[a.range(r,s,i,M("dtype",e,t,n))]}case"TruncatedNormal":{let r=M("shape",e,t,n),s=M("mean",e,t,n),i=M("stdDev",e,t,n),o=M("seed",e,t,n);return[a.truncatedNormal(r,s,i,M("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(M("shape",e,t,n),M("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(M("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function vR(e,t,n){let a=M("boxes",e,t,n),r=M("scores",e,t,n),s=M("maxOutputSize",e,t,n),i=M("iouThreshold",e,t,n),o=M("scoreThreshold",e,t,n),l=M("softNmsSigma",e,t,n);return{boxes:a,scores:r,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var sNe=async(e,t,n,a,r=zr)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=vR(e,t,n),h=await r.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=vR(e,t,n),c=M("padToMaxOutputSize",e,t,n),h=await r.image.nonMaxSuppressionPaddedAsync(s,i,o,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=vR(e,t,n);return[await r.image.nonMaxSuppressionAsync(s,i,o,l,u)]}case"Where":{let s=r.cast(M("condition",e,t,n),"bool"),i=[await r.whereAsync(s)];return s.dispose(),i}case"ListDiff":return r.setdiff1dAsync(M("x",e,t,n),M("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},iNe=(e,t,n,a=zr)=>{switch(e.op){case"LowerBound":{let r=M("sortedSequence",e,t,n),s=M("values",e,t,n);return[a.lowerBound(r,s)]}case"TopKV2":{let r=M("x",e,t,n),s=M("k",e,t,n),i=M("sorted",e,t,n),o=a.topk(r,s,i);return[o.values,o.indices]}case"UpperBound":{let r=M("sortedSequence",e,t,n),s=M("values",e,t,n);return[a.upperBound(r,s)]}case"Unique":{let r=M("x",e,t,n),s=a.unique(r);return[s.values,s.indices]}case"UniqueV2":{let r=M("x",e,t,n),s=M("axis",e,t,n),i=a.unique(r,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},oNe=(e,t,n,a=zr)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=M("default",e,t,n);return[Gr(e.name,t,n)||r];case"Placeholder":return[Gr(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=M("x",e,t,n);return[Pu(c)]}case"IdentityN":return M("x",e,t,n).map(c=>Pu(c));case"Snapshot":let s=M("x",e,t,n);return[Pu(s)];case"Shape":return[a.tensor1d(M("x",e,t,n).shape,"int32")];case"ShapeN":return M("x",e,t,n).map(c=>a.tensor1d(c.shape));case"Size":return[a.scalar(M("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(M("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":let i=M("x",e,t,n),o=M("data",e,t,n),l=M("message",e,t,n),u=M("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},lNe=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=xt(0),this.tensorMap=new Map,cr(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return xt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),fe(()=>{let a=Ra(t),r=n.length,s=a.length;F.assert(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let i=0;i<r;i++){let o=n[i],l=a[i];cr(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return fe(()=>{let a=[];for(let r=0;r<n.length;r++){let s=n[r],i=this.findWithDefault(s,t);a.push(i)}return Ja(a)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},uNe=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{let r=a.getHashTableHandleByName(e.name);if(r!=null)return[r];{let s=M("keyDType",e,t,n),i=M("valueDType",e,t,n),o=new lNe(s,i);return a.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let r=M("tableHandle",e,t,n,a),s=M("keys",e,t,n),i=M("values",e,t,n);return[await a.getHashTableById(r.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let r=M("tableHandle",e,t,n,a),s=M("keys",e,t,n),i=M("defaultValue",e,t,n);return[await a.getHashTableById(r.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let r=M("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},cNe=(e,t,n,a=zr)=>{switch(e.op){case"ResizeBilinear":{let r=M("images",e,t,n),s=M("size",e,t,n),i=M("alignCorners",e,t,n),o=M("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let r=M("images",e,t,n),s=M("size",e,t,n),i=M("alignCorners",e,t,n),o=M("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case"CropAndResize":{let r=M("image",e,t,n),s=M("boxes",e,t,n),i=M("boxInd",e,t,n),o=M("cropSize",e,t,n),l=M("method",e,t,n),u=M("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let r=M("images",e,t,n),s=M("transforms",e,t,n),i=M("outputShape",e,t,n),o=M("fillValue",e,t,n),l=M("interpolation",e,t,n),u=M("fillMode",e,t,n);return[a.image.transform(r,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},hNe=(e,t,n,a=zr)=>{switch(e.op){case"Equal":return[a.equal(M("a",e,t,n),M("b",e,t,n))];case"NotEqual":return[a.notEqual(M("a",e,t,n),M("b",e,t,n))];case"Greater":return[a.greater(M("a",e,t,n),M("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(M("a",e,t,n),M("b",e,t,n))];case"Less":return[a.less(M("a",e,t,n),M("b",e,t,n))];case"LessEqual":return[a.lessEqual(M("a",e,t,n),M("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(M("a",e,t,n),M("b",e,t,n))];case"LogicalNot":return[a.logicalNot(M("a",e,t,n))];case"LogicalOr":return[a.logicalOr(M("a",e,t,n),M("b",e,t,n))];case"Select":case"SelectV2":return[a.where(M("condition",e,t,n),M("a",e,t,n),M("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(M("a",e,t,n),M("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},dNe=(e,t,n,a=zr)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(M("a",e,t,n),M("b",e,t,n),M("transposeA",e,t,n),M("transposeB",e,t,n))];case"Einsum":return[a.einsum(M("equation",e,t,n),...M("tensors",e,t,n))];case"Transpose":return[a.transpose(M("x",e,t,n),M("perm",e,t,n))];case"_FusedMatMul":let[r,s]=M("fusedOps",e,t,n),i=r==="biasadd",o=s==="prelu",l=M("numArgs",e,t,n),u=M("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,h]=M("args",e,t,n);return[a.fused.matMul({a:M("a",e,t,n),b:M("b",e,t,n),transposeA:M("transposeA",e,t,n),transposeB:M("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[a.linalg.bandPart(M("a",e,t,n),M("numLower",e,t,n),M("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},pNe=(e,t,n,a=zr)=>{switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(M("x",e,t,n),M("axis",e,t,n),M("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[a.batchNorm(M("x",e,t,n),M("mean",e,t,n),M("variance",e,t,n),M("offset",e,t,n),M("scale",e,t,n),M("epsilon",e,t,n))];case"FusedBatchNormV3":return[a.batchNorm(M("x",e,t,n),M("mean",e,t,n),M("variance",e,t,n),M("offset",e,t,n),M("scale",e,t,n),M("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(M("x",e,t,n),M("radius",e,t,n),M("bias",e,t,n),M("alpha",e,t,n),M("beta",e,t,n))];case"Softmax":return[a.softmax(M("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(M("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},fNe=(e,t,n,a=zr)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:r,outputDenseValues:s}=a.raggedGather(M("paramsNestedSplits",e,t,n),M("paramsDenseValues",e,t,n),M("indices",e,t,n),M("outputRaggedRank",e,t,n));return r.concat(s)}case"RaggedRange":{let{rtNestedSplits:r,rtDenseValues:s}=a.raggedRange(M("starts",e,t,n),M("limits",e,t,n),M("splits",e,t,n));return[r,s]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(M("shape",e,t,n),M("values",e,t,n),M("defaultValue",e,t,n),M("rowPartitionTensors",e,t,n),M("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},mNe=(e,t,n,a=zr)=>{switch(e.op){case"Max":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[a.max(M("x",e,t,n),o,l)]}case"Mean":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[a.mean(M("x",e,t,n),o,l)]}case"Min":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[a.min(M("x",e,t,n),o,l)]}case"Sum":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[a.sum(M("x",e,t,n),o,l)]}case"All":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[a.all(M("x",e,t,n),o,l)]}case"Any":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[a.any(M("x",e,t,n),o,l)]}case"ArgMax":{let o=M("axis",e,t,n);return[a.argMax(M("x",e,t,n),o)]}case"ArgMin":{let o=M("axis",e,t,n);return[a.argMin(M("x",e,t,n),o)]}case"Prod":{let o=M("axis",e,t,n),l=M("keepDims",e,t,n);return[a.prod(M("x",e,t,n),o,l)]}case"Cumprod":{let o=M("axis",e,t,n),l=M("exclusive",e,t,n),u=M("reverse",e,t,n);return[a.cumprod(M("x",e,t,n),o,l,u)]}case"Cumsum":{let o=M("axis",e,t,n),l=M("exclusive",e,t,n),u=M("reverse",e,t,n);return[a.cumsum(M("x",e,t,n),o,l,u)]}case"Bincount":let r=M("x",e,t,n),s=M("weights",e,t,n),i=M("size",e,t,n);return[a.bincount(r,s,i)];case"DenseBincount":{let o=M("x",e,t,n),l=M("weights",e,t,n),u=M("size",e,t,n),c=M("binaryOutput",e,t,n);return[a.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},gNe=(e,t,n,a=zr)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=M("n",e,t,n),s=M("axis",e,t,n),i=M("tensors",e,t,n);return i=i.slice(0,r),[a.concat(i,s)]}case"Gather":{let r=M("x",e,t,n),s=M("indices",e,t,n);return[a.gather(r,a.cast(s,"int32"),0)]}case"GatherV2":{let r=M("axis",e,t,n),s=M("batchDims",e,t,n),i=M("x",e,t,n),o=M("indices",e,t,n);return[a.gather(i,a.cast(o,"int32"),r,s)]}case"Reverse":{let r=M("dims",e,t,n),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);let i=M("x",e,t,n);return[a.reverse(i,s)]}case"ReverseV2":{let r=M("axis",e,t,n),s=M("x",e,t,n);return[a.reverse(s,r)]}case"Slice":{let r=M("begin",e,t,n),s=M("size",e,t,n);return[a.slice(M("x",e,t,n),r,s)]}case"StridedSlice":{let r=M("begin",e,t,n),s=M("end",e,t,n),i=M("strides",e,t,n),o=M("beginMask",e,t,n),l=M("endMask",e,t,n),u=M("ellipsisMask",e,t,n),c=M("newAxisMask",e,t,n),h=M("shrinkAxisMask",e,t,n),p=M("x",e,t,n);return[a.stridedSlice(p,r,s,i,o,l,u,c,h)]}case"Pack":return fe(()=>{let r=M("axis",e,t,n),s=M("tensors",e,t,n),i=s[0].shape,o=a.squeeze(s[0]).shape,l=s.map(u=>{let c=F.arraysEqual(u.shape,i);if(!c&&!F.arraysEqual(a.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:a.reshape(u,i)});return[a.stack(l,r)]});case"Unpack":{let r=M("axis",e,t,n),s=M("tensor",e,t,n);return a.unstack(s,r)}case"Tile":{let r=M("reps",e,t,n);return[a.tile(M("x",e,t,n),r)]}case"Split":case"SplitV":{let r=M("axis",e,t,n),s=M("numOrSizeSplits",e,t,n),i=M("x",e,t,n);return a.split(i,s,r)}case"ScatterNd":{let r=M("indices",e,t,n),s=M("values",e,t,n),i=M("shape",e,t,n);return[a.scatterND(r,s,i)]}case"GatherNd":{let r=M("x",e,t,n),s=M("indices",e,t,n);return[a.gatherND(r,s)]}case"SparseToDense":{let r=M("sparseIndices",e,t,n),s=M("outputShape",e,t,n),i=M("sparseValues",e,t,n),o=M("defaultValue",e,t,n);return[a.sparseToDense(r,i,s,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case"TensorScatterUpdate":{let r=M("indices",e,t,n),s=M("values",e,t,n),i=M("tensor",e,t,n);return[a.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},yNe=(e,t,n,a=zr)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(M("indices",e,t,n),M("values",e,t,n),M("denseShape",e,t,n),M("defaultValue",e,t,n));return[r,s,i,o]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(M("inputIndices",e,t,n),M("inputShape",e,t,n),M("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(M("data",e,t,n),M("indices",e,t,n),M("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(M("data",e,t,n),M("indices",e,t,n),M("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},bNe=(e,t,n,a=zr)=>{switch(e.op){case"FFT":return[a.fft(M("x",e,t,n))];case"IFFT":return[a.ifft(M("x",e,t,n))];case"RFFT":return[a.rfft(M("x",e,t,n))];case"IRFFT":return[a.irfft(M("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},xNe=(e,t,n,a=zr)=>{switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(M("input",e,t,n),M("pattern",e,t,n),M("rewrite",e,t,n),M("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(M("data",e,t,n),M("dataSplits",e,t,n),M("separator",e,t,n),M("nGramWidths",e,t,n),M("leftPad",e,t,n),M("rightPad",e,t,n),M("padWidth",e,t,n),M("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:i}=a.string.stringSplit(M("input",e,t,n),M("delimiter",e,t,n),M("skipEmpty",e,t,n));return[r,s,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(M("input",e,t,n),M("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},vNe=(e,t,n,a=zr)=>{switch(e.op){case"Cast":return[a.cast(M("x",e,t,n),M("dtype",e,t,n))];case"ExpandDims":{let r=M("axis",e,t,n);return[a.expandDims(M("x",e,t,n),r)]}case"Squeeze":{let r=M("axis",e,t,n);return[a.squeeze(M("x",e,t,n),r)]}case"Reshape":return[a.reshape(M("x",e,t,n),M("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(M("x",e,t,n),M("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(M("x",e,t,n),M("padding",e,t,n),M("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(M("x",e,t,n),M("padding",e,t,n),M("constantValue",e,t,n))];case"SpaceToBatchND":{let r=M("blockShape",e,t,n),s=M("paddings",e,t,n);return[a.spaceToBatchND(M("x",e,t,n),r,s)]}case"BatchToSpaceND":{let r=M("blockShape",e,t,n),s=M("crops",e,t,n);return[a.batchToSpaceND(M("x",e,t,n),r,s)]}case"DepthToSpace":{let r=M("blockSize",e,t,n),s=M("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(M("x",e,t,n),r,s)]}case"BroadcastTo":return[a.broadcastTo(M("x",e,t,n),M("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(M("s0",e,t,n),M("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function gH(e,t,n,a,r=fe){let s=((i,o,l)=>{switch(i.category){case"arithmetic":return r(()=>XIe(i,o,l));case"basic_math":return r(()=>YIe(i,o,l));case"control":return nNe(i,o,l);case"convolution":return r(()=>aNe(i,o,l));case"creation":return r(()=>rNe(i,o,l));case"dynamic":return sNe(i,o,l);case"evaluation":return r(()=>iNe(i,o,l));case"image":return r(()=>cNe(i,o,l));case"graph":return r(()=>oNe(i,o,l));case"logical":return r(()=>hNe(i,o,l));case"matrices":return r(()=>dNe(i,o,l));case"normalization":return r(()=>pNe(i,o,l));case"ragged":return r(()=>fNe(i,o,l));case"reduction":return r(()=>mNe(i,o,l));case"slice_join":return r(()=>gNe(i,o,l));case"sparse":return r(()=>yNe(i,o,l));case"spectral":return r(()=>bNe(i,o,l));case"string":return r(()=>xNe(i,o,l));case"transformation":return r(()=>vNe(i,o,l));case"hash_table":return uNe(i,o,l,a);case"custom":let u=FX(i.op);if(u&&u.customExecutor)return u.customExecutor(new KIe(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return F.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var yH=class{constructor(e={},t={},n={},a={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function bH(e,t,n,a){let r=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(p=>wi(p)[0]));a=a||[];let c=new Set(a.map(p=>wi(p.name)[0])),h=[...t];for(;h.length>0;){let p=h.pop();if((np(p)||TNe(p)||ENe(p))&&i==null&&(i=p,o=i.children.map(m=>m.name).filter(m=>r.has(m))),r.add(p.name),n[p.name]==null&&!u.has(p.name)&&!c.has(p.name)){if(p.inputs.length===0){s.push(p.name);continue}p.inputs.forEach(m=>{l.has(m.name)||(l.add(m.name),h.push(m))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function wNe(e,t){let{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(b=>wi(b)[0]).map(b=>e.nodes[b]),s=e.initNodes||[],i=b=>n.has(typeof b=="string"?b:b.name);function o(b){return[...new Map(b.map(v=>[v.name,v])).values()]}let l=o([...r,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(b=>[b.name,b])),h={};for(let b of u){h[b.name]=h[b.name]||0;for(let v of b.children)i(v)||(h[v.name]=Number.POSITIVE_INFINITY),h[v.name]=(h[v.name]||0)+1}let p=Object.entries(h).filter(([,b])=>b===0).map(([b])=>b),m=[...p];for(;p.length>0;){let b=p.pop(),v=c.get(b);for(let w of v.children.filter(i))--h[w.name]===0&&(m.push(w.name),p.push(w.name))}let g=m.map(b=>c.get(b)),y=ANe(g,l);return SNe(y,l),y}function ANe(e,t){let n=new Map(e.map(s=>[s.name,s])),a=t.map(s=>s.name),r=new Set(a);for(;a.length>0;){let s=a.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||r.has(o.name)||(r.add(o.name),a.push(o.name))}return e.filter(s=>r.has(s.name))}var Xk=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function SNe(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),a=new Set(t.map(o=>o.name)),r=o=>a.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new Xk(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Xk(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(let l of o.inputs){if(!n.has(l.name))throw new Xk(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Xk(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function kNe(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,a=e.map((o,l)=>np(o)?n:l),r=o=>{let l=a[t.get(o.name)];return l??-1},s=e.map((o,l)=>o.children.map(r).reduce((u,c)=>Math.max(u,c),a[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let u=e[o],c=e[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}var INe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),NNe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),CNe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function np(e){return INe.has(e.op)}function TNe(e){return NNe.has(e.op)}function ENe(e){return CNe.has(e.op)}var xH=class a7{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(a=>t[a].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(a=>{this._functionExecutorMap[a]=new a7(t.functions[a],this)})}getCompilationKey(t,n){let a=t.map(s=>s.name).sort(),r=n.map(s=>s.name).sort();return a.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,n){let a=bH(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:i}=a;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let u=n.map(h=>h.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}let o=wNe(this.graph,a),l=kNe(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return cr(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,a])=>[n,this.cloneTensorList(a)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let r=a.map(p=>this.graph.nodes[wi(p)[0]]),s=n.map(p=>wi(p)[0]),i=new Set(s),o=s.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(r,o),u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let c={},h={};return fe(()=>{let p=new yH(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(v=>{let[w,S]=wi(v,p),k=[];k[S]=t[v],m[w]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(k))});let g=this.getFrozenTensorIds(m),{orderedNodes:y,nodeLiveUntilMap:b}=u;for(let v of y){if(m[v.name])continue;let w=gH(v,m,p,this._resourceManager);if(F.isPromise(w))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);m[v.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList(w)),this.checkTensorForDisposalWithNodeLiveUntilInfo(v,m,p,g,i,b.get(v.name))}return this.parent==null&&p.dispose(g),n.map(v=>Gr(v,m,p))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(a=>t[a]).map(a=>a.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,a,r,s,i,o){if(!(np(n)||i.has(t))){for(let l of a[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(np(l))continue;let u=hH(l.name,a,r);if(u!=null)for(let c of u){if(!c||c.kept||s.has(c.id))continue;let h=o[c.id];h===1?(c.dispose(),delete o[c.id]):h!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,a,r,s,i){function o(l){return np(l)||s.has(l.name)}if(!(np(t)||i==null))for(let l of i){if(o(l))continue;let u=hH(l.name,n,a);for(let c of u)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,a=!1,r={},s={}){this.disposeIntermediateTensors(),a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let i=new yH(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,a),l=n.map(p=>Gr(p,o,i)),u=l.map(p=>p.id),c=Object.keys(t).map(p=>t[p].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(m=>{m&&!m.isDisposed&&!h.has(m.id)&&m.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(t,n,a){let r=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(r,this.outputNodes,!0,n,a)}async executeWithControlFlow(t,n,a,r){let s=Object.keys(t),i=s.map(k=>this.graph.nodes[wi(k)[0]]),o=a.map(k=>wi(k)[0]),l=new Set(o),u=o.map(k=>this.graph.nodes[k]);u.length===0&&(u=this._outputs);let{usedNodes:c,missingInputs:h,dynamicNode:p,syncInputs:m}=bH(t,u,this.weightMap,this._initNodes),g=[...i,...this.graph.weights,...this._initNodes||[]].map(k=>({node:k,contexts:n.currentContext})),y=Object.assign({},this.weightMap);Object.keys(t).forEach(k=>{let[I,T]=wi(k),E=[];E[T]=t[k],y[I]=E});let b={},v=this.getFrozenTensorIds(y),w={};for(;g.length>0;){let k=this.processStack(i,g,n,y,w,v,l,b,c);await Promise.all(k)}p==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let S=u.filter(k=>!np(k)&&!Gr(k.name,y,n)).map(k=>k.name);if(S.length>0){let k="";throw p!=null&&(k=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${S}] from the provided inputs [${s}]. Consider providing the following inputs: [${h}]. ${k}`)}return y}processStack(t,n,a,r,s,i,o,l,u){let c=[];for(;n.length>0;){let h=n.pop();a.currentContext=h.contexts;let p="";if(h.node.op==="Enter"&&M("isConstant",h.node,r,a)&&([p]=Bu(h.node.name,a)),r[h.node.name]==null){let m=gH(h.node,r,a,this._resourceManager);p||([p]=Bu(h.node.name,a));let g=a.currentContext;F.isPromise(m)?c.push(m.then(y=>(r[p]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(y)),a.currentContext=g,this.checkTensorForDisposal(p,h.node,r,a,i,o,l),this.processChildNodes(h.node,n,a,r,s,u),y))):(r[p]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(m)),this.checkTensorForDisposal(p,h.node,r,a,i,o,l),this.processChildNodes(h.node,n,a,r,s,u))}else this.processChildNodes(h.node,n,a,r,s,u)}return c}processChildNodes(t,n,a,r,s,i){t.children.forEach(o=>{let[l]=Bu(o.name,a);s[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!Gr(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})):o.inputNames.every(u=>!!Gr(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let a=t[n],[r]=wi(n),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===a.shape.length&&a.shape.every((l,u)=>i[u]===-1||i[u]===l);F.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${a.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&F.assert(a.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(t){var n,a;let r={};for(let s in t){let i=(a=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||a===void 0?void 0:a[s];i!=null?r[i.name]=t[s]:r[s]=t[s]}return r}checkInputs(t){let n=Object.keys(t).filter(a=>{let[r]=wi(a);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var a,r;let s=(r=(a=this._signature)===null||a===void 0?void 0:a.outputs)===null||r===void 0?void 0:r[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[a]=wi(n);if(!this.graph.nodes[a])throw new Error(`The output '${n}' is not found in the graph`)})}},$Ne=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},_Ne="?tfjs-format=file",RNe="model.json",IL=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=Kr){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new $Ne}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return F.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await iq(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let r=this.artifacts.userDefinedMetadata;r.signature!=null&&(a=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=a,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new xH(dH.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let r=dH.Instance.transformGraph(e.modelInitializer);this.initializer=new xH(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Bt?[e]:e,n={};return t.forEach((a,r)=>n[this.structuredOutputKeys[r]]=a),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Bt)&&!Array.isArray(e)){let r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(let s in r){let i=r[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((r,s)=>{var i,o,l;let u=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return u!=null?r[s]=this.resourceIdToCapturedInput[u]:r[s]=e[a++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){let r=n[a],s=t[r];this.resourceIdToCapturedInput[s.resourceId]=e[a]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ft(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function DNe(e,t={},n=Kr){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=FNe(e));let a=new IL(e,t,n);return await a.load(),a}function ONe(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[a,r]=e;if(!a)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in a))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in a))throw new Error("Model JSON is missing 'weightsManifest'");let s=Kr.getWeightSpecs(a.weightsManifest),i=Kr.getModelArtifactsForJSONSync(a,s,r);t=Kr.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=Kr.fromMemorySync(e);else throw new Error("Unknown model format");let n=new IL(t);return n.load(),n}function FNe(e){return e.endsWith("/")||(e=e+"/"),`${e}${RNe}${_Ne}`}var MNe="4.22.0",r7={};Lt(r7,{CSVDataset:()=>m7,Dataset:()=>tx,FileDataSource:()=>A7,TextLineDataset:()=>f7,URLDataSource:()=>S7,array:()=>s2e,csv:()=>b2e,func:()=>x2e,generator:()=>v2e,microphone:()=>A2e,version_data:()=>S2e,webcam:()=>w2e,zip:()=>i2e});var LNe=Kh(o2()),zNe=Kh(o2());function BNe(e,t){return hN(e,t)}function hN(e,t,n=new Map,a=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(wy(e)){let s=Array.isArray(e)?[]:{};a.add(e);for(let i in e){let o=e[i],l=hN(o,t,n,a);s[i]=l}return a.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,r.value),r.value}function PNe(e,t=i7){return s7(e,t)}function s7(e,t,n=new Set){let a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(wy(a)){let s=Array.isArray(a)?[]:{};n.add(a);for(let i in a){let o=e.map(u=>u[i]),l=s7(o,t,n);s[i]=l}return n.delete(a),s}else throw new Error(`Can't recurse into non-iterable type: ${a}`);else return r.value}function i7(e){return e===null?null:wy(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function o7(e,t){let n=new Map;hN(e,t,n);for(let a of Array.from(n.keys())){let r=n.get(a);if(F.isPromise(r)){let s=await r;n.set(a,s)}}return hN(e,t,n)}function wy(e){let t=!1;if(xe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=N5();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Bt)&&!(e instanceof Promise)&&!t)}function VNe(e){return e==null||UNe(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Bt||F.isTypedArray(e)}function UNe(e){return e===null||typeof e!="object"&&typeof e!="function"}function WNe(e){return BNe(e,GNe)}function GNe(e){return e instanceof Bt?{value:e.clone(),recurse:!1}:wy(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var l7=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},u7=class c7 extends l7{constructor(){super(c7.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),a=this.length();for(let r=0;r<a;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=a}};u7.INITIAL_CAPACITY=32;function h7(e){return new qNe(e)}function NL(e){return new KNe(e)}function HNe(e,t){return new d7(e,t)}function jNe(e,t=ch.FAIL){return new a2e(e,t)}var Fr=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new t2e(this,e)}filter(e){return new JNe(this,e)}map(e){return new e2e(this,e)}mapAsync(e){return new vH(this,e)}serialMapAsync(e){return new vH(this,e).serial()}flatmap(e){return new n2e(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new ZNe(this,e,t)}columnMajorBatch(e,t=!0,n=i7){return this.rowMajorBatch(e,t).map(a=>PNe(a,n))}concatenate(e,t){return new d7(h7([this,e]),t)}take(e){return e<0||e==null?this:new QNe(this,e)}skip(e){return e<0||e==null?this:new YNe(this,e)}prefetch(e){return new p7(this,e)}shuffle(e,t){return new r2e(this,e,t)}serial(){return new XNe(this)}},qNe=class extends Fr{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:WNe(e),done:!1}}},KNe=class extends Fr{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},XNe=class extends Fr{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},YNe=class extends Fr{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Ft(e.value)}return this.upstream.next()}},QNe=class extends Fr{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},ZNe=class extends Fr{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},JNe=class extends Fr{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ft(e.value)}}},e2e=class extends Fr{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=il.getTensorsInContainer(e.value),n=this.transform(e.value),a=il.getTensorsInContainer(n);for(let r of t)il.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},t2e=class extends Fr{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},vH=class extends Fr{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=il.getTensorsInContainer(e.value),n=await this.transform(e.value),a=il.getTensorsInContainer(n);for(let r of t)il.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},CL=class extends Fr{constructor(){super(),this.outputQueue=new u7,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},n2e=class extends CL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=il.getTensorsInContainer(e.value),n=this.transform(e.value),a=il.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let r of t)il.isTensorInList(r,a)||r.dispose();return!0}},d7=class extends Fr{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},ch;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(ch||(ch={}));var a2e=class extends Fr{constructor(e,t=ch.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function a(s){return s instanceof Fr?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let r=await o7(this.iterators,a);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case ch.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case ch.SHORTEST:return{value:null,done:!0};case ch.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},p7=class extends Fr{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new l7(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},r2e=class extends p7{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=zNe.alea(n||F.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},tx=class{constructor(){this.size=null}batch(e,t=!0){let n=this;F.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let a;return this.size===1/0||this.size==null?a=this.size:t?a=Math.ceil(this.size/e):a=Math.floor(this.size/e),vi(async()=>(await n.iterator()).columnMajorBatch(e,t,o2e),a)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,vi(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,vi(async()=>(await t.iterator()).filter(a=>fe(()=>e(a))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return vi(async()=>(await t.iterator()).map(n=>fe(()=>e(n))),this.size)}mapAsync(e){let t=this;return vi(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return vi(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,vi(async()=>{let a=NL(async()=>({value:await t.iterator(),done:!1}));return HNe(a.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,vi(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let a=this,r=LNe.alea(t||F.now().toString());return vi(async()=>{let s=r.int32();return n&&(s+=r.int32()),(await a.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,vi(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};tx.MAX_BUFFER_SIZE=1e4;function vi(e,t=null){return new class extends tx{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function s2e(e){return vi(async()=>h7(e),e.length)}function i2e(e){if(!wy(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return vi(async()=>{let n=await o7(e,a=>{if(a instanceof tx)return{value:a.iterator(),recurse:!1};if(wy(a))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return jNe(n,ch.SHORTEST)},t)}function o2e(e){if(e===null)return null;let t=e[0];return VNe(t)?{value:l2e(e),recurse:!1}:{value:null,recurse:!0}}function l2e(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Bt?Ja(e):Cs(e)}var f7=class extends tx{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Yk='"',kv=Symbol("out"),wH=Symbol("field"),Qk=Symbol("quote"),wR=Symbol("quoteafterquote"),AH=Symbol("quoteinquote"),m7=class extends tx{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&F.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((a,r)=>(a[r]=a[r]+1||1,a),{}),n=Object.keys(t).filter(a=>t[a]>1);if(F.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let a of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(a)===-1)throw new Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new f7(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(F.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){let s=this.fullColumnNames[r],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[r],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=u;else switch(i.dtype){case"float32":l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(o);break;default:l=u}}i&&i.isLabel?a[s]=l:n[s]=l}}return Object.keys(a).length===0?n:{xs:n,ys:a}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],a=0,r=e.length,s=kv;for(let i=0;i<r;i++)switch(s){case kv:switch(e.charAt(i)){case Yk:a=i+1,s=Qk;break;case this.delimiter:if(a=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=kv;break;default:s=wH,a=i;break}break;case wH:e.charAt(i)===this.delimiter&&(n.push(e.substring(a,i)),s=kv,a=i+1);break;case Qk:e.charAt(i)===Yk&&(s=wR);break;case wR:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i-1)),s=kv,a=i+1;break;case Yk:s=Qk;break;default:s=AH;break}break;case AH:e.charAt(i)===Yk&&(s=Qk);break}if(s===wR?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},u2e=class g7 extends Fr{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!xe().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new g7(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,a=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(a.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(a.timeDataQueue);n=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],a=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++a===this.numFrames&&(clearInterval(s),r({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,a=new Float32Array(t.length*n);return t.forEach((r,s)=>a.set(r,s*n)),a}getTensorFromAudioDataArray(t,n){let a=new Float32Array(F.sizeFromShape(n));return a.set(t,a.length-t.length),Cs(a,n)}},c2e=class y7 extends Fr{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Nn([0],"int32"),this.webcamConfig.centerCrop){let a=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-a)/2,i=(1-r)/2,o=s+a,l=r+i;this.cropBox=ql([i,s,l,o],[1,4])}else this.cropBox=ql([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!xe().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let a=new y7(t,n);return await a.start(),a}async start(){this.webcamConfig.facingMode&&F.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=C1.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return fe(()=>{let n=Tr(He(t,"float32"),0),a;a=Xi.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=a.shape;return pe(a,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},b7=class{},x7=class extends Fr{split(e){return new h2e(this,e)}},h2e=class extends x7{constructor(e,t){super(),this.upstream=e,this.impl=new d2e(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},d2e=class extends CL{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},p2e=class extends Fr{decodeUTF8(){return new f2e(this)}},f2e=class extends x7{constructor(e){super(),this.upstream=e,this.impl=new m2e(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},m2e=class extends CL{constructor(e){if(super(),this.upstream=e,xe().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=N5();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return xe().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},v7=class extends p2e{constructor(e,t={}){super(),this.file=e,this.options=t,F.assert(e instanceof Uint8Array||(xe().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let a=new FileReader;a.onload=s=>{let i=a.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},a.onabort=s=>t(new Error("Aborted")),a.onerror=s=>t(new Error(s.type));let r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}),done:!1}}};async function g2e(e,t={},n){let a,r;typeof e=="string"?a=e:(a=e.url,r=y2e(e));let s=await(0,F.fetch)(a,r);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new v7(i,t)}else throw new Error(s.statusText)}var y2e=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function w7(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var A7=class extends b7{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(w7(this.input)&&xe().get("IS_NODE")){let e=bF();this.input=e.readFileSync(this.input.slice(7))}return new v7(this.input,this.options)}},S7=class extends b7{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return w7(this.url)?new A7(this.url,this.fileOptions).iterator():g2e(this.url,this.fileOptions)}};function b2e(e,t={}){return new m7(new S7(e),t)}function x2e(e){let t=NL(e);return vi(async()=>t)}function v2e(e){return vi(async()=>{let t=await e();return NL(()=>t.next())})}async function w2e(e,t){return c2e.create(e,t)}async function A2e(e){return u2e.create(e)}var S2e="4.22.0";function dt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&F.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var k2e=pu.whereImpl,TL=class k7 extends Bw{nextDataId(){return k7.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new l2(this,_o())}write(t,n,a){this.firstUse&&(this.firstUse=!1,xe().get("IS_NODE")&&G.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:a,refCount:1}),r}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&F.isString(a[0])){let s=a.map(i=>F.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,a,r,s){this.data.set(t,{values:n,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:a}=this.data.get(t);if(n==="complex64"){let r=this.readSync(a.real.dataId),s=this.readSync(a.imag.dataId);return G.mergeRealAndImagArrays(r,s)}return F.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>F.decodeString(r));return Wt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(t.shape,t.dtype,n)}makeOutput(t,n,a){return _o().makeTensorFromTensorInfo(this.makeTensorInfo(n,a,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=F.now();return t(),{kernelMs:F.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){dt([t],"where");let n=this.readSync(t.dataId);return k2e(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};TL.nextDataId=0;var EL={};Lt(EL,{addImpl:()=>C7,bincountImpl:()=>_L,bincountReduceImpl:()=>T7,bitwiseAndImpl:()=>E7,castImpl:()=>N7,ceilImpl:()=>$7,concatImpl:()=>RL,equalImpl:()=>_7,expImpl:()=>D7,expm1Impl:()=>F7,floorDivImpl:()=>L7,floorImpl:()=>M7,gatherNdImpl:()=>z7,gatherV2Impl:()=>B7,greaterEqualImpl:()=>V7,greaterImpl:()=>P7,lessEqualImpl:()=>W7,lessImpl:()=>U7,linSpaceImpl:()=>G7,logImpl:()=>H7,maxImpl:()=>j7,maximumImpl:()=>q7,minimumImpl:()=>K7,multiplyImpl:()=>DL,negImpl:()=>X7,notEqualImpl:()=>Y7,prodImpl:()=>Q7,raggedGatherImpl:()=>Z7,raggedRangeImpl:()=>J7,raggedTensorToTensorImpl:()=>e9,rangeImpl:()=>FL,rsqrtImpl:()=>t9,scatterImpl:()=>cp,sigmoidImpl:()=>SCe,simpleAbsImpl:()=>I7,sliceImpl:()=>pN,sparseFillEmptyRowsImpl:()=>a9,sparseReshapeImpl:()=>r9,sparseSegmentReductionImpl:()=>ML,sqrtImpl:()=>NCe,squaredDifferenceImpl:()=>s9,staticRegexReplaceImpl:()=>i9,stridedSliceImpl:()=>o9,stringNGramsImpl:()=>LL,stringSplitImpl:()=>zL,stringToHashBucketFastImpl:()=>BL,subImpl:()=>l9,tileImpl:()=>u9,topKImpl:()=>h9,transposeImpl:()=>OL,uniqueImpl:()=>VL});function I7(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var I2e=e=>{let{x:t}=e.inputs,n=e.backend;dt(t,"abs");let a=new Float32Array(F.sizeFromShape(t.shape)),r=n.data.get(t.dataId).values;return a=I7(r),n.makeOutput(a,t.shape,t.dtype)},N2e={kernelName:Wy,backendName:"cpu",kernelFunc:I2e};function Va(e){return(t,n,a,r,s)=>{let i=G.assertAndGetBroadcastShape(t,n),o=i.length,l=F.computeStrides(i),u=F.sizeFromShape(i),c=F.getTypedArrayFromDType(s,u),h=t.length,p=n.length,m=F.computeStrides(t),g=F.computeStrides(n),y=G.getBroadcastDims(t,i),b=G.getBroadcastDims(n,i);if(y.length+b.length===0)for(let v=0;v<c.length;++v)c[v]=e(a[v%a.length],r[v%r.length]);else for(let v=0;v<c.length;++v){let w=F.indexToLoc(v,o,l),S=w.slice(-h);y.forEach(E=>S[E]=0);let k=F.locToIndex(S,h,m),I=w.slice(-p);b.forEach(E=>I[E]=0);let T=F.locToIndex(I,p,g);c[v]=e(a[k],r[T])}return[c,i]}}function Si(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",i)},o}var C2e={kernelName:h2,backendName:"cpu",kernelFunc:Si};function dN(e,t,n="float32"){if(n==="complex64"){let r=dN(e,t,"float32"),s=dN(e,t,"float32");return Si({inputs:{real:r,imag:s},backend:e})}let a=F.makeZerosTypedArray(F.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function au(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var T2e={kernelName:Mf,backendName:"cpu",kernelFunc:au};function Fp(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var E2e={kernelName:S2,backendName:"cpu",kernelFunc:Fp};function N7(e,t,n,a){if(a==="int32"){let r=Int32Array.from(e);return[t,"int32",r]}if(a==="bool"){let r=F.toTypedArray([0],n),[s,i]=Va((o,l)=>o!==l?1:0)(t,[],e,r,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function Dh(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return au({inputs:{x:r},backend:n});let c=dN(n,r.shape,r.dtype),h=Dh({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),p=Si({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),p}if(r.dtype==="complex64"){let c=Fp({inputs:{input:r},backend:n}),h=Dh({inputs:{x:c},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(c),h}if(!F.hasEncodingLoss(r.dtype,s)){let c=au({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=n.data.get(r.dataId).values,[o,l,u]=N7(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}var $2e={kernelName:yf,backendName:"cpu",kernelFunc:Dh};function vr(e,t,n,a){return n==null?({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;dt([i,o],e);let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h=i.dtype==="string"?G.fromUint8ToStringArray(u):u,p=i.dtype==="string"?G.fromUint8ToStringArray(c):c,m=a||i.dtype,[g,y]=t(i.shape,o.shape,h,p,m);return l.makeTensorInfo(y,m,g)}:({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let u=Dh({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,p=c.complexTensorInfos.imag,m=l.data.get(h.dataId).values,g=l.data.get(p.dataId).values,y=Dh({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),b=l.data.get(y.dataId),v=b.complexTensorInfos.real,w=b.complexTensorInfos.imag,S=l.data.get(v.dataId).values,k=l.data.get(w.dataId).values,[I,T,E]=n(i.shape,o.shape,m,g,S,k),R=l.makeTensorInfo(E,"float32",I),D=l.makeTensorInfo(E,"float32",T),O=Si({inputs:{real:R,imag:D},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(y),l.disposeIntermediateTensorInfo(R),l.disposeIntermediateTensorInfo(D),O}else{let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h=a||i.dtype,[p,m]=t(i.shape,o.shape,u,c,h);return l.makeTensorInfo(m,h,p)}}}function $L(e){return(t,n,a,r,s,i)=>{let o=G.assertAndGetBroadcastShape(t,n),l=F.sizeFromShape(o),u=o.length,c=F.computeStrides(o),h=F.getTypedArrayFromDType("float32",l),p=F.getTypedArrayFromDType("float32",l),m=G.getBroadcastDims(t,o),g=G.getBroadcastDims(n,o),y=G.mergeRealAndImagArrays(a,r),b=G.mergeRealAndImagArrays(s,i),v=t.length,w=F.computeStrides(t),S=n.length,k=F.computeStrides(n);if(m.length+g.length===0)for(let I=0;I<h.length;I++){let T=I%y.length,E=I%b.length,R=e(y[T*2],y[T*2+1],b[E*2],b[E*2+1]);h[I]=R.real,p[I]=R.imag}else for(let I=0;I<h.length;I++){let T=F.indexToLoc(I,u,c),E=T.slice(-v);m.forEach(_=>E[_]=0);let R=F.locToIndex(E,v,w),D=T.slice(-S);g.forEach(_=>D[_]=0);let O=F.locToIndex(D,S,k),$=e(y[R*2],y[R*2+1],b[O*2],b[O*2+1]);h[I]=$.real,p[I]=$.imag}return[h,p,o]}}var C7=Va((e,t)=>e+t),_2e=$L((e,t,n,a)=>({real:e+n,imag:t+a})),Ay=vr(Xh,C7,_2e),R2e={kernelName:Xh,backendName:"cpu",kernelFunc:Ay};function _L(e,t,n,a,r){let s=F.sizeFromShape(a),i=F.makeZerosTypedArray(r,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function T7(e,t,n,a=!1){let r=e.shape[0],s=e.shape[1],i=Wt([r,n],t.dtype);for(let o=0;o<r;o++)for(let l=0;l<s;l++){let u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(a?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}var E7=Va((e,t)=>e&t),D2e=vr(Qy,E7),O2e={kernelName:Qy,backendName:"cpu",kernelFunc:D2e};function fu(e){return(t,n,a)=>{let r=F.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function Dn(e,t,n){let a=fu(t);return rd(e,a,n)}function rd(e,t,n){return({inputs:a,attrs:r,backend:s})=>{let{x:i}=a;dt(i,e);let o=s,l=o.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=G.fromUint8ToStringArray(l)}else u=l;let c=n||i.dtype,h=t(u,c,r);return o.makeTensorInfo(i.shape,c,h)}}var $7=fu(e=>Math.ceil(e)),F2e=rd(bf,$7),M2e={kernelName:bf,backendName:"cpu",kernelFunc:F2e};function RL(e,t,n,a){let r=F.getArrayFromDType(n,F.sizeFromShape(t));if(a&&n!=="string"){let s=0;e.forEach(i=>{let o=F.sizeFromShape(i.shape);r.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?G.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*t[1]+s;for(let h=0;h<i.shape[1];++h)r[c+h]=o[l++]}s+=i.shape[1]})}return r}var _7=Va((e,t)=>e===t?1:0),R7=vr(sb,_7,null,"bool"),L2e={kernelName:sb,backendName:"cpu",kernelFunc:R7},D7=fu(e=>Math.exp(e)),O7=rd($f,D7,"float32"),z2e={kernelName:$f,backendName:"cpu",kernelFunc:O7},F7=fu(e=>Math.expm1(e)),B2e=rd(_f,F7),P2e={kernelName:_f,backendName:"cpu",kernelFunc:B2e},M7=fu(e=>Math.floor(e)),V2e=rd(Rf,M7),U2e={kernelName:Rf,backendName:"cpu",kernelFunc:V2e},L7=Va((e,t)=>Math.floor(e/t)),W2e=vr(Df,L7,null,"int32"),G2e={kernelName:Df,backendName:"cpu",kernelFunc:W2e};function z7(e,t,n,a,r,s,i,o,l){let u=Wt([a,s],n);for(let c=0;c<a;c++){let h=[],p=0;for(let m=0;m<r;m++){let g=e[c*r+m];p+=g*i[m],h.push(g)}if(p<0||p>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let m=0;m<s;m++)u.values[c*s+m]=t.get(...t.indexToLoc(p*s+m))}return u}function B7(e,t,n){let a=Wt(n,e.dtype);for(let r=0;r<a.size;++r){let s=a.indexToLoc(r).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let u=e.locToIndex(s);0<=u&&u<e.values.length&&(a.values[r]=e.values[u])}return a}var P7=Va((e,t)=>e>t?1:0),H2e=vr(cb,P7,null,"bool"),j2e={kernelName:cb,backendName:"cpu",kernelFunc:H2e},V7=Va((e,t)=>e>=t?1:0),q2e=vr(Ff,V7,null,"bool"),K2e={kernelName:Ff,backendName:"cpu",kernelFunc:q2e},U7=Va((e,t)=>e<t?1:0),X2e=vr(hb,U7,null,"bool"),Y2e={kernelName:hb,backendName:"cpu",kernelFunc:X2e},W7=Va((e,t)=>e<=t?1:0),Q2e=vr(db,W7,null,"bool"),Z2e={kernelName:db,backendName:"cpu",kernelFunc:Q2e};function G7(e,t,n){let a=(t-e)/(n-1),r=F.makeZerosTypedArray(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}var H7=fu(e=>Math.log(e)),J2e=rd(Vf,H7),eCe={kernelName:Vf,backendName:"cpu",kernelFunc:J2e};function j7(e,t,n,a){let r=F.getTypedArrayFromDType(a,F.sizeFromShape(n));for(let s=0;s<r.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}r[s]=o}return r}var q7=Va((e,t)=>Math.max(e,t)),tCe=vr(Hf,q7),nCe={kernelName:Hf,backendName:"cpu",kernelFunc:tCe},K7=Va((e,t)=>Math.min(e,t)),aCe=vr(Xf,K7),rCe={kernelName:Xf,backendName:"cpu",kernelFunc:aCe},DL=Va((e,t)=>e*t),sCe=$L((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),EC=vr(Zf,DL,sCe),iCe={kernelName:Zf,backendName:"cpu",kernelFunc:EC};function X7(e,t,n){let a=F.createScalarValue(-1,n);return DL([],t,a,e,n)}function oCe(e){let{inputs:t,backend:n}=e,{x:a}=t;dt(a,"neg");let r=n.data.get(a.dataId).values,[s,i]=X7(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}var lCe={kernelName:vb,backendName:"cpu",kernelFunc:oCe},Y7=Va((e,t)=>e!==t?1:0),uCe=vr(wb,Y7,null,"bool"),cCe={kernelName:wb,backendName:"cpu",kernelFunc:uCe};function OL(e,t,n,a,r){let s=t.length,i=F.sizeFromShape(t),o=F.computeStrides(t),l=F.computeStrides(r),u=F.getTypedArrayFromDType(n,F.sizeFromShape(r));for(let c=0;c<i;++c){let h=F.indexToLoc(c,s,o),p=new Array(h.length);for(let g=0;g<p.length;g++)p[g]=h[a[g]];let m=F.locToIndex(p,s,l);u[m]=e[c]}return u}function Js(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;dt(r,"transpose");let i=r.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=r.shape[s[c]];let l=a.data.get(r.dataId).values,u=OL(l,r.shape,r.dtype,s,o);return{dataId:a.write(u,o,r.dtype),shape:o,dtype:r.dtype}}var hCe={kernelName:Ku,backendName:"cpu",kernelFunc:Js};function Q7(e,t,n,a){let[r,s]=G.computeOutAndReduceShapes(e,a),i=ro(t,"int32"),o=F.makeZerosTypedArray(F.sizeFromShape(r),i),l=F.sizeFromShape(s);for(let u=0;u<o.length;++u){let c=u*l,h=1;for(let p=0;p<l;++p)h*=n[c+p];o[u]=h}return{outVals:o,outShape:r,outDtype:i}}function dCe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;dt(r,"prod");let o=r.shape.length,l=F.parseAxisParam(s,r.shape),u=G.getAxesPermutation(l,o),c=l,h=r,p=[];u!=null&&(h=Js({inputs:{x:r},backend:n,attrs:{perm:u}}),p.push(h),c=G.getInnerMostAxes(c.length,o));let m=n.data.get(h.dataId).values,{outVals:g,outShape:y,outDtype:b}=Q7(h.shape,h.dtype,m,c),v=y;return i&&(v=G.expandShapeToKeepDim(y,l)),p.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(v,b,g)}var pCe={kernelName:am,backendName:"cpu",kernelFunc:dCe};function fCe(e,t,n){e.forEach((a,r)=>{if(a<0||a>=n){let s=F.indexToLoc(r,t.length,F.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${a} is not in [0, ${n})`)}})}function mCe(e,t){for(let n=0;n<e.length;++n){let a=e[n],r=n===e.length-1?t:e[n+1].length;if(a.length===0)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let s=1;s<a.length;++s)if(a[s-1]>a[s])throw new Error("Ragged splits must be sorted in ascending order")}}function gCe(e,t,n,a){let r=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);mCe(n,a);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let h=1;h<l+1;++h)o[u].push(h*c)}for(let u=0;u<e.length;++u){let c=e[u],h=e[u]+1;for(let p=0;p<n.length;++p){let m=n[p],g=p+t.length-1;if(g>=0){let y=o[g],b=y[y.length-1]-m[c];for(let v=c;v<h;++v)o[g].push(m[v+1]+b)}c=m[c],h=m[h]}h!==c&&(r.push([c,h]),s+=h-c)}return{outSplits:o,valueSlices:r,numValues:s}}function yCe(e){let t=[];for(let n=0;n<e.length;++n){let a=e[n].length,r=F.getArrayFromDType("int32",a);t.push(r),e[n].forEach((s,i)=>r[i]=s)}return t}function SH(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function bCe(e,t,n,a,r,s){let i=SH(t,2)[1],o=SH(s,2)[1],l=0;for(let u of n)for(let c=u[0];c<u[1];++c){for(let h=0;h<a;++h)r[l*o+h]=e[c*i+h];++l}}function xCe(e,t,n,a,r){let s=t.slice();s[0]=r;let i=F.getArrayFromDType(n,F.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return bCe(e,t,a,l,i,s),[i,s]}function Z7(e,t,n,a,r,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(fCe(s,i,l),a.length===0)throw new Error("params.rank must be nonzero");let u=a[0],{outSplits:c,valueSlices:h,numValues:p}=gCe(s,i,e,u),m=yCe(c),g=xCe(n,a,r,h,p);return[m,g[0],g[1]]}var kH=2147483647;function J7(e,t,n,a,r,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=r.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(r[0]),u||c.push(i[0]);for(let b=1;b<c.length;++b)if(c[b]!==c[b-1])throw new Error("starts, limits, and deltas must have the same shape");let h=c.length===0?1:c[0],p=F.getArrayFromDType("int32",h+1);p[0]=0;for(let b=0;b<h;++b){let v=o?e[0]:e[b],w=l?a[0]:a[b],S=u?s[0]:s[b];if(S===0)throw new Error("Requires delta != 0");let k;if(S>0&&w<v||S<0&&w>v)k=0;else if(k=Math.ceil(Math.abs((w-v)/S)),k>kH)throw new Error(`Requires ((limit - start) / delta) <= ${kH}`);p[b+1]=p[b]+k}let m=p[h],g=F.getArrayFromDType(n,m),y=0;for(let b=0;b<h;++b){let v=p[b+1]-p[b],w=o?e[0]:e[b],S=u?s[0]:s[b];for(let k=0;k<v;++k)g[y++]=w,w+=S}return[p,g]}var Co=G.RowPartitionType,vCe=class UD{constructor(t,n,a,r,s,i,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=a,this.valuesShape=r,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=G.getRowPartitionTypesHelper(c),this.raggedRank=G.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Co.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Co.VALUE_ROWIDS:return UD.getMaxWidthValueRowID(n);case Co.ROW_SPLITS:return UD.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Co[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let a=0;for(let r=0;r<n-1;++r){let s=t[r+1]-t[r];s>a&&(a=s)}return a}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let a=0,r=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==r&&(r=o,s=Math.max(i-a,s),a=i)}return Math.max(n-a,s)}tensorShapeFromTensor(t,n,a=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return NH(t,a)}calculateOutputSize(t){let n=this.valuesShape,a=this.defaultValueShape;G.validateDefaultValueShape(a,n);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=G.combineRaggedTensorToTensorShapes(this.raggedRank,r,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,a){let r=Math.min(t,a),s=[],i=0;for(let o=0;o<r;++o,i+=n)s.push(i);for(let o=r;o<t;++o)s.push(-1);return F.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,a,r){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],u=Math.min(r,l),c=n[o];c===-1&&(u=0);for(let h=0;h<u;++h)i.push(c),c+=a;for(let h=0;h<l-u;++h)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,a,r){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<s;++c){let h=t[c];if(h===l)u>=0&&(++o,o<r?u+=a:u=-1);else{if(o=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);u=n[h]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,a,r){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Co.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,a,r);case Co.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,a,r);default:throw new Error(`Unsupported partition type: ${Co[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case Co.FIRST_DIM_SIZE:return t[0];case Co.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Co.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Co[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),a=new Array(this.raggedRank+1);a[a.length-1]=1;for(let i=a.length-2;i>=0;--i)a[i]=a[i+1]*n[i+1];let r=NH(n,!1),s=F.getArrayFromDType(this.valuesDType,F.sizeFromShape(r));if(a[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,a[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,a[o],n[o]);this.setOutput(this.raggedRank,i,s,r)}return[r,s]}setOutput(t,n,a,r){if(a.length===0)return;let s=this.values,i=a,o=r.slice();o=o.slice(t+1);let l=F.sizeFromShape(o),u=n.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let g=this.defaultValueShape;fe(()=>{let y=pe(c,g);c=pp(y,o).dataSync()})}let h=0,p=0,m=0;for(let g=0;g<=u;++g){let y=g<u?n[g]:-1;if(y===m){++m;continue}if(p<m){let b=s.subarray(h*l),v=i.subarray(p*l),w=(m-p)*l;IH(v,b,w)}if(g>=u){let b=a.length;y=Math.floor(b/l)}if(y>m)if(this.defaultValue.length===1)i.subarray(m*l,y*l).fill(this.defaultValue[0]),m=y;else for(;y>m;){let b=i.slice(m*l);IH(b,c,l),++m}y<0?(h=g+1,p=m):(h=g,p=m,m=p+1)}}};function IH(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function NH(e,t){let n=[];for(let a of e){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function e9(e,t,n,a,r,s,i,o,l,u){return new vCe(e,t,n,a,r,s,i,o,l,u).compute()}function FL(e,t,n,a){let r=e===t,s=e<t&&n<0,i=t<e&&n>1;if(r||s||i)return F.makeZerosTypedArray(0,a);let o=Math.abs(Math.ceil((t-e)/n)),l=F.makeZerosTypedArray(o,a);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var t9=fu(e=>1/Math.sqrt(e)),wCe=rd(hm,t9),ACe={kernelName:hm,backendName:"cpu",kernelFunc:wCe};function cp(e,t,n,a,r,s,i,o,l,u){let c=[a/r,r],h=e.values,p=t.values;if(a===0)return Wt(n,t.dtype);let m=l instanceof Za?l:Wt(c,t.dtype);typeof l=="string"||typeof l=="number"?m.values.fill(l):typeof l=="boolean"&&m.values.fill(+l);for(let g=0;g<s;g++){let y=[],b=0;for(let v=0;v<i;v++){let w=h[g*i+v];y.push(w),b+=w*o[v]}if(b<0||b>=a/r)throw new Error(`Invalid indices: ${y} does not index into ${n}`);for(let v=0;v<r;v++)u?m.values[b*r+v]+=p[g*r+v]:m.values[b*r+v]=t.rank===0?p[0]:p[g*r+v]}return m}var SCe=fu(e=>1/(1+Math.exp(-e))),n9=Dn(gm,e=>1/(1+Math.exp(-e))),kCe={kernelName:gm,backendName:"cpu",kernelFunc:n9};function pN(e,t,n,a,r){let s=mr.isSliceContinous(a,t,n),i=F.sizeFromShape(n),o=F.computeStrides(a);if(s){let h=mr.computeFlatOffset(t,o);return r==="string"?e.slice(h,h+i):e.subarray(h,h+i)}let l=r==="string"?G.fromUint8ToStringArray(e):e,u=Wt(a,r,l),c=Wt(n,r);for(let h=0;h<c.size;++h){let p=c.indexToLoc(h),m=p.map((g,y)=>g+t[y]);c.set(u.get(...m),...p)}return r==="string"?G.fromStringArrayToUint8(c.values):c.values}function Mp(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a;dt(r,"slice");let[o,l]=mr.parseSliceParams(r,s,i);mr.assertParamsValid(r,o,l);let u=n.data.get(r.dataId).values,c=pN(u,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}var ICe={kernelName:Ob,backendName:"cpu",kernelFunc:Mp};function a9(e,t,n,a,r,s,i){let o=t[0],l=s[0],u=new Array(l),c=new Array(o),h=t[1];if(l===0){if(o!==0)throw new Error(G.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let b=F.getArrayFromDType(n,0),v=F.getArrayFromDType(r,0);return[b,[0,h],v,u,c]}let p=!0,m=0,g=new Array(l).fill(0);for(let b=0;b<o;++b){let v=e[b*h];if(v<0)throw new Error(G.getSparseFillEmptyRowsNegativeIndexErrorMessage(b,v));if(v>=l)throw new Error(G.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(b,v,l));++g[v],p=p&&v>=m,m=v}let y=!0;for(let b=0;b<l;++b){let v=g[b]===0;u[b]=v,y=y&&!v,g[b]=Math.max(g[b],1),b>0&&(g[b]+=g[b-1])}if(y&&p){let b=e,v=a;for(let w=0;w<o;++w)c[w]=w;return[b,[o,h],v,u,c]}else{let b=g[l-1],v=F.getArrayFromDType(n,b*h),w=F.getArrayFromDType(r,b),S=new Array(l).fill(0);for(let k=0;k<o;++k){let I=e[k*h],T=S[I],E=(I===0?0:g[I-1])+T;S[I]++;for(let R=0;R<h;++R)v[E*h+R]=e[k*h+R];w[E]=a[k],c[k]=E}for(let k=0;k<l;++k)if(S[k]===0){let I=k===0?0:g[k-1];v[I*h+0]=k;for(let T=1;T<h;++T)v[I*h+T]=0;w[I]=i}return[v,[b,h],w,u,c]}}function r9(e,t,n,a,r){let s=F.sizeFromShape(a),i=t[0],o=r.length,l=[],u=1,c=-1;for(let y=0;y<o;++y){let b=r[y];if(b===-1){if(c!==-1)throw new Error(G.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,y));c=y,l.push(1)}else{if(b<0)throw new Error(G.getSparseReshapeNegativeOutputDimErrorMessage(y,b));u*=b,l.push(b)}}if(c!==-1){if(u<=0)throw new Error(G.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let y=Math.trunc(s/u);if(u*y!==s)throw new Error(G.getSparseReshapeInputOutputMultipleErrorMessage(a,l));l[c]=y}if(F.sizeFromShape(l)!==s)throw new Error(G.getSparseReshapeInputOutputMismatchErrorMessage(a,l));let h=a.length,p=[];if(h>0){p[h-1]=1;for(let y=h-2;y>=0;--y)p[y]=p[y+1]*a[y+1]}let m=[];if(o>0){m[o-1]=1;for(let y=o-2;y>=0;--y)m[y]=m[y+1]*l[y+1]}let g=F.getArrayFromDType(n,i*o);for(let y=0;y<i;++y){let b=0;for(let v=0;v<h;++v)b+=e[y*h+v]*p[v];for(let v=0;v<o;++v)g[y*o+v]=Math.trunc(b/m[v]),b%=m[v]}return[g,[i,o],l]}function ML(e,t,n,a,r,s=!1,i=0){let o=a.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?r[o-1]+1:0;if(c<0)throw new Error(G.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=t.slice();h[0]=c;let p=h.reduce((w,S)=>w*S,1),m=F.getArrayFromDType(n,p);if(o===0)return c>0&&m.fill(i),[m,h];if(c<=0)throw new Error(G.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,y=1,b=0,v=r[g];for(;;){let w=0;if(y<o){if(w=r[y],v===w){++y;continue}if(v>=w)throw new Error(G.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=c)throw new Error(G.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,c));v>b&&m.fill(i,b*u,v*u);for(let S=g;S<y;++S){let k=a[S];if(k<0||k>=l[0])throw new Error(G.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(S,a[S],l[0]));for(let I=0;I<u;I++)m[v*u+I]+=e[k*u+I]}if(s)for(let S=0;S<u;S++)m[v*u+S]/=y-g;if(g=y,++y,b=v+1,v=w,y>o)break}return b<c&&m.fill(i,b*u,c*u),[m,h]}var NCe=fu(e=>Math.sqrt(e)),CCe=Dn(bm,e=>Math.sqrt(e)),TCe={kernelName:bm,backendName:"cpu",kernelFunc:CCe},s9=Va((e,t)=>{let n=e-t;return n*n}),ECe=vr(wm,s9),$Ce={kernelName:wm,backendName:"cpu",kernelFunc:ECe},i9=fu((e,t)=>{let{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)}),_Ce=rd(n1,i9),RCe={kernelName:n1,backendName:"cpu",kernelFunc:_Ce};function o9(e,t,n,a){let r=Wt(e,t.dtype);for(let s=0;s<r.size;s++){let i=r.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+a[l];r.set(t.get(...o),...i)}return r}var DCe=class{constructor(e,t,n,a,r,s){this.separator=F.encodeString(e),this.nGramWidths=t,this.leftPad=F.encodeString(n),this.rightPad=F.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(r-(i+1))),c=s-(l+u),h=t+(l>0?0:i-o),p=0;p+=l*this.leftPad.length;for(let v=0;v<c;++v)p+=e[h+v].length;p+=u*this.rightPad.length;let m=l+u+c-1;p+=m*this.separator.length,n[a+i]=new Uint8Array(p);let g=n[a+i],y=0,b=v=>v.forEach(w=>g[y++]=w);for(let v=0;v<l;++v)b(this.leftPad),b(this.separator);for(let v=0;v<c-1;++v)b(e[h+v]),b(this.separator);if(c>0){b(e[h+c-1]);for(let v=0;v<u;++v)b(this.separator),b(this.rightPad)}else{for(let v=0;v<u-1;++v)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){let n=e.length,a=t.length;if(a>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<a;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let r=a-1,s=F.getArrayFromDType("int32",a);if(n===0||a===0){let o=new Array(n);for(let l=0;l<=r;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=r;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(c=>{u+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&u===0&&(u=1),s[o]=s[o-1]+u}let i=new Array(s[r]);for(let o=0;o<r;++o){let l=t[o],u=s[o];if(this.nGramWidths.forEach(c=>{let h=t[o+1]-t[o],p=this.getNumNGrams(h,c);this.createNGrams(e,l,i,u,p,c),u+=p}),this.preserveShort&&u===s[o]){let c=t[o+1]-t[o];if(c===0)continue;let h=c+2*this.padWidth;this.createNGrams(e,l,i,u,1,h)}}return[i,s]}};function LL(e,t,n,a,r,s,i,o){return new DCe(n,a,r,s,i,o).compute(e,t)}function OCe(e,t,n,a){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)a.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&a.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&a.push(e);return}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(r,s);(!n||i.length!==0)&&a.push(i),r=s+1}}function zL(e,t,n){let a=e.length,r=[],s=0,i=0,o=new Array(a);for(let p=0;p<a;++p){let m=r.length;OCe(e[p],t,n,r);let g=r.length-m;o[p]=g,s+=g,i=Math.max(i,g)}let l=F.getArrayFromDType("int32",s*2),u=new Array(s),c=[a,i],h=0;for(let p=0;p<a;++p)for(let m=0;m<o[p];++m)l[h*2]=p,l[h*2+1]=m,u[h]=r[h],++h;return[l,u,c]}function BL(e,t){let n=F.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=F.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var l9=Va((e,t)=>e-t),FCe=$L((e,t,n,a)=>({real:e-n,imag:t-a})),PL=vr(Am,l9,FCe),MCe={kernelName:Am,backendName:"cpu",kernelFunc:PL};function u9(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let a=Wt(n,e.dtype);for(let r=0;r<a.values.length;++r){let s=a.indexToLoc(r),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);a.values[r]=e.values[o]}return a}var Rv=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function c9(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){let o=a-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),p=Math.max(n,Math.floor(t-l*c/o+h)),m=Math.min(a,Math.floor(t+(o-l)*c/o+h));c9(e,t,p,m)}let r=e[t],s=n,i=a;for(F.swap(e,n,t),Rv(e[a],r)>0&&F.swap(e,n,a);s<i;){for(F.swap(e,s,i),s++,i--;Rv(e[s],r)<0;)s=s+1;for(;Rv(e[i],r)>0;)i=i-1}Rv(e[n],r)===0?F.swap(e,n,i):(i=i+1,F.swap(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function h9(e,t,n,a,r){let s=t[t.length-1],[i,o]=[e.length/s,s],l=F.getTypedArrayFromDType(n,i*a),u=F.getTypedArrayFromDType("int32",i*a);for(let h=0;h<i;h++){let p=h*o,m=e.subarray(p,p+o),g=new Array(m.length);m.forEach((w,S)=>g[S]={value:w,index:S}),a<g.length&&(c9(g,a),g=g.slice(0,a)),r&&g.sort(Rv);let y=h*a,b=l.subarray(y,y+a),v=u.subarray(y,y+a);for(let w=0;w<a;w++)b[w]=g[w].value,v[w]=g[w].index}let c=t.slice();return c[c.length-1]=a,[Wt(c,n,l),Wt(c,"int32",u)]}function VL(e,t,n,a){let r=F.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let g=0;g<r;g++)s[0]*=n[g];s[1]=n[r];for(let g=r+1;g<n.length;g++)s[2]*=n[g];let i=new Map,o=new Int32Array(n[r]),l=new Za(s,a,e),u=[],c=s[0]===1&&s[2]===1;for(let g=0;g<n[r];g++){let y;if(c)y=e[g].toString();else{let v=[];for(let w=0;w<s[0];w++)for(let S=0;S<s[2];S++)v.push(l.get(w,g,S));y=v.join(",")}let b=i.get(y);if(b!=null)o[g]=b;else{let v=i.size;i.set(y,v),o[g]=v,u.push(g)}}let h=s.slice();h[1]=i.size;let p=new Za(h,a);u.forEach((g,y)=>{for(let b=0;b<s[0];b++)for(let v=0;v<s[2];v++)p.set(l.get(b,g,v),b,y,v)});let m=n.slice();return m[r]=h[1],{outputValues:p.values,outputShape:m,indices:o}}var LCe="4.22.0";N2("cpu",()=>new TL,1);var d9=Dn(Tf,e=>e>=0?e:Math.exp(e)-1),zCe={kernelName:Tf,backendName:"cpu",kernelFunc:d9};function p9(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;dt([r],"leakyRelu");let i=F.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,l=F.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(r.shape,"float32",l)}var BCe={kernelName:Pf,backendName:"cpu",kernelFunc:p9},PCe=Va((e,t)=>e<0?t*e:e);function f9(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t;dt([a,r],"prelu");let s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,l]=PCe(a.shape,r.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var VCe={kernelName:nm,backendName:"cpu",kernelFunc:f9},m9=Dn(sm,e=>Math.max(0,e)),UCe={kernelName:sm,backendName:"cpu",kernelFunc:m9},g9=Dn(lm,e=>Math.min(Math.max(0,e),6)),WCe={kernelName:lm,backendName:"cpu",kernelFunc:g9};function fN(e,t,n,a,r){if(n==="linear")return au({inputs:{x:t},backend:e});if(n==="relu")return m9({inputs:{x:t},backend:e});if(n==="elu")return d9({inputs:{x:t},backend:e});if(n==="relu6")return g9({inputs:{x:t},backend:e});if(n==="prelu")return f9({inputs:{x:t,alpha:a},backend:e});if(n==="leakyrelu")return p9({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n==="sigmoid")return n9({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function oa(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=F.sizeFromShape(r.shape),o=F.inferFromImplicitShape(s,i),l=F.sizeFromShape(o);F.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);let u=n.data.get(r.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=o,h.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var GCe={kernelName:Cb,backendName:"cpu",kernelFunc:oa};function y9(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;dt([r,s],"matMul");let l=r.shape.length,u=s.shape.length,c=i?r.shape[l-2]:r.shape[l-1],h=o?s.shape[u-1]:s.shape[u-2],p=i?r.shape[l-1]:r.shape[l-2],m=o?s.shape[u-2]:s.shape[u-1],g=r.shape.slice(0,-2),y=s.shape.slice(0,-2),b=F.sizeFromShape(g),v=F.sizeFromShape(y),w=Hb.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,m]);F.assert(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let S=i?[b,c,p]:[b,p,c],k=o?[v,m,h]:[v,h,m],I=oa({inputs:{x:r},backend:n,attrs:{shape:S}}),T=oa({inputs:{x:s},backend:n,attrs:{shape:k}}),E=i?I.shape[1]:I.shape[2],R=i?I.shape[2]:I.shape[1],D=o?T.shape[1]:T.shape[2],O=Math.max(b,v),$=n.data.get(I.dataId).values,_=n.data.get(T.dataId).values,P=F.computeStrides(I.shape),U=F.computeStrides(T.shape),[W,B,H]=i?[P[0],1,P[1]]:[P[0],P[1],1],[j,Z,te]=o?[1,U[1],U[0]]:[U[1],1,U[0]],V=R*D,Q=Wt([O,R,D],I.dtype),ee=Q.values,ae=n.blockSize;for(let de=0;de<O;de++){let ke=de%b,Te=de%v;for(let $e=0;$e<R;$e+=ae){let Le=Math.min($e+ae,R);for(let Ge=0;Ge<D;Ge+=ae){let Ke=Math.min(Ge+ae,D);for(let at=0;at<E;at+=ae){let vt=Math.min(at+ae,E);for(let ot=$e;ot<Le;ot++)for(let lt=Ge;lt<Ke;lt++){let tt=0;for(let wt=at;wt<vt;wt++){let It=$[ke*W+ot*B+wt*H],jn=_[wt*j+lt*Z+Te*te];tt+=It*jn}ee[de*V+(ot*D+lt)]+=tt}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(T),n.makeTensorInfo(w,Q.dtype,Q.values)}var HCe={kernelName:gf,backendName:"cpu",kernelFunc:y9};function jCe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=a,p,m,g,y=[];p=y9({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(m=Ay({inputs:{a:p,b:i},backend:n}),y.push(p),p=m),c&&(g=fN(n,p,c,o,h),y.push(p),p=g);for(let b of y)n.disposeIntermediateTensorInfo(b);return p}var qCe={kernelName:Ap,backendName:"cpu",kernelFunc:jCe},KCe=Dn(of,e=>Math.acos(e)),XCe={kernelName:of,backendName:"cpu",kernelFunc:KCe},YCe=Dn(lf,e=>Math.acosh(e)),QCe={kernelName:lf,backendName:"cpu",kernelFunc:YCe};function ZCe(e){let{inputs:t,backend:n}=e,a=t;dt(t,"addN");let r=a.map(o=>n.data.get(o.dataId).values),s=Wt(a[0].shape,a[0].dtype),i=s.values;for(let o=0;o<a.length;o++){let l=r[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var JCe={kernelName:uf,backendName:"cpu",kernelFunc:ZCe};function eTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;dt(r,"all");let o=F.parseAxisParam(s,r.shape),l=o,u=G.getAxesPermutation(l,r.shape.length),c=r;u!=null&&(c=Js({inputs:{x:r},backend:n,attrs:{perm:u}}),l=G.getInnerMostAxes(l.length,r.shape.length)),G.assertAxesAreInnerMostDims("all",l,c.shape.length);let[h,p]=G.computeOutAndReduceShapes(c.shape,l),m=F.sizeFromShape(p),g=F.makeZerosTypedArray(F.sizeFromShape(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){let w=v*m,S=y[w];for(let k=0;k<m;++k){let I=y[w+k];S=S&&I}g[v]=S}u!=null&&n.disposeIntermediateTensorInfo(c);let b=n.makeTensorInfo(h,c.dtype,g);if(i){let v=G.expandShapeToKeepDim(h,o),w=oa({inputs:{x:b},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(b),w}return b}var tTe={kernelName:Gy,backendName:"cpu",kernelFunc:eTe};function nTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;dt(r,"any");let o=F.parseAxisParam(s,r.shape),l=o,u=G.getAxesPermutation(l,r.shape.length),c=r;u!=null&&(c=Js({inputs:{x:r},backend:n,attrs:{perm:u}}),l=G.getInnerMostAxes(l.length,r.shape.length)),G.assertAxesAreInnerMostDims("any",l,c.shape.length);let[h,p]=G.computeOutAndReduceShapes(c.shape,l),m=F.sizeFromShape(p),g=F.makeZerosTypedArray(F.sizeFromShape(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){let w=v*m,S=y[w];for(let k=0;k<m;++k){let I=y[w+k];S=S||I}g[v]=S}u!=null&&n.disposeIntermediateTensorInfo(c);let b=n.makeTensorInfo(h,c.dtype,g);if(i){let v=G.expandShapeToKeepDim(h,o),w=oa({inputs:{x:b},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(b),w}return b}var aTe={kernelName:Hy,backendName:"cpu",kernelFunc:nTe};function rTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;dt(r,"argMax");let i=F.parseAxisParam(s,r.shape),o=G.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Js({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=G.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],G.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,h]=G.computeOutAndReduceShapes(l.shape,i),p=F.sizeFromShape(c),m=F.makeZerosTypedArray(p,"int32"),g=F.sizeFromShape(h),y=n.data.get(l.dataId).values;for(let b=0;b<m.length;++b){let v=b*g,w=y[v],S=0;for(let k=0;k<g;++k){let I=y[v+k];I>w&&(w=I,S=k)}m[b]=S}return u.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(c,"int32",m)}var sTe={kernelName:jy,backendName:"cpu",kernelFunc:rTe};function iTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;dt(r,"argMin");let i=F.parseAxisParam(s,r.shape),o=G.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Js({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=G.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],G.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,h]=G.computeOutAndReduceShapes(l.shape,i),p=F.sizeFromShape(c),m=F.makeZerosTypedArray(p,"int32"),g=F.sizeFromShape(h),y=n.data.get(l.dataId).values;for(let b=0;b<m.length;++b){let v=b*g,w=y[v],S=0;for(let k=0;k<g;++k){let I=y[v+k];I<w&&(w=I,S=k)}m[b]=S}return u.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(c,"int32",m)}var oTe={kernelName:qy,backendName:"cpu",kernelFunc:iTe},lTe=Dn(cf,e=>Math.asin(e)),uTe={kernelName:cf,backendName:"cpu",kernelFunc:lTe},cTe=Dn(hf,e=>Math.asinh(e)),hTe={kernelName:hf,backendName:"cpu",kernelFunc:cTe},dTe=Dn(df,e=>Math.atan(e)),pTe={kernelName:df,backendName:"cpu",kernelFunc:dTe},fTe=Va((e,t)=>Math.atan2(e,t)),mTe=vr(ff,fTe),gTe={kernelName:ff,backendName:"cpu",kernelFunc:mTe},yTe=Dn(pf,e=>Math.atanh(e)),bTe={kernelName:pf,backendName:"cpu",kernelFunc:yTe};function UL(e,t,n,a,r,s){let i=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,m=r.padInfo.left,g=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=Wt(r.outShape,n),b=y.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3],w=r.outShape[2]*r.outShape[3],S=r.outShape[3];for(let k=0;k<r.batchSize;++k){let I=k*v,T=k*a[0];for(let E=0;E<r.inChannels;++E)for(let R=0;R<r.outHeight;++R){let D=R*i-p,O=Math.max(0,D),$=Math.min(r.inHeight,c+D),_=I+R*w;for(let P=0;P<r.outWidth;++P){let U=P*o-m,W=Math.max(0,U),B=Math.min(r.inWidth,h+U),H=g,j=0,Z=0;for(let V=O;V<$;V+=l){let Q=T+V*a[1];for(let ee=W;ee<B;ee+=u){let ae=Q+ee*a[2],de=e[ae+E];s==="max"&&de>H?H=de:s==="avg"&&(j+=de,Z++)}if(isNaN(H))break}let te=_+P*S+E;b[te]=s==="avg"?j/Z:H}}}return y}function b9(e,t,n,a,r=!1,s=!1){let i=Wt(a.outShape,"int32"),o=a.strideHeight,l=a.strideWidth,u=a.dilationHeight,c=a.dilationWidth,h=a.effectiveFilterHeight,p=a.effectiveFilterWidth,m=a.padInfo.top,g=a.padInfo.left,y=Wt(t,n,e);for(let b=0;b<a.batchSize;++b)for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outHeight;++w){let S=w*o-m,k=S;for(;k<0;)k+=u;let I=Math.min(a.inHeight,h+S);for(let T=0;T<a.outWidth;++T){let E=T*l-g,R=E;for(;R<0;)R+=c;let D=Math.min(a.inWidth,p+E),O=Number.NEGATIVE_INFINITY,$=-1;for(let _=k;_<I;_+=u){let P=_-S;for(let U=R;U<D;U+=c){let W=U-E,B=y.get(b,_,U,v);B>O&&(O=B,r?$=s?((b*a.inHeight+_)*a.inWidth+U)*a.inChannels+v:(_*a.inWidth+U)*a.inChannels+v:$=P*p+W)}}i.set($,b,w,T,v)}}return i}function x9(e,t,n,a,r,s){let i=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,p=r.effectiveFilterDepth,m=r.effectiveFilterHeight,g=r.effectiveFilterWidth,y=r.padInfo.front,b=r.padInfo.top,v=r.padInfo.left,w=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=Wt(r.outShape,n),k=S.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],T=r.outShape[2]*r.outShape[3]*r.outShape[4],E=r.outShape[3]*r.outShape[4],R=r.outShape[4];for(let D=0;D<r.batchSize;++D){let O=D*I,$=D*a[0];for(let _=0;_<r.inChannels;++_)for(let P=0;P<r.outDepth;++P){let U=P*i-y,W=U;for(;W<0;)W+=u;let B=Math.min(r.inDepth,p+U),H=O+P*T;for(let j=0;j<r.outHeight;++j){let Z=j*o-b,te=Z;for(;te<0;)te+=c;let V=Math.min(r.inHeight,m+Z),Q=H+j*E;for(let ee=0;ee<r.outWidth;++ee){let ae=ee*l-v,de=ae;for(;de<0;)de+=h;let ke=Math.min(r.inWidth,g+ae),Te=Q+ee*R,$e=w,Le=0,Ge=0;for(let at=W;at<B;at+=u){let vt=$+at*a[1];for(let ot=te;ot<V;ot+=c){let lt=vt+ot*a[2];for(let tt=de;tt<ke;tt+=h){let wt=lt+tt*a[3],It=e[wt+_];if(s==="max"&&It>$e?$e=It:s==="avg"&&(Le+=It,Ge++),isNaN($e))break}if(isNaN($e))break}if(isNaN($e))break}let Ke=Te+_;k[Ke]=s==="avg"?Le/Math.max(Ge,1):$e}}}}return S}function xTe(e,t){let n=Wt(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,m=t.padInfo.top,g=t.padInfo.left;for(let y=0;y<t.batchSize;++y)for(let b=0;b<t.inChannels;++b)for(let v=0;v<t.outDepth;++v){let w=v*a-p,S=w;for(;S<0;)S+=i;let k=Math.min(t.inDepth,u+w);for(let I=0;I<t.outHeight;++I){let T=I*r-m,E=T;for(;E<0;)E+=o;let R=Math.min(t.inHeight,c+T);for(let D=0;D<t.outWidth;++D){let O=D*s-g,$=O;for(;$<0;)$+=l;let _=Math.min(t.inWidth,h+O),P=Number.NEGATIVE_INFINITY,U=-1;for(let W=S;W<k;W+=i){let B=W-w;for(let H=E;H<R;H+=o){let j=H-T;for(let Z=$;Z<_;Z+=l){let te=Z-O,V=e.get(y,W,H,Z,b);V>=P&&(P=V,U=B*c*h+j*c+te)}}}n.set(U,y,v,I,D,b)}}}return n}function vTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;dt(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;F.assert(G.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=G.computePool2DInfo(r.shape,s,i,u,o,l),h;if(c.filterWidth===1&&c.filterHeight===1&&F.arraysEqual(c.inShape,c.outShape))h=au({inputs:{x:r},backend:n});else{let p=n.data.get(r.dataId).values,m=F.computeStrides(r.shape),g=UL(p,r.shape,r.dtype,m,c,"avg");h=n.makeTensorInfo(c.outShape,r.dtype,g.values)}return h}var wTe={kernelName:mf,backendName:"cpu",kernelFunc:vTe};function ATe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;dt(r,"avgPool3d");let c=G.computePool3DInfo(r.shape,s,i,1,o,l,u),h=n.data.get(r.dataId).values,p=x9(h,r.shape,r.dtype,F.computeStrides(r.shape),c,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}var STe={kernelName:Ky,backendName:"cpu",kernelFunc:ATe};function kTe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;dt([r,s],"avgPool3DGrad");let c=G.computePool3DInfo(s.shape,i,o,1,l,u),h=c.strideDepth,p=c.strideHeight,m=c.strideWidth,g=c.filterDepth,y=c.filterHeight,b=c.filterWidth,v=c.dilationDepth,w=c.dilationHeight,S=c.dilationWidth,k=c.effectiveFilterDepth,I=c.effectiveFilterHeight,T=c.effectiveFilterWidth,E=k-1-c.padInfo.front,R=T-1-c.padInfo.left,D=I-1-c.padInfo.top,O=Wt(s.shape,"float32"),$=1/(g*y*b),_=n.bufferSync(r);for(let P=0;P<c.batchSize;++P)for(let U=0;U<c.inChannels;++U)for(let W=0;W<c.inDepth;++W)for(let B=0;B<c.inHeight;++B)for(let H=0;H<c.inWidth;++H){let j=W-E,Z=B-D,te=H-R,V=0;for(let Q=0;Q<k;Q+=v){let ee=(j+Q)/h;if(!(ee<0||ee>=c.outDepth||Math.floor(ee)!==ee))for(let ae=0;ae<I;ae+=w){let de=(Z+ae)/p;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let ke=0;ke<T;ke+=S){let Te=(te+ke)/m;if(Te<0||Te>=c.outWidth||Math.floor(Te)!==Te)continue;let $e=_.get(P,ee,de,Te,U);V+=$e}}}O.set(V*$,P,W,B,H,U)}return n.makeTensorInfo(O.shape,O.dtype,O.values)}var ITe={kernelName:Uw,backendName:"cpu",kernelFunc:kTe};function NTe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;dt([r,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=a,c=G.computePool2DInfo(i.shape,o,l,1,u),h=c.strideHeight,p=c.strideWidth,m=c.filterHeight,g=c.filterWidth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,S=w-1-c.padInfo.left,k=v-1-c.padInfo.top,I=Wt(i.shape,"float32"),T=1/(m*g),E=n.data.get(r.dataId).values,R=Wt(r.shape,"float32",E);for(let D=0;D<c.batchSize;++D)for(let O=0;O<c.inChannels;++O)for(let $=0;$<c.inHeight;++$)for(let _=0;_<c.inWidth;++_){let P=$-k,U=_-S,W=0;for(let B=0;B<v;B+=y){let H=(P+B)/h;if(!(H<0||H>=c.outHeight||Math.floor(H)!==H))for(let j=0;j<w;j+=b){let Z=(U+j)/p;if(Z<0||Z>=c.outWidth||Math.floor(Z)!==Z)continue;let te=R.get(D,H,Z,O);W+=te}}I.set(W*T,D,$,_,O)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var CTe={kernelName:Vw,backendName:"cpu",kernelFunc:NTe};function TTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:i,mean:o,variance:l}=t;F.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),dt([r,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=a;u==null&&(u=.001);let c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,p=n.data.get(l.dataId).values,m=s?n.data.get(s.dataId).values:new Float32Array([1]),g=i?n.data.get(i.dataId).values:new Float32Array([0]),y=new Float32Array(c.length),b=g.length,v=m.length,w=p.length,S=h.length,k=0,I=0,T=0,E=0;for(let R=0;R<c.length;++R)y[R]=g[k++]+(c[R]-h[I++])*m[T++]/Math.sqrt(p[E++]+u),k>=b&&(k=0),I>=S&&(I=0),T>=v&&(T=0),E>=w&&(E=0);return n.makeTensorInfo(r.shape,r.dtype,y)}var ETe={kernelName:Of,backendName:"cpu",kernelFunc:TTe};function $Te(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;dt([r],"batchToSpaceND");let o=s.reduce((v,w)=>v*w),l=G.getReshaped(r.shape,s,o),u=G.getPermuted(l.length,s.length),c=G.getReshapedPermuted(r.shape,s,o),h=G.getSliceBeginCoords(i,s.length),p=G.getSliceSize(c,i,s.length),m=oa({inputs:{x:r},backend:n,attrs:{shape:l}}),g=Js({inputs:{x:m},backend:n,attrs:{perm:u}}),y=oa({inputs:{x:g},backend:n,attrs:{shape:c}}),b=Mp({inputs:{x:y},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}var _Te={kernelName:Xy,backendName:"cpu",kernelFunc:$Te};function RTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=_L(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var DTe={kernelName:Yy,backendName:"cpu",kernelFunc:RTe};function OTe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=G.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var FTe={kernelName:Ww,backendName:"cpu",kernelFunc:OTe},MTe=Dn(Yh,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),LTe={kernelName:Yh,backendName:"cpu",kernelFunc:MTe},zTe=e=>{let{x:t}=e.inputs,n=e.backend,a=new Float32Array(F.sizeFromShape(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let c=o[u],h=l[u];a[u]=Math.hypot(c,h)}return n.makeOutput(a,t.shape,"float32")},BTe={kernelName:Gw,backendName:"cpu",kernelFunc:zTe};function Sy(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var PTe={kernelName:x2,backendName:"cpu",kernelFunc:Sy};function ky(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=F.parseAxisParam(r,t[0].shape)[0],i=t.map(y=>y.shape);G.assertParamsConsistent(i,s);let o=G.computeOutShape(t.map(y=>y.shape),s);if(F.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(y=>F.sizeFromShape(y.shape)>0);if(l.length===1)return au({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let y=l.map(k=>Fp({inputs:{input:k},backend:n})),b=l.map(k=>Sy({inputs:{input:k},backend:n})),v=ky({inputs:y,backend:n,attrs:{axis:s}}),w=ky({inputs:b,backend:n,attrs:{axis:s}}),S=Si({inputs:{real:v,imag:w},backend:n});return y.forEach(k=>n.disposeIntermediateTensorInfo(k)),b.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),S}let u=l.map(y=>{let b=[-1,F.sizeFromShape(y.shape.slice(s))];return oa({inputs:{x:y},backend:n,attrs:{shape:b}})}),c=u.map(y=>({vals:n.data.get(y.dataId).values,shape:y.shape}));o=G.computeOutShape(u.map(y=>y.shape),1);let h=u[0].shape[0]===1,p=RL(c,o,t[0].dtype,h),m=G.computeOutShape(l.map(y=>y.shape),s),g=n.makeTensorInfo(m,t[0].dtype,p);return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}var VTe={kernelName:Zy,backendName:"cpu",kernelFunc:ky};function v9(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=a;dt([r,s],"conv2d");let h=G.convertConv2DDataFormat(l),p=G.computeConv2DInfo(r.shape,s.shape,i,u,o,c,!1,h),m=p.filterHeight,g=p.filterWidth,y=p.dilationHeight,b=p.dilationWidth,v=p.padInfo.left,w=p.padInfo.top,S=p.dataFormat==="channelsLast",k=new Za(p.outShape,r.dtype),I=F.computeStrides(r.shape),T=F.computeStrides(s.shape),E=I[0],R=S?I[1]:I[2],D=S?I[2]:1,O=S?1:I[1],$=k.strides[0],_=S?k.strides[1]:k.strides[2],P=S?k.strides[2]:1,U=S?1:k.strides[1],W=n.data.get(r.dataId).values,B=n.data.get(s.dataId).values,H=k.values;for(let j=0;j<p.batchSize;++j){let Z=j*E,te=j*$;for(let V=0;V<p.outHeight;++V){let Q=te+V*_,ee=V*p.strideHeight-w;for(let ae=0;ae<m;++ae){let de=ee+ae*y;if(de<0||de>=p.inHeight)continue;let ke=ae*T[0],Te=Z+de*R;for(let $e=0;$e<p.outWidth;++$e){let Le=Q+$e*P,Ge=$e*p.strideWidth-v;for(let Ke=0;Ke<g;++Ke){let at=Ge+Ke*b;if(at<0||at>=p.inWidth)continue;let vt=ke+Ke*T[1],ot=Te+at*D,lt=vt;for(let tt=0;tt<p.inChannels;++tt){let wt=W[ot+tt*O];for(let It=0;It<p.outChannels;++It)H[Le+It*U]+=wt*B[lt+It];lt+=p.outChannels}}}}}}return n.makeTensorInfo(k.shape,k.dtype,H)}var UTe={kernelName:xf,backendName:"cpu",kernelFunc:v9};function WTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=a;dt([r,s],"conv2dBackpropFilter");let h=G.convertConv2DDataFormat(l),p=G.computeConv2DInfo(r.shape,c,i,1,o,u,!1,h),{strideHeight:m,strideWidth:g,filterHeight:y,filterWidth:b}=p,v=p.dataFormat==="channelsLast",w=new Za(p.filterShape,"float32"),S=p.padInfo.left,k=p.padInfo.top,I=n.data.get(r.dataId).values,T=n.data.get(s.dataId).values,E=new Za(r.shape,r.dtype,I),R=new Za(s.shape,s.dtype,T);for(let D=0;D<y;++D){let O=Math.max(0,Math.ceil((k-D)/m)),$=Math.min(p.outHeight,(p.inHeight+k-D)/m);for(let _=0;_<b;++_){let P=Math.max(0,Math.ceil((S-_)/g)),U=Math.min(p.outWidth,(p.inWidth+S-_)/g);for(let W=0;W<p.inChannels;++W)for(let B=0;B<p.outChannels;++B){let H=0;for(let j=0;j<p.batchSize;++j)for(let Z=O;Z<$;++Z){let te=D+Z*m-k;for(let V=P;V<U;++V){let Q=_+V*g-S;v?H+=E.get(j,te,Q,W)*R.get(j,Z,V,B):H+=E.get(j,W,te,Q)*R.get(j,B,Z,V)}}w.set(H,D,_,W,B)}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var GTe={kernelName:d2,backendName:"cpu",kernelFunc:WTe};function HTe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=a;dt([r,s],"conv2dBackpropInput");let h=F.computeStrides(s.shape),p=F.computeStrides(r.shape),m=G.convertConv2DDataFormat(u),g=G.computeConv2DInfo(i,s.shape,o,1,l,c,!1,m),y=new Za(g.inShape,"float32"),b=y.values,v=n.data.get(r.dataId).values,w=n.data.get(s.dataId).values,[S,k,I]=h,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:D,inHeight:O,inWidth:$,outChannels:_,outHeight:P,outWidth:U,strideHeight:W,strideWidth:B}=g;m=g.dataFormat;let H=E-1-g.padInfo.top,j=R-1-g.padInfo.left,Z=m==="channelsLast",te=y.strides[0],V=Z?y.strides[1]:y.strides[2],Q=Z?y.strides[2]:1,ee=Z?1:y.strides[1],ae=p[0],de=Z?p[1]:p[2],ke=Z?p[2]:1,Te=Z?1:p[1];for(let $e=0;$e<T;++$e)for(let Le=0;Le<D;++Le)for(let Ge=0;Ge<O;++Ge){let Ke=Ge-H,at=Math.max(0,Math.ceil(Ke/W)),vt=Math.min(P,(E+Ke)/W);for(let ot=0;ot<$;++ot){let lt=ot-j,tt=Math.max(0,Math.ceil(lt/B)),wt=Math.min(U,(R+lt)/B),It=0;for(let Dt=at;Dt<vt;++Dt){let qn=Dt*W-Ke;for(let yn=tt;yn<wt;++yn){let ca=yn*B-lt,nn=ae*$e+de*Dt+ke*yn,ua=S*(E-1-qn)+k*(R-1-ca)+I*Le;for(let ea=0;ea<_;++ea){let Cn=v[nn+Te*ea],ta=w[ua+ea];It+=Cn*ta}}}let jn=te*$e+V*Ge+Q*ot+ee*Le;b[jn]=It}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var jTe={kernelName:vf,backendName:"cpu",kernelFunc:HTe};function qTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;dt([r,s],"conv3d");let u=G.computeConv3DInfo(r.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:h,filterWidth:p,dilationDepth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=u,v=b.front,w=b.left,S=b.top,k=new Za(u.outShape,r.dtype),I=n.data.get(r.dataId).values,T=n.data.get(s.dataId).values,E=k.values,R=F.computeStrides(r.shape),D=F.computeStrides(s.shape);for(let O=0;O<u.batchSize;++O){let $=O*R[0],_=O*k.strides[0];for(let P=0;P<u.outDepth;++P){let U=_+P*k.strides[1],W=P*u.strideDepth-v;for(let B=0;B<c;++B){let H=W+B*m;if(H<0||H>=u.inDepth)continue;let j=B*D[0],Z=$+H*R[1];for(let te=0;te<u.outHeight;++te){let V=U+te*k.strides[2],Q=te*u.strideHeight-S;for(let ee=0;ee<h;++ee){let ae=Q+ee*g;if(ae<0||ae>=u.inHeight)continue;let de=j+ee*D[1],ke=Z+ae*R[2];for(let Te=0;Te<u.outWidth;++Te){let $e=V+Te*u.outChannels,Le=Te*u.strideWidth-w;for(let Ge=0;Ge<p;++Ge){let Ke=Le+Ge*y;if(Ke<0||Ke>=u.inWidth)continue;let at=de+Ge*D[2],vt=ke+Ke*u.inChannels,ot=at;for(let lt=0;lt<u.inChannels;++lt){let tt=I[vt+lt];for(let wt=0;wt<u.outChannels;++wt)E[$e+wt]+=tt*T[ot+wt];ot+=u.outChannels}}}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var KTe={kernelName:wf,backendName:"cpu",kernelFunc:qTe};function XTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;dt([r,s],"conv3dBackpropFilterV2");let u=F.computeStrides(r.shape),c=F.computeStrides(s.shape),h=G.computeConv3DInfo(r.shape,l,i,1,o),p=h.strideDepth,m=h.strideHeight,g=h.strideWidth,y=h.filterDepth,b=h.filterHeight,v=h.filterWidth,w=new Za(h.filterShape,"float32"),S=w.values,[k,I,T,E]=w.strides,R=n.data.get(s.dataId).values,[D,O,$,_]=c,P=n.data.get(r.dataId).values,[U,W,B,H]=u,j=h.padInfo.front,Z=h.padInfo.left,te=h.padInfo.top;for(let V=0;V<y;++V){let Q=Math.max(0,Math.ceil((j-V)/p)),ee=Math.min(h.outDepth,(h.inDepth+j-V)/p),ae=V*k;for(let de=0;de<b;++de){let ke=Math.max(0,Math.ceil((te-de)/m)),Te=Math.min(h.outHeight,(h.inHeight+te-de)/m),$e=de*I+ae;for(let Le=0;Le<v;++Le){let Ge=Math.max(0,Math.ceil((Z-Le)/g)),Ke=Math.min(h.outWidth,(h.inWidth+Z-Le)/g),at=Le*T+$e;for(let vt=0;vt<h.inChannels;++vt){let ot=vt*E+at;for(let lt=0;lt<h.outChannels;++lt){let tt=0;for(let wt=0;wt<h.batchSize;++wt){let It=wt*U,jn=wt*D;for(let Dt=Q;Dt<ee;++Dt){let qn=(V+Dt*p-j)*W+It,yn=Dt*O+jn;for(let ca=ke;ca<Te;++ca){let nn=(de+ca*m-te)*B+qn,ua=ca*$+yn;for(let ea=Ge;ea<Ke;++ea){let Cn=(Le+ea*g-Z)*H+nn,ta=ea*_+ua;tt+=P[Cn+vt]*R[ta+lt]}}}}S[ot+lt]=tt}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var YTe={kernelName:Jy,backendName:"cpu",kernelFunc:XTe};function QTe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;dt([r],"conv3dBackpropInputV2");let u=F.computeStrides(r.shape),c=F.computeStrides(s.shape),h=G.computeConv3DInfo(l,s.shape,o,1,i),p=new Za(h.inShape,"float32"),m=p.values,[g,y,b,v]=p.strides,w=n.data.get(r.dataId).values,[S,k,I,T]=u,E=n.data.get(s.dataId).values,[R,D,O,$]=c,{batchSize:_,filterDepth:P,filterHeight:U,filterWidth:W,inChannels:B,inDepth:H,inHeight:j,inWidth:Z,outChannels:te,outDepth:V,outHeight:Q,outWidth:ee,strideDepth:ae,strideHeight:de,strideWidth:ke}=h,Te=P-1-h.padInfo.front,$e=U-1-h.padInfo.top,Le=W-1-h.padInfo.left;for(let Ge=0;Ge<_;++Ge)for(let Ke=0;Ke<B;++Ke)for(let at=0;at<H;++at){let vt=at-Te,ot=Math.max(0,Math.ceil(vt/ae)),lt=Math.min(V,(P+vt)/ae);for(let tt=0;tt<j;++tt){let wt=tt-$e,It=Math.max(0,Math.ceil(wt/de)),jn=Math.min(Q,(U+wt)/de);for(let Dt=0;Dt<Z;++Dt){let qn=Dt-Le,yn=Math.max(0,Math.ceil(qn/ke)),ca=Math.min(ee,(W+qn)/ke),nn=0;for(let ua=ot;ua<lt;++ua){let ea=ua*ae-vt;for(let Cn=It;Cn<jn;++Cn){let ta=Cn*de-wt;for(let ys=yn;ys<ca;++ys){let po=ys*ke-qn,Bs=S*Ge+k*ua+I*Cn+T*ys,yu=R*(P-1-ea)+D*(U-1-ta)+O*(W-1-po)+$*Ke;for(let Ha=0;Ha<te;++Ha){let ba=w[Bs+Ha],Fn=E[yu+Ha];nn+=ba*Fn}}}}m[g*Ge+y*at+b*tt+v*Dt+Ke]=nn}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}var ZTe={kernelName:eb,backendName:"cpu",kernelFunc:QTe},JTe=Dn(Af,e=>Math.cos(e)),eEe={kernelName:Af,backendName:"cpu",kernelFunc:JTe},tEe=Dn(Sf,e=>Math.cosh(e)),nEe={kernelName:Sf,backendName:"cpu",kernelFunc:tEe};function aEe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,[c,h,p,m]=r.shape,g=s.shape[0],[y,b]=o,v=Wt([g,y,b,m],"float32"),w=n.data.get(s.dataId).values,S=n.data.get(i.dataId).values,k=n.data.get(r.dataId).values,I=F.computeStrides(r.shape),T=F.computeStrides(v.shape);for(let E=0;E<g;E++){let R=E*4,D=w[R],O=w[R+1],$=w[R+2],_=w[R+3],P=S[E];if(P>=c)continue;let U=y>1?($-D)*(h-1)/(y-1):0,W=b>1?(_-O)*(p-1)/(b-1):0;for(let B=0;B<y;B++){let H=y>1?D*(h-1)+B*U:.5*(D+$)*(h-1);if(H<0||H>h-1){for(let j=0;j<b;j++)for(let Z=0;Z<m;Z++){let te=Z+j*T[2]+B*T[1]+E*T[0];v.values[te]=u}continue}if(l==="bilinear"){let j=Math.floor(H),Z=Math.ceil(H),te=H-j;for(let V=0;V<b;V++){let Q=b>1?O*(p-1)+V*W:.5*(O+_)*(p-1);if(Q<0||Q>p-1){for(let ke=0;ke<m;ke++){let Te=ke+V*T[2]+B*T[1]+E*T[0];v.values[Te]=u}continue}let ee=Math.floor(Q),ae=Math.ceil(Q),de=Q-ee;for(let ke=0;ke<m;ke++){let Te=ke+ee*I[2]+j*I[1]+P*I[0],$e=k[Te];Te=ke+ae*I[2]+j*I[1]+P*I[0];let Le=k[Te];Te=ke+ee*I[2]+Z*I[1]+P*I[0];let Ge=k[Te];Te=ke+ae*I[2]+Z*I[1]+P*I[0];let Ke=k[Te],at=$e+(Le-$e)*de,vt=Ge+(Ke-Ge)*de;Te=ke+V*T[2]+B*T[1]+E*T[0],v.values[Te]=at+(vt-at)*te}}}else for(let j=0;j<b;++j){let Z=b>1?O*(p-1)+j*W:.5*(O+_)*(p-1);if(Z<0||Z>p-1){for(let Q=0;Q<m;Q++){let ee=Q+j*T[2]+B*T[1]+E*T[0];v.values[ee]=u}continue}let te=Math.round(Z),V=Math.round(H);for(let Q=0;Q<m;Q++){let ee=Q+te*I[2]+V*I[1]+P*I[0],ae=Q+j*T[2]+B*T[1]+E*T[0];v.values[ae]=k[ee]}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var rEe={kernelName:nb,backendName:"cpu",kernelFunc:aEe};function sEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;dt(r,"cumprod");let l=G.getAxesPermutation([s],r.shape.length),u=r;l!=null&&(u=Js({inputs:{x:r},backend:n,attrs:{perm:l}}));let c=G.getInnerMostAxes(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let h=ro(u.dtype,"int32"),p=F.makeOnesTypedArray(F.sizeFromShape(u.shape),h),m=n.data.get(u.dataId).values,g=u.shape[u.shape.length-1],y=o?(v,w)=>v+g-w-1:(v,w)=>v+w;for(let v=0;v<m.length;v+=g)for(let w=0;w<g;w++){let S=y(v,w);if(w===0)p[S]=i?1:m[S];else{let k=y(v,w-1);p[S]=i?m[k]*p[k]:m[S]*p[k]}}let b=n.makeTensorInfo(u.shape,h,p);if(l!=null){let v=G.getUndoAxesPermutation(l),w=Js({inputs:{x:b},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(u),w}return b}var iEe={kernelName:tb,backendName:"cpu",kernelFunc:sEe};function oEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;dt(r,"cumsum");let l=G.getAxesPermutation([s],r.shape.length),u=r;l!=null&&(u=Js({inputs:{x:r},backend:n,attrs:{perm:l}}));let c=G.getInnerMostAxes(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let h=ro(u.dtype,"int32"),p=F.makeZerosTypedArray(F.sizeFromShape(u.shape),h),m=n.data.get(u.dataId).values,g=u.shape[u.shape.length-1],y=o?(v,w)=>v+g-w-1:(v,w)=>v+w;for(let v=0;v<m.length;v+=g)for(let w=0;w<g;w++){let S=y(v,w);if(w===0)p[S]=i?0:m[S];else{let k=y(v,w-1);p[S]=i?m[k]+p[k]:m[S]+p[k]}}let b=n.makeTensorInfo(u.shape,h,p);if(l!=null){let v=G.getUndoAxesPermutation(l),w=Js({inputs:{x:b},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(u),w}return b}var lEe={kernelName:kf,backendName:"cpu",kernelFunc:oEe};function uEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=_L(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){let l=n.bufferSync(r),u=n.bufferSync(s),c=T7(l,u,i,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var cEe={kernelName:Hw,backendName:"cpu",kernelFunc:uEe};function hEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a;F.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*s,p=u*s,m=c/(s*s),g=n.data.get(r.dataId).values,y=new Float32Array(o*h*p*m),b=0;for(let v=0;v<o;++v)for(let w=0;w<h;++w){let S=Math.floor(w/s),k=w%s;for(let I=0;I<p;++I){let T=Math.floor(I/s),E=I%s,R=(k*s+E)*m;for(let D=0;D<m;++D){let O=D+R+c*(T+u*(S+l*v));y[b++]=g[O]}}}return n.makeTensorInfo([o,h,p,m],r.dtype,y)}var dEe={kernelName:ab,backendName:"cpu",kernelFunc:hEe};function w9(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a;dt([r,s],"depthwiseConv2DNative");let c=F.computeStrides(r.shape),h=F.computeStrides(s.shape),p=l;p==null&&(p=[1,1]),F.assert(G.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let m=G.computeConv2DInfo(r.shape,s.shape,i,p,o,u,!0),{filterHeight:g,filterWidth:y,dilationHeight:b,dilationWidth:v,padInfo:w}=m,S=w.left,k=w.top,I=m.outChannels/m.inChannels,T=new Za(m.outShape,r.dtype),E=n.data.get(r.dataId).values,R=n.data.get(s.dataId).values,D=T.values;for(let O=0;O<m.batchSize;++O){let $=O*c[0],_=O*T.strides[0];for(let P=0;P<m.outHeight;++P){let U=_+P*T.strides[1],W=P*m.strideHeight-k;for(let B=0;B<g;++B){let H=W+B*b;if(H<0||H>=m.inHeight)continue;let j=B*h[0],Z=$+H*c[1];for(let te=0;te<m.outWidth;++te){let V=U+te*T.strides[2],Q=te*m.strideWidth-S;for(let ee=0;ee<y;++ee){let ae=Q+ee*v;if(ae<0||ae>=m.inWidth)continue;let de=j+ee*h[1],ke=Z+ae*m.inChannels,Te=V,$e=de;for(let Le=0;Le<m.inChannels;++Le){let Ge=E[ke+Le];for(let Ke=0;Ke<I;++Ke)D[Te+Ke]+=Ge*R[$e+Ke];Te+=I,$e+=I}}}}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var pEe={kernelName:If,backendName:"cpu",kernelFunc:w9};function fEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=a;dt([r,s],"depthwiseConv2dNativeBackpropFilter");let h=G.computeConv2DInfo(r.shape,c,i,o,l,u,!0),{strideHeight:p,strideWidth:m,filterHeight:g,filterWidth:y}=h,b=new Za(h.filterShape,"float32"),v=h.padInfo.left,w=h.padInfo.top,S=h.outChannels/h.inChannels,k=n.data.get(r.dataId).values,I=new Za(r.shape,r.dtype,k),T=n.data.get(s.dataId).values,E=new Za(s.shape,s.dtype,T);for(let R=0;R<g;++R){let D=Math.max(0,Math.ceil((w-R)/p)),O=Math.min(h.outHeight,(h.inHeight+w-R)/p);for(let $=0;$<y;++$){let _=Math.max(0,Math.ceil((v-$)/m)),P=Math.min(h.outWidth,(h.inWidth+v-$)/m);for(let U=0;U<h.outChannels;++U){let W=Math.trunc(U/S),B=U%S,H=0;for(let j=0;j<h.batchSize;++j)for(let Z=D;Z<O;++Z){let te=R+Z*p-w;for(let V=_;V<P;++V){let Q=$+V*m-v;H+=I.get(j,te,Q,W)*E.get(j,Z,V,U)}}b.set(H,R,$,W,B)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var mEe={kernelName:p2,backendName:"cpu",kernelFunc:fEe};function gEe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=a;dt([r,s],"depthwiseConv2DNativeBackpropInput");let h=F.computeStrides(r.shape),p=F.computeStrides(s.shape),m=G.computeConv2DInfo(c,s.shape,i,o,l,u,!0),g=new Za(m.inShape,"float32"),y=g.values,[b,v,w]=g.strides,S=n.data.get(r.dataId).values,[k,I,T]=h,E=n.data.get(s.dataId).values,[R,D,O]=p,{batchSize:$,filterHeight:_,filterWidth:P,inChannels:U,inHeight:W,inWidth:B,outChannels:H,outHeight:j,outWidth:Z,strideHeight:te,strideWidth:V}=m,Q=_-1-m.padInfo.top,ee=P-1-m.padInfo.left,ae=H/U;for(let de=0;de<$;++de)for(let ke=0;ke<U;++ke)for(let Te=0;Te<W;++Te){let $e=Te-Q,Le=Math.max(0,Math.ceil($e/te)),Ge=Math.min(j,(_+$e)/te);for(let Ke=0;Ke<B;++Ke){let at=Ke-ee,vt=Math.max(0,Math.ceil(at/V)),ot=Math.min(Z,(P+at)/V),lt=0;for(let tt=Le;tt<Ge;++tt){let wt=tt*te-$e;for(let It=vt;It<ot;++It){let jn=It*V-at,Dt=k*de+I*tt+T*It,qn=R*(_-1-wt)+D*(P-1-jn)+O*ke;for(let yn=0;yn<ae;++yn){let ca=ke*ae+yn,nn=S[Dt+ca],ua=E[qn+yn];lt+=nn*ua}}}y[b*de+v*Te+w*Ke+ke]=lt}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var yEe={kernelName:f2,backendName:"cpu",kernelFunc:gEe};function bEe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=F.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,i=Wt([r,r],a.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*r+u]=s[u];let l=[...a.shape,...a.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var xEe={kernelName:jw,backendName:"cpu",kernelFunc:bEe},vEe={kernelName:Nf,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(a.dataId).values,c=a.shape.length,h=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:m,inHeight:g,inWidth:y,inChannels:b,outHeight:v,outWidth:w,padInfo:S,strideHeight:k,strideWidth:I,filterHeight:T,filterWidth:E,dilationHeight:R,dilationWidth:D,outShape:O}=G.computeDilation2DInfo(a.shape,r.shape,s,i,"NHWC",o),$=F.sizeFromShape(O),_=O.length,P=F.getArrayFromDType(a.dtype,$);for(let U=0;U<m;++U)for(let W=0;W<v;++W){let B=W*k-S.top;for(let H=0;H<w;++H){let j=H*I-S.left;for(let Z=0;Z<b;++Z){let te=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<T;++Q){let ee=B+Q*R;if(ee>=0&&ee<g)for(let ae=0;ae<E;++ae){let de=j+ae*D;if(de>=0&&de<y){let ke=F.locToIndex([U,ee,de,Z],c,F.computeStrides(a.shape)),Te=F.locToIndex([Q,ae,Z],p,F.computeStrides(r.shape)),$e=u[ke]+h[Te];$e>te&&(te=$e)}}}let V=F.locToIndex([U,W,H,Z],_,F.computeStrides(O));P[V]=te}}}return{dataId:l.write(F.toTypedArray(P,a.dtype),O,a.dtype),shape:O,dtype:a.dtype}}},wEe={kernelName:cy,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=F.toNestedArray(a.shape,u.data.get(a.dataId).values),h=F.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:w,strideHeight:S,strideWidth:k,filterHeight:I,filterWidth:T,dilationHeight:E,dilationWidth:R,outShape:D}=G.computeDilation2DInfo(a.shape,r.shape,i,o,"NHWC",l);F.assert(s.rank===D.length,()=>`Error in ${cy}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);let O=F.toNestedArray(D,u.data.get(s.dataId).values),$=F.makeZerosNestedTypedArray(r.shape,r.dtype);for(let _=0;_<p;++_)for(let P=0;P<b;++P){let U=P*S-w.top;for(let W=0;W<v;++W){let B=W*k-w.left;for(let H=0;H<y;++H){let j=Number.MIN_SAFE_INTEGER,Z=0,te=0;for(let V=0;V<I;++V){let Q=U+V*E;if(Q>=0&&Q<m)for(let ee=0;ee<T;++ee){let ae=B+ee*R;if(ae>=0&&ae<g){let de=c[_][Q][ae][H]+h[V][ee][H];de>j&&(j=de,Z=V,te=ee)}}}$[Z][te][H]+=O[_][P][W][H]}}}return{dataId:u.write(F.toTypedArray($,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},AEe={kernelName:uy,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=F.toNestedArray(a.shape,u.data.get(a.dataId).values),h=F.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:w,strideHeight:S,strideWidth:k,filterHeight:I,filterWidth:T,dilationHeight:E,dilationWidth:R,outShape:D}=G.computeDilation2DInfo(a.shape,r.shape,i,o,"NHWC",l);F.assert(s.rank===D.length,()=>`Error in ${uy}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);let O=F.toNestedArray(D,u.data.get(s.dataId).values),$=F.makeZerosNestedTypedArray(a.shape,a.dtype);for(let _=0;_<p;++_)for(let P=0;P<b;++P){let U=P*S-w.top;for(let W=0;W<v;++W){let B=W*k-w.left;for(let H=0;H<y;++H){let j=Number.MIN_SAFE_INTEGER,Z=U<0?0:U,te=B<0?0:B;for(let V=0;V<I;++V){let Q=U+V*E;if(Q>=0&&Q<m)for(let ee=0;ee<T;++ee){let ae=B+ee*R;if(ae>=0&&ae<g){let de=c[_][Q][ae][H]+h[V][ee][H];de>j&&(j=de,Z=Q,te=ae)}}}$[_][Z][te][H]+=O[_][P][W][H]}}}return{dataId:u.write(F.toTypedArray($,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function SEe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:i}=a,{contextOptions:o,imageOptions:l}=i||{},u=l?.alpha||1,c=o?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let h=s.getContext(c,o?.contextAttributes||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);let[p,m]=r.shape.slice(0,2),g=r.shape.length===2?1:r.shape[2],y=n.data.get(r.dataId).values,b=r.dtype==="float32"?255:1,v=new Uint8ClampedArray(m*p*4);for(let S=0;S<p*m;++S){let k=[0,0,0,255*u];for(let T=0;T<g;T++){let E=y[S*g+T];if(r.dtype==="float32"){if(E<0||E>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${E}.`)}else if(r.dtype==="int32"&&(E<0||E>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${E}.`);g===1?(k[0]=E*b,k[1]=E*b,k[2]=E*b):k[T]=E*b}let I=S*4;v[I+0]=Math.round(k[0]),v[I+1]=Math.round(k[1]),v[I+2]=Math.round(k[2]),v[I+3]=Math.round(k[3])}s.width=m,s.height=p;let w=new ImageData(v,m,p);return h.putImageData(w,0,0),r}var kEe={kernelName:m2,backendName:"cpu",kernelFunc:SEe};function M1(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;dt(r,"sum");let o;r.dtype==="bool"?o=Dh({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):o=au({inputs:{x:r},backend:n});let l=o.shape.length,u=F.parseAxisParam(s,o.shape),c=G.getAxesPermutation(u,l),h=u,p=o;c!=null&&(p=Js({inputs:{x:o},backend:n,attrs:{perm:c}}),h=G.getInnerMostAxes(h.length,l)),G.assertAxesAreInnerMostDims("sum",h,p.shape.length);let[m,g]=G.computeOutAndReduceShapes(p.shape,h),y=G.upcastType(p.dtype,"int32"),b=dN(n,m,y),v=F.sizeFromShape(g),w=n.data.get(b.dataId).values,S=n.data.get(p.dataId).values;for(let k=0;k<w.length;++k){let I=k*v,T=0;for(let E=0;E<v;++E)T+=S[I+E];w[k]=T}if(i){let k=G.expandShapeToKeepDim(b.shape,u),I=b;b=oa({inputs:{x:b},backend:n,attrs:{shape:k}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(p),b}var IEe={kernelName:xm,backendName:"cpu",kernelFunc:M1};function NEe(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=G.decodeEinsumEquation(r,s.length);G.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=G.getEinsumComputePath(o,l),h=c.length,p=null,m=i.length,g=[];for(let y=0;y<h;++y){for(let b of c[y]){let{permutationIndices:v,expandDims:w}=G.getEinsumPermutation(m,l[b]),S;G.isIdentityPermutation(v)?S=s[b]:(S=Js({inputs:{x:s[b]},backend:n,attrs:{perm:v}}),g.push(S));let k=S.shape.slice();for(let I=0;I<w.length;++I)k.splice(w[I],0,1);F.arraysEqual(S.shape,k)||(S=oa({inputs:{x:S},backend:n,attrs:{shape:k}}),g.push(S)),p===null?p=S:(p=EC({inputs:{a:S,b:p},backend:n}),g.push(p))}y<h-1&&(u[y]>=0&&(p=M1({inputs:{x:p},backend:n,attrs:{axis:u[y]-(i.length-m),keepDims:!1}}),g.push(p)),m--)}for(let y of g)y!==p&&n.disposeIntermediateTensorInfo(y);return p}var CEe={kernelName:g2,backendName:"cpu",kernelFunc:NEe};function TEe(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t;dt([a,r],"eluGrad");let s=new Float32Array(F.sizeFromShape(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?s[l]=o[l]:s[l]=o[l]*(u+1)}return n.makeTensorInfo(r.shape,"float32",s)}var EEe={kernelName:rb,backendName:"cpu",kernelFunc:TEe},$Ee=G.ERF_P,_Ee=G.ERF_A1,REe=G.ERF_A2,DEe=G.ERF_A3,OEe=G.ERF_A4,FEe=G.ERF_A5,MEe=Dn(Ef,e=>{let t=Math.sign(e),n=Math.abs(e),a=1/(1+$Ee*n);return t*(1-((((FEe*a+OEe)*a+DEe)*a+REe)*a+_Ee)*a*Math.exp(-n*n))}),LEe={kernelName:Ef,backendName:"cpu",kernelFunc:MEe};function mN(e){let{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(F.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),oa({inputs:{x:r},backend:n,attrs:{shape:o}})}var zEe={kernelName:ib,backendName:"cpu",kernelFunc:mN},BEe=Va((e,t)=>e/t),WL=vr(Cf,BEe),WD={kernelName:Cf,backendName:"cpu",kernelFunc:WL};function A9(e,t,n){let a=e.shape,r=a[0],s=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[r,s],c=F.sizeFromShape(u),h=F.getTypedArrayFromDType("float32",c),p=F.getTypedArrayFromDType("float32",c);for(let b=0;b<r;b++){let v=Mp({inputs:{x:o},backend:n,attrs:{begin:[b,0],size:[1,s]}}),w=Mp({inputs:{x:l},backend:n,attrs:{begin:[b,0],size:[1,s]}}),S=Si({inputs:{real:v,imag:w},backend:n}),{real:k,imag:I}=PEe(S,t,n),T=G.mergeRealAndImagArrays(k,I);for(let E=0;E<s;E++){let R=G.getComplexWithIndex(T,E);h[b*s+E]=R.real,p[b*s+E]=R.imag}n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(S)}let m=n.makeTensorInfo(u,"float32",h),g=n.makeTensorInfo(u,"float32",p),y=Si({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}function PEe(e,t,n){let a=F.sizeFromShape(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(VEe(a)){let o=GD(s,i,a,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",F.createScalarValue(a,"float32")),p=au({inputs:{x:h},backend:n}),m=WD.kernelFunc({inputs:{a:u,b:h},backend:n}),g=WD.kernelFunc({inputs:{a:c,b:p},backend:n}),y=n.data.get(m.dataId).values,b=n.data.get(g.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),{real:y,imag:b}}return o}else{let o=G.mergeRealAndImagArrays(s,i),l=UEe(o,a,t);return G.splitRealAndImagArrays(l)}}function VEe(e){return(e&e-1)===0}function GD(e,t,n,a,r){if(n===1)return{real:e,imag:t};let s=G.mergeRealAndImagArrays(e,t),i=n/2,o=G.complexWithEvenIndex(s),l=o.real,u=o.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),p=r.makeTensorInfo(c,"float32",u),m=Si({inputs:{real:h,imag:p},backend:r}),g=G.complexWithOddIndex(s),y=g.real,b=g.imag,v=[y.length],w=r.makeTensorInfo(v,"float32",y),S=r.makeTensorInfo(v,"float32",b),k=Si({inputs:{real:w,imag:S},backend:r}),I=GD(l,u,i,a,r),T=I.real,E=I.imag,R=[T.length],D=r.makeTensorInfo(R,"float32",T),O=r.makeTensorInfo(R,"float32",E),$=Si({inputs:{real:D,imag:O},backend:r}),_=GD(y,b,i,a,r),P=_.real,U=_.imag,W=[P.length],B=r.makeTensorInfo(W,"float32",P),H=r.makeTensorInfo(W,"float32",U),j=Si({inputs:{real:B,imag:H},backend:r}),Z=G.exponents(n,a),te=[Z.real.length],V=r.makeTensorInfo(te,"float32",Z.real),Q=r.makeTensorInfo(te,"float32",Z.imag),ee=Si({inputs:{real:V,imag:Q},backend:r}),ae=EC({inputs:{a:ee,b:j},backend:r}),de=Ay({inputs:{a:$,b:ae},backend:r}),ke=PL({inputs:{a:$,b:ae},backend:r}),Te=Fp({inputs:{input:de},backend:r}),$e=Fp({inputs:{input:ke},backend:r}),Le=Sy({inputs:{input:de},backend:r}),Ge=Sy({inputs:{input:ke},backend:r}),Ke=ky({inputs:[Te,$e],backend:r,attrs:{axis:0}}),at=ky({inputs:[Le,Ge],backend:r,attrs:{axis:0}}),vt=r.data.get(Ke.dataId).values,ot=r.data.get(at.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(Ge),r.disposeIntermediateTensorInfo(Ke),r.disposeIntermediateTensorInfo(at),{real:vt,imag:ot}}function UEe(e,t,n){let a=new Float32Array(t*2);for(let r=0;r<t;r++){let s=0,i=0;for(let o=0;o<t;o++){let l=G.exponent(r*o,t,n),u=G.getComplexWithIndex(e,o);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(s/=t,i/=t),G.assignToTypedArray(a,s,i,r)}return a}function WEe(e){let{inputs:t,backend:n}=e,{input:a}=t,r=F.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=oa({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=A9(o,!1,n),u=oa({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var GEe={kernelName:y2,backendName:"cpu",kernelFunc:WEe};function GL(e){let{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,i=s||F.inferDtype(r),o=F.getArrayFromDType(i,F.sizeFromShape(a));return jEe(o,r),t.makeTensorInfo(a,i,o)}var HEe={kernelName:qw,backendName:"cpu",kernelFunc:GL};function jEe(e,t,n){e.fill(t)}var qEe={kernelName:ob,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,r=n,s=F.getTypedArrayFromDType(a.dtype,F.sizeFromShape(a.shape)),[i,o,l,u]=a.shape,c=r.data.get(a.dataId).values;for(let h=0;h<i;h++){let p=h*l*o*u;for(let m=0;m<o;m++){let g=m*(l*u);for(let y=0;y<l;y++){let b=y*u;for(let v=0;v<u;v++){let w=Math.round(l-y-1),S=p+g+b+v,k=c[S];if(w>=0&&w<l){let I=w*u,T=p+g+I+v;k=c[T]}s[S]=k}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function KEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=a,y=v9({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){let b=y;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let v=oa({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});y=Ay({inputs:{a:y,b:v},backend:n}),n.disposeIntermediateTensorInfo(v)}else y=Ay({inputs:{a:y,b:i},backend:n});n.disposeIntermediateTensorInfo(b)}if(m){let b=y;if(c==="NCHW"&&m==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let v=oa({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});y=fN(n,y,m,v,g),n.disposeIntermediateTensorInfo(v)}else y=fN(n,y,m,o,g);n.disposeIntermediateTensorInfo(b)}return y}var XEe={kernelName:Sp,backendName:"cpu",kernelFunc:KEe};function YEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=a,y=w9({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){let b=y;y=Ay({inputs:{a:y,b:i},backend:n}),n.disposeIntermediateTensorInfo(b)}if(m){let b=y;y=fN(n,y,m,o,g),n.disposeIntermediateTensorInfo(b)}return y}var QEe={kernelName:kp,backendName:"cpu",kernelFunc:YEe};function ZEe(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=F.sizeFromShape(a.shape),i=r.shape,o=i[i.length-1],[l,u,c,h]=G.prepareAndValidate(a,r);if(u===0)return n.makeTensorInfo(l,a.dtype,[]);let p=n.data.get(r.dataId).values,m=n.bufferSync(a),g=z7(p,m,a.dtype,u,o,c,h,a.shape,s);return n.makeTensorInfo(l,a.dtype,g.values)}var JEe={kernelName:ub,backendName:"cpu",kernelFunc:ZEe};function e$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a;dt([r,s],"gatherV2");let l=F.parseAxisParam(i,r.shape)[0],u=n.data.get(s.dataId).values,c=r.shape[l];for(let k=0;k<u.length;++k){let I=u[k];F.assert(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let h=o;o==null&&(h=0);let p=F.sizeFromShape(s.shape),m=G.segment_util.collectGatherOpShapeInfo(r,s,l,h),g=oa({inputs:{x:r},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),y=oa({inputs:{x:s},backend:n,attrs:{shape:[m.batchSize,p/m.batchSize]}}),b=[m.batchSize,m.outerSize,p/m.batchSize,m.sliceSize],v=n.bufferSync(y),w=n.bufferSync(g),S=B7(w,v,b);return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.makeTensorInfo(m.outputShape,S.dtype,S.values)}var t$e={kernelName:lb,backendName:"cpu",kernelFunc:e$e};function n$e(e){let{inputs:t,backend:n}=e,{input:a}=t,r=F.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=oa({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=A9(o,!0,n),u=oa({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var a$e={kernelName:b2,backendName:"cpu",kernelFunc:n$e},r$e=Dn(Lf,e=>Number.isFinite(e)?1:0,"bool"),s$e={kernelName:Lf,backendName:"cpu",kernelFunc:r$e},i$e=Dn(zf,e=>Math.abs(e)===1/0?1:0,"bool"),o$e={kernelName:zf,backendName:"cpu",kernelFunc:i$e},l$e=Dn(Bf,e=>Number.isNaN(e)?1:0,"bool"),u$e={kernelName:Bf,backendName:"cpu",kernelFunc:l$e};function c$e(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=G7(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}var h$e={kernelName:pb,backendName:"cpu",kernelFunc:c$e},d$e=Dn(Uf,e=>Math.log1p(e)),p$e={kernelName:Uf,backendName:"cpu",kernelFunc:d$e},f$e=Va((e,t)=>e&&t),m$e=vr(fb,f$e,null,"bool"),g$e={kernelName:fb,backendName:"cpu",kernelFunc:m$e},y$e=Dn(mb,e=>e?0:1,"bool"),b$e={kernelName:mb,backendName:"cpu",kernelFunc:y$e},x$e=Va((e,t)=>e||t),v$e=vr(gb,x$e,null,"bool"),w$e={kernelName:gb,backendName:"cpu",kernelFunc:v$e};function A$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;dt(r,"LRN");let u=r.shape[3],c=u-1,h=n.data.get(r.dataId).values,p=F.sizeFromShape(r.shape),m=new Float32Array(p);function g(y){let b=y%u,v=y-b+Math.max(0,b-s),w=y-b+Math.min(b+s,c),S=0;for(;v<=w;v++){let k=h[v];S+=k*k}return S}for(let y=0;y<p;y++){let b=g(y),v=h[y]*Math.pow(i+o*b,-l);m[y]=v}return n.makeTensorInfo(r.shape,r.dtype,m)}var S$e={kernelName:Wf,backendName:"cpu",kernelFunc:A$e};function k$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=a;dt(i,"LRNGrad");let h=F.sizeFromShape(i.shape),p=i.shape[3],m=n.data.get(i.dataId).values,g=n.data.get(r.dataId).values,y=n.data.get(s.dataId).values,b=new Float32Array(h),v=h;for(let w=0;w<v;w++){let S=w%p,k=w-S+Math.max(0,S-o),I=w-S+Math.min(p,S+o+1),T=0;for(let E=k;E<I;E++)T+=Math.pow(g[E],2);T=u*T+l;for(let E=k;E<I;E++){let R=-2*u*c*g[E]*y[w]/T;w===E&&(R+=Math.pow(T,-c)),R*=m[w],b[E]+=R}}return n.makeTensorInfo(i.shape,r.dtype,b)}var I$e={kernelName:yb,backendName:"cpu",kernelFunc:k$e};function S9(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=n,l=r.shape,u=l.length,c=F.parseAxisParam(s,l),h=c,p=G.getAxesPermutation(h,u),m=o.data.get(r.dataId).values;if(p!=null){let k=new Array(u);for(let I=0;I<k.length;I++)k[I]=l[p[I]];m=OL(m,l,r.dtype,p,k),h=G.getInnerMostAxes(h.length,u),l=k}dt(r,"max"),G.assertAxesAreInnerMostDims("max",h,u);let[g,y]=G.computeOutAndReduceShapes(l,h),b=F.sizeFromShape(y),v=j7(m,b,g,r.dtype),w=o.write(v,g,r.dtype),S=g;return i&&(S=G.expandShapeToKeepDim(g,c)),{dataId:w,shape:S,dtype:r.dtype}}var N$e={kernelName:Gf,backendName:"cpu",kernelFunc:S9};function C$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;dt(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;F.assert(G.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=G.computePool2DInfo(r.shape,s,i,u,o,l),h;if(c.filterWidth===1&&c.filterHeight===1&&F.arraysEqual(c.inShape,c.outShape))h=au({inputs:{x:r},backend:n});else{let p=n.data.get(r.dataId).values,m=F.computeStrides(r.shape),g=UL(p,r.shape,r.dtype,m,c,"max");h=n.makeTensorInfo(c.outShape,r.dtype,g.values)}return h}var T$e={kernelName:jf,backendName:"cpu",kernelFunc:C$e};function E$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;dt(r,"maxPool3d");let c=G.computePool3DInfo(r.shape,s,i,1,o,l,u),h=n.data.get(r.dataId).values,p=x9(h,r.shape,r.dtype,F.computeStrides(r.shape),c,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}var $$e={kernelName:bb,backendName:"cpu",kernelFunc:E$e};function _$e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;dt([r,s],"maxPool3DGrad");let c=G.computePool3DInfo(s.shape,i,o,1,l,u),h=n.bufferSync(s),p=xTe(h,c),m=c.strideDepth,g=c.strideHeight,y=c.strideWidth,b=c.dilationDepth,v=c.dilationHeight,w=c.dilationWidth,S=c.effectiveFilterDepth,k=c.effectiveFilterHeight,I=c.effectiveFilterWidth,T=S-1-c.padInfo.front,E=I-1-c.padInfo.left,R=k-1-c.padInfo.top,D=Wt(s.shape,"float32"),O=n.bufferSync(r);for(let $=0;$<c.batchSize;++$)for(let _=0;_<c.inChannels;++_)for(let P=0;P<c.inDepth;++P)for(let U=0;U<c.inHeight;++U)for(let W=0;W<c.inWidth;++W){let B=P-T,H=U-R,j=W-E,Z=0;for(let te=0;te<S;te+=b){let V=(B+te)/m;if(!(V<0||V>=c.outDepth||Math.floor(V)!==V))for(let Q=0;Q<k;Q+=v){let ee=(H+Q)/g;if(!(ee<0||ee>=c.outHeight||Math.floor(ee)!==ee))for(let ae=0;ae<I;ae+=w){let de=(j+ae)/y;if(de<0||de>=c.outWidth||Math.floor(de)!==de)continue;let ke=S*k*I-1-p.get($,V,ee,de,_),Te=te*k*I+Q*I+ae,$e=ke===Te?1:0;if($e===0)continue;let Le=O.get($,V,ee,de,_);Z+=Le*$e}}}D.set(Z,$,P,U,W,_)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}var R$e={kernelName:Xw,backendName:"cpu",kernelFunc:_$e};function D$e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;dt([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=a,p=G.computePool2DInfo(o.shape,l,u,1,c,h),m=n.data.get(o.dataId).values,g=Wt(p.outShape,o.dtype,b9(m,o.shape,o.dtype,p).values),y=p.strideHeight,b=p.strideWidth,v=p.dilationHeight,w=p.dilationWidth,S=p.effectiveFilterHeight,k=p.effectiveFilterWidth,I=k-1-p.padInfo.left,T=S-1-p.padInfo.top,E=Wt(o.shape,"float32"),R=n.data.get(r.dataId).values,D=Wt(r.shape,"float32",R);for(let O=0;O<p.batchSize;++O)for(let $=0;$<p.inChannels;++$)for(let _=0;_<p.inHeight;++_)for(let P=0;P<p.inWidth;++P){let U=_-T,W=P-I,B=0;for(let H=0;H<S;H+=v){let j=(U+H)/y;if(!(j<0||j>=p.outHeight||Math.floor(j)!==j))for(let Z=0;Z<k;Z+=w){let te=(W+Z)/b;if(te<0||te>=p.outWidth||Math.floor(te)!==te)continue;let V=S*k-1-g.get(O,j,te,$),Q=H*k+Z,ee=V===Q?1:0;if(ee===0)continue;let ae=D.get(O,j,te,$);B+=ae*ee}}E.set(B,O,_,P,$)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}var O$e={kernelName:Kw,backendName:"cpu",kernelFunc:D$e};function F$e(e,t,n,a,r){let s=F.computeStrides(t),i=UL(e,t,n,s,r,"max"),o=b9(e,t,n,r,!0,a);return[i.values,o.values]}var M$e={kernelName:Yw,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;dt(a,"MaxPoolWithArgmax");let u=l.data.get(a.dataId).values,c=G.computePool2DInfo(a.shape,r,s,[1,1],i),[h,p]=F$e(u,a.shape,a.dtype,o,c),m=l.write(h,c.outShape,a.dtype),g=l.write(p,c.outShape,a.dtype);return[{dataId:m,shape:c.outShape,dtype:a.dtype},{dataId:g,shape:c.outShape,dtype:"int32"}]}};function L$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=F.parseAxisParam(s,r.shape),l=G.computeOutAndReduceShapes(r.shape,o)[1],u=F.sizeFromShape(l),c=[],h=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(h);let p=Dh({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});c.push(p);let m=WL({inputs:{a:p,b:h},backend:n});c.push(m);let g=M1({inputs:{x:m},backend:n,attrs:{axis:s,keepDims:i}});return c.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}var z$e={kernelName:qf,backendName:"cpu",kernelFunc:L$e};function B$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;dt(r,"min");let o=F.parseAxisParam(s,r.shape),l=o,u=G.getAxesPermutation(l,r.shape.length),c=r;u!=null&&(c=Js({inputs:{x:r},backend:n,attrs:{perm:u}}),l=G.getInnerMostAxes(l.length,r.shape.length)),G.assertAxesAreInnerMostDims("min",l,c.shape.length);let[h,p]=G.computeOutAndReduceShapes(c.shape,l),m=F.sizeFromShape(p),g=F.makeZerosTypedArray(F.sizeFromShape(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){let w=v*m,S=y[w];for(let k=0;k<m;++k){let I=y[w+k];(Number.isNaN(I)||I<S)&&(S=I)}g[v]=S}u!=null&&n.disposeIntermediateTensorInfo(c);let b=n.makeTensorInfo(h,c.dtype,g);if(i){let v=G.expandShapeToKeepDim(h,o),w=oa({inputs:{x:b},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(b),w}return b}var P$e={kernelName:Kf,backendName:"cpu",kernelFunc:B$e};function V$e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a;dt(r,"mirrorPad");let o=s.map((w,S)=>w[0]+r.shape[S]+w[1]),l=s.map(w=>w[0]),u=s.map((w,S)=>w[0]+r.shape[S]),c=i==="reflect"?0:1,h=n.data.get(r.dataId).values,p=r.shape.length,m=F.computeStrides(r.shape),g=F.sizeFromShape(o),y=o.length,b=F.computeStrides(o),v=F.getTypedArrayFromDType(r.dtype,g);for(let w=0;w<g;w++){let S=F.indexToLoc(w,y,b);for(let I=0;I<y;I++)S[I]<l[I]?S[I]=l[I]*2-S[I]-c:S[I]>=u[I]&&(S[I]=(u[I]-1)*2-S[I]+c);S=S.map((I,T)=>I-l[T]);let k=F.locToIndex(S,p,m);v[w]=h[k]}return{dataId:n.write(v,o,r.dtype),shape:o,dtype:r.dtype}}var U$e={kernelName:Yf,backendName:"cpu",kernelFunc:V$e},W$e=Va((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),G$e=vr(Qf,W$e),H$e={kernelName:Qf,backendName:"cpu",kernelFunc:G$e},j$e=Kh(o2());function k9(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=r.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=F.parseAxisParam([o],r.shape),u=S9({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=G.expandShapeToKeepDim(u.shape,l),h=oa({inputs:{x:u},backend:n,attrs:{shape:c}}),p=PL({inputs:{a:r,b:h},backend:n}),m=O7({inputs:{x:p},backend:n}),g=M1({inputs:{x:m},backend:n,attrs:{axis:l,keepDims:!1}}),y=oa({inputs:{x:g},backend:n,attrs:{shape:c}}),b=WL({inputs:{a:m,b:y},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}var q$e={kernelName:vm,backendName:"cpu",kernelFunc:k9};function K$e(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;dt(r,"multinomial");let l=o?r:k9({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,p=[u,s],m=F.makeZerosTypedArray(F.sizeFromShape(p),"int32");for(let g=0;g<u;++g){let y=g*c,b=new Float32Array(c-1);b[0]=h[y];for(let S=1;S<b.length;++S)b[S]=b[S-1]+h[y+S];let v=j$e.alea(i.toString()),w=g*s;for(let S=0;S<s;++S){let k=v();m[w+S]=b.length;for(let I=0;I<b.length;I++)if(k<b[I]){m[w+S]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",m)}var X$e={kernelName:xb,backendName:"cpu",kernelFunc:K$e},Y$e=pu.nonMaxSuppressionV3Impl;function Q$e(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a;dt(r,"NonMaxSuppression");let u=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:h}=Y$e(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var Z$e={kernelName:Ab,backendName:"cpu",kernelFunc:Q$e},J$e=pu.nonMaxSuppressionV4Impl;function e_e(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a;dt(r,"NonMaxSuppressionPadded");let c=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:p,validOutputs:m}=J$e(c,h,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([m]))]}var t_e={kernelName:Sb,backendName:"cpu",kernelFunc:e_e},n_e=pu.nonMaxSuppressionV5Impl;function a_e(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a;dt(r,"NonMaxSuppressionWithScore");let c=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,p=i,m=o,g=l,y=u,{selectedIndices:b,selectedScores:v}=n_e(c,h,p,m,g,y);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}var r_e={kernelName:kb,backendName:"cpu",kernelFunc:a_e};function s_e(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a;dt(r,"oneHot");let u=F.sizeFromShape(r.shape),c=new Float32Array(u*i);c.fill(l);let h=n.data.get(r.dataId).values;for(let p=0;p<u;++p)h[p]>=0&&h[p]<i&&(c[p*i+h[p]]=o);return n.makeTensorInfo([...r.shape,i],s,c)}var i_e={kernelName:Jf,backendName:"cpu",kernelFunc:s_e};function gN(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(a.dtype==="complex64"){let r=Fp({inputs:{input:a},backend:n}),s=gN({inputs:{x:r},backend:n}),i=Sy({inputs:{input:a},backend:n}),o=gN({inputs:{x:i},backend:n}),l=Si({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return GL({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var o_e={kernelName:Wb,backendName:"cpu",kernelFunc:gN};function I9(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(a.dtype==="complex64"){let r=Fp({inputs:{input:a},backend:n}),s=I9({inputs:{x:r},backend:n}),i=Sy({inputs:{input:a},backend:n}),o=gN({inputs:{x:i},backend:n}),l=Si({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return GL({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}var l_e={kernelName:Ib,backendName:"cpu",kernelFunc:I9};function N9(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return mN({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{F.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),F.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let h=mN({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),u=ky({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var u_e={kernelName:Nb,backendName:"cpu",kernelFunc:N9};function c_e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;dt(r,"pad");let o=s.map((v,w)=>v[0]+r.shape[w]+v[1]),l=s.map(v=>v[0]),u=n.data.get(r.dataId).values,c=F.sizeFromShape(r.shape),h=r.shape.length,p=F.computeStrides(r.shape),m=F.sizeFromShape(o),g=o.length,y=F.computeStrides(o),b=F.getTypedArrayFromDType(r.dtype,m);i!==0&&b.fill(i);for(let v=0;v<c;v++){let w=F.indexToLoc(v,h,p).map((k,I)=>k+l[I]),S=F.locToIndex(w,g,y);b[S]=u[v]}return{dataId:n.write(b,o,r.dtype),shape:o,dtype:r.dtype}}var C9={kernelName:em,backendName:"cpu",kernelFunc:c_e},h_e=Va((e,t)=>Math.pow(e,t)),d_e=vr(tm,h_e),p_e={kernelName:tm,backendName:"cpu",kernelFunc:d_e};function f_e(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(v=>n.data.get(v.dataId).values),u=r.map(v=>v.shape),c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,[p,m,g]=Z7(l,u,c,s.shape,s.dtype,h,i.shape),y=p.map(v=>n.makeTensorInfo([v.length],"int32",v)),b=n.makeTensorInfo(g,s.dtype,m);return y.concat([b])}var m_e={kernelName:v2,backendName:"cpu",kernelFunc:f_e};function g_e(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=J7(i,a.shape,a.dtype,o,r.shape,l,s.shape),h=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],a.dtype,c);return[h,p]}var y_e={kernelName:w2,backendName:"cpu",kernelFunc:g_e};function b_e(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,p=o.map(b=>n.data.get(b.dataId).values),m=o.map(b=>b.shape),[g,y]=e9(u,r.shape,c,s.shape,s.dtype,h,i.shape,p,m,l);return n.makeTensorInfo(g,s.dtype,y)}var x_e={kernelName:A2,backendName:"cpu",kernelFunc:b_e};function v_e(e){let{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=FL(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}var w_e={kernelName:Qw,backendName:"cpu",kernelFunc:v_e},A_e=Dn(rm,e=>1/e),S_e={kernelName:rm,backendName:"cpu",kernelFunc:A_e};function k_e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;dt(r,"resizeBilinear");let l=F.computeStrides(r.shape),[u,c]=o,[h,p,m,g]=r.shape,y=n.data.get(r.dataId).values,b=new Float32Array(F.sizeFromShape([h,u,c,g])),v=[s&&u>1?p-1:p,s&&c>1?m-1:m],w=[s&&u>1?u-1:u,s&&c>1?c-1:c],S=0,k=v[0]/w[0],I=v[1]/w[1];for(let T=0;T<h;T++)for(let E=0;E<u;E++){let R;i?R=k*(E+.5)-.5:R=k*E;let D=Math.max(0,Math.floor(R)),O=R-D,$=Math.min(p-1,Math.ceil(R)),_=T*l[0]+D*l[1],P=T*l[0]+$*l[1];for(let U=0;U<c;U++){let W;i?W=I*(U+.5)-.5:W=I*U;let B=Math.max(0,Math.floor(W)),H=W-B,j=Math.min(m-1,Math.ceil(W)),Z=_+B*l[2],te=P+B*l[2],V=_+j*l[2],Q=P+j*l[2];for(let ee=0;ee<g;ee++){let ae=y[Z+ee],de=y[te+ee],ke=y[V+ee],Te=y[Q+ee],$e=ae+(ke-ae)*H,Le=de+(Te-de)*H,Ge=$e+(Le-$e)*O;b[S++]=Ge}}}return n.makeTensorInfo([h,u,c,g],"float32",b)}var I_e={kernelName:om,backendName:"cpu",kernelFunc:k_e};function N_e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;dt([s,r],"resizeBilinearGrad");let o=F.computeStrides(r.shape),[l,u,c,h]=r.shape,[,p,m]=s.shape,g=new Float32Array(l*u*c*h),y=[i&&p>1?u-1:u,i&&m>1?c-1:c],b=[i&&p>1?p-1:p,i&&m>1?m-1:m],v=y[0]/b[0],w=y[1]/b[1],S=n.data.get(s.dataId).values,k=0;for(let I=0;I<l;I++){let T=I*o[0];for(let E=0;E<p;E++){let R=E*v,D=Math.floor(R),O=Math.min(Math.ceil(R),u-1),$=T+D*o[1],_=T+O*o[1],P=R-D,U=1-P;for(let W=0;W<m;W++){let B=W*w,H=Math.floor(B),j=Math.min(Math.ceil(B),c-1),Z=B-H,te=1-Z,V=$+H*o[2],Q=$+j*o[2],ee=_+H*o[2],ae=_+j*o[2],de=U*te,ke=U*Z,Te=P*te,$e=P*Z;for(let Le=0;Le<h;Le++){let Ge=S[k++];g[V+Le]+=Ge*de,g[Q+Le]+=Ge*ke,g[ee+Le]+=Ge*Te,g[ae+Le]+=Ge*$e}}}}return n.makeTensorInfo([l,c,u,h],"float32",g)}var C_e={kernelName:Eb,backendName:"cpu",kernelFunc:N_e};function T_e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;dt(r,"resizeNearestNeighbor");let l=F.computeStrides(r.shape),[u,c]=o,[h,p,m,g]=r.shape,y=n.data.get(r.dataId).values,b=new Float32Array(h*u*c*g),v=[s&&u>1?p-1:p,s&&c>1?m-1:m],w=[s&&u>1?u-1:u,s&&c>1?c-1:c],S=v[0]/w[0],k=v[1]/w[1],I=0;for(let T=0;T<h;T++){let E=T*l[0];for(let R=0;R<u;R++){let D=i?S*(R+.5):S*R,O=Math.min(p-1,s?Math.round(D):Math.floor(D));i&&(O=Math.max(0,O));let $=E+O*l[1];for(let _=0;_<c;_++){let P=i?k*(_+.5):k*_,U=Math.min(m-1,s?Math.round(P):Math.floor(P));i&&(U=Math.max(0,U));let W=$+U*l[2];for(let B=0;B<g;B++){let H=y[W+B];b[I++]=H}}}}return n.makeTensorInfo([h,u,c,g],r.dtype,b)}var E_e={kernelName:im,backendName:"cpu",kernelFunc:T_e};function $_e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;dt([s,r],"resizeNearestNeighborGrad");let o=F.computeStrides(r.shape),l=F.computeStrides(s.shape),[u,c,h,p]=r.shape,[,m,g]=s.shape,y=new Float32Array(u*c*h*p),b=n.data.get(s.dataId).values,v=[i&&m>1?c-1:c,i&&g>1?h-1:h],w=[i&&m>1?m-1:m,i&&g>1?g-1:g],S=v[0]/w[0],k=v[1]/w[1],I=1/S,T=1/k,E=Math.ceil(I)*2+2,R=Math.ceil(T)*2+2;for(let D=0;D<u;D++){let O=D*o[0];for(let $=0;$<c;$++){let _=O+$*o[1],P=Math.floor($*I),U=Math.floor(P-E/2);for(let W=0;W<h;W++){let B=_+W*o[2],H=Math.floor(W*T),j=Math.floor(H-R/2);for(let Z=0;Z<p;Z++){let te=0;for(let V=0;V<E;V++){let Q=V+U;if(Q<0||Q>=m)continue;let ee=O+Q*l[1],ae=Q*S,de=Math.min(c-1,i?Math.round(ae):Math.floor(ae));if($===de)for(let ke=0;ke<R;ke++){let Te=ke+j;if(Te<0||Te>=g)continue;let $e=ee+Te*l[2],Le=Te*k,Ge=Math.min(h-1,i?Math.round(Le):Math.floor(Le));W===Ge&&(te+=b[$e+Z])}}y[B+Z]=te}}}}return n.makeTensorInfo(r.shape,r.dtype,y)}var __e={kernelName:Tb,backendName:"cpu",kernelFunc:$_e};function R_e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;dt(r,"reverse");let i=r.shape.length,o=F.parseAxisParam(s,r.shape);if(i===0)return au({inputs:{x:r},backend:n});let l=new Za(r.shape,r.dtype),u=n.bufferSync(r);for(let c=0;c<l.size;c++){let h=l.indexToLoc(c),p=h.slice();o.forEach(m=>p[m]=r.shape[m]-1-p[m]),l.set(u.get(...p),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var D_e={kernelName:um,backendName:"cpu",kernelFunc:R_e},O_e={kernelName:Gb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=F.getTypedArrayFromDType(a.dtype,F.sizeFromShape(a.shape)),[u,c,h,p]=a.shape,[m,g]=G.getImageCenter(i,c,h),y=255,b=Math.sin(r),v=Math.cos(r),w=o.data.get(a.dataId).values;for(let S=0;S<u;S++){let k=S*h*c*p;for(let I=0;I<c;I++){let T=I*(h*p);for(let E=0;E<h;E++){let R=E*p;for(let D=0;D<p;D++){let O=[u,I,E,D],$=O[2],_=O[1],P=($-m)*v-(_-g)*b,U=($-m)*b+(_-g)*v;P=Math.round(P+m),U=Math.round(U+g);let W=s;if(typeof s!="number"&&(D===3?W=y:W=s[D]),P>=0&&P<h&&U>=0&&U<c){let H=U*(h*p),j=P*p,Z=k+H+j+D;W=w[Z]}let B=k+T+R+D;l[B]=W}}}}return{dataId:o.write(l,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},F_e=Dn(cm,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),M_e={kernelName:cm,backendName:"cpu",kernelFunc:F_e};function L_e(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=G.calculateShapes(s,r,i),p=!0,m=n.bufferSync(r),g=n.bufferSync(s),y=cp(m,g,i,h,u,l,o,c,0,p);return n.makeTensorInfo(i,y.dtype,y.values)}var z_e={kernelName:$b,backendName:"cpu",kernelFunc:L_e};function B_e(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function P_e(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}function V_e(e,t,n,a,r,s){let i=F.getArrayFromDType("int32",n*r);for(let o=0;o<n;++o){let l=e.slice(o*a,(o+1)*a),u=o*r;for(let c=0;c<r;++c)i[u+c]=s==="left"?B_e(l,t[c+u]):P_e(l,t[c+u])}return i}function U_e(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=V_e(o,l,r.shape[0],r.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",u)}var W_e={kernelName:Rb,backendName:"cpu",kernelFunc:U_e};function G_e(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;dt([a,r,s],"select");let i=a.shape.length,o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=ro(r.dtype,s.dtype),h=F.makeZerosTypedArray(F.sizeFromShape(r.shape),c),p=0,m=i===0||i>1||r.shape.length===1?1:F.sizeFromShape(r.shape.slice(1));for(let g=0;g<o.length;g++)for(let y=0;y<m;y++)o[g]===1?h[p++]=l[g]:h[p++]=u[g];return n.makeTensorInfo(r.shape,c,h)}var H_e={kernelName:Db,backendName:"cpu",kernelFunc:G_e},j_e=G.SELU_SCALEALPHA,q_e=G.SELU_SCALE,K_e=Dn(dm,e=>e>=0?q_e*e:j_e*(Math.exp(e)-1)),X_e={kernelName:dm,backendName:"cpu",kernelFunc:K_e},Y_e=Dn(mm,e=>e<0?-1:e>0?1:0),Q_e={kernelName:mm,backendName:"cpu",kernelFunc:Y_e},Z_e=Dn(pm,e=>Math.sin(e)),J_e={kernelName:pm,backendName:"cpu",kernelFunc:Z_e},eRe=Dn(fm,e=>Math.sinh(e)),tRe={kernelName:fm,backendName:"cpu",kernelFunc:eRe},nRe=11920928955078125e-23,CH=Math.log(nRe)+2,aRe=Dn(ym,e=>{let t=e>-CH,n=e<CH,a=Math.exp(e),r;return n?r=a:t?r=e:r=Math.log(1+a),r}),rRe={kernelName:ym,backendName:"cpu",kernelFunc:aRe};function sRe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;dt([r],"spaceToBatchND");let o=F.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let b=1+s.length;b<r.shape.length;++b)l.push([0,0]);let u=C9.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=G.getReshaped(u.shape,s,o,!1),h=G.getPermuted(c.length,s.length,!1),p=G.getReshapedPermuted(u.shape,s,o,!1),m=oa({inputs:{x:u},backend:n,attrs:{shape:c}}),g=Js({inputs:{x:m},backend:n,attrs:{perm:h}}),y=oa({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}var iRe={kernelName:Fb,backendName:"cpu",kernelFunc:sRe};function oRe(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[h,p,m,g,y]=a9(o,a.shape,a.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(p,a.dtype,h),n.makeTensorInfo([p[0]],r.dtype,m),n.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(b=>Number(b)))),n.makeTensorInfo([y.length],a.dtype,new Int32Array(y))]}var lRe={kernelName:Zw,backendName:"cpu",kernelFunc:oRe};function uRe(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,h]=r9(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(c,a.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var cRe={kernelName:Lb,backendName:"cpu",kernelFunc:uRe};function hRe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=ML(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(c,a.dtype,u)}var dRe={kernelName:Jw,backendName:"cpu",kernelFunc:hRe};function pRe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=ML(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(c,a.dtype,u)}var fRe={kernelName:e1,backendName:"cpu",kernelFunc:pRe};function mRe(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=G.calculateShapes(s,r,o),m=!1,g=n.bufferSync(r),y;switch(s.dtype){case"bool":{let b=n.bufferSync(s),v=!!n.data.get(i.dataId).values[0];y=cp(g,b,o,p,c,u,l,h,v,m);break}case"float32":{let b=n.bufferSync(s),v=n.data.get(i.dataId).values[0];y=cp(g,b,o,p,c,u,l,h,v,m);break}case"int32":{let b=n.bufferSync(s),v=n.data.get(i.dataId).values[0];y=cp(g,b,o,p,c,u,l,h,v,m);break}case"string":{let b=n.bufferSync(s),v=F.decodeString(n.data.get(i.dataId).values[0]);y=cp(g,b,o,p,c,u,l,h,v,m);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,y.dtype,y.values)}var gRe={kernelName:zb,backendName:"cpu",kernelFunc:mRe};function yRe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=F.parseAxisParam(i,r.shape)[0],l=G.prepareSplitSize(r,s,o),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{let p=[...c];p[o]=h;let m=Mp({inputs:{x:r},backend:n,attrs:{begin:u,size:p}});return u[o]+=h,m})}var bRe={kernelName:Mb,backendName:"cpu",kernelFunc:yRe},xRe={kernelName:t1,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,a=t;dt(n,"square");let r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let i=0;i<r.length;++i){let o=r[i];s[i]=o*o}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},vRe=Dn(Zh,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),wRe={kernelName:Zh,backendName:"cpu",kernelFunc:vRe};function ARe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=a;dt(r,"stridedSlice");let{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:b,isSimpleSlice:v,begin:w,end:S,strides:k}=mr.sliceInfo(r.shape,s,i,o,l,u,c,h,p),I;if(y)I=oa({inputs:{x:r},backend:n,attrs:{shape:g}});else if(b||v){F.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let T=mr.computeOutShape(w,S,k),E=Mp({inputs:{x:r},backend:n,attrs:{begin:w,size:T}});I=oa({inputs:{x:E},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(E)}else{let T=n.bufferSync(r),E=o9(m,T,k,w);I=n.makeTensorInfo(g,E.dtype,E.values)}return I}var SRe={kernelName:Bb,backendName:"cpu",kernelFunc:ARe};function kRe(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:c,dataSplits:h}=t,p=n.data.get(c.dataId).values,m=n.data.get(h.dataId).values,[g,y]=LL(p,m,r,s,i,o,l,u);return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(h.shape,"int32",y)]}var IRe={kernelName:a1,backendName:"cpu",kernelFunc:kRe};function NRe(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,h]=zL(o,l,r),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var CRe={kernelName:r1,backendName:"cpu",kernelFunc:NRe};function TRe(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=BL(i,r);return n.makeTensorInfo(s.shape,"int32",o)}var ERe={kernelName:s1,backendName:"cpu",kernelFunc:TRe},$Re=Dn(Sm,e=>Math.tan(e)),_Re={kernelName:Sm,backendName:"cpu",kernelFunc:$Re},RRe=Dn(km,e=>Math.tanh(e)),DRe={kernelName:km,backendName:"cpu",kernelFunc:RRe};function ORe(e){let{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=G.calculateShapes(s,r,a.shape),h=!1,p=n.bufferSync(r),m=n.bufferSync(s),g=n.bufferSync(a),y=cp(p,m,a.shape,c,l,o,i,u,g,h);return n.makeTensorInfo(a.shape,y.dtype,y.values)}var FRe={kernelName:_b,backendName:"cpu",kernelFunc:ORe};function MRe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;dt(r,"tile");let i=u9(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var LRe={kernelName:Qh,backendName:"cpu",kernelFunc:MRe};function zRe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;dt(r,"topk");let o=n.data.get(r.dataId).values,[l,u]=h9(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var BRe={kernelName:Pb,backendName:"cpu",kernelFunc:zRe};function PRe(e){let{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,p,m]=r.shape,[g,y]=u??[h,p],b=[c,g,y,m],v=F.computeStrides(r.shape),w=v[0],S=v[1],k=v[2],I=F.computeStrides(b),T=I[0],E=I[1],R=I[2],D=F.getTypedArrayFromDType(r.dtype,F.sizeFromShape(b));D.fill(l);let O=a.data.get(r.dataId).values,$=a.data.get(s.dataId).values;for(let _=0;_<c;++_){let P=s.shape[0]===1?$:$.subarray(_*8,_*8+8);for(let U=0;U<g;++U)for(let W=0;W<y;++W)for(let B=0;B<m;++B){let H,j=P[6]*W+P[7]*U+1;if(j===0)continue;let Z=(P[0]*W+P[1]*U+P[2])/j,te=(P[3]*W+P[4]*U+P[5])/j,V=TH(Z,p,o),Q=TH(te,h,o);switch(i){case"nearest":H=jRe(O,h,p,w,S,k,_,Q,V,B,l);break;case"bilinear":H=qRe(O,h,p,w,S,k,_,Q,V,B,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ee=_*T+U*E+W*R+B;D[ee]=H}return a.makeTensorInfo(b,r.dtype,D)}return{dataId:a.write(D,b,r.dtype),shape:r.shape,dtype:r.dtype}}var VRe={kernelName:Vb,backendName:"cpu",kernelFunc:PRe};function TH(e,t,n){switch(n){case"reflect":return URe(e,t);case"wrap":return WRe(e,t);case"nearest":return HRe(e,t);default:return GRe(e)}}function URe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=2*t;n<a&&(n=a*Math.trunc(-n/a)+n),n=n<-t?n+a:-n-1}else if(n>t-1)if(t<=1)n=0;else{let a=2*t;n-=a*Math.trunc(n/a),n>=t&&(n=a-n-1)}return F.clamp(0,n,t-1)}function WRe(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=t-1;n+=t*(Math.trunc(-n/a)+1)}else if(n>t-1)if(t<=1)n=0;else{let a=t-1;n-=t*Math.trunc(n/a)}return F.clamp(0,n,t-1)}function GRe(e,t){return e}function HRe(e,t){return F.clamp(0,e,t-1)}function Dv(e,t,n,a,r,s,i,o,l,u,c){let h=i*a+o*r+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[h]:c}function jRe(e,t,n,a,r,s,i,o,l,u,c){let h=Math.round(o),p=Math.round(l);return Dv(e,t,n,a,r,s,i,h,p,u,c)}function qRe(e,t,n,a,r,s,i,o,l,u,c){let h=Math.floor(o),p=Math.floor(l),m=h+1,g=p+1,y=(g-l)*Dv(e,t,n,a,r,s,i,h,p,u,c)+(l-p)*Dv(e,t,n,a,r,s,i,h,g,u,c),b=(g-l)*Dv(e,t,n,a,r,s,i,m,p,u,c)+(l-p)*Dv(e,t,n,a,r,s,i,m,g,u,c);return(m-o)*y+(o-h)*b}function KRe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;dt(s,"unique");let i=a.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=VL(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],"int32",u)]}var XRe={kernelName:i1,backendName:"cpu",kernelFunc:KRe};function YRe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape.length,o=r.shape[s],l=new Array(i-1),u=0;for(let m=0;m<i;m++)m!==s&&(l[u++]=r.shape[m]);let c=new Array(i).fill(0),h=r.shape.slice();h[s]=1;let p=new Array(o);for(let m=0;m<p.length;m++){c[s]=m;let g=Mp({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});p[m]=oa({inputs:{x:g},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(g)}return p}var QRe={kernelName:Ub,backendName:"cpu",kernelFunc:YRe};function ZRe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a;dt(r,"unsortedSegmentSum");let o=r.shape.length,l=s.shape.length,u=[],c=[],h=o-l,p=s;for(let g=0;g<h;++g){let y=mN({inputs:{input:p},backend:n,attrs:{dim:g+1}});p=y,c.push(y)}for(let g=0;g<i;++g){let y=F.createScalarValue(g,"int32"),b=n.makeTensorInfo([],"int32",y),v=R7({inputs:{a:b,b:p},backend:n}),w=Dh({inputs:{x:v},backend:n,attrs:{dtype:"float32"}}),S=EC({inputs:{a:w,b:r},backend:n}),k=M1({inputs:{x:S},backend:n,attrs:{axis:0,keepDims:!1}});u.push(k),c.push(b),c.push(v),c.push(w),c.push(S),c.push(k)}let m=N9({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var JRe={kernelName:o1,backendName:"cpu",kernelFunc:ZRe},eDe=[qCe,N2e,XCe,QCe,R2e,JCe,tTe,aTe,sTe,oTe,uTe,hTe,pTe,gTe,bTe,wTe,STe,ITe,CTe,HCe,ETe,_Te,DTe,O2e,FTe,$2e,M2e,LTe,C2e,BTe,VTe,UTe,GTe,jTe,KTe,YTe,ZTe,eEe,nEe,rEe,iEe,lEe,cEe,dEe,pEe,mEe,yEe,xEe,vEe,wEe,AEe,kEe,CEe,zCe,EEe,L2e,LEe,z2e,zEe,P2e,GEe,HEe,qEe,U2e,G2e,XEe,QEe,JEe,t$e,j2e,K2e,T2e,a$e,PTe,s$e,o$e,u$e,BCe,Y2e,Z2e,h$e,eCe,p$e,g$e,b$e,w$e,S$e,I$e,N$e,nCe,T$e,$$e,R$e,O$e,M$e,z$e,P$e,rCe,U$e,H$e,X$e,iCe,lCe,Z$e,t_e,r_e,cCe,i_e,l_e,u_e,C9,p_e,VCe,pCe,m_e,y_e,x_e,w_e,E2e,WD,S_e,UCe,WCe,GCe,I_e,C_e,E_e,__e,D_e,O_e,M_e,ACe,z_e,W_e,H_e,X_e,kCe,Q_e,J_e,tRe,ICe,q$e,rRe,iRe,lRe,cRe,dRe,fRe,gRe,bRe,TCe,xRe,$Ce,RCe,wRe,SRe,IRe,CRe,ERe,MCe,IEe,_Re,DRe,FRe,LRe,BRe,VRe,hCe,XRe,QRe,JRe,o_e];for(let e of eDe)l1(e);var T9={};Lt(T9,{assertNotComplex:()=>ax,bindCanvasToFramebuffer:()=>hDe,bindColorTextureToFramebuffer:()=>$I,bindTextureToProgramUniformSampler:()=>G9,bindTextureUnit:()=>V9,bindVertexBufferToProgramAttribute:()=>HD,callAndCheck:()=>et,canBeRepresented:()=>$9,createFragmentShader:()=>D9,createFramebuffer:()=>P9,createProgram:()=>O9,createStaticIndexBuffer:()=>L9,createStaticVertexBuffer:()=>M9,createTexture:()=>z9,createVertexShader:()=>R9,getBatchDim:()=>Lp,getExtensionOrThrow:()=>Ov,getFramebufferErrorMessage:()=>H9,getMaxTexturesInShader:()=>X9,getNumChannels:()=>uDe,getProgramUniformLocation:()=>W9,getProgramUniformLocationOrThrow:()=>U9,getRowsCols:()=>zp,getShapeAs3D:()=>Mv,getTextureShapeFromLogicalShape:()=>q9,getWebGLDisjointQueryTimerVersion:()=>Y9,getWebGLErrorMessage:()=>_9,getWebGLMaxTextureSize:()=>K9,hasExtension:()=>Qi,isCapableOfRenderingToFloatTexture:()=>Q9,isDownloadFloatTextureEnabled:()=>Z9,isReshapeFree:()=>dw,isWebGLFenceEnabled:()=>J9,isWebGLVersionEnabled:()=>qD,linkProgram:()=>F9,logShaderSourceAndInfoLog:()=>jL,resetMaxTextureSize:()=>dDe,resetMaxTexturesInShader:()=>pDe,unbindColorTextureFromFramebuffer:()=>jD,unbindTextureUnit:()=>cDe,validateFramebuffer:()=>Fv,validateProgram:()=>EI,validateTextureSize:()=>B9});var ap={},Zk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function E9(e,t){ap[e]=t}function ml(e,t){if(!(e in ap)||t!=null){let a=nDe(e,t);if(a!==null)ap[e]=a;else return console.log("Could not get context for WebGL version",e),null}let n=ap[e];return n==null||n.isContextLost()?(delete ap[e],ml(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),ap[e])}function tDe(e){if(!xe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function nDe(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??tDe(e);return n.addEventListener("webglcontextlost",a=>{a.preventDefault(),delete ap[e]},!1),xe().getBool("SOFTWARE_WEBGL_ENABLED")&&(Zk.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Zk)||n.getContext("experimental-webgl",Zk):n.getContext("webgl2",Zk)}var hw;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(hw||(hw={}));var Yi;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Yi||(Yi={}));var Hr;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Hr||(Hr={}));function L1(e,t){return[t,e]}function aDe(e,t){return e*t}function Jk(e){let t=F.sizeFromShape(e),n=Math.ceil(t/4);return F.sizeToSquarishShape(n)}function nx(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function rDe(e,t){let[n,a]=nx(e,t);return n*a*4}function HL(e,t){let n=e,a,r,s,i,o,l,u,c,h,p;return xe().getNumber("WEBGL_VERSION")===2?(a=n.R32F,r=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,h=t!=null?t.HALF_FLOAT_OES:null,p=e.FLOAT,l=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:p}}function et(e,t){let n=t();return xe().getBool("DEBUG")&&sDe(e),n}function sDe(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+_9(e,t))}var iDe=596e-10,oDe=65504;function $9(e){return!!(xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||iDe<Math.abs(e)&&Math.abs(e)<oDe)}function _9(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Ov(e,t){return fc(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function R9(e,t){let n=fc(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(et(e,()=>e.shaderSource(n,t)),et(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function D9(e,t){let n=fc(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(et(e,()=>e.shaderSource(n,t)),et(e,()=>e.compileShader(n)),xe().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw jL(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var lDe=/ERROR: [0-9]+:([0-9]+):/g;function jL(e,t){let n=lDe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let a=+n[1],r=e.split(`
`),s=r.length.toString().length+2,i=r.map((h,p)=>F.rightPad((p+1).toString(),s)+h),o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);let l=i.slice(0,a-1),u=i.slice(a-1,a),c=i.slice(a);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${F.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function O9(e){return fc(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function F9(e,t){if(et(e,()=>e.linkProgram(t)),!xe().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function EI(e,t){if(et(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function M9(e,t){let n=fc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),et(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function L9(e,t){let n=fc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return et(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),et(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function uDe(){return xe().getNumber("WEBGL_VERSION")===2?1:4}function z9(e){return fc(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function B9(e,t){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let a=`[${e}x${t}]`;throw new Error("Requested texture size "+a+" is invalid.")}if(e>n||t>n){let a=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}function P9(e){return fc(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function HD(e,t,n,a,r,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),et(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),et(e,()=>e.enableVertexAttribArray(o)),!0)}function V9(e,t,n){j9(e,n),et(e,()=>e.activeTexture(e.TEXTURE0+n)),et(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function cDe(e,t){j9(e,t),et(e,()=>e.activeTexture(e.TEXTURE0+t)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function U9(e,t,n){return fc(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function W9(e,t,n){return e.getUniformLocation(t,n)}function G9(e,t,n,a){et(e,()=>V9(e,t,a)),et(e,()=>e.uniform1i(n,a))}function hDe(e){et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),et(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),et(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function $I(e,t,n){et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),et(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function jD(e,t){et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),et(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Fv(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+H9(e,t))}function H9(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function fc(e,t,n){let a=et(e,()=>t());if(a==null)throw new Error(n);return a}function j9(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){let r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Lp(e,t=2){return F.sizeFromShape(e.slice(0,e.length-t))}function zp(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Mv(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Lp(e),...zp(e)]),t}function q9(e,t=!1){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=xe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");a===1/0&&xe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n=n*2,a=a*2,e=e.map((o,l)=>l>=e.length-2?F.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=F.squeezeShape(e).newShape);let r=F.sizeFromShape(e),s=null;e.length<=1&&r<=n?s=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=Lp(e),l=2,u=2;e.length&&([l,u]=zp(e)),r=o*(l/2)*(u/2),s=F.sizeToSquarishShape(r).map(c=>c*2)}else s=F.sizeToSquarishShape(r);return s}function eI(e){return e%2===0}function dw(e,t){if(e=e.slice(-2),t=t.slice(-2),F.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],a=t[t.length-1];if(n===a||eI(n)&&eI(a)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&eI(e[0])&&eI(t[0])}var _I,RI;function K9(e){if(_I==null){let t=ml(e);_I=t.getParameter(t.MAX_TEXTURE_SIZE)}return _I}function dDe(){_I=null}function pDe(){RI=null}function X9(e){if(RI==null){let t=ml(e);RI=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,RI)}function Y9(e){if(e===0)return 0;let t,n=ml(e);return Qi(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Qi(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Qi(e,t){return e.getExtension(t)!=null}function qD(e){try{if(ml(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Q9(e){if(e===0)return!1;let t=ml(e);if(e===1){if(!Qi(t,"OES_texture_float"))return!1}else if(!Qi(t,"EXT_color_buffer_float"))return!1;return KD(t)}function Z9(e){if(e===0)return!1;let t=ml(e);if(e===1){if(!Qi(t,"OES_texture_float")||!Qi(t,"WEBGL_color_buffer_float"))return!1}else{if(Qi(t,"EXT_color_buffer_float"))return KD(t);let n="EXT_color_buffer_half_float";if(Qi(t,n)){let a=t.getExtension(n);return fDe(t,a)}return!1}return KD(t)}function KD(e){let t=HL(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function fDe(e,t){let n=HL(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}function J9(e){return e!==2?!1:ml(e).fenceSync!=null}function ax(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&F.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var ft=xe();ft.registerFlag("HAS_WEBGL",()=>ft.getNumber("WEBGL_VERSION")>0);ft.registerFlag("WEBGL_VERSION",()=>qD(2)?2:qD(1)?1:0);ft.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ft.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ft.get("WEBGL_VERSION")===2);ft.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ft.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ft.registerFlag("WEBGL_PACK",()=>ft.getBool("HAS_WEBGL"));ft.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_CLIP",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_REDUCE",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_LAZILY_UNPACK",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_CONV_IM2COL",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>K9(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>X9(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=ft.getNumber("WEBGL_VERSION");return e===0?0:Y9(e)});ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ft.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!h1.isMobile());ft.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Q9(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ft.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ft.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ft.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Z9(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_FENCE_API_ENABLED",()=>J9(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ft.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ft.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});ft.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>h1.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});ft.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ft.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ft.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ft.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ft.registerFlag("WEBGL_EXP_CONV",()=>!1);ft.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ft.getBool("IS_TEST"));ft.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ft.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ft.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ft.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Ms(){let e,t,n,a,r,s,i,o,l,u;return xe().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",i="out vec4 outputColor;",o=xe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Rm(e,t,n="index"){let a=F.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / ${r}`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r}`:`index -= ${e[s]} * ${r}`;return`${i}; ${o};`}).join("")}function $C(e,t,n="index"){let a=F.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function mDe(e,t){let n=e.length,a=e.map(s=>`${t}[${s}]`),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]=`(${r[s+1]} * ${a[s+1]})`;return r}function gDe(e,t,n="index"){let a=e.map((s,i)=>i),r=mDe(a,t);return r.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${r[i]}`,l=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${l};`}).join("")}function qL(e){let t=F.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function KL(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var eY=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:tY}=G;function yDe(e,t,n){let a=[];if(e.forEach(p=>{let m=F.sizeFromShape(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?a.push(`uniform float ${p.name}${m>1?`[${m}]`:""};`):(a.push(`uniform sampler2D ${p.name};`),a.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){let{uniformShape:g}=XL(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:a.push(`uniform int ${p.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${p.name}Shape;`);break}a.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;");break}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{a.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});let r=a.join(`
`),s=e.map(p=>bDe(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=Ms(),l=wDe(o),u,c,h=kDe(o);return t.isPacked?(u=xDe(t.logicalShape,i,n.enableShapeUniforms),c=SDe(o)):(u=vDe(t.logicalShape,i,n.enableShapeUniforms),c=ADe(o)),n.packedInputs&&(h+=TDe),[h,l,c,r,u,s,n.userCode].join(`
`)}function rx(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return PDe(e,t);case 1:return UDe(e,t);case 2:return GDe(e,t);case 3:return jDe(e,t);case 4:return KDe(e,t);case 5:return XDe(e);case 6:return YDe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function nY(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return BDe(e);case 1:return VDe(e,t);case 2:return WDe(e,t);case 3:return HDe(e,t);default:return qDe(e,t)}}function bDe(e,t,n=!1,a){let r="";n?r+=nY(e,a):r+=rx(e,a);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?r+=QDe(e,t):r+=ZDe(e,t)),r}function xDe(e,t,n){switch(e.length){case 0:return aY();case 1:return EDe(e,t,n);case 2:return LDe(e,t,n);case 3:return _De(e,t,n);default:return DDe(e,t,n)}}function vDe(e,t,n){switch(e.length){case 0:return aY();case 1:return $De(e,t,n);case 2:return zDe(e,t,n);case 3:return RDe(e,t,n);case 4:return ODe(e,t,n);case 5:return FDe(e,t);case 6:return MDe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function wDe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function ADe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function SDe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function kDe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${IDe}
    ${NDe}
    ${CDe}
  `}var IDe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,NDe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,CDe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,TDe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function aY(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function EDe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${a[1]}.0);
      }
    `:a[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${a[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);
    }
  `}function $De(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function _De(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function RDe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${$C(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let a=Rm(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec3(r, c, d);
    }
  `}function DDe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${e.length}(${l});
    }
  `}function ODe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${$C(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let a=Rm(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `}function FDe(e,t){let n=Rm(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function MDe(e,t){let n=Rm(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function LDe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(F.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));
      }
    `;let r=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));

      int index = resTexRC.x * ${a[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function zDe(e,t,n){return F.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Dm(e){return`offset${e}`}function BDe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=Ms();return`
    vec4 ${n}() {
      return ${a.texture2D}(${t}, halfCR);
    }
  `}function PDe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;let[r,s]=e.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${a}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Dm(n);if(t)return`
    float ${a}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${a}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function VDe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=Ms();if(t)return`
    vec4 ${a}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${a}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function UDe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${a}(int index) {
        ${sx(e)}
      }
    `;let r=e.shapeInfo.texShape,s=r[0],i=r[1];if(i===1&&s===1)return`
      float ${a}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Dm(n);return i===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function WDe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=Ms();if(s!=null&&F.arraysEqual(n,s))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);

        return ${l.texture2D}(${a}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${a}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `}function GDe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(s!=null&&F.arraysEqual(n,s)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;let p=s[0],m=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${a}, uv);
    }
  `}let{newShape:i,keptDims:o}=F.squeezeShape(n),l=i;if(l.length<n.length){let p=ix(e,l),m=["row","col"];return`
      ${rx(p,t)}
      float ${r}(int row, int col) {
        return ${r}(${ox(m,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${sx(e)}
      }
    `;let u=s[0],c=s[1],h=Dm(a);return c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${a}, uv);
    }
  `:u===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${a}, uv);
  }
`}function HDe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let p=n.slice(1),m=[1,2],g=ix(e,p),y=["b","row","col"];return`
        ${nY(g,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${ox(y,m)});
        }
      `}let o=Ms();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `}function jDe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=F.squeezeShape(n),u=o;if(u.length<n.length){let y=ix(e,u),b=["row","col","depth"];return`
        ${rx(y,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${ox(b,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${sx(e)}
      }
    `;let c=e.shapeInfo.texShape,h=c[0],p=c[1],m=e.shapeInfo.flatOffset;if(p===s&&m==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${h}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(p===i&&m==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${a}, uv);
    }
  `;let g=Dm(a);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${g};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${g};
        vec2 uv = uvFromFlat(${h}, ${p}, index);
        return sampleTexture(${a}, uv);
      }
  `}function qDe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=Ms();if(t)return`
    vec4 ${a}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(s[i-1]/2),p=h*Math.ceil(s[i-2]/2),m="int b, int row, int col",g=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let y=2;y<i-1;y++)m=`int b${y}, `+m,p*=s[i-y-1],g=`b${y} * ${p} + `+g;return`
    vec4 ${a}(${m}) {
      int index = ${g};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${n}, uv);
    }
  `}function KDe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=F.squeezeShape(n);if(l.length<n.length){let w=ix(e,l),S=["row","col","depth","depth2"];return`
      ${rx(w,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${ox(S,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${sx(e)}
      }
    `;let c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],m=h[1],g=`int stride2 = ${a}Shape[3];`,y=`int stride1 = ${a}Shape[2] * stride2;`,b=`int stride0 = ${a}Shape[1] * stride1;`;if(m===o&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${g}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(m===s&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${a}, uv);
      }
    `;let v=Dm(a);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${g}
      ${y}
      ${b}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${v});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${p}, ${m}, index + ${v});
      return sampleTexture(${a}, uv);
    }
  `}function XDe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=F.squeezeShape(t);if(l.length<t.length){let y=ix(e,l),b=["row","col","depth","depth2","depth3"];return`
      ${rx(y)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${ox(b,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${r})) +
          depth3;
        ${sx(e)}
      }
    `;let c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],m=h[1];if(m===o&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===r&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let g=Dm(n);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${r} + depth3 + ${g};
      vec2 uv = uvFromFlat(${p}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function YDe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=F.squeezeShape(t);if(r.length<t.length){let b=ix(e,r),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${rx(b)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${ox(v,s)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${sx(e)}
      }
    `;let h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,m=p[0],g=p[1];if(g===c&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===i&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let y=Dm(n);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${y};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function sx(e){let t=e.name,n=F.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function QDe(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=tY(e.shapeInfo.logicalShape,t.logicalShape),l=Gn(i),u=i-s,c,h=["x","y","z","w","u","v"];s===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(b=>`coords.${h[b+u]} = 0;`).join(`
`);let p="";i<2&&s>0?p="coords":p=e.shapeInfo.logicalShape.map((b,v)=>`coords.${h[v+u]}`).join(", ");let m="return outputValue;",g=F.sizeFromShape(e.shapeInfo.logicalShape)===1,y=F.sizeFromShape(t.logicalShape)===1;if(s===1&&!g&&!y)m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!y)i===1?m=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:m=`
        return vec4(outputValue.x);
      `;else if(o.length){let b=s-2,v=s-1;o.indexOf(b)>-1&&o.indexOf(v)>-1?m="return vec4(outputValue.x);":o.indexOf(b)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(v)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${a}(${p});
      ${m}
    }
  `}function ZDe(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&F.arraysEqual(i,s))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=Gn(l),c=tY(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,p,m=["x","y","z","w","u","v"];o===0?p="":l<2&&c.length>=1?p="coords = 0;":p=c.map(y=>`coords.${m[y+h]} = 0;`).join(`
`);let g="";return l<2&&o>0?g="coords":g=e.shapeInfo.logicalShape.map((y,b)=>`coords.${m[b+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${p}
      return get${a}(${g});
    }
  `}function Gn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function XL(e,t,n){let{newShape:a,keptDims:r}=F.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):a,l=!e&&s>1&&!F.arraysEqual(t,n)&&a.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:r}}function ix(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function ox(e,t){return t.map(n=>e[n]).join(", ")}function JDe(e,t,n,a){let r=n.map((c,h)=>{let p={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(p.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:p}}),s=r.map(c=>c.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=yDe(r,i,t),l=D9(e.gl,o),u=e.createProgram(l);return xe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},rY(e,t,u)))}function rY(e,t,n){let a=[],r=[],s,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),xe().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let h of t.variableNames){let p={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(p.shape=e.getUniformLocation(n,`${h}Shape`,c),p.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),a.push(p)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let h of t.customUniforms)r.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:a,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function EH(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,a)=>{let r=n.logicalShape,s=t[a],i=s.shape;if(!F.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!F.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function eOe(e,t,n,a,r){t.program.enableShapeUniforms||(EH(t.inShapeInfos,n),EH([t.outShapeInfo],[a]));let s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),xe().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:c,offset:h,shape:p,texShape:m}=t.variablesLocations[l];if(p){let{uniformShape:g}=XL(t.program.packedInputs,u.shape,u.texData.texShape);switch(g.length){case 1:e.gl.uniform1iv(p,new Int32Array(g));break;case 2:e.gl.uniform2iv(p,new Int32Array(g));break;case 3:e.gl.uniform3iv(p,new Int32Array(g));break;case 4:e.gl.uniform4iv(p,new Int32Array(g));break}}if(m&&e.gl.uniform2i(m,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(F.sizeFromShape(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let g=u.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),e.gl.uniform1fv(c,g)}continue}u.texData.slice!=null&&h!=null&&e.gl.uniform1i(h,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape));break}if(t.outShapeStridesLocation){let l=F.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],c=t.customUniformLocations[l],h=r[l];if(u.type==="float")e.gl.uniform1fv(c,h);else if(u.type==="vec2")e.gl.uniform2fv(c,h);else if(u.type==="vec3")e.gl.uniform3fv(c,h);else if(u.type==="vec4")e.gl.uniform4fv(c,h);else if(u.type==="int")e.gl.uniform1iv(c,h);else if(u.type==="ivec2")e.gl.uniform2iv(c,h);else if(u.type==="ivec3")e.gl.uniform3iv(c,h);else if(u.type==="ivec4")e.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function tOe(e,t,n){let a="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=XL(e.packedInputs,i.shape,l),p="",m="",g="";if(c.length===1&&e.packedInputs){let I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${I[0]>1}_${I[1]>1}`}else if(c.length===2&&!e.packedInputs)m=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let I=F.computeStrides(c);g=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}let y=i.shape.length,b=c.length===2&&F.arraysEqual(i.shape,l),v=F.sizeFromShape(i.shape)===1,w=G.getBroadcastDims(i.shape,n.shape),S=!e.packedInputs&&y===n.shape.length&&F.arraysEqual(l,n.texData.texShape),k=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;a+=`${y}_${S}_${u?h:""}_${c.length}_${v}_${w}_${b}_${p}_${m}_${g}_${k}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;a+=`${i.shape}_${l}_${o}`}});let r=e.userCode,s=e.constructor.name;return s+="_"+a+"_"+r+`${xe().getNumber("WEBGL_VERSION")}`,s}function fs(e){return xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var nOe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=hw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Ms();this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?$C(["r","c","d"],e):Rm(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},aOe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=hw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Ms();this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?$C(["r","c","d"],e):Rm(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},rOe=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Yi.DOWNLOAD;let t=Ms();this.outputShape=e,this.userCode=`
      ${eY}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},sOe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Yi.DOWNLOAD;let t=Ms();this.outputShape=e,this.userCode=`
      ${eY}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},iOe={R:0,G:1,B:2,A:3},$H=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let a=Ms();this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${iOe[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?KL():qL(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${a.texture2D}(A, uv);
          ${s}
        }
        ${a.output} = vec4(${r}, 0., 0., 0.);
      }
    `}},oOe=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Ms();this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;a+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?KL():qL(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${a}

          ${n.output} = ${r};
        }
    `}},sY={};Lt(sY,{bindVertexProgramAttributeStreams:()=>fY,createBufferFromOutputTexture:()=>yY,createFloat16MatrixTexture:()=>cY,createFloat16PackedMatrixTexture:()=>pY,createFloat32MatrixTexture:()=>uY,createIndexBuffer:()=>lY,createPackedMatrixTexture:()=>dY,createUnsignedBytesMatrixTexture:()=>hY,createVertexBuffer:()=>oY,createVertexShader:()=>iY,downloadByteEncodedFloatMatrixFromOutputTexture:()=>xY,downloadFloat32MatrixFromBuffer:()=>bY,downloadMatrixFromPackedOutputTexture:()=>wY,downloadPackedMatrixFromBuffer:()=>vY,getInternalFormatForFloat16MatrixTexture:()=>QL,getInternalFormatForFloat16PackedMatrixTexture:()=>ez,getInternalFormatForFloat32MatrixTexture:()=>YL,getInternalFormatForPackedMatrixTexture:()=>JL,getInternalFormatForUnsignedBytesMatrixTexture:()=>ZL,uploadDenseMatrixToTexture:()=>mY,uploadPixelDataToTexture:()=>gY});function iY(e){let t=Ms(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return R9(e,n)}function oY(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return M9(e,t)}function lY(e){let t=new Uint16Array([0,1,2,2,1,3]);return L9(e,t)}function z1(e,t,n,a,r,s){B9(t,n);let i=z9(e),o=e.TEXTURE_2D;return et(e,()=>e.bindTexture(o,i)),et(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),et(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),et(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),et(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),xe().getNumber("WEBGL_VERSION")===1?et(e,()=>e.texImage2D(o,0,a,t,n,0,r,s,null)):et(e,()=>e.texStorage2D(o,1,a,t,n)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function YL(e){return e.internalFormatFloat}function uY(e,t,n,a){let[r,s]=L1(t,n);return z1(e,r,s,YL(a),a.textureFormatFloat,e.FLOAT)}function QL(e){return e.internalFormatHalfFloat}function cY(e,t,n,a){let[r,s]=L1(t,n);return z1(e,r,s,QL(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function ZL(e){return e.downloadTextureFormat}function hY(e,t,n,a){let[r,s]=L1(t,n);return z1(e,r,s,ZL(a),e.RGBA,e.UNSIGNED_BYTE)}function JL(e){return e.internalFormatPackedFloat}function dY(e,t,n,a){let[r,s]=nx(t,n);return z1(e,r,s,JL(a),e.RGBA,e.FLOAT)}function ez(e){return e.internalFormatPackedHalfFloat}function pY(e,t,n,a){let[r,s]=nx(t,n);return z1(e,r,s,ez(a),e.RGBA,a.textureTypeHalfFloat)}function fY(e,t,n){return et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),HD(e,t,"clipSpacePos",n,3,20,0)&&HD(e,t,"uv",n,2,20,12)}function mY(e,t,n,a,r,s){et(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;r instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(r),xe().getNumber("WEBGL_VERSION")===2?et(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):et(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,o,i)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function gY(e,t,n){et(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?xe().getNumber("WEBGL_VERSION")===2?et(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):et(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):xe().getNumber("WEBGL_VERSION")===2?et(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):et(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function yY(e,t,n,a){let r=e.createBuffer();et(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let s=16*t*n;return et(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),et(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),et(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function bY(e,t,n){let a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function xY(e,t,n,a){let[r,s]=L1(t,n),i=4,o=new Uint8Array(aDe(t*n,i));return et(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function vY(e,t,n,a,r,s,i,o){let l=e,u=new Float32Array(rDe(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function wY(e,t,n){let a=new Float32Array(t*n*4);return et(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}var DI=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=xe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,E9(t,e)):this.gl=ml(t),e=this.gl,xe().getNumber("WEBGL_VERSION")===2){let r=e;this.createVertexArray=()=>et(r,()=>r.createVertexArray()),this.bindVertexArray=s=>et(r,()=>r.bindVertexArray(s)),this.deleteVertexArray=s=>et(r,()=>r.deleteVertexArray(s)),this.getVertexArray=()=>et(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){let r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>et(e,()=>r.createVertexArrayOES()),this.bindVertexArray=s=>et(e,()=>r.bindVertexArrayOES(s)),this.deleteVertexArray=s=>et(e,()=>r.deleteVertexArrayOES(s)),this.getVertexArray=()=>et(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),xe().getNumber("WEBGL_VERSION")===1){let r="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=Ov(this.gl,r),Qi(this.gl,s))this.textureHalfFloatExtension=Ov(this.gl,s);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Qi(this.gl,a))this.colorBufferHalfFloatExtension=Ov(this.gl,a);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Qi(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Qi(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=oY(this.gl),this.indexBuffer=lY(this.gl),this.framebuffer=P9(this.gl),this.textureConfig=HL(this.gl,this.textureHalfFloatExtension)}get debug(){return xe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;et(e,()=>e.finish()),et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),et(e,()=>e.deleteFramebuffer(this.framebuffer)),et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),et(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),et(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),uY(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),cY(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),hY(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),gY(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),mY(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),pY(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),dY(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(jD(this.gl,this.framebuffer),this.outputTexture=null),et(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>xY(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return vY(this.gl,e,t,n,a,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return bY(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let a=yY(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(xe().getBool("WEBGL_FENCE_API_ENABLED")){let a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=a.clientWaitSync(r,0,0);return s===a.ALREADY_SIGNALED||s===a.CONDITION_SATISFIED},t=r}else xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>wY(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=iY(t));let n=O9(t);et(t,()=>t.attachShader(n,this.vertexShader)),et(t,()=>t.attachShader(n,e)),F9(t,n);let a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&EI(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;et(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),fY(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(et(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&EI(this.gl,this.program),et(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?U9(this.gl,e,t):W9(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),et(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),G9(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[a,r]=nx(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&EI(this.gl,this.program),Fv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}et(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),et(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ov(this.gl,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(a.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await F.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),a=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=lOe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in xe().platform&&(n=xe().platform.setTimeoutCustom.bind(xe().platform)),F.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),$I(this.gl,e,this.framebuffer),this.debug&&Fv(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?($I(this.gl,this.outputTexture,this.framebuffer),this.debug&&Fv(this.gl)):jD(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let a=this.gl;$I(a,e,this.framebuffer),this.debug&&Fv(a),this.outputTexture=e,et(a,()=>a.viewport(0,0,t,n)),et(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),et(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function lOe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:uOe,bincountImpl:AY,bincountReduceImpl:cOe,bitwiseAndImpl:hOe,castImpl:dOe,ceilImpl:pOe,concatImpl:fOe,equalImpl:mOe,expImpl:gOe,expm1Impl:yOe,floorImpl:bOe,gatherNdImpl:xOe,gatherV2Impl:vOe,greaterImpl:wOe,greaterEqualImpl:AOe,lessImpl:SOe,lessEqualImpl:kOe,linSpaceImpl:IOe,logImpl:NOe,maxImpl:COe,maximumImpl:TOe,minimumImpl:EOe,multiplyImpl:$Oe,negImpl:_Oe,notEqualImpl:ROe,prodImpl:DOe,raggedGatherImpl:OOe,raggedRangeImpl:FOe,raggedTensorToTensorImpl:MOe,rangeImpl:LOe,rsqrtImpl:zOe,scatterImpl:BOe,sigmoidImpl:POe,simpleAbsImpl:SY,sliceImpl:VOe,sparseFillEmptyRowsImpl:UOe,sparseReshapeImpl:WOe,sparseSegmentReductionImpl:kY,sqrtImpl:GOe,staticRegexReplaceImpl:HOe,stridedSliceImpl:jOe,stringNGramsImpl:qOe,stringSplitImpl:KOe,stringToHashBucketFastImpl:XOe,subImpl:YOe,tileImpl:QOe,topKImpl:ZOe,transposeImpl:tz,uniqueImpl:JOe}=EL;function IY(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function ks(e,t){return t===1?[e]:IY(e,t)}function eFe(e,t){if(e===1)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}var tFe=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=fs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=ks("rc",this.rank),n=Gn(this.rank),a=this.getOutOfBoundsCondition(t),r=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r=`${n===0?"r":"rp1"}, ${a===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)r=`${e[e.length-1-s]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${a};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},NY=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length);let n="";for(let a=0;a<4;a++){let r="thisRC = rc;";a%2===1&&(r+="thisRC.z += 1;"),a>1&&(r+="thisRC.y += 1;"),n+=`
        ${r}
        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${a}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${a>0?"}":""}
      `}this.userCode=`
      ${nFe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?KL():qL(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function nFe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?gDe(["r","c","d"],"inputShape"):Rm(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var aFe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let a=RH(t,n),r=DH(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let s=_H(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[r].pop();return this.usedTextures[r].push(o),o}let i;return a===Hr.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===Hr.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===Hr.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===Hr.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===Hr.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,a){if(this.freeTextures==null)return;let r=RH(n,a),s=DH(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);let i=_H(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=xe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function rFe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function _H(e,t,n,a,r){let s=sFe(t,a),i;if(r){let[l,u]=nx(e[0],e[1]);i=l*u}else{let[l,u]=L1(e[0],e[1]);i=l*u}let o=rFe(n,s);return i*o}function sFe(e,t){switch(e){case Hr.PACKED_2X2_FLOAT32:return JL(t);case Hr.PACKED_2X2_FLOAT16:return ez(t);case Hr.UNPACKED_FLOAT32:return YL(t);case Hr.UNPACKED_FLOAT16:return QL(t);case Hr.PACKED_4X1_UNSIGNED_BYTE:return ZL(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function iFe(e){return xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Hr.PACKED_2X2_FLOAT32:Hr.UNPACKED_FLOAT32:e?Hr.PACKED_2X2_FLOAT16:Hr.UNPACKED_FLOAT16}function RH(e,t){if(e===Yi.UPLOAD)return Hr.PACKED_2X2_FLOAT32;if(e===Yi.RENDER||e==null)return iFe(t);if(e===Yi.DOWNLOAD||e===Yi.PIXELS)return Hr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function DH(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Wl=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Uo="if (isnan(x)) return x;",oFe="return x;",OH="return abs(x);",lFe="return (x >= 0.0) ? x : (exp(x) - 1.0);",uFe=Uo+`
  return (x < 0.0) ? 0.0 : x;
`,cFe=Uo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,sh="return x;",hFe="return 1.0 / (1.0 + exp(-1.0 * x));",dFe="return x;",pFe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,fFe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mFe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gFe="return 1.0 / (1.0 + exp(-1.0 * x));",hh=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},yFe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length);let t=e.length,n=ks("rc",t),a=Gn(t),r=eFe(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${a} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},bFe=pu.whereImpl,xFe=1e-7,vFe=1e-4,AR={};function wFe(e){return e in AR||(AR[e]={}),AR[e]}var AFe=xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),SFe=600;function kFe(){return xe().global.screen==null?1024:xe().global.screen.height*xe().global.screen.width*window.devicePixelRatio*SFe/1024/1024}var nz=class CY extends Bw{nextDataId(){return CY.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof DI)n=t;else{let a=ml(xe().getNumber("WEBGL_VERSION"),t);n=new DI(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let a=ml(xe().getNumber("WEBGL_VERSION"));n=new DI(a),this.binaryCache=wFe(xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new aFe(this.gpgpu),this.numMBBeforeWarning=kFe(),this.texData=new l2(this,_o())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,a,r,s,i){let o=this.makeTensorInfo(n,a),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,s]},l.texShape=[r,s];let u=Mv(n),c=new $H(u,!1,i),h=this.runWebGLProgram(c,[o],a,[[r,s]]);return h.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(t,n,a){if((xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xe().getBool("DEBUG"))&&this.checkNumericalProblems(t),a==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:t,usage:Yi.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,a,r,s){if(xe().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:a,dtype:r,values:n,usage:Yi.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:a,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let p;l?p=new hh(o,sh):p=new Wl(o,sh);let m=this.runWebGLProgram(p,[{dataId:t,shape:o,dtype:r}],r),g=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(a!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return a;let u=this.activeTimers!=null,c;u&&(c=F.now());let h;if(r==="complex64"){let p=this.readSync(s.real.dataId),m=this.readSync(s.imag.dataId);h=G.mergeRealAndImagArrays(p,m)}else h=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=F.now()-c),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){let g=this.pendingRead.get(t);return new Promise(y=>g.push(y))}let n=this.texData.get(t),{values:a,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let g;l?g=new hh(r,sh):g=new Wl(r,sh);let y=this.runWebGLProgram(g,[{dataId:t,shape:r,dtype:i}],i),b=this.read(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(a!=null)return this.convertAndCacheOnCPU(t);if(xe().getBool("DEBUG")&&!xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&xe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&xe().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let g=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(g.texture.texture,...Jk(r))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){let g=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),y=g[0],b=g[1];h=G.mergeRealAndImagArrays(y,b)}else if(u==null)h=this.getValuesFromTexture(t);else{let g=F.sizeFromShape(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,g)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let g=this.gpgpu.gl;et(g,()=>g.deleteBuffer(u))}let p=this.convertAndCacheOnCPU(t,h),m=this.pendingRead.get(t);return this.pendingRead.delete(t),m.forEach(g=>g(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&_o().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,n={}){let a=this.texData.get(t),{values:r,shape:s,slice:i,dtype:o,isPacked:l,texture:u}=a;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let m;l?m=new hh(s,sh):m=new Wl(s,sh);let g=this.runWebGLProgram(m,[{dataId:t,shape:s,dtype:o}],o),y=this.readToGPU(g,n);return this.disposeIntermediateTensorInfo(g),y}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,n.customTexShape),h=_o().makeTensorFromTensorInfo(c),p=this.texData.get(c.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>F.decodeString(r));return Wt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let a=t[n];if(!$9(a))throw xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:a,isPacked:r}=this.texData.get(t),s=F.sizeFromShape(n);if(xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let p=this.decode(t),m=this.texData.get(p.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...Jk(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(p),g}let i=xe().getBool("WEBGL_PACK")&&r===!0,o=i?Mv(n):n,l=i?new sOe(o):new rOe(o),u=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:t}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,a=[],r=!1;this.programTimersStack==null?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,t();let s=F.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=F.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);o.kernelMs=F.sum(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:F.now(),endMs:null}}endTimer(t){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=F.now(),t)}async getQueryTime(t){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,n),this.disposeData(a.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:a,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(n,r,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=AFe){return xe().getBool("WEBGL_CPU_FORWARD")&&t.every(a=>this.texData.get(a.dataId).texture==null&&F.sizeFromShape(a.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){G.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return bFe(t.shape,n)}packedUnaryOp(t,n,a){let r=new hh(t.shape,n),s=this.compileAndRun(r,[t],a);return _o().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let r=SY(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,OH,t.dtype);let n=new Wl(t.shape,OH),a=this.compileAndRun(n,[t]);return _o().makeTensorFromTensorInfo(a)}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&F.isString(a[0])){let s=a.map(i=>F.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,a){return _o().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,a),this)}unpackTensor(t){let n=new yFe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new tFe(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let a=[Lp(t.shape),...zp(t.shape)],r={dtype:t.dtype,shape:a,dataId:t.dataId},s=[Lp(n),...zp(n)],i=new NY(s,a),o=!0,l=[a],u=this.runWebGLProgram(i,[r],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){let a=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=a;if(n!=null){let p=F.sizeFromShape(s),m=n[0]*n[1]*4;F.assert(p<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Mv(s),l;r?l=new aOe(o):l=new nOe(o);let u=!0,c=[n??Jk(o)],h=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,c,u,n);return{dtype:i,shape:s,dataId:h.dataId}}runWebGLProgram(t,n,a,r,s=!1,i){let o=this.makeTensorInfo(t.outputShape,a),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===hw.DENSE){let v=i??Jk(t.outputShape);l.texShape=v.map(w=>w*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),F.sizeFromShape(o.shape)===0)return l.values=F.getTypedArrayFromDType(o.dtype,0),o;let u=[],c=n.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(w.texture==null){if(!t.packedInputs&&F.sizeFromShape(v.shape)<=xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};t.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!t.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),u.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!dw(w.shape,v.shape)){let S=v,k=v.shape;v.shape=w.shape,v=this.packedReshape(v,k),u.push(v),w=this.texData.get(v.dataId),S.shape=k}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(o.dataId);let h={shape:o.shape,texData:l,isUniform:!1},p=tOe(t,c,h),m=this.getAndSaveBinary(p,()=>JDe(this.gpgpu,t,c,h)),g=this.activeTimers!=null,y;g&&(y=this.startTimer()),xe().get("ENGINE_COMPILE_ONLY")||eOe(this.gpgpu,m,c,h,r),u.forEach(v=>this.disposeIntermediateTensorInfo(v)),g&&(y=this.endTimer(y),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(y)}));let b=xe().getNumber("WEBGL_FLUSH_THRESHOLD");if(b>0){let v=F.now();v-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!xe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let v=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),v}return o}compileAndRun(t,n,a,r,s=!1){return a=a||n[0].dtype,this.runWebGLProgram(t,n,a,r,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=fe(()=>{if(!xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=xe().getBool("DEBUG");xe().set("DEBUG",!1);let n=this.abs(xt(1e-8)).dataSync()[0];if(xe().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?xFe:vFe}uploadToGPU(t){let n=this.texData.get(t),{shape:a,dtype:r,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let u=this.activeTimers!=null,c;u&&(c=F.now());let h=n.texShape;if(h==null&&(h=q9(a,l),n.texShape=h),s!=null){let p=Mv(a),m,g=h[1],y=h[0],b=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!b)&&([g,y]=nx(h[0],h[1])),l?m=new oOe(p,b):m=new $H(p,b);let v=b?[y,g]:h,w=this.makeTensorInfo(v,r),S=this.texData.get(w.dataId);b?S.usage=Yi.PIXELS:S.usage=Yi.UPLOAD,S.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),g,y,s);let k=[[y,g]],I=this.runWebGLProgram(m,[w],r,k,!0),T=this.texData.get(I.dataId);n.texShape=T.texShape,n.isPacked=T.isPacked,n.usage=T.usage,xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(n.texture=T.texture,n.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(w),u&&(this.uploadWaitMs+=F.now()-c)}else{let p=this.acquireTexture(h,o,r,l);n.texture=p}}convertAndCacheOnCPU(t,n){let a=this.texData.get(t),{dtype:r}=a;return n!=null&&(a.values=IFe(n,r)),a.values}acquireTexture(t,n,a,r){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*F.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let a=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(s){throw s}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await HM(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(jL(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:a,infLoc:r,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=rY(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=a,t.infLoc=r,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,a){t.channels=t.channels||"RGBA";let{texture:r,height:s,width:i,channels:o}=t,l=_o().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(r,n,a,s,i,o);return _o().makeTensorFromDataId(u,n,a,l)}};nz.nextDataId=0;function IFe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<n.length;++a)n[a]=Math.round(e[a]);return n}else throw new Error(`Unknown dtype ${t}`)}var NFe="4.22.0";function TY(){xe().set("WEBGL_FORCE_F16_TEXTURES",!0)}h1.isBrowser()&&N2("webgl",()=>new nz,2);var CFe={forceHalfFloat:TY},az=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Bp=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=G.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=fs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Om=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,lx=class{constructor(e,t,n,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=G.assertAndGetBroadcastShape(t,n);let r=this.outputShape.length;this.enableShapeUniforms=fs(r);let s="";if(a)if(r===0||F.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${Gn(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=ks("coords",r);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function Ri(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var TFe={kernelName:Mf,backendName:"webgl",kernelFunc:Ri};function sd(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(s.dataId),o=Ri({inputs:{x:a},backend:n}),l=Ri({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var EFe={kernelName:h2,backendName:"webgl",kernelFunc:sd},EY="return (a < 0.) ? b * a : a;",$Y=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $Fe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,i=n.makeTensorInfo([],"float32",F.createScalarValue(s,"float32")),o=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new lx($Y,r.shape,i.shape):new Bp(EY,r.shape,i.shape),l=n.runWebGLProgram(o,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var _Fe={kernelName:Pf,backendName:"webgl",kernelFunc:$Fe},_Y="return (a < 0.) ? b * a : a;",RY=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function RFe(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new lx(RY,a.shape,r.shape):new Bp(_Y,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}var DFe={kernelName:nm,backendName:"webgl",kernelFunc:RFe},ux="if (isnan(x)) return x;";function mn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{let{x:i}=r,o=s,l=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let h=o.texData.get(i.dataId),p=n(h.values,l);return o.makeTensorInfo(i.shape,l,p)}let u=xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new hh(i.shape,t):c=new Wl(i.shape,e),o.runWebGLProgram(c,[i],l)}}function Qr({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,c=o;if(a&&l.dtype==="complex64"){let g=c.texData.get(l.dataId),y=c.texData.get(u.dataId),[b,v]=[[g.complexTensorInfos.real,y.complexTensorInfos.real],[g.complexTensorInfos.imag,y.complexTensorInfos.imag]].map(S=>{let[k,I]=S,T={dataId:k.dataId,dtype:k.dtype,shape:l.shape},E={dataId:I.dataId,dtype:I.dtype,shape:u.shape},R=new Bp(e,l.shape,u.shape);return c.runWebGLProgram(R,[T,E],ro(k.dtype,I.dtype))}),w=sd({inputs:{real:b,imag:v},backend:c});return c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(v),w}let h=s||ro(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){let g=c.texData.get(l.dataId).values,y=c.texData.get(u.dataId).values,b=l.dtype==="string"?G.fromUint8ToStringArray(g):g,v=l.dtype==="string"?G.fromUint8ToStringArray(y):y,[w,S]=r(l.shape,u.shape,b,v,h),k=c.makeTensorInfo(S,h),I=c.texData.get(k.dataId);return I.values=w,k}let p=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,m;return p?m=new lx(t,l.shape,u.shape,n):m=new Bp(e,l.shape,u.shape),c.runWebGLProgram(m,[l,u],h)}}function pw(e,t=!1){if(e==="linear")return t?dFe:oFe;if(e==="relu")return t?fFe:uFe;if(e==="elu")return t?pFe:lFe;if(e==="relu6")return t?mFe:cFe;if(e==="prelu")return t?RY:_Y;if(e==="leakyrelu")return t?$Y:EY;if(e==="sigmoid")return t?gFe:hFe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var DY=class{constructor(e,t,n,a=!1,r=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=fs(this.outputShape.length);let u=a?e[1]:e[2],c=Math.ceil(u/2),h=a?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",m=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],y="",b="";i&&(o?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:y=`vec4 activation(vec4 x) {
          ${i}
        }`,b="result = activation(result);");let v=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",S="rc.x";e[0]<t[0]?w=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(S=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${S};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${g[0]});
          result += (${m[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${b}

        setOutput(result);
      }
    `}},FH={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},MH=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=G.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},LH="return a * b;";function rz(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=G.upcastType(a.dtype,r.dtype);if(a.dtype==="complex64"){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),u=new MH(FH.REAL,a.shape,r.shape),c=new MH(FH.IMAG,a.shape,r.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],p=n.runWebGLProgram(u,h,"float32"),m=n.runWebGLProgram(c,h,"float32"),g=sd({inputs:{real:p,imag:m},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}if(n.shouldExecuteOnCPU([a,r])){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),[u,c]=$Oe(a.shape,r.shape,o.values,l.values,s),h=n.makeTensorInfo(c,s),p=n.texData.get(h.dataId);return p.values=u,h}let i;return xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new lx(LH,a.shape,r.shape):i=new Bp(LH,a.shape,r.shape),n.runWebGLProgram(i,[a,r],s)}var OFe={kernelName:Zf,backendName:"webgl",kernelFunc:rz};function FFe(e,t,n){let a=[Lp(e.shape),...zp(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[Lp(t),...zp(t)],i=new NY(s,a),o=!0,l=[a],u=n.runWebGLProgram(i,[r],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function Ze(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=n,o=F.sizeFromShape(r.shape),l=F.inferFromImplicitShape(s,o),u=F.sizeFromShape(l);F.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(r.dataId);return c.isPacked&&!dw(r.shape,l)&&!(c.texture!==null&&dw(c.shape,l))?FFe(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}var MFe={kernelName:Cb,backendName:"webgl",kernelFunc:Ze},zH=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let c=1/t;l=`sumValue += dot(values * ${F.isInt(c)?c.toPrecision(2):c}, ones);`}let u="";r%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},LFe=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(n/4)*4,c=n%4,h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(i="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(i="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let m="";r%n>0&&(m=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${c===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${c===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function zFe(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],a=G.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function Fm(e,t,n,a){let r=zFe(e.shape),s=e;for(let i=0;i<r.length;i++){let{inSize:o,windowSize:l,outSize:u}=r[i],c,h;n==="mean"?c=i===0?new zH({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new zH({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new LFe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=s,s=a.runWebGLProgram(c,[s],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return s}var BFe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let a=Gn(this.rank),r=PFe(t);this.userCode=`
    void main() {
      ${a} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}};function PFe(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}var VFe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let a=Gn(this.rank),r=IY("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=r[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${a} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function _C(e,t,n){let a=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VFe(e.shape,t):new BFe(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function UFe(e,t,n,a){let r=t,s=e.shape.length,i=F.parseAxisParam(r,e.shape),o=i,l=G.getAxesPermutation(o,s),u=l!=null,c=e;u&&(c=_C(e,l,a),o=G.getInnerMostAxes(o.length,s)),G.assertAxesAreInnerMostDims("sum",o,s);let[h,p]=G.computeOutAndReduceShapes(c.shape,o),m=h;n&&(m=G.expandShapeToKeepDim(h,i));let g=F.sizeFromShape(p),y=F.sizeFromShape(e.shape)/g,b=Ze({inputs:{x:c},attrs:{shape:[y,g]},backend:a}),v=I2(e.dtype),w=Fm(b,v,"sum",a),S=Ze({inputs:{x:w},attrs:{shape:m},backend:a});return a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(w),u&&a.disposeIntermediateTensorInfo(c),S}function RC(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;return UFe(r,s,i,n)}var WFe={kernelName:xm,backendName:"webgl",kernelFunc:RC};function Es(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,i=n,o=r.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=r.shape[s[c]];let u;if(i.shouldExecuteOnCPU([r])){let c=i.texData.get(r.dataId).values,h=tz(c,r.shape,r.dtype,s,l);u=i.makeTensorInfo(l,r.dtype);let p=i.texData.get(u.dataId);p.values=h}else u=_C(r,s,i);return u}var GFe={kernelName:Ku,backendName:"webgl",kernelFunc:Es},OY=1e3;function yN({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,h=n?e.shape[u-2]:e.shape[u-1],p=a?t.shape[c-1]:t.shape[c-2],m=n?e.shape[u-1]:e.shape[u-2],g=a?t.shape[c-2]:t.shape[c-1],y=e.shape.slice(0,-2),b=t.shape.slice(0,-2),v=F.sizeFromShape(y),w=F.sizeFromShape(b),S=Hb.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([m,g]);F.assert(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);let k=n?[v,h,m]:[v,m,h],I=a?[w,g,p]:[w,p,g],T=Ze({inputs:{x:e},backend:r,attrs:{shape:k}}),E=Ze({inputs:{x:t},backend:r,attrs:{shape:I}}),R=[T,E],D=Math.max(v,w),O=n?T.shape[1]:T.shape[2],$=s!=null,_=i!=null,P=l==="leakyrelu",U=l!=null?pw(l,!0):null,W=$||_||P||U!=null,B;if((m===1||g===1)&&O>OY&&W===!1){let j=T,Z=E;n&&(j=Es({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),R.push(j)),a&&(Z=Es({inputs:{x:E},backend:r,attrs:{perm:[0,2,1]}}),R.push(Z));let te=g!==1,V=g===1,Q=j;te&&(Q=Ze({inputs:{x:j},backend:r,attrs:{shape:[D,O,1]}}),R.push(Q));let ee=g===1?2:1,ae=Z;V&&(ae=Ze({inputs:{x:Z},backend:r,attrs:{shape:[D,1,O]}}),R.push(ae));let de=rz({inputs:{a:Q,b:ae},backend:r});B=RC({inputs:{x:de},backend:r,attrs:{axis:ee,keepDims:!0}}),R.push(de)}else{let j=ro(e.dtype,t.dtype),Z=new DY(k,I,[D,m,g],n,a,$,U,_,P),te=[T,E];if(s!=null&&te.push(s),_&&te.push(i),P){let V=r.makeTensorInfo([],"float32",F.createScalarValue(o,"float32"));te.push(V),R.push(V)}B=r.runWebGLProgram(Z,te,j)}let H=Ze({inputs:{x:B},backend:r,attrs:{shape:S}});R.push(B);for(let j of R)r.disposeIntermediateTensorInfo(j);return H}function HFe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=a;return yN({a:r,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}var jFe={kernelName:Ap,backendName:"webgl",kernelFunc:HFe},BH="return abs(x);";function qFe(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){let s=n.texData.get(a.dataId),i=SY(s.values);return n.makeTensorInfo(a.shape,a.dtype,i)}let r;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new hh(a.shape,BH):r=new Wl(a.shape,BH),n.runWebGLProgram(r,[a],a.dtype)}var KFe={kernelName:Wy,backendName:"webgl",kernelFunc:qFe},XFe=Uo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,YFe=mn({opSnippet:XFe}),QFe={kernelName:of,backendName:"webgl",kernelFunc:YFe},ZFe=Uo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,JFe=mn({opSnippet:ZFe}),eMe={kernelName:lf,backendName:"webgl",kernelFunc:JFe},PH="return a + b;",tMe=Qr({opSnippet:PH,packedOpSnippet:PH,supportsComplex:!0,cpuKernelImpl:uOe}),nMe={kernelName:Xh,backendName:"webgl",kernelFunc:tMe},aMe=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`float v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${a};
        setOutput(result);
      }
    `}},rMe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`vec4 v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${a};
        setOutput(result);
      }
    `}};function OI(e){let{inputs:t,backend:n}=e,a=t;if(a.length===1)return Ri({inputs:{x:a[0]},backend:n});if(a.length>xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(a.length/2),l=OI({inputs:a.slice(0,o),backend:n}),u=OI({inputs:a.slice(o),backend:n});return OI({inputs:[l,u],backend:n})}let r=a.map(o=>o.dtype).reduce((o,l)=>ro(o,l)),s=a.map(o=>o.shape),i=xe().getBool("WEBGL_PACK")?new rMe(a[0].shape,s):new aMe(a[0].shape,s);return n.runWebGLProgram(i,a,r)}var sMe={kernelName:uf,backendName:"webgl",kernelFunc:OI};function iMe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=F.parseAxisParam(s,r.shape),u=l,c=G.getAxesPermutation(u,o),h=r;c!=null&&(h=Es({inputs:{x:r},backend:n,attrs:{perm:c}}),u=G.getInnerMostAxes(u.length,o)),G.assertAxesAreInnerMostDims("all",u,o);let[p,m]=G.computeOutAndReduceShapes(h.shape,u),g=F.sizeFromShape(m),y=Ze({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=Fm(y,y.dtype,"all",n),v;if(i){let w=G.expandShapeToKeepDim(p,l);v=Ze({inputs:{x:b},backend:n,attrs:{shape:w}})}else v=Ze({inputs:{x:b},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),c!=null&&n.disposeIntermediateTensorInfo(h),v}var oMe={kernelName:Gy,backendName:"webgl",kernelFunc:iMe};function lMe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=F.parseAxisParam(s,r.shape),u=l,c=G.getAxesPermutation(u,o),h=r;c!=null&&(h=Es({inputs:{x:r},backend:n,attrs:{perm:c}}),u=G.getInnerMostAxes(u.length,o)),G.assertAxesAreInnerMostDims("any",u,o);let[p,m]=G.computeOutAndReduceShapes(h.shape,u),g=F.sizeFromShape(m),y=Ze({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=Fm(y,y.dtype,"any",n),v;if(i){let w=G.expandShapeToKeepDim(p,l);v=Ze({inputs:{x:b},backend:n,attrs:{shape:w}})}else v=Ze({inputs:{x:b},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),c!=null&&n.disposeIntermediateTensorInfo(h),v}var uMe={kernelName:Hy,backendName:"webgl",kernelFunc:lMe},cMe=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${a}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},hMe=class{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,F.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=Gn(o),u=ks("coords",o),c,h;if(s===1){h=o+1;let E=Gn(h);c=`
        ${E} sourceLocR = ${E}(${u.join()}, 0);
        ++${u[o-1]};
        ${E} sourceLocG = ${E}(${u.join()}, 0);
        ++${u[o-2]};
        ${E} sourceLocA = ${E}(${u.join()}, 0);
        --${u[o-1]};
        ${E} sourceLocB = ${E}(${u.join()}, 0);
        --${u[o-2]};`}else h=o,c=`
        ${l} sourceLocR = coords;
        ++${u[o-1]};
        ${l} sourceLocG = coords;
        ++${u[o-2]};
        ${l} sourceLocA = coords;
        --${u[o-1]};
        ${l} sourceLocB = coords;
        --${u[o-2]};`;let p=["x","y","z","w","u","v"].slice(0,h),m="."+p[h-1],g=p.map(E=>"int "+E),y=ks("sourceLocR",h-1).concat("inIdx.r"),b=ks("sourceLocG",h-1).concat("inIdx.g"),v=ks("sourceLocB",h-1).concat("inIdx.b"),w=ks("sourceLocA",h-1).concat("inIdx.a"),S=n==="max"?"greaterThan":"lessThan",k=a?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()})));`,I=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,T=a?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${S}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function FY(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];a!=null&&(r=a.shape[0],s=a.shape[1]);let i=G.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:r,outSize:Math.ceil(s/i)},l=new cMe(o,n,a==null),u=[t];a!=null&&u.push(a);let c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let h=FY(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function MY(e,t,n,a=null){let r=a!=null?a.shape:t.shape,s=r[r.length-1],i=G.computeOptimalWindowSize(s),o=new hMe(r,i,n,a==null),l=a==null?[t]:[t,a],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let c=MY(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function LY(e,t,n,a){let r=[n];if(G.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!xe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[u,c]=G.computeOutAndReduceShapes(l.shape,r),h=F.sizeFromShape(c),p=Ze({inputs:{x:l},backend:e,attrs:{shape:[-1,h]}});s.push(p);let m=FY(e,p,a);s.push(m);let g=Ze({inputs:{x:m},backend:e,attrs:{shape:u}});return s.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}return MY(e,t,a)}function dMe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=F.parseAxisParam(s,r.shape),o=G.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Es({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=G.getInnerMostAxes(i.length,l.shape.length)),G.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=LY(n,l,i[0],"max");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}var pMe={kernelName:jy,backendName:"webgl",kernelFunc:dMe};function fMe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=F.parseAxisParam(s,r.shape),o=G.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Es({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=G.getInnerMostAxes(i.length,l.shape.length)),G.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=LY(n,l,i[0],"min");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}var mMe={kernelName:qy,backendName:"webgl",kernelFunc:fMe},gMe=Uo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,yMe=mn({opSnippet:gMe}),bMe={kernelName:cf,backendName:"webgl",kernelFunc:yMe},xMe=Uo+"return log(x + sqrt(x * x + 1.0));",vMe=mn({opSnippet:xMe}),wMe={kernelName:hf,backendName:"webgl",kernelFunc:vMe},AMe=Uo+`
  return atan(x);
`,SMe=mn({opSnippet:AMe}),kMe={kernelName:df,backendName:"webgl",kernelFunc:SMe},IMe=az+`
  return atan(a, b);
`,NMe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Om+`
  return result;
`,CMe=Qr({opSnippet:IMe,packedOpSnippet:NMe}),TMe={kernelName:ff,backendName:"webgl",kernelFunc:CMe},EMe=Uo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,$Me=mn({opSnippet:EMe}),_Me={kernelName:pf,backendName:"webgl",kernelFunc:$Me},fw=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;let g=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,v="0.0";if(g||(v="-1.0 / 1e-20"),n){let E=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${p}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${E} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${a?r?y:b:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");let k=Math.floor(s/4)*4,I=s%4,T=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${p}, ${m});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${T}
          }

          int xC = xCCorner + ${k};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${T}
          }
        }
        setOutput(${S});
      }
    `}},sz=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterDepth,m=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=e.padInfo.front,b=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;let w=t==="avg",S="0.0";if(w||(S="-1.0 / 1e-20"),n){let D=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${y}, ${b}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${D} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");let T=Math.floor(s/4)*4,E=s%4,R=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${y}, ${b}, ${v});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${T}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${T};
            if (${E===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${E===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${E===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${R}
            }
          }
        }
        setOutput(${I});
      }
    `}};function RMe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ax(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;F.assert(G.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=G.computePool2DInfo(r.shape,s,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&F.arraysEqual(c.inShape,c.outShape))return Ri({inputs:{x:r},backend:n});let h=new fw(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}var DMe={kernelName:mf,backendName:"webgl",kernelFunc:RMe};function OMe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,c=[1,1,1],h=G.computePool3DInfo(r.shape,s,i,c,o,l,u),p=new sz(h,"avg",!1);return n.runWebGLProgram(p,[r],"float32")}var FMe={kernelName:Ky,backendName:"webgl",kernelFunc:OMe},MMe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},LMe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=c-1-e.padInfo.front,g=h-1-e.padInfo.top,y=p-1-e.padInfo.left,b=1/(t*n*a);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function zMe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=a,h=[1,1,1],p=G.computePool3DInfo(i.shape,o,l,h,u,c),m=new LMe(p);return n.runWebGLProgram(m,[r],i.dtype)}var BMe={kernelName:Uw,backendName:"webgl",kernelFunc:zMe};function PMe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;ax([r,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=a,c=G.computePool2DInfo(i.shape,o,l,1,u),h=new MMe(c);return n.runWebGLProgram(h,[r],i.dtype)}var VMe={kernelName:Vw,backendName:"webgl",kernelFunc:PMe};function UMe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return yN({a:r,b:s,transposeA:i,transposeB:o,backend:n})}var WMe={kernelName:gf,backendName:"webgl",kernelFunc:UMe},GMe=class{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],G.assertAndGetBroadcastShape(e,t),G.assertAndGetBroadcastShape(e,n);let i="0.0";a!=null&&(G.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";r!=null&&(G.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},HMe=class{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],G.assertAndGetBroadcastShape(e,t),G.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";a!=null&&(G.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";r!=null&&(G.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},jMe=({inputs:e,backend:t,attrs:n})=>{let{x:a,mean:r,variance:s,offset:i,scale:o}=e;F.assert(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F.assert(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F.assert(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[a,r,s],c=null;i!=null&&(c=i.shape,u.push(i));let h=null;o!=null&&(h=o.shape,u.push(o));let p=xe().getBool("WEBGL_PACK_NORMALIZATION")?new HMe(a.shape,r.shape,s.shape,c,h,l):new GMe(a.shape,r.shape,s.shape,c,h,l);return t.runWebGLProgram(p,u,u[0].dtype)},qMe={kernelName:Of,backendName:"webgl",kernelFunc:jMe},KMe=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Gn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=XMe(this.rank),a,r=e.map((s,i)=>`sourceLoc.${XD[i]} = start[${i}] + coords.${XD[i]};`);a=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${a}
        setOutput(getSource(${n}));
      }
    `}},XD=["x","y","z","w","u","v"];function XMe(e){if(e===1)return"sourceLoc";if(e<=6)return XD.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var YMe=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Gn(this.rank),n=ks("coords",this.rank),a=ks("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${a.slice(-2).join()})`,s=`getChannel(getSource(${a.join()}), ${r})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${a[this.rank-1]};
        result.y = ${s};
        --${a[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${a[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${a[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,c)=>`start[${c}]`).join()});`:e.map((u,c)=>`${a[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function QMe(e,t,n,a){let r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=mr.computeFlatOffset(t,F.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let l=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,l+1),s}function cx(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a,[o,l]=mr.parseSliceParams(r,s,i);if(mr.assertParamsValid(r,o,l),F.sizeFromShape(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){let h=n.texData.get(r.dataId),p=VOe(h.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,p)}let{isPacked:u}=n.texData.get(r.dataId),c=mr.isSliceContinous(r.shape,o,l);if(u||!c){let h=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YMe(l):new KMe(l),p=[o];return n.runWebGLProgram(h,[r],r.dtype,p)}return n.uploadToGPU(r.dataId),QMe(r,o,l,n)}var ZMe={kernelName:Ob,backendName:"webgl",kernelFunc:cx},JMe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;F.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((w,S)=>w*S),l=G.getReshaped(r.shape,s,o),u=G.getPermuted(l.length,s.length),c=G.getReshapedPermuted(r.shape,s,o),h=G.getSliceBeginCoords(i,s.length),p=G.getSliceSize(c,i,s.length),m=[],g=Ze({inputs:{x:r},backend:n,attrs:{shape:l}}),y=Es({inputs:{x:g},backend:n,attrs:{perm:u}}),b=Ze({inputs:{x:y},backend:n,attrs:{shape:c}}),v=cx({inputs:{x:b},backend:n,attrs:{begin:h,size:p}});return m.push(g),m.push(y),m.push(b),m.forEach(w=>n.disposeIntermediateTensorInfo(w)),v},e3e={kernelName:Xy,backendName:"webgl",kernelFunc:JMe};function t3e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=AY(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var n3e={kernelName:Yy,backendName:"webgl",kernelFunc:t3e},a3e=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,r3e=`
  return float(int(a.r) & int(b.r));
`;function s3e(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=xe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||i===1){let l=n.texData.get(a.dataId).values,u=n.texData.get(r.dataId).values,[c,h]=hOe(a.shape,r.shape,l,u,a.dtype),p=n.makeTensorInfo(h,a.dtype),m=n.texData.get(p.dataId);return m.values=c,p}let o;return s?o=new lx(a3e,a.shape,r.shape,!1):o=new Bp(r3e,a.shape,r.shape),n.runWebGLProgram(o,[a,r],a.dtype)}var i3e={kernelName:Qy,backendName:"webgl",kernelFunc:s3e};function o3e(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),o=G.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var l3e={kernelName:Ww,backendName:"webgl",kernelFunc:o3e},u3e="return float(a != b);",zY=Qr({opSnippet:u3e,cpuKernelImpl:ROe,dtype:"bool"}),c3e={kernelName:wb,backendName:"webgl",kernelFunc:zY};function B1(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Ri({inputs:{x:r.complexTensorInfos.real},backend:n})}var h3e={kernelName:S2,backendName:"webgl",kernelFunc:B1},d3e="return float(int(x));";function p3e(e,t){let n=new Wl(e.shape,d3e),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function YD(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return Ri({inputs:{x:r},backend:n});let i=Aa(r.shape),o=YD({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=sd({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(r.dtype==="complex64"){let i=B1({inputs:{input:r},backend:n}),o=YD({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!F.hasEncodingLoss(r.dtype,s)){let i=Ri({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([r])){let i=n.texData.get(r.dataId).values,[o,l,u]=dOe(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}if(s==="int32")return p3e(r,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",F.getTypedArrayFromDType("bool",1)),o=zY({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var f3e={kernelName:yf,backendName:"webgl",kernelFunc:YD},VH="return ceil(x);",m3e=mn({opSnippet:VH,packedOpSnippet:VH,cpuKernelImpl:pOe}),g3e={kernelName:bf,backendName:"webgl",kernelFunc:m3e},y3e=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},b3e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function x3e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o;xe().getBool("WEBGL_PACK_CLIP")?o=new b3e(r.shape):o=new y3e(r.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[r],r.dtype,l)}var v3e={kernelName:Yh,backendName:"webgl",kernelFunc:x3e},w3e=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function UH(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function A3e(e){let{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new w3e(a.shape),i=[UH(a,r.complexTensorInfos.real),UH(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var S3e={kernelName:Gw,backendName:"webgl",kernelFunc:A3e},k3e=class{constructor(e){this.outputShape=[],this.outputShape=G.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},I3e=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=G.computeOutShape(e,t);let n=this.outputShape,a=n.length,r=Gn(a),s=ks("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((g,y)=>`T${y}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let g=1;g<o.length;g++)o[g]=o[g-1]+e[g][t];let l=i[t],u=i.slice(-2),c=i.join(),h=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${u.join()}));
        }`;for(let g=1;g<o.length;g++){let y=o[g-1];h+=`
        if (${l} < ${o[g]}  && ${l} >= ${o[g-1]}) {
          return getChannel(
            getT${g}(${tI(i,l,y)}),
            vec2(${tI(u,l,y)}));
        }`}let p=o.length,m=o[o.length-1];h+=`
        return getChannel(
          getT${p}(${tI(i,l,m)}),
          vec2(${tI(u,l,m)}));`,this.userCode=`
      float getValue(${i.map(g=>"int "+g)}) {
        ${h}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[a-1]} = ${s[a-1]} + 1;
        if (${s[a-1]} < ${n[a-1]}) {
          result.g = getValue(${s});
        }

        ${s[a-2]} = ${s[a-2]} + 1;
        if (${s[a-2]} < ${n[a-2]}) {
          result.a = getValue(${s});
        }

        ${s[a-1]} = ${s[a-1]} - 1;
        if (${s[a-2]} < ${n[a-2]} &&
            ${s[a-1]} < ${n[a-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function tI(e,t,n){let a=e.indexOf(t);return e.map((r,s)=>s===a?`${r} - ${n}`:r).join()}function DC(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Ri({inputs:{x:r.complexTensorInfos.imag},backend:n})}var N3e={kernelName:x2,backendName:"webgl",kernelFunc:DC};function Lv(e,t,n){let a=e[0].dtype;if(a==="complex64"){let m=e.map(w=>B1({inputs:{input:w},backend:n})),g=e.map(w=>DC({inputs:{input:w},backend:n})),y=Lv(m,t,n),b=Lv(g,t,n),v=sd({inputs:{real:y,imag:b},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),v}let r=n.shouldExecuteOnCPU(e);if(a==="string"&&(r=!0),r){let m=e.map(k=>{let I=[-1,F.sizeFromShape(k.shape.slice(t))];return Ze({inputs:{x:k},backend:n,attrs:{shape:I}})}),g=m.map(k=>({vals:n.readSync(k.dataId),shape:k.shape})),y=G.computeOutShape(m.map(k=>k.shape),1),b=m[0].shape[0]===1,v=fOe(g,y,a,b),w=G.computeOutShape(e.map(k=>k.shape),t),S=n.makeTensorInfo(w,a,v);return m.forEach(k=>n.disposeIntermediateTensorInfo(k)),S}let s=e.filter(m=>F.sizeFromShape(m.shape)>0),i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let m=i?new Wl(e[0].shape,sh):new hh(e[0].shape,sh);return n.runWebGLProgram(m,e,a)}let o=xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let m=[];for(let y=0;y<s.length;y+=o){let b=s.slice(y,y+o);m.push(Lv(b,t,n))}let g=Lv(m,t,n);for(let y of m)n.disposeIntermediateTensorInfo(y);return g}if(i){let m=new I3e(s.map(g=>g.shape),t);return n.runWebGLProgram(m,s,a)}let{tensors2D:l,outShape:u}=C3e(s,t,n),c=new k3e(l.map(m=>m.shape)),h=n.runWebGLProgram(c,l,a);l.forEach(m=>n.disposeIntermediateTensorInfo(m));let p=Ze({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),p}function C3e(e,t,n){let a=G.computeOutShape(e.map(r=>r.shape),t);return{tensors2D:e.map(r=>Ze({inputs:{x:r},attrs:{shape:[-1,F.sizeFromShape(r.shape.slice(t))]},backend:n})),outShape:a}}function BY(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=F.parseAxisParam(r,t[0].shape)[0],i=t.map(u=>u.shape);G.assertParamsConsistent(i,s);let o=G.computeOutShape(t.map(u=>u.shape),s);if(F.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>F.sizeFromShape(u.shape)>0);return l.length===1?Ri({inputs:{x:l[0]},backend:n}):Lv(l,s,n)}var T3e={kernelName:Zy,backendName:"webgl",kernelFunc:BY},PY=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,m=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,y=e.dataFormat==="channelsLast",b=y?1:2,v=y?2:3,w=y?3:1,S="",k="";n&&(a?S=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?S=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:S=`
          float activation(float x) {
            ${n}
          }
        `,k="result = activation(result);");let I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${S}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${k}
        setOutput(result);
      }
    `}},E3e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,p=e.filterWidth,m=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${a});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},VY=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fs(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<u;y++)h+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<u;y++)h+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(c+1)/2;y++){let b=y*2;if(h+=`
           xC = xCCorner + ${b*o};
           `,i===1){if(b<u&&(s%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,o===1&&b>0?h+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<u)){let v=s%2===0?F.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:h+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):v===1?h+=`
                     xC${b+1} = xTexelC${b};
                     `:h+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<u&&(s%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<u&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<u&&(h+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<u&&(h+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<u&&(h+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let p="",m="";n&&(a?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:r?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:p=`vec4 activation(vec4 x) {
           ${n}
         }`,m="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${m}
         setOutput(result);
       }
     `}},$3e=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=fs(this.outputShape.length);let{dataFormat:n}=t,a=Ms(),r=n==="channelsLast",s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${u};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${a.output} = result;
      }
    `}};function bN(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function UY({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,u=a.texData.get(e.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],p=n.outChannels,m=n.dataFormat==="channelsLast",g=!1,y=!1,b,v=[];if(s!=null){let w=bN(s.shape,m);w!=null&&(s=Ze({inputs:{x:s},backend:a,attrs:{shape:w}}),v.push(s))}if(r!=null){let w=bN(r.shape,m);w!=null&&(r=Ze({inputs:{x:r},backend:a,attrs:{shape:w}}),v.push(r))}if(!((h===1||p===1)&&c>OY)&&u.isPacked&&m&&u.texture!=null&&l[2]%2!==0&&F.arraysEqual(u.shape.slice(-3),l.slice(-3))){let w=l[0]*l[1]*(l[2]+1),S={dataId:e.dataId,shape:[1,w,n.inChannels],dtype:e.dtype},k=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,F.assert(dw(u.shape,S.shape),()=>`packed reshape ${u.shape} to ${S.shape} isn't free`);let I=Ze({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});v.push(I);let T=yN({a:S,b:I,backend:a,transposeA:g,transposeB:y,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),E=a.texData.get(T.dataId);F.assert(E.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=k,E.shape=n.outShape,b=Ri({inputs:{x:T},backend:a}),b.shape=n.outShape,v.push(T)}else{let w=n.outHeight*n.outWidth,S=Ze({inputs:{x:e},backend:a,attrs:{shape:m?[n.batchSize,w,n.inChannels]:[n.batchSize,n.inChannels,w]}}),k=Ze({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),I=yN({a:m?S:k,b:m?k:S,transposeA:!m,transposeB:y,backend:a,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i});b=Ze({inputs:{x:I},backend:a,attrs:{shape:n.outShape}}),v.push(S),v.push(k),v.push(I)}for(let w of v)a.disposeIntermediateTensorInfo(w);return b}function WY({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:p,dataFormat:m}=n,g=m==="channelsLast",y=l*u*c,b=p*h,v=[n.batchSize,y,b],w=!0,S=!1,k=[];if(s!=null){let j=bN(s.shape,g);j!=null&&(s=Ze({inputs:{x:s},backend:a,attrs:{shape:j}}),k.push(s))}if(r!=null){let j=bN(r.shape,g);j!=null&&(r=Ze({inputs:{x:r},backend:a,attrs:{shape:j}}),k.push(r))}let I=Ze({inputs:{x:t},backend:a,attrs:{shape:[1,y,F.sizeFromShape(t.shape)/y]}});k.push(I);let T=new $3e(v,n),E=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],R=a.runWebGLProgram(T,[e],"float32",E),D=Ze({inputs:{x:R},backend:a,attrs:{shape:v}});k.push(R),k.push(D);let O=r!=null,$=s!=null,_=o==="leakyrelu",P=o?pw(o,!0):null,U=new DY(g?D.shape:I.shape,g?I.shape:D.shape,g?[n.batchSize,b,n.outChannels]:[n.batchSize,n.outChannels,b],w,S,O,P,$,_),W=g?[D,I]:[I,D];if(r&&W.push(r),$&&W.push(s),_){let j=a.makeTensorInfo([],"float32",F.createScalarValue(i,"float32"));W.push(j),k.push(j)}let B=a.runWebGLProgram(U,W,"float32"),H=Ze({inputs:{x:B},backend:a,attrs:{shape:n.outShape}});k.push(B);for(let j of k)a.disposeIntermediateTensorInfo(j);return H}function _3e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=a,h=G.convertConv2DDataFormat(l),p=G.computeConv2DInfo(r.shape,s.shape,i,u,o,c,!1,h),m;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))m=UY({x:r,filter:s,convInfo:p,backend:n});else if(p.strideWidth<=2&&h==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){let y=new VY(p),b=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];m=n.runWebGLProgram(y,[r,s],"float32",b)}else if(xe().getBool("WEBGL_CONV_IM2COL"))m=WY({x:r,filter:s,convInfo:p,backend:n});else{let y=new PY(p);m=n.runWebGLProgram(y,[r,s],"float32")}let g=Ze({inputs:{x:m},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(m),g}var R3e={kernelName:xf,backendName:"webgl",kernelFunc:_3e},D3e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},O3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},F3e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${a} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},M3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=a-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${a}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${a} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function L3e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=a,h=G.convertConv2DDataFormat(l),p=G.computeConv2DInfo(r.shape,c,i,1,o,u,!1,h),m=new D3e(p);return n.runWebGLProgram(m,[r,s],"float32")}var z3e={kernelName:d2,backendName:"webgl",kernelFunc:L3e},B3e=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=fs(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function P3e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=a,h=G.convertConv2DDataFormat(u),p=G.computeConv2DInfo(i,s.shape,o,1,l,c,!1,h);if(xe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){let m=[[p.strideHeight,p.strideWidth]],g=new B3e(p);return n.runWebGLProgram(g,[r,s],"float32",m)}else{let m=new O3e(p);return n.runWebGLProgram(m,[r,s],"float32")}}var V3e={kernelName:vf,backendName:"webgl",kernelFunc:P3e};function U3e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=G.computeConv3DInfo(r.shape,s.shape,i,l,o),c=new E3e(u);return n.runWebGLProgram(c,[r,s],"float32")}var W3e={kernelName:wf,backendName:"webgl",kernelFunc:U3e};function G3e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a,u=G.computeConv3DInfo(r.shape,l,i,1,o),c=new F3e(u);return n.runWebGLProgram(c,[r,s],"float32")}var H3e={kernelName:Jy,backendName:"webgl",kernelFunc:G3e};function j3e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a,u=G.computeConv3DInfo(l,s.shape,o,1,i),c=new M3e(u);return n.runWebGLProgram(c,[r,s],"float32")}var q3e={kernelName:eb,backendName:"webgl",kernelFunc:j3e},K3e=ux+`
  return cos(x);
`,X3e=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Om}
  return result;
`,Y3e=mn({opSnippet:K3e,packedOpSnippet:X3e}),Q3e={kernelName:Af,backendName:"webgl",kernelFunc:Y3e},Z3e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,J3e=mn({opSnippet:Z3e}),eLe={kernelName:Sf,backendName:"webgl",kernelFunc:J3e},tLe=class{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[c,h]=n;this.outputShape=[u,c,h,l];let p=a==="bilinear"?1:0,[m,g]=[`${i-1}.0`,`${o-1}.0`],[y,b,v]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[w,S,k]=h>1?[`${(o-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${S};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},nLe=e=>{let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,c=new tLe(r.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[r,s,i],"float32")},aLe={kernelName:nb,backendName:"webgl",kernelFunc:nLe},mw;(function(e){e.Prod="*",e.Sum="+"})(mw||(mw={}));var WH=class{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let r=this.outputShape.length,s=this.op===mw.Prod?"1.0":"0.0",i=n?s:`getX(${GH(r,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=a?`end != ${o-1}`:"end != 0",u=a?"end + 1":"end - 1"):(l=a?`end + pow2 < ${o}`:"end >= pow2",u=a?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Gn(r)} coords = getOutputCoords();
        int end = ${HH(r,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${HH(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${GH(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function GH(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function HH(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function GY(e,t,n,a,r,s){let i=t.shape.length,o=G.getAxesPermutation([a],i),l=t;o!=null&&(l=Es({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=G.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);let c=l.shape[u],h=Ri({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){let m=new WH(e,l.shape,!1,s),g=[[p]],y=h;h=n.runWebGLProgram(m,[h],h.dtype,g),n.disposeIntermediateTensorInfo(y)}if(r){let p=new WH(e,l.shape,r,s),m=h;h=n.runWebGLProgram(p,[h],h.dtype),n.disposeIntermediateTensorInfo(m)}if(o!=null){let p=G.getUndoAxesPermutation(o),m=Es({inputs:{x:h},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),m}return h}function rLe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return GY(mw.Prod,r,n,s,i,o)}var sLe={kernelName:tb,backendName:"webgl",kernelFunc:rLe};function iLe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return GY(mw.Sum,r,n,s,i,o)}var oLe={kernelName:kf,backendName:"webgl",kernelFunc:iLe};function lLe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.readSync(r.dataId),u=n.readSync(s.dataId),c=AY(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){let l=n.bufferSync(r),u=n.bufferSync(s),c=cOe(l,u,i,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var uLe={kernelName:Hw,backendName:"webgl",kernelFunc:lLe},cLe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function hLe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],u=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],h=l*s,p=u*s,m=c/(s*s),g=i==="NHWC"?[o,h,p,m]:[o,m,h,p],y=new cLe(g,s,i);return n.runWebGLProgram(y,[r],r.dtype)}var dLe={kernelName:ab,backendName:"webgl",kernelFunc:hLe},HY=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fs(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(a?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${u}
        setOutput(result);
      }
    `}},jY=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fs(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c,p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<c;b++)p+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let b=0;b<c;b++)p+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(h+1)/2;b++){let v=b*2;if(p+=`
          xC = xCCorner + ${v*l};
          `,o===1){if(v<c&&(i%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,l===1&&v>0?p+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<c)){let w=i%2===0?F.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:p+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):w===1?p+=`
                    xC${v+1} = xTexelC${v};
                    `:p+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<c&&(i%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<c&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<c&&(p+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<c&&(p+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<c&&(p+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let m="",g="";n&&(a?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:m=`vec4 activation(vec4 x) {
          ${n}
        }`,g="result = activation(result);");let y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}};function pLe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a,c=l;c==null&&(c=[1,1]),F.assert(G.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let h=G.computeConv2DInfo(r.shape,s.shape,i,c,o,u,!0),p;xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?p=new jY(h):p=new HY(h);let m=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(p,[r,s],"float32",m)}var fLe={kernelName:If,backendName:"webgl",kernelFunc:pLe},mLe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},gLe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function yLe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=a,h=G.computeConv2DInfo(r.shape,c,i,o,l,u,!0),p=new mLe(h);return n.runWebGLProgram(p,[r,s],"float32")}var bLe={kernelName:p2,backendName:"webgl",kernelFunc:yLe};function xLe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=a,h=G.computeConv2DInfo(c,s.shape,i,o,l,u,!0),p=new gLe(h);return n.runWebGLProgram(p,[r,s],"float32")}var vLe={kernelName:f2,backendName:"webgl",kernelFunc:xLe},wLe=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function ALe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=F.sizeFromShape(a.shape),i=Ze({inputs:{x:a},backend:n,attrs:{shape:[s]}}),o=new wLe(s),l=n.runWebGLProgram(o,[i],i.dtype),u=Ze({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var SLe={kernelName:jw,backendName:"webgl",kernelFunc:ALe},kLe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:h}=a;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${s});
      const ivec2 pads = ivec2(${c}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function ILe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=G.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l),c,h=new kLe(u);c=n.runWebGLProgram(h,[r,s],"float32");let p=Ze({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),p}var NLe={kernelName:Nf,backendName:"webgl",kernelFunc:ILe};function CLe(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=G.decodeEinsumEquation(r,s.length);G.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=G.getEinsumComputePath(o,l),h=c.length,p=null,m=i.length,g=[];for(let y=0;y<h;++y){for(let b of c[y]){let{permutationIndices:v,expandDims:w}=G.getEinsumPermutation(m,l[b]),S;G.isIdentityPermutation(v)?S=s[b]:(S=Es({inputs:{x:s[b]},backend:n,attrs:{perm:v}}),g.push(S));let k=S.shape.slice();for(let I=0;I<w.length;++I)k.splice(w[I],0,1);F.arraysEqual(S.shape,k)||(S=Ze({inputs:{x:S},backend:n,attrs:{shape:k}}),g.push(S)),p===null?p=S:(p=rz({inputs:{a:S,b:p},backend:n}),g.push(p))}y<h-1&&(u[y]>=0&&(p=RC({inputs:{x:p},backend:n,attrs:{axis:u[y]-(i.length-m),keepDims:!1}}),g.push(p)),m--)}for(let y of g)y!==p&&n.disposeIntermediateTensorInfo(y);return p}var TLe={kernelName:g2,backendName:"webgl",kernelFunc:CLe},ELe="return (x >= 0.0) ? x : (exp(x) - 1.0);",$Le=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,_Le=mn({opSnippet:ELe,packedOpSnippet:$Le}),RLe={kernelName:Tf,backendName:"webgl",kernelFunc:_Le},DLe="return (b >= 0.0) ? a : a * (b + 1.0);",OLe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,FLe=e=>{let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new lx(OLe,a.shape,r.shape):new Bp(DLe,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)},MLe={kernelName:rb,backendName:"webgl",kernelFunc:FLe},LLe=`
  return vec4(equal(a, b));
`,zLe="return float(a == b);",BLe=Qr({opSnippet:zLe,packedOpSnippet:LLe,dtype:"bool",cpuKernelImpl:mOe}),PLe={kernelName:sb,backendName:"webgl",kernelFunc:BLe},VLe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${G.ERF_P};
  float a1 = ${G.ERF_A1};
  float a2 = ${G.ERF_A2};
  float a3 = ${G.ERF_A3};
  float a4 = ${G.ERF_A4};
  float a5 = ${G.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,ULe=mn({opSnippet:VLe}),WLe={kernelName:Ef,backendName:"webgl",kernelFunc:ULe},GLe=ux+`
  return exp(x);
`,HLe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qY=mn({opSnippet:GLe,packedOpSnippet:HLe,cpuKernelImpl:gOe,dtype:"float32"}),jLe={kernelName:$f,backendName:"webgl",kernelFunc:qY};function QD(e){let{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=r;return r<0&&(F.assert(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),o.splice(l,0,1),Ze({inputs:{x:s},backend:a,attrs:{shape:o}})}var qLe={kernelName:ib,backendName:"webgl",kernelFunc:QD},jH="return exp(x) - 1.0;",KLe=mn({opSnippet:jH,packedOpSnippet:jH,cpuKernelImpl:yOe}),XLe={kernelName:_f,backendName:"webgl",kernelFunc:KLe},qH=class{constructor(e,t,n){this.variableNames=["real","imag"];let a=t[1];this.outputShape=t;let r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${a}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function KY(e,t,n){let a=n.texData.get(e.dataId),r=F.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=r/s,o=Ze({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new qH("real",l,t),c=new qH("imag",l,t),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:l},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(u,h,"float32"),m=n.runWebGLProgram(c,h,"float32"),g=sd({inputs:{real:p,imag:m},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m);let y=Ze({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(g),y}function YLe(e){let{inputs:t,backend:n}=e,{input:a}=t;return KY(a,!1,n)}var QLe={kernelName:y2,backendName:"webgl",kernelFunc:YLe},ZLe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function P1(e){let{backend:t,attrs:n}=e,{shape:a,value:r}=n,{dtype:s}=n;if(s=s||F.inferDtype(r),s==="string"){let i=F.getArrayFromDType(s,F.sizeFromShape(a));return i.fill(r),t.makeTensorInfo(a,s,i)}else{let i=new ZLe(a,r),o=[[r]];return t.runWebGLProgram(i,[],s,o)}}var JLe={kernelName:qw,backendName:"webgl",kernelFunc:P1},eze=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},tze={kernelName:ob,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,a=t,r=new eze(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},KH="return floor(x);",nze=mn({opSnippet:KH,packedOpSnippet:KH,cpuKernelImpl:bOe}),aze={kernelName:Rf,backendName:"webgl",kernelFunc:nze},rze=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,sze=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,ize=Qr({opSnippet:rze,packedOpSnippet:sze,dtype:"int32"}),oze={kernelName:Df,backendName:"webgl",kernelFunc:ize},lze=class{constructor(e){this.variableNames=["A"];let t=Ms(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},uze=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Ms(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${a}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},cze={kernelName:YI,backendName:"webgl",kernelFunc:hze},Vg,SR=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function hze(e){let{inputs:t,backend:n,attrs:a}=e,{pixels:r}=t,{numChannels:s}=a,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,s];if(o||i){let y=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Vg==null||y!==SR)&&(SR=y,Vg=document.createElement("canvas").getContext("2d",{willReadFrequently:SR})),Vg.canvas.width=l,Vg.canvas.height=u,Vg.drawImage(r,0,0,l,u),r=Vg.canvas}let p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=Yi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),r);let m=xe().getBool("WEBGL_PACK")?new uze(h):new lze(h),g=n.runWebGLProgram(m,[p],"int32");return n.disposeData(p.dataId),g}function dze(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=a,y=G.convertConv2DDataFormat(c),b=G.computeConv2DInfo(r.shape,s.shape,l,h,u,p,!1,y),v,w=[],S=i!=null,k=o!=null,I=m==="leakyrelu",T=()=>{let R=[r,s],D=(O,$)=>{if($==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){let _=Ze({inputs:{x:O},backend:n,attrs:{shape:[O.shape[0],1,1]}});return w.push(_),_}return O};if(S&&R.push(D(i,c)),k&&R.push(D(o,c)),I){let O=n.makeTensorInfo([],"float32",F.createScalarValue(g,"float32"));R.push(O),w.push(O)}return R};if(b.filterHeight===1&&b.filterWidth===1&&b.dilationHeight===1&&b.dilationWidth===1&&b.strideHeight===1&&b.strideWidth===1&&(b.padInfo.type==="SAME"||b.padInfo.type==="VALID"))v=UY({x:r,filter:s,convInfo:b,backend:n,bias:i,activation:m,preluActivationWeights:o,leakyreluAlpha:g});else if(b.strideWidth<=2&&y==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){let R=m?pw(m,!0):null,D=new VY(b,S,R,k,I),O=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],$=T();v=n.runWebGLProgram(D,$,"float32",O)}else if(xe().getBool("WEBGL_CONV_IM2COL"))v=WY({x:r,filter:s,convInfo:b,backend:n,bias:i,activation:m,preluActivationWeights:o,leakyreluAlpha:g});else{let R=m?pw(m,!1):null,D=new PY(b,S,R,k,I),O=T();v=n.runWebGLProgram(D,O,"float32")}let E=Ze({inputs:{x:v},backend:n,attrs:{shape:b.outShape}});return w.push(v),w.forEach(R=>n.disposeIntermediateTensorInfo(R)),E}var pze={kernelName:Sp,backendName:"webgl",kernelFunc:dze};function fze(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:p,leakyreluAlpha:m}=a,g=[],y=c;y==null&&(y=[1,1]),F.assert(G.eitherStridesOrDilationsAreOne(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);let b=G.computeConv2DInfo(r.shape,s.shape,l,y,u,h,!0),v=xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,w=p?pw(p,v):null,S=[r,s],k=i!=null,I=o!=null,T=p==="leakyrelu";if(k&&S.push(i),I&&S.push(o),T){let O=n.makeTensorInfo([],"float32",F.createScalarValue(m,"float32"));S.push(O),g.push(O)}let E;v?E=new jY(b,k,w,I,T):E=new HY(b,k,w,I,T);let R=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],D=n.runWebGLProgram(E,S,"float32",R);return g.forEach(O=>n.disposeIntermediateTensorInfo(O)),D}var mze={kernelName:kp,backendName:"webgl",kernelFunc:fze},gze=class{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;let r=Gn(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function yze(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,i=s[s.length-1],o=F.sizeFromShape(a.shape),[l,u,c,h]=G.prepareAndValidate(a,r),p=Ze({inputs:{x:r},backend:n,attrs:{shape:[u,i]}}),m=Ze({inputs:{x:a},backend:n,attrs:{shape:[F.sizeFromShape(a.shape)/c,c]}});if(n.shouldExecuteOnCPU([a,r])||a.dtype==="string"){let v=n.readSync(r.dataId),w=n.bufferSync(a),S=xOe(v,w,a.dtype,u,i,c,h,a.shape,o);return n.makeTensorInfo(l,a.dtype,S.values)}let g=new gze(i,h,[u,c],a.shape),y=n.runWebGLProgram(g,[m,p],m.dtype),b=Ze({inputs:{x:y},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}var bze={kernelName:ub,backendName:"webgl",kernelFunc:yze},xze=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Gn(this.rank),a=vze(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${a}));
      }
    `}};function vze(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)r===2?a.push("index"):a.push(`${n[r]}`);return a.join()}function XY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a,l=F.parseAxisParam(i,r.shape)[0];if(xe().get("DEBUG")){let w=n.readSync(s.dataId),S=r.shape[l];for(let k=0;k<w.length;++k){let I=w[k];F.assert(I<=S-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${S-1}]`)}}let u=G.segment_util.collectGatherOpShapeInfo(r,s,l,o),c=F.sizeFromShape(s.shape),h=[],p=Ze({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),m=Ze({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(p),h.push(m);let g=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let w=n.bufferSync(m),S=n.bufferSync(p),k=vOe(S,w,g);return h.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(u.outputShape,k.dtype,k.values)}let y=new xze(p.shape,g),b=n.runWebGLProgram(y,[p,m],p.dtype);h.push(b);let v=Ze({inputs:{x:b},backend:n,attrs:{shape:u.outputShape}});return h.forEach(w=>n.disposeIntermediateTensorInfo(w)),v}var wze={kernelName:lb,backendName:"webgl",kernelFunc:XY},Aze="return float(a > b);",Sze=`
  return vec4(greaterThan(a, b));
`,kze=Qr({opSnippet:Aze,packedOpSnippet:Sze,cpuKernelImpl:wOe,dtype:"bool"}),Ize={kernelName:cb,backendName:"webgl",kernelFunc:kze},Nze="return float(a >= b);",Cze=`
  return vec4(greaterThanEqual(a, b));
`,Tze=Qr({opSnippet:Nze,packedOpSnippet:Cze,dtype:"bool",cpuKernelImpl:AOe}),Eze={kernelName:Ff,backendName:"webgl",kernelFunc:Tze};function $ze(e){let{inputs:t,backend:n}=e,{input:a}=t;return KY(a,!0,n)}var _ze={kernelName:b2,backendName:"webgl",kernelFunc:$ze},Rze="return float(!isnan(x) && !isinf(x));",Dze=mn({opSnippet:Rze,dtype:"bool"}),Oze={kernelName:Lf,backendName:"webgl",kernelFunc:Dze},Fze="return float(isinf(x));",Mze=mn({opSnippet:Fze,dtype:"bool"}),Lze={kernelName:zf,backendName:"webgl",kernelFunc:Mze},zze="return float(isnan(x));",Bze=mn({opSnippet:zze,dtype:"bool"}),Pze={kernelName:Bf,backendName:"webgl",kernelFunc:Bze},Vze="return float(a < b);",Uze=`
  return vec4(lessThan(a, b));
`,Wze=Qr({opSnippet:Vze,packedOpSnippet:Uze,cpuKernelImpl:SOe,dtype:"bool"}),Gze={kernelName:hb,backendName:"webgl",kernelFunc:Wze},Hze="return float(a <= b);",jze=`
  return vec4(lessThanEqual(a, b));
`,qze=Qr({opSnippet:Hze,packedOpSnippet:jze,cpuKernelImpl:kOe,dtype:"bool"}),Kze={kernelName:db,backendName:"webgl",kernelFunc:qze};function Xze(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=IOe(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}var Yze={kernelName:pb,backendName:"webgl",kernelFunc:Xze},Qze=ux+`
  return x < 0.0 ? 0./0. : log(x);
`,Zze=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Jze=mn({opSnippet:Qze,packedOpSnippet:Zze,cpuKernelImpl:NOe}),eBe={kernelName:Vf,backendName:"webgl",kernelFunc:Jze},tBe=ux+`
  return log(1.0 + x);
`,nBe=mn({opSnippet:tBe}),aBe={kernelName:Uf,backendName:"webgl",kernelFunc:nBe},rBe="return float(a >= 1.0 && b >= 1.0);",sBe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,iBe=Qr({opSnippet:rBe,packedOpSnippet:sBe,dtype:"bool"}),oBe={kernelName:fb,backendName:"webgl",kernelFunc:iBe},lBe="return float(!(x >= 1.0));",uBe=mn({opSnippet:lBe}),cBe={kernelName:mb,backendName:"webgl",kernelFunc:uBe},hBe="return float(a >= 1.0 || b >= 1.0);",dBe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,pBe=Qr({opSnippet:hBe,packedOpSnippet:dBe,dtype:"bool"}),fBe={kernelName:gb,backendName:"webgl",kernelFunc:pBe},mBe=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},gBe=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},yBe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a,u=xe().getBool("WEBGL_PACK_NORMALIZATION")?new gBe(r.shape,s,i,o,l):new mBe(r.shape,s,i,o,l);return n.runWebGLProgram(u,[r],r.dtype)},bBe={kernelName:Wf,backendName:"webgl",kernelFunc:yBe},xBe=class{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${a}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${a})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},vBe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=a,h=new xBe(r.shape,o,l,u,c);return n.runWebGLProgram(h,[r,s,i],r.dtype)},wBe={kernelName:yb,backendName:"webgl",kernelFunc:vBe};function ABe(e,t,n,a){let r=F.sizeFromShape(t),s=F.sizeFromShape(e.shape)/r,i=Ze({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=Fm(i,e.dtype,"max",a),l=Ze({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}function YY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=r.shape.length,l=F.parseAxisParam(s,r.shape),u=l,c=G.getAxesPermutation(u,o),h=c!=null,p=n.shouldExecuteOnCPU([r]),m=r;if(h){if(p){let w=n.texData.get(m.dataId).values,S=new Array(o);for(let T=0;T<S.length;T++)S[T]=r.shape[c[T]];let k=tz(w,r.shape,r.dtype,c,S);m=n.makeTensorInfo(S,r.dtype);let I=n.texData.get(m.dataId);I.values=k}else m=_C(r,c,n);u=G.getInnerMostAxes(u.length,o)}G.assertAxesAreInnerMostDims("max",u,o);let[g,y]=G.computeOutAndReduceShapes(m.shape,u),b=g;i&&(b=G.expandShapeToKeepDim(g,l));let v;if(p){let w=n.texData.get(m.dataId).values,S=COe(w,F.sizeFromShape(y),b,r.dtype);v=n.makeTensorInfo(b,r.dtype);let k=n.texData.get(v.dataId);k.values=S}else v=ABe(m,y,b,n);return h&&n.disposeIntermediateTensorInfo(m),v}var SBe={kernelName:Gf,backendName:"webgl",kernelFunc:YY},kBe=az+`
  return max(a, b);
`,IBe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Om+`
  return result;
`,NBe=Qr({opSnippet:kBe,packedOpSnippet:IBe,cpuKernelImpl:TOe}),CBe={kernelName:Hf,backendName:"webgl",kernelFunc:NBe};function TBe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ax(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;F.assert(G.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=G.computePool2DInfo(r.shape,s,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&F.arraysEqual(c.inShape,c.outShape))return Ri({inputs:{x:r},backend:n});let h=new fw(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}var EBe={kernelName:jf,backendName:"webgl",kernelFunc:TBe};function $Be(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=a,c=[1,1,1],h=G.computePool3DInfo(r.shape,s,i,c,o,u,l),p=new sz(h,"max",!1);return n.runWebGLProgram(p,[r],r.dtype)}var _Be={kernelName:bb,backendName:"webgl",kernelFunc:$Be},RBe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,l=r*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},DBe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=l-1-e.padInfo.top,p=u-1-e.padInfo.left,m=o*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function OBe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=a,h=[1,1,1],p=G.computePool3DInfo(i.shape,o,l,h,u,c),m=new sz(p,"max",!0),g=n.runWebGLProgram(m,[i],i.dtype),y=new DBe(p),b=n.runWebGLProgram(y,[r,g],i.dtype);return n.disposeIntermediateTensorInfo(g),b}var FBe={kernelName:Xw,backendName:"webgl",kernelFunc:OBe};function MBe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;ax([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=a,p=G.computePool2DInfo(o.shape,l,u,1,c,h),m=!0,g=new fw(p,"max",m),y=n.runWebGLProgram(g,[o],o.dtype),b=new RBe(p),v=n.runWebGLProgram(b,[r,y],o.dtype);return n.disposeIntermediateTensorInfo(y),v}var LBe={kernelName:Kw,backendName:"webgl",kernelFunc:MBe};function zBe(e,t,n,a){let r=new fw(n,"max",!1),s=a.runWebGLProgram(r,[e],"float32");r=new fw(n,"max",!0,!0,t);let i=a.runWebGLProgram(r,[e],"float32");return[s,i]}var BBe={kernelName:Yw,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;F.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let u=[1,1];F.assert(G.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=G.computePool2DInfo(a.shape,r,s,u,i),[h,p]=zBe(a,o,c,l);return[h,p]}};function PBe(e,t,n,a){let r=F.sizeFromShape(t),s=F.sizeFromShape(e.shape)/r,i=Ze({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=Fm(i,"float32","mean",a),l=Ze({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}var VBe={kernelName:qf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{keepDims:r,axis:s}=t,i=n,o=a.shape.length,l=F.parseAxisParam(s,a.shape),u=l,c=G.getAxesPermutation(u,o),h=c!=null,p=i.shouldExecuteOnCPU([a]),m=[],g=a;if(h){if(p){let S=i.texData.get(g.dataId).values,k=new Array(o);for(let E=0;E<k.length;E++)k[E]=a.shape[c[E]];let I=tz(S,a.shape,a.dtype,c,k);g=i.makeTensorInfo(k,a.dtype);let T=i.texData.get(g.dataId);T.values=I}else g=_C(a,c,i);m.push(g),u=G.getInnerMostAxes(u.length,o)}G.assertAxesAreInnerMostDims("sum",u,o);let[y,b]=G.computeOutAndReduceShapes(g.shape,u),v=y;r&&(v=G.expandShapeToKeepDim(y,l));let w=PBe(g,b,v,i);for(let S of m)i.disposeIntermediateTensorInfo(S);return w}};function UBe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=F.parseAxisParam(s,r.shape),u=l,c=G.getAxesPermutation(u,o),h=r;c!=null&&(h=Es({inputs:{x:r},backend:n,attrs:{perm:c}}),u=G.getInnerMostAxes(u.length,r.shape.length)),G.assertAxesAreInnerMostDims("min",u,o);let[p,m]=G.computeOutAndReduceShapes(h.shape,u),g=F.sizeFromShape(m),y=Ze({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=Fm(y,y.dtype,"min",n),v;if(i){let w=G.expandShapeToKeepDim(p,l);v=Ze({inputs:{x:b},backend:n,attrs:{shape:w}})}else v=Ze({inputs:{x:b},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),c!=null&&n.disposeIntermediateTensorInfo(h),v}var WBe={kernelName:Kf,backendName:"webgl",kernelFunc:UBe},GBe=az+`
  return min(a, b);
`,HBe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Om+`
  return result;
`,jBe=Qr({opSnippet:GBe,packedOpSnippet:HBe,cpuKernelImpl:EOe}),qBe={kernelName:Xf,backendName:"webgl",kernelFunc:jBe},KBe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let a=e.length,r=Gn(a),s=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),l=n==="reflect"?0:1;if(a===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${a}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},XBe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);let a=e.length,r=Gn(a),s=t.map(m=>m[0]).join(","),i=t.map((m,g)=>m[0]+e[g]).join(","),o=ks("rc",a),l=ks("source",a),u=`${o[a-1]} < ${this.outputShape[a-1]}`,c=a===1?"source":`vec2(${l.slice(-2).join()})`,h=n==="reflect"?0:1,p="";if(a===1){let m=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[a-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let m=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[a-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${o[a-2]} += 1;
        if(${o[a-2]} < ${this.outputShape[a-2]}) {
          ${m}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${o[a-1]} += 1;
          if(${u}) {
            ${m}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},YBe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{paddings:r,mode:s}=n,i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new XBe(a.shape,r,s):new KBe(a.shape,r,s);return t.runWebGLProgram(i,[a],a.dtype)},QBe={kernelName:Yf,backendName:"webgl",kernelFunc:YBe},ZBe=`if (b == 0.0) return NAN;
  return mod(a, b);`,JBe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Om+`
  return result;
`,ePe=Qr({opSnippet:ZBe,packedOpSnippet:JBe}),tPe={kernelName:Qf,backendName:"webgl",kernelFunc:ePe},nPe=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},aPe=`
if (a == b) {
  return 1.0;
};
return a / b;`,rPe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,QY=Qr({opSnippet:aPe,packedOpSnippet:rPe,checkOutOfBounds:!0}),sPe={kernelName:Cf,backendName:"webgl",kernelFunc:QY},XH="return a - b;",ZY=Qr({opSnippet:XH,packedOpSnippet:XH,supportsComplex:!0,cpuKernelImpl:YOe}),iPe={kernelName:Am,backendName:"webgl",kernelFunc:ZY};function JY(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=F.parseAxisParam([s],r.shape),o=YY({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=G.expandShapeToKeepDim(o.shape,i),u=Ze({inputs:{x:o},backend:n,attrs:{shape:l}}),c=ZY({inputs:{a:r,b:u},backend:n}),h=qY({inputs:{x:c},backend:n}),p=RC({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),m=Ze({inputs:{x:p},backend:n,attrs:{shape:l}}),g=QY({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}var oPe={kernelName:vm,backendName:"webgl",kernelFunc:JY};function lPe(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,l=o?r:JY({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new nPe(u,c,s),p=[[i]],m=n.runWebGLProgram(h,[l],"int32",p);return o||n.disposeIntermediateTensorInfo(l),m}var uPe={kernelName:xb,backendName:"webgl",kernelFunc:lPe},cPe=Uo+`
  return -x;
`,hPe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function dPe(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){let s=n.texData.get(a.dataId),[i,o]=_Oe(s.values,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,i)}let r;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new hh(a.shape,hPe):r=new Wl(a.shape,cPe),n.runWebGLProgram(r,[a],a.dtype)}var pPe={kernelName:vb,backendName:"webgl",kernelFunc:dPe},fPe=pu.nonMaxSuppressionV3Impl;function mPe(e){G.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a,u=n.readSync(r.dataId),c=n.readSync(s.dataId),{selectedIndices:h}=fPe(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var gPe={kernelName:Ab,backendName:"webgl",kernelFunc:mPe},yPe=pu.nonMaxSuppressionV4Impl;function bPe(e){G.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a,c=n.readSync(r.dataId),h=n.readSync(s.dataId),{selectedIndices:p,validOutputs:m}=yPe(c,h,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([m]))]}var xPe={kernelName:Sb,backendName:"webgl",kernelFunc:bPe},vPe=pu.nonMaxSuppressionV5Impl;function wPe(e){G.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a,c=n.readSync(r.dataId),h=n.readSync(s.dataId),p=i,m=o,g=l,y=u,{selectedIndices:b,selectedScores:v}=vPe(c,h,p,m,g,y);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}var APe={kernelName:kb,backendName:"webgl",kernelFunc:wPe},SPe=class{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${a}), float(${n}),
                      float(index == coords.y)));
      }
    `}},kPe=e=>{let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,u=F.sizeFromShape(r.shape),c=new SPe(u,i,o,l),h=Ze({inputs:{x:r},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(c,[h],s);n.disposeIntermediateTensorInfo(h);let m=[...r.shape,i],g=Ze({inputs:{x:p},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(p),g},IPe={kernelName:Jf,backendName:"webgl",kernelFunc:kPe};function xN(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="complex64"){let r=B1({inputs:{input:a},backend:n}),s=xN({inputs:{x:r},backend:n}),i=DC({inputs:{input:a},backend:n}),o=xN({inputs:{x:i},backend:n}),l=sd({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return P1({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype==="string"?"":0},backend:n})}var NPe={kernelName:Wb,backendName:"webgl",kernelFunc:xN};function eQ(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(a.dtype==="complex64"){let r=B1({inputs:{input:a},backend:n}),s=eQ({inputs:{x:r},backend:n}),i=DC({inputs:{input:a},backend:n}),o=xN({inputs:{x:i},backend:n}),l=sd({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return P1({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var CPe={kernelName:Ib,backendName:"webgl",kernelFunc:eQ};function TPe(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return QD({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{F.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),F.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let h=QD({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),u=BY({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var EPe={kernelName:Nb,backendName:"webgl",kernelFunc:TPe},$Pe=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let a=e.length,r=Gn(a),s=t.map(l=>l[0]).join(","),i=t.map((l,u)=>l[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);if(a===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},_Pe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);let a=e.length,r=Gn(a),s=t.map(g=>g[0]).join(","),i=t.map((g,y)=>g[0]+e[y]).join(","),o=ks("rc",a),l=ks("source",a),u=`${o[a-1]} < ${this.outputShape[a-1]}`,c=a===1?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[a-1]} += 1;
       if(${u}) {
      `,a===1?"":`}
       rc = outputLoc;
       ${o[a-2]} += 1;
       if(${o[a-2]} < ${this.outputShape[a-2]}) {`,a===1?"":`  ${o[a-1]} += 1;
         if(${u}) {`],p=a===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",m="";for(let g=0,y=a===1?2:4;g<y;g++)m+=`
        ${h[g]}
        if (${p}) {
          result[${g}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${g}] = getChannel(getX(${l.join()}), ${c});
        }
      `;m+=a===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}},tQ=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;if(F.sizeFromShape(r.shape)===0){let u=s.map((c,h)=>c[0]+r.shape[h]+c[1]);return P1({backend:n,attrs:{shape:u,value:i,dtype:r.dtype}})}let o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _Pe(r.shape,s,i):new $Pe(r.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[r],r.dtype,l)},RPe={kernelName:em,backendName:"webgl",kernelFunc:tQ},DPe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,OPe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Om+`
  return result;
`,FPe=Qr({opSnippet:DPe,packedOpSnippet:OPe}),MPe={kernelName:tm,backendName:"webgl",kernelFunc:FPe};function LPe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=[],u=F.parseAxisParam(s,r.shape),c=u,h=G.getAxesPermutation(c,o),p=r;h!=null&&(p=Es({inputs:{x:r},backend:n,attrs:{perm:h}}),c=G.getInnerMostAxes(c.length,o),l.push(p)),G.assertAxesAreInnerMostDims("prod",c,o);let m;if(n.shouldExecuteOnCPU([p])){let g=n.texData.get(p.dataId).values,{outVals:y,outShape:b,outDtype:v}=DOe(p.shape,p.dtype,g,c);m=n.makeTensorInfo(b,v,y)}else{let[g,y]=G.computeOutAndReduceShapes(p.shape,c),b=F.sizeFromShape(y),v=Ze({inputs:{x:p},backend:n,attrs:{shape:[-1,b]}}),w=I2(r.dtype),S=Fm(v,w,"prod",n);m=Ze({inputs:{x:S},backend:n,attrs:{shape:g}}),l.push(v),l.push(S)}if(i){l.push(m);let g=G.expandShapeToKeepDim(m.shape,u);m=Ze({inputs:{x:m},backend:n,attrs:{shape:g}})}return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}var zPe={kernelName:am,backendName:"webgl",kernelFunc:LPe};function BPe(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(v=>n.readSync(v.dataId)),u=r.map(v=>v.shape),c=n.readSync(s.dataId),h=n.readSync(i.dataId),[p,m,g]=OOe(l,u,c,s.shape,s.dtype,h,i.shape,o),y=p.map(v=>n.makeTensorInfo([v.length],"int32",v)),b=n.makeTensorInfo(g,s.dtype,m);return y.concat([b])}var PPe={kernelName:v2,backendName:"webgl",kernelFunc:BPe};function VPe(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=FOe(i,a.shape,a.dtype,o,r.shape,l,s.shape),h=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],a.dtype,c);return[h,p]}var UPe={kernelName:w2,backendName:"webgl",kernelFunc:VPe};function WPe(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.readSync(r.dataId),c=n.readSync(s.dataId),h=n.readSync(i.dataId),p=o.map(b=>n.readSync(b.dataId)),m=o.map(b=>b.shape),[g,y]=MOe(u,r.shape,c,s.shape,s.dtype,h,i.shape,p,m,l);return n.makeTensorInfo(g,s.dtype,y)}var GPe={kernelName:A2,backendName:"webgl",kernelFunc:WPe},nQ=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=LOe(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},HPe={kernelName:Qw,backendName:"webgl",kernelFunc:nQ},jPe="return 1.0 / x;",qPe=mn({opSnippet:jPe}),KPe={kernelName:rm,backendName:"webgl",kernelFunc:qPe},XPe=Uo+`
  return (x < 0.0) ? 0.0 : x;
`,YPe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,QPe=mn({opSnippet:XPe,packedOpSnippet:YPe}),ZPe={kernelName:sm,backendName:"webgl",kernelFunc:QPe},JPe=Uo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,e4e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,t4e=mn({opSnippet:JPe,packedOpSnippet:e4e}),n4e={kernelName:lm,backendName:"webgl",kernelFunc:t4e},a4e=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h;r?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},r4e=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h;r?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function s4e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new r4e(r.shape,l,u,s,i):new a4e(r.shape,l,u,s,i);return n.runWebGLProgram(c,[r],"float32")}var i4e={kernelName:om,backendName:"webgl",kernelFunc:s4e},o4e=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,p=1/c,m=Math.ceil(h)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function l4e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new o4e(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var u4e={kernelName:Eb,backendName:"webgl",kernelFunc:l4e},c4e=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0",p;r?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},h4e=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0",p;r?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function d4e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new h4e(r.shape,l,u,s,i):new c4e(r.shape,l,u,s,i);return n.runWebGLProgram(c,[r],r.dtype)}var p4e={kernelName:im,backendName:"webgl",kernelFunc:d4e},f4e=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,p=1/c,m=Math.ceil(h)*2+2,g=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${m});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function m4e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new f4e(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var g4e={kernelName:Tb,backendName:"webgl",kernelFunc:m4e},y4e=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let a=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,r=e.map((i,o)=>a(o)).join(","),s=Gn(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}},b4e=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let a=ks("rc",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Gn(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(a.slice())};
          if(${r}){
            result.g = ${l(a.slice())};
          }
          if(${s}) {
            result.b = ${u(a.slice())};
            if(${r}) {
              result.a = ${c(a.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(m){return h(m)}function l(m){return m[n-1]="("+m[n-1]+" + 1)",h(m)}function u(m){return m[n-2]="("+m[n-2]+" + 1)",h(m)}function c(m){return m[n-1]="("+m[n-1]+" + 1)",m[n-2]="("+m[n-2]+" + 1)",h(m)}function h(m){let g=e.map((v,w)=>p(w,m)),y=g.join(","),b=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${b}))`}function p(m,g){return t.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${g[m]} - 1`:`${g[m]}`}}};function x4e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=r.shape.length,o=F.parseAxisParam(s,r.shape);if(i===0)return Ri({inputs:{x:r},backend:n});let l=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new b4e(r.shape,o):new y4e(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}var v4e={kernelName:um,backendName:"webgl",kernelFunc:x4e},w4e=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],a=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},A4e={kernelName:Gb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=new w4e(a.shape,s),[u,c]=G.getImageCenter(i,a.shape[1],a.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[a],a.dtype,h)}},S4e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,k4e=mn({opSnippet:S4e}),I4e={kernelName:cm,backendName:"webgl",kernelFunc:k4e},N4e="return inversesqrt(x);",C4e=mn({opSnippet:N4e,cpuKernelImpl:zOe}),T4e={kernelName:hm,backendName:"webgl",kernelFunc:C4e},iz=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=Gn(r.length),u=Gn(s.length),c="";n===1?c="i":n===2&&(c="i, j");let h=`getIndices(${c})`,p="";a===1?p="i":a===2&&(p="i, coords[1]");let m=`getUpdates(${p})`,g="";o&&(g="coords[0], coords[1]");let y=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${y}, sum, float(found)));
        }
      `}},E4e=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=Gn(r.length),u=Gn(s.length),c="";n===1?c="i":n===2&&(c="i, j");let h=`getIndices(${c})`,p="";a===1?p="i":a===2&&(p="i, coords[1]");let m=`getUpdates(${p})`,g="";o&&(g="coords[0], coords[1]");let y=`getDefaultValue(${g})`,b=t>1?"strides[j]":"strides",v=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${v};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}};function $4e(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=G.calculateShapes(s,r,i),p=[h/u,u];if(h===0)return n.makeTensorInfo(i,r.dtype);let m=Ze({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),g=Ze({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),y=n.makeTensorInfo([],"float32",new Float32Array([0])),b;xe().getBool("WEBGL_PACK")?b=new E4e(l,o,m.shape.length,g.shape.length,c,p):b=new iz(l,o,m.shape.length,g.shape.length,c,p);let v=n.runWebGLProgram(b,[g,m,y],g.dtype),w=Ze({inputs:{x:v},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(y),w}var _4e={kernelName:$b,backendName:"webgl",kernelFunc:$4e},R4e=class{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let r="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=xe().getNumber("WEBGL_VERSION")===2?r:s,o=a==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function D4e(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new R4e(r.shape[0],r.shape[1],s.shape[1],i),l=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],"int32",l)}var O4e={kernelName:Rb,backendName:"webgl",kernelFunc:D4e},F4e=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let a,r;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)r="resRC",a="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&o.push(`${i[u]}`);a=o.join(),r=l.join()}let s=Gn(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${a});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}};function M4e(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=new F4e(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[a,r,s],ro(r.dtype,s.dtype))}var L4e={kernelName:Db,backendName:"webgl",kernelFunc:M4e},z4e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${G.SELU_SCALEALPHA};
  float scale = ${G.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,B4e=mn({opSnippet:z4e}),P4e={kernelName:dm,backendName:"webgl",kernelFunc:B4e},V4e=ux+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,U4e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,W4e=mn({opSnippet:V4e,packedOpSnippet:U4e,cpuKernelImpl:POe}),G4e={kernelName:gm,backendName:"webgl",kernelFunc:W4e},H4e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,j4e=mn({opSnippet:H4e}),q4e={kernelName:mm,backendName:"webgl",kernelFunc:j4e},K4e=ux+`
  return sin(x);
`,X4e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Om}
  return result;
`,Y4e=mn({opSnippet:K4e,packedOpSnippet:X4e}),Q4e={kernelName:pm,backendName:"webgl",kernelFunc:Y4e},Z4e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,J4e=mn({opSnippet:Z4e}),eVe={kernelName:fm,backendName:"webgl",kernelFunc:J4e},tVe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,nVe=mn({opSnippet:tVe}),aVe={kernelName:ym,backendName:"webgl",kernelFunc:nVe},rVe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;F.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((v,w)=>v*w),l=[[0,0]];l.push(...i);for(let v=1+s.length;v<r.shape.length;++v)l.push([0,0]);let u=[],c=tQ({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=G.getReshaped(c.shape,s,o,!1),p=G.getPermuted(h.length,s.length,!1),m=G.getReshapedPermuted(c.shape,s,o,!1),g=Ze({inputs:{x:c},backend:n,attrs:{shape:h}}),y=Es({inputs:{x:g},backend:n,attrs:{perm:p}}),b=Ze({inputs:{x:y},backend:n,attrs:{shape:m}});return u.push(c),u.push(g),u.push(y),u.forEach(v=>n.disposeIntermediateTensorInfo(v)),b},sVe={kernelName:Fb,backendName:"webgl",kernelFunc:rVe};function iVe(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(a.dataId),l=n.readSync(r.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[h,p,m,g,y]=UOe(o,a.shape,a.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(p,a.dtype,h),n.makeTensorInfo([p[0]],r.dtype,m),n.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(b=>Number(b)))),n.makeTensorInfo([y.length],a.dtype,new Int32Array(y))]}var oVe={kernelName:Zw,backendName:"webgl",kernelFunc:iVe};function lVe(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,h]=WOe(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(c,a.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var uVe={kernelName:Lb,backendName:"webgl",kernelFunc:lVe};function cVe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=kY(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(c,a.dtype,u)}var hVe={kernelName:Jw,backendName:"webgl",kernelFunc:cVe};function dVe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=kY(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(c,a.dtype,u)}var pVe={kernelName:e1,backendName:"webgl",kernelFunc:dVe};function fVe(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=G.calculateShapes(s,r,o),m=!1;if(s.dtype==="string"){let v=n.bufferSync(r),w=n.bufferSync(s),S=F.decodeString(n.readSync(i.dataId)[0]),k=BOe(v,w,o,p,c,u,l,h,S,m);return n.makeTensorInfo(o,k.dtype,k.values)}let g=new iz(u,l,r.shape.length,s.shape.length,h,[p,1],m),y=n.runWebGLProgram(g,[s,r,i],s.dtype),b=Ze({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(y),b}var mVe={kernelName:zb,backendName:"webgl",kernelFunc:fVe};function gVe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=F.parseAxisParam(i,r.shape)[0],l=G.prepareSplitSize(r,s,o),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(p=>{let m=[...h];m[o]=p;let g=cx({inputs:{x:r},backend:n,attrs:{begin:c,size:m}});return c[o]+=p,g})}var yVe={kernelName:Mb,backendName:"webgl",kernelFunc:gVe},YH="return sqrt(x);",bVe=mn({opSnippet:YH,packedOpSnippet:YH,cpuKernelImpl:GOe}),xVe={kernelName:bm,backendName:"webgl",kernelFunc:bVe},vVe="return x * x;",wVe=mn({opSnippet:vVe}),AVe={kernelName:t1,backendName:"webgl",kernelFunc:wVe},QH="return (a - b) * (a - b);",SVe=Qr({opSnippet:QH,packedOpSnippet:QH}),kVe={kernelName:wm,backendName:"webgl",kernelFunc:SVe};function IVe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(r.dataId),i=G.fromUint8ToStringArray(s),o=HOe(i,"string",a);return n.makeTensorInfo(r.shape,"string",o)}var NVe={kernelName:n1,backendName:"webgl",kernelFunc:IVe};function CVe({inputs:e,attrs:t,backend:n}){let{x:a}=e,r=Uo+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Wl(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}var TVe={kernelName:Zh,backendName:"webgl",kernelFunc:CVe},EVe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let a=n.length,r=Gn(n.length),s=Gn(n.length),i="";if(a===1)i="coords * strides + begin";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function $Ve(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:b,isSimpleSlice:v,begin:w,end:S,strides:k}=mr.sliceInfo(r.shape,s,i,o,l,u,c,h,p),I;if(y)I=Ze({inputs:{x:r},backend:n,attrs:{shape:g}});else if(b||v){F.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let E=mr.computeOutShape(w,S,k),R=cx({inputs:{x:r},backend:n,attrs:{begin:w,size:E}});I=Ze({inputs:{x:R},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(R)}else if(n.shouldExecuteOnCPU([r])){let E=n.readSync(r.dataId),R=Wt(r.shape,r.dtype,E),D=jOe(m,R,k,w);I=n.makeTensorInfo(g,r.dtype,D.values)}else{let E=new EVe(w,k,m);I=n.runWebGLProgram(E,[r],r.dtype)}let T=Ze({inputs:{x:I},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(I),T}var _Ve={kernelName:Bb,backendName:"webgl",kernelFunc:$Ve};function RVe(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:c,dataSplits:h}=t,p=n.readSync(c.dataId),m=n.readSync(h.dataId),[g,y]=qOe(p,m,r,s,i,o,l,u);return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(h.shape,"int32",y)]}var DVe={kernelName:a1,backendName:"webgl",kernelFunc:RVe};function OVe(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,h]=KOe(o,l,r),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var FVe={kernelName:r1,backendName:"webgl",kernelFunc:OVe};function MVe(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=XOe(i,r);return n.makeTensorInfo(s.shape,"int32",o)}var LVe={kernelName:s1,backendName:"webgl",kernelFunc:MVe},zVe="return tan(x);",BVe=mn({opSnippet:zVe}),PVe={kernelName:Sm,backendName:"webgl",kernelFunc:BVe},VVe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,UVe=mn({opSnippet:VVe}),WVe={kernelName:km,backendName:"webgl",kernelFunc:UVe};function GVe(e){let{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=G.calculateShapes(i,s,r.shape),p=[h/u,u];if(h===0)return n.makeTensorInfo(r.shape,s.dtype);let m=Ze({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),g=Ze({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),y=Ze({inputs:{x:r},backend:n,attrs:{shape:p}}),b=new iz(l,o,m.shape.length,g.shape.length,c,p,!1,!0),v=n.runWebGLProgram(b,[g,m,y],y.dtype),w=Ze({inputs:{x:v},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),w}var HVe={kernelName:_b,backendName:"webgl",kernelFunc:GVe},jVe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let a=Gn(this.rank),r=qVe(e);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function qVe(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push(`imod(${n[r]}, ${e[r]})`);return a.join()}function aQ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if(r.dtype==="string"||r.shape.length>5){let o=n.readSync(r.dataId),l=r.dtype==="string"?o.map(h=>F.decodeString(h)):o,u=Wt(r.shape,r.dtype,l),c=QOe(u,s);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new jVe(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}var KVe={kernelName:Qh,backendName:"webgl",kernelFunc:aQ},XVe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},YVe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Gd(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function ZH(e){let t=1;for(;t<e;)t*=2;return t}function QVe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([r])||c<o||s>l){let D=n.readSync(r.dataId),[O,$]=ZOe(D,u,r.dtype,s,i);return[n.makeTensorInfo(O.shape,O.dtype,O.values),n.makeTensorInfo($.shape,$.dtype,$.values)]}if(s===0)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[r,P1({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let h=n.texData.get(r.dataId),p=h!==null&&h.isPacked,m=p?n.unpackTensor(r):r,g=F.sizeFromShape(u)/c,y=Ze({inputs:{x:m},attrs:{shape:[g,c]},backend:n});p&&Gd(n,m);let b=ZH(s),v=ZH(c),w=null,S=()=>w===null?[y,y]:[y,w],k=(D,O,$)=>{let _=S(),P=new XVe($),U=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[D],[O]],W=w;w=n.runWebGLProgram(P,_,"int32",U),Gd(n,W)};for(let D=1;D<b;D*=2){let O=D*2;for(let $=D;$>=1;$/=2)k(O,$,[g,v])}for(let D=v;D>b;D/=2){let O=S(),$=new YVe([g,D/2]),_=[[c],[w===null?1:0],[b]],P=w;w=n.runWebGLProgram($,O,"int32",_),Gd(n,P);let U=b/2,W=U*2;for(let B=U;B>=1;B/=2)k(W,B,w.shape)}let I=w;w=cx({inputs:{x:w},backend:n,attrs:{begin:0,size:[g,s]}}),Gd(n,I);let T=XY({inputs:{x:y,indices:w},backend:n,attrs:{axis:1,batchDims:1}});Gd(n,y);let E=u.slice(0,-1);E.push(s),I=w,w=Ze({inputs:{x:w},attrs:{shape:E},backend:n}),Gd(n,I);let R=T;return T=Ze({inputs:{x:T},attrs:{shape:E},backend:n}),Gd(n,R),[T,w]}var ZVe={kernelName:Pb,backendName:"webgl",kernelFunc:QVe},JVe=class{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(a){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function eUe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=a,[c,h,p,m]=r.shape,[g,y]=u??[h,p],b=[c,g,y,m],v=new JVe(h,p,i,o,l,b);return n.runWebGLProgram(v,[r,s],"float32")}var tUe={kernelName:Vb,backendName:"webgl",kernelFunc:eUe};function nUe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;ax(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=a.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=JOe(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],"int32",u)]}var aUe={kernelName:i1,backendName:"webgl",kernelFunc:nUe};function rUe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r,o=i.shape.length,l=r.shape[s],u=new Array(o-1),c=0;for(let y=0;y<o;y++)y!==s&&(u[c++]=i.shape[y]);let h=[],p=new Array(o).fill(0),m=i.shape.slice();m[s]=1;let g=new Array(l);for(let y=0;y<g.length;y++){p[s]=y;let b=cx({inputs:{x:i},backend:n,attrs:{begin:p,size:m}}),v=Ze({inputs:{x:b},backend:n,attrs:{shape:u}});g[y]=v,h.push(b)}return h.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}var sUe={kernelName:Ub,backendName:"webgl",kernelFunc:rUe},iUe=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/n);this.outputShape=[a,i];let o="0.0",l="sumValue",u=Math.floor(n/4)*4,c=n%4,h=`
        sumValue += dot(values, segFilter);
    `,p="";r%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let m="";r%n>0&&(m=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function oUe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a,o=r.shape.length,l=[],u=0,c=G.getAxesPermutation([u],o),h=r;c!=null&&(h=Es({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(h),u=G.getInnerMostAxes(1,o)[0]);let p=G.segment_util.computeOutShape(h.shape,u,i),m=F.sizeFromShape([h.shape[u]]),g=Ze({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}});l.push(g);let y=I2(r.dtype),b=(k,I,T,E,R)=>{let D=k.shape[0],O=k.shape[1],$=G.segment_util.segOpComputeOptimalWindowSize(O,R),_={windowSize:$,inSize:O,batchSize:D,numSegments:R},P=new iUe(_,I),U=n.compileAndRun(P,[k,T],E);if(l.push(U),U.shape[1]===R)return U;let W=nQ({backend:n,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),B=aQ({inputs:{x:W},backend:n,attrs:{reps:[O/$]}});return l.push(W),l.push(B),b(U,I,B,E,R)},v=b(g,"unsortedSegmentSum",s,y,i),w=Ze({inputs:{x:v},backend:n,attrs:{shape:p}}),S=w;if(c!=null){l.push(w);let k=G.getUndoAxesPermutation(c);S=Es({inputs:{x:S},backend:n,attrs:{perm:k}})}return l.forEach(k=>n.disposeIntermediateTensorInfo(k)),S}var lUe={kernelName:o1,backendName:"webgl",kernelFunc:oUe},uUe=[jFe,KFe,QFe,eMe,nMe,sMe,oMe,uMe,pMe,mMe,bMe,wMe,kMe,TMe,_Me,DMe,FMe,BMe,VMe,WMe,qMe,e3e,n3e,i3e,l3e,f3e,g3e,v3e,EFe,S3e,T3e,R3e,z3e,V3e,W3e,H3e,q3e,Q3e,eLe,aLe,sLe,oLe,uLe,dLe,fLe,bLe,vLe,SLe,NLe,TLe,RLe,MLe,PLe,WLe,jLe,qLe,XLe,QLe,JLe,tze,aze,oze,cze,pze,mze,bze,wze,Ize,Eze,TFe,_ze,N3e,Oze,Lze,Pze,_Fe,Gze,Kze,Yze,eBe,aBe,oBe,cBe,fBe,bBe,wBe,SBe,CBe,EBe,_Be,FBe,LBe,BBe,VBe,WBe,qBe,QBe,tPe,uPe,OFe,pPe,gPe,xPe,APe,c3e,IPe,CPe,EPe,RPe,MPe,DFe,zPe,PPe,UPe,GPe,HPe,h3e,sPe,KPe,ZPe,n4e,MFe,i4e,u4e,p4e,g4e,v4e,A4e,I4e,T4e,_4e,O4e,L4e,P4e,G4e,q4e,Q4e,eVe,ZMe,oPe,aVe,sVe,oVe,uVe,hVe,pVe,mVe,yVe,xVe,AVe,kVe,NVe,TVe,_Ve,DVe,FVe,LVe,iPe,WFe,PVe,WVe,HVe,KVe,ZVe,tUe,GFe,aUe,sUe,lUe,NPe];for(let e of uUe)l1(e);var xn;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(xn||(xn={}));var gw;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(gw||(gw={}));var rQ;function cUe(e){rQ=e.wasm.cwrap(Ap,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function hUe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=a,p=n.dataIdMap.get(r.dataId).id,m=n.dataIdMap.get(s.dataId).id,g=0;if(i!=null){let R=n.dataIdMap.get(i.dataId);if(R.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${R.shape.length}.`);g=R.id}let y=o==null?0:n.dataIdMap.get(o.dataId).id,b=gw[c];if(b==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let v=l?r.shape[2]:r.shape[1],w=u?s.shape[1]:s.shape[2],S=Hb.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),k=n.makeOutput([...S,v,w],r.dtype),I=n.dataIdMap.get(k.dataId).id,T=new Uint8Array(new Int32Array(r.shape).buffer),E=new Uint8Array(new Int32Array(s.shape).buffer);return rQ(p,T,r.shape.length,m,E,s.shape.length,l,u,b,g,y,h||0,I),k}var dUe={kernelName:Ap,backendName:"wasm",setupFunc:cUe,kernelFunc:hUe};function pn(e,t){let n;function a(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function r(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,u=i.makeOutput(o.shape,t||o.dtype),c=i.dataIdMap.get(u.dataId).id;return F.sizeFromShape(u.shape)===0||n(l,xn[o.dtype],c),u}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:r}}var pUe=pn(Wy),fUe=pn(of),mUe=pn(lf);function rr(e,t,n){let a;function r(i){a=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:l}=i,{a:u,b:c}=l,h=o.dataIdMap.get(u.dataId).id,p=o.dataIdMap.get(c.dataId).id,m=n??u.dtype,g=G.assertAndGetBroadcastShape(u.shape,c.shape),y=o.makeOutput(g,m);if(F.sizeFromShape(g)===0)return y;let b=new Uint8Array(new Int32Array(u.shape).buffer),v=new Uint8Array(new Int32Array(c.shape).buffer),w=o.dataIdMap.get(y.dataId).id;return a(h,b,u.shape.length,p,v,c.shape.length,xn[u.dtype],w),y}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var gUe=rr(Xh),sQ;function yUe(e){sQ=e.wasm.cwrap(uf,null,["array","number","number","number"])}function bUe(e){let{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(F.sizeFromShape(a.shape)===0)return a;let r=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(r).buffer),i=n.dataIdMap.get(a.dataId).id;return sQ(s,r.length,xn[a.dtype],i),a}var xUe={kernelName:uf,backendName:"wasm",setupFunc:yUe,kernelFunc:bUe};function OC(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return Cs(n.readSync(t.dataId),t.shape,t.dtype);let a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var vUe={kernelName:Mf,backendName:"wasm",kernelFunc:OC},iQ;function wUe(e){iQ=e.wasm.cwrap(Ku,null,["number","array","number","number","number","array","number"])}function Oh(e){let{inputs:t,backend:n,attrs:a}=e,[r,s]=SUe(t.x.shape,a.perm),i=!0;for(let g=0;g<s.length;g++)s[g]!==g&&(i=!1);let o=AUe(t.x.shape,a.perm),l={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){let g=OC({inputs:t,backend:n});return g.shape=o,g}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,h=n.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(s).buffer),m=new Uint8Array(new Int32Array(l.shape).buffer);return iQ(c,m,l.shape.length,xn[l.dtype],h,p,s.length),u}function AUe(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function SUe(e,t){let n=[],a=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&a.push(t[r]);for(let r=0;r<a.length;++r){let s=-1;for(let i=0;i<a.length;++i)a[i]>=r&&(s===-1||a[s]>a[i])&&(s=i);a[s]=r}return[n,a]}var kUe={kernelName:Ku,backendName:"wasm",kernelFunc:Oh,setupFunc:wUe};function id(e,t,n){let a=e.shape,r=e.shape.length,s=F.parseAxisParam(t,a),i=s,o=G.getAxesPermutation(i,r),l=null,u=!1;if(o!=null){let c=new Array(r);for(let p=0;p<c.length;p++)c[p]=a[o[p]];i=G.getInnerMostAxes(i.length,r),l=Oh({inputs:{x:e},attrs:{perm:o},backend:n});let h=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==h&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var oQ;function IUe(e){oQ=e.wasm.cwrap(Gy,null,["number, number, number"])}function NUe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:h,inputWasTransposed:p}=id(i,r,t);if(p){let w=t.dataIdMap.get(u.dataId).id;l=u,o=w}let m=l.shape.length;G.assertAxesAreInnerMostDims("all",c,m);let[g,y]=G.computeOutAndReduceShapes(l.shape,c),b=F.sizeFromShape(y),v=t.makeOutput(g,i.dtype);if(F.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(v.dataId).id;oQ(o,b,w)}if(p&&t.disposeData(u.dataId),s){let w=G.expandShapeToKeepDim(v.shape,h);v.shape=w}return v}var CUe={kernelName:Gy,backendName:"wasm",setupFunc:IUe,kernelFunc:NUe},lQ;function TUe(e){lQ=e.wasm.cwrap(Hy,null,["number, number, number"])}function EUe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:h,inputWasTransposed:p}=id(i,r,t);if(p){let w=t.dataIdMap.get(u.dataId).id;l=u,o=w}let m=l.shape.length;G.assertAxesAreInnerMostDims("any",c,m);let[g,y]=G.computeOutAndReduceShapes(l.shape,c),b=F.sizeFromShape(y),v=t.makeOutput(g,i.dtype);if(F.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(v.dataId).id;lQ(o,b,w)}if(p&&t.disposeData(u.dataId),s){let w=G.expandShapeToKeepDim(v.shape,h);v.shape=w}return v}var $Ue={kernelName:Hy,backendName:"wasm",setupFunc:TUe,kernelFunc:EUe};function uQ(e){let t;function n(r){t=r.wasm.cwrap(e,null,["number","number","number","number","number"])}function a(r){let{backend:s,inputs:i,attrs:o}=r,{axis:l}=o,{x:u}=i,c=s.dataIdMap.get(u.dataId).id,h=c,p=u,{transposed:m,axes:g,inputWasTransposed:y}=id(u,l,s);if(y){let I=s.dataIdMap.get(m.dataId).id;I!==c&&(p=m,h=I)}let b=p.shape.slice(0,-1),v=s.makeOutput(b,"int32"),w=s.dataIdMap.get(v.dataId).id,S=F.sizeFromShape(v.shape),k=p.shape[g[0]];return t(h,xn[p.dtype],S,k,w),y&&s.disposeData(m.dataId),v}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:a}}var _Ue=uQ(jy),RUe=uQ(qy),DUe=pn(cf),OUe=pn(hf),FUe=pn(df),MUe=rr(ff),LUe=pn(pf),cQ;function zUe(e){cQ=e.wasm.cwrap(mf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function BUe(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=G.computePool2DInfo(r.shape,i,o,1,l,u),h=c.filterHeight,p=c.filterWidth,m=c.padInfo.top,g=c.padInfo.right,y=c.padInfo.bottom,b=c.padInfo.left,v=c.strideHeight,w=c.strideWidth,S=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let k=a.makeOutput(c.outShape,"float32"),I=a.dataIdMap.get(k.dataId).id;return cQ(s,r.shape[0],r.shape[1],r.shape[2],h,p,m,g,y,b,v,w,S,I),k}var PUe={kernelName:mf,backendName:"wasm",setupFunc:zUe,kernelFunc:BUe},hQ;function VUe(e){hQ=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function UUe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,c=G.computePool3DInfo(r.shape,s,i,1,o,l,u),h=n.makeOutput(c.outShape,r.dtype);return hQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var WUe={kernelName:Ky,backendName:"wasm",setupFunc:VUe,kernelFunc:UUe},dQ;function GUe(e){dQ=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function HUe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,c=G.computePool3DInfo(s.shape,i,o,1,l,u),h=n.makeOutput(s.shape,s.dtype);return dQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),h}var jUe={kernelName:Uw,backendName:"wasm",setupFunc:GUe,kernelFunc:HUe},pQ;function qUe(e){pQ=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function KUe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l}=a,u=G.computePool2DInfo(s.shape,i,o,1,l),c=n.makeOutput(s.shape,s.dtype);return pQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}var XUe={kernelName:Vw,backendName:"wasm",setupFunc:qUe,kernelFunc:KUe};function Xs(e){let{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=F.sizeFromShape(a.shape),i=F.inferFromImplicitShape(r,s);return F.assert(s===F.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}var YUe={kernelName:Cb,backendName:"wasm",kernelFunc:Xs},fQ;function QUe(e){fQ=e.wasm.cwrap(gf,null,["number","array","number","number","array","number","number","number","number"])}function ZUe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=r.shape.length,u=s.shape.length,c=i?r.shape[l-2]:r.shape[l-1],h=o?s.shape[u-1]:s.shape[u-2],p=i?r.shape[l-1]:r.shape[l-2],m=o?s.shape[u-2]:s.shape[u-1],g=r.shape.slice(0,-2),y=s.shape.slice(0,-2),b=F.sizeFromShape(g),v=F.sizeFromShape(y),w=Hb.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,m]);F.assert(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let S=i?[b,c,p]:[b,p,c],k=o?[v,m,h]:[v,h,m],I=Xs({inputs:{x:r},backend:n,attrs:{shape:S}}),T=Xs({inputs:{x:s},backend:n,attrs:{shape:k}}),E=n.dataIdMap.get(I.dataId).id,R=n.dataIdMap.get(T.dataId).id,D=i?I.shape[2]:I.shape[1],O=o?T.shape[1]:T.shape[2],$=Math.max(b,v),_=n.makeOutput([$,D,O],I.dtype),P=n.dataIdMap.get(_.dataId).id,U=new Uint8Array(new Int32Array(I.shape).buffer),W=new Uint8Array(new Int32Array(T.shape).buffer);return fQ(E,U,I.shape.length,R,W,T.shape.length,i,o,P),n.disposeData(I.dataId),n.disposeData(T.dataId),_.shape=w,_}var JUe={kernelName:gf,backendName:"wasm",setupFunc:QUe,kernelFunc:ZUe};function Pp(e){let{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,i]=mr.parseSliceParams(t,n,a),o=mr.isSliceContinous(t.shape,s,i),l=r.readSync(t.dataId),u=r.makeOutput(i,t.dtype),c=F.computeStrides(t.shape),h=r.dataIdMap.get(u.dataId);if(o){let g=mr.computeFlatOffset(s,c);return t.dtype==="string"?h.stringBytes=l.slice(g,g+F.sizeFromShape(i)):r.typedArrayFromHeap(u).set(l.subarray(g,g+F.sizeFromShape(i))),u}if(t.dtype==="string"){let g=pN(l,s,i,t.shape,t.dtype);return h.stringBytes=g,u}let p=r.typedArrayFromHeap(u),m=t.shape.length;if(m===2)eWe(l,c[0],p,s,i);else if(m===3)tWe(l,c[0],c[1],p,s,i);else if(m===4)nWe(l,c[0],c[1],c[2],p,s,i);else{let g=pN(l,s,i,t.shape,t.dtype);p.set(g)}return u}function eWe(e,t,n,a,r){let s=0,i=a[0],o=a[1],l=i+r[0];for(let u=i;u<l;u++){let c=u*t+o;n.set(e.subarray(c,c+r[1]),s),s+=r[1]}}function tWe(e,t,n,a,r,s){let i=0,o=r[0],l=r[1],u=r[2],c=o+s[0],h=l+s[1];for(let p=o;p<c;p++)for(let m=l;m<h;m++){let g=p*t+m*n+u;a.set(e.subarray(g,g+s[2]),i),i+=s[2]}}function nWe(e,t,n,a,r,s,i){let o=0,l=s[0],u=s[1],c=s[2],h=l+i[0],p=u+i[1],m=c+i[2],g=s[3];for(let y=l;y<h;y++)for(let b=u;b<p;b++)for(let v=c;v<m;v++){let w=y*t+b*n+v*a+g;r.set(e.subarray(w,w+i[3]),o),o+=i[3]}}var aWe={kernelName:Ob,backendName:"wasm",kernelFunc:Pp};function rWe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a,o=s.reduce((v,w)=>v*w),l=G.getReshaped(r.shape,s,o),u=G.getPermuted(l.length,s.length),c=G.getReshapedPermuted(r.shape,s,o),h=G.getSliceBeginCoords(i,s.length),p=G.getSliceSize(c,i,s.length),m=Xs({inputs:{x:r},backend:n,attrs:{shape:l}}),g=Oh({inputs:{x:m},backend:n,attrs:{perm:u}}),y=Xs({inputs:{x:g},backend:n,attrs:{shape:c}}),b=Pp({inputs:{x:y},backend:n,attrs:{begin:h,size:p}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(y.dataId),b}var sWe={kernelName:Xy,backendName:"wasm",kernelFunc:rWe},mQ;function iWe(e){mQ=e.wasm.cwrap(Yy,null,["number","number","boolean","number","number","number"])}function oWe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i}=a,o=s.shape.reduce((h,p)=>h*p,1)!==0,l=r.shape.length===1?[i]:[r.shape[0],i],u=t.makeOutput(l,s.dtype);function c(h){return t.dataIdMap.get(h.dataId).id}return mQ(c(r),i,o,c(s),xn[s.dtype],c(u)),u}var lWe={kernelName:Yy,backendName:"wasm",setupFunc:iWe,kernelFunc:oWe},uWe=rr(Qy);function cWe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.typedArrayFromHeap(a),i=n.typedArrayFromHeap(r),o=G.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var hWe={kernelName:Ww,backendName:"wasm",kernelFunc:cWe};function od(e){let{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}var dWe={kernelName:yf,backendName:"wasm",kernelFunc:od},pWe=pn(bf),gQ;function fWe(e){gQ=e.wasm.cwrap(Yh,null,["number","number","number","number"])}function mWe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o=n.dataIdMap.get(r.dataId).id,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(l.dataId).id;return gQ(o,s,i,u),l}var gWe={kernelName:Yh,backendName:"wasm",setupFunc:fWe,kernelFunc:mWe};function yQ(e){let{inputs:t,backend:n}=e,a=F.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(m=>m.shape);G.assertParamsConsistent(r,a);let s=G.computeOutShape(t.map(m=>m.shape),a),i=t.filter(m=>F.sizeFromShape(m.shape)>0);if(i.length===1)return OC({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(F.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let m=i.map(S=>{let k=[-1,F.sizeFromShape(S.shape.slice(a))];return Xs({inputs:{x:S},backend:n,attrs:{shape:k}})}),g=m.map(S=>({vals:n.readSync(S.dataId),shape:S.shape}));s=G.computeOutShape(m.map(S=>S.shape),1);let y=m[0].shape[0]===1,b=RL(g,s,t[0].dtype,y),v=G.computeOutShape(i.map(S=>S.shape),a);o.shape=v;let w=n.dataIdMap.get(o.dataId);return w.stringBytes=G.fromStringArrayToUint8(b),m.forEach(S=>n.disposeData(S.dataId)),o}let l=F.sizeFromShape(i[0].shape.slice(0,a)),u=0,c=i.map(m=>{let g=F.sizeFromShape(m.shape.slice(a));return u+=g,g}),h=i.map(m=>n.typedArrayFromHeap(m)),p=n.typedArrayFromHeap(o);for(let m=0;m<l;m++){let g=m*u;for(let y=0;y<h.length;y++){let b=c[y],v=m*b,w=h[y].subarray(v,v+b);p.set(w,g),g+=b}}return o}var yWe={kernelName:Zy,backendName:"wasm",kernelFunc:yQ},bQ;function bWe(e){bQ=e.wasm.cwrap(xf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function xWe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:h,dataFormat:p}=n,m=G.convertConv2DDataFormat(p),g=G.computeConv2DInfo(r.shape,s.shape,l,u,c,h,!1,m),y=g.filterHeight,b=g.filterWidth,v=g.padInfo.top,w=g.padInfo.right,S=g.padInfo.bottom,k=g.padInfo.left,I=g.dilationHeight,T=g.dilationWidth,E=g.strideHeight,R=g.strideWidth,D=g.inChannels,O=g.outChannels,$=g.padInfo.type==="SAME"?1:0;if(g.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${g.dataFormat}'. Please use 'channelsLast'.`);let _=a.makeOutput(g.outShape,"float32"),P=a.dataIdMap.get(_.dataId).id;return bQ(i,r.shape[0],r.shape[1],r.shape[2],o,y,b,v,w,S,k,$,I,T,E,R,D,O,P),_}var vWe={kernelName:xf,backendName:"wasm",setupFunc:bWe,kernelFunc:xWe},xQ;function wWe(e){xQ=e.wasm.cwrap(vf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function AWe(e){let{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=a,h=1,p=G.convertConv2DDataFormat(l),m=G.computeConv2DInfo(c,s.shape,i,h,o,u,!1,p),{batchSize:g,filterHeight:y,filterWidth:b,inChannels:v,inHeight:w,inWidth:S,outChannels:k,outHeight:I,outWidth:T,strideHeight:E,strideWidth:R}=m,D=y-1-m.padInfo.top,O=b-1-m.padInfo.left,$=m.dataFormat==="channelsLast",_=F.computeStrides(m.inShape),P=F.computeStrides(r.shape),[U,W,B]=F.computeStrides(s.shape),H=_[0],j=$?_[1]:_[2],Z=$?_[2]:1,te=$?1:_[1],V=P[0],Q=$?P[1]:P[2],ee=$?P[2]:1,ae=$?1:P[1],de=t.makeOutput(m.inShape,"float32"),ke=t.dataIdMap.get(de.dataId).id,Te=t.dataIdMap.get(r.dataId).id,$e=t.dataIdMap.get(s.dataId).id;return xQ(Te,$e,g,y,b,w,S,v,I,T,k,E,R,D,O,U,W,B,H,j,Z,te,V,Q,ee,ae,ke),de}var SWe={kernelName:vf,backendName:"wasm",setupFunc:wWe,kernelFunc:AWe},vQ;function kWe(e){vQ=e.wasm.cwrap(wf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function IWe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=G.computeConv3DInfo(r.shape,s.shape,i,l,o),c=n.makeOutput(u.outShape,r.dtype);return vQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var NWe={kernelName:wf,backendName:"wasm",setupFunc:kWe,kernelFunc:IWe},wQ;function CWe(e){wQ=e.wasm.cwrap(Jy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function TWe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=G.computeConv3DInfo(r.shape,l,i,1,o),c=n.makeOutput(u.filterShape,s.dtype);return wQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var EWe={kernelName:Jy,backendName:"wasm",setupFunc:CWe,kernelFunc:TWe},AQ;function $We(e){AQ=e.wasm.cwrap(eb,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _We(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=G.computeConv3DInfo(l,s.shape,o,1,i),c=n.makeOutput(u.inShape,r.dtype);return AQ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var RWe={kernelName:eb,backendName:"wasm",setupFunc:$We,kernelFunc:_We},DWe=pn(Af),OWe=pn(Sf),ZD;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(ZD||(ZD={}));var SQ;function FWe(e){SQ=e.wasm.cwrap(nb,null,["number","number","number","number","array","number","number","number","number","number"])}function MWe(e){let{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:s,cropSize:i}=a,{image:o,boxes:l,boxInd:u}=n,c=l.shape[0],[h,p]=i,m=[c,h,p,o.shape[3]],g=t.dataIdMap.get(o.dataId),y;o.dtype!=="float32"&&(y=od({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,v=t.dataIdMap.get(l.dataId).id,w=t.dataIdMap.get(u.dataId).id,S=t.makeOutput(m,"float32"),k=t.dataIdMap.get(S.dataId).id,I=new Uint8Array(new Int32Array(o.shape).buffer);return SQ(b,v,w,c,I,h,p,ZD[r],s,k),y!=null&&t.disposeData(y.dataId),S}var LWe={kernelName:nb,backendName:"wasm",setupFunc:FWe,kernelFunc:MWe},kQ;function zWe(e){kQ=e.wasm.cwrap(tb,null,["number","number","number","number","number","number"])}function BWe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;F.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`);let u=G.getAxesPermutation([s],l),c=r;u!==null&&(c=Oh({inputs:{x:r},attrs:{perm:u},backend:n}));let h=G.getInnerMostAxes(1,l)[0];G.assertAxesAreInnerMostDims("cumprod",[h],l);let p=n.makeOutput(c.shape,c.dtype),m=c.shape[h],g=n.dataIdMap.get(c.dataId).id,y=n.dataIdMap.get(p.dataId).id;kQ(g,i?1:0,o?1:0,m,y,xn[r.dtype]);let b=p;if(u!==null){let v=G.getUndoAxesPermutation(u);b=Oh({inputs:{x:p},attrs:{perm:v},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return b}var PWe={kernelName:tb,backendName:"wasm",setupFunc:zWe,kernelFunc:BWe},IQ;function VWe(e){IQ=e.wasm.cwrap(kf,null,["number","number","number","number","number","number"])}function UWe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;F.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`);let u=G.getAxesPermutation([s],l),c=r;u!==null&&(c=Oh({inputs:{x:r},attrs:{perm:u},backend:n}));let h=G.getInnerMostAxes(1,l)[0];G.assertAxesAreInnerMostDims("cumsum",[h],l);let p=n.makeOutput(c.shape,c.dtype),m=c.shape[h],g=n.dataIdMap.get(c.dataId).id,y=n.dataIdMap.get(p.dataId).id;IQ(g,i?1:0,o?1:0,m,y,xn[r.dtype]);let b=p;if(u!==null){let v=G.getUndoAxesPermutation(u);b=Oh({inputs:{x:p},attrs:{perm:v},backend:n}),n.disposeData(c.dataId),n.disposeData(p.dataId)}return b}var WWe={kernelName:kf,backendName:"wasm",setupFunc:VWe,kernelFunc:UWe},NQ;function GWe(e){NQ=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function HWe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i,binaryOutput:o}=a,l=s.shape.reduce((p,m)=>p*m,1)!==0,u=r.shape.length===1?[i]:[r.shape[0],i],c=t.makeOutput(u,s.dtype);function h(p){return t.dataIdMap.get(p.dataId).id}return NQ(h(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,l,h(s),xn[s.dtype],o,h(c)),c}var jWe={kernelName:Hw,backendName:"wasm",setupFunc:GWe,kernelFunc:HWe},CQ;function qWe(e){CQ=e.wasm.cwrap(ab,null,["number","number","number","array","number","array","array","number","number"])}function KWe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],u=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],h=l*s,p=u*s,m=c/(s*s),g=i==="NHWC"?[o,h,p,m]:[o,m,h,p],y=t.makeOutput(g,"float32"),b=t.dataIdMap.get(r.dataId).id,v=new Uint8Array(new Int32Array(F.computeStrides(r.shape)).buffer),w=new Uint8Array(new Int32Array(g).buffer),S=new Uint8Array(new Int32Array(F.computeStrides(g)).buffer),k=t.dataIdMap.get(y.dataId).id;return CQ(b,s,i==="NHWC"?1:0,v,r.shape.length-1,w,S,g.length,k),y}var XWe={kernelName:ab,backendName:"wasm",setupFunc:qWe,kernelFunc:KWe},TQ;function YWe(e){TQ=e.wasm.cwrap(If,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function QWe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:h}=n,p=u??[1,1],m=G.computeConv2DInfo(r.shape,s.shape,l,p,c,h,!0),g=m.filterHeight,y=m.filterWidth,b=m.padInfo.top,v=m.padInfo.right,w=m.padInfo.bottom,S=m.padInfo.left,k=m.dilationHeight,I=m.dilationWidth,T=m.strideHeight,E=m.strideWidth,R=m.inChannels,D=m.outChannels,O=m.padInfo.type==="SAME"?1:0;if(m.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);let $=a.makeOutput(m.outShape,"float32"),_=a.dataIdMap.get($.dataId).id;return TQ(i,r.shape[0],r.shape[1],r.shape[2],o,g,y,b,v,w,S,O,k,I,T,E,R,D,_),$}var ZWe={kernelName:If,backendName:"wasm",setupFunc:YWe,kernelFunc:QWe},EQ;function JWe(e){EQ=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function eGe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=F.sizeFromShape(a.shape),s=n.makeOutput([...a.shape,...a.shape],a.dtype);return EQ(n.dataIdMap.get(a.dataId).id,xn[a.dtype],r,n.dataIdMap.get(s.dataId).id),s}var tGe={kernelName:jw,backendName:"wasm",setupFunc:JWe,kernelFunc:eGe},$Q;function nGe(e){$Q=e.wasm.cwrap(Nf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function aGe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);let u=G.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l),c=n.makeOutput(u.outShape,r.dtype);return $Q(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,xn[r.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}var rGe={kernelName:Nf,backendName:"wasm",setupFunc:nGe,kernelFunc:aGe},_Q;function sGe(e){_Q=e.wasm.cwrap(cy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function iGe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let c=G.computeDilation2DInfo(r.shape,s.shape,o,l,"NHWC",u),h=n.makeOutput(s.shape,s.dtype);return _Q(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,xn[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),h}var oGe={kernelName:cy,backendName:"wasm",setupFunc:sGe,kernelFunc:iGe},RQ;function lGe(e){RQ=e.wasm.cwrap(uy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function uGe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let c=G.computeDilation2DInfo(r.shape,s.shape,o,l,"NHWC",u),h=n.makeOutput(r.shape,r.dtype);return RQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,xn[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),h}var cGe={kernelName:uy,backendName:"wasm",setupFunc:lGe,kernelFunc:uGe},hGe=pn(Tf),DQ;function dGe(e){DQ=e.wasm.cwrap(rb,null,["number","number","number"])}function pGe(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=n.makeOutput(r.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return DQ(i(r),i(a),i(s)),s}var fGe={kernelName:rb,backendName:"wasm",setupFunc:dGe,kernelFunc:pGe},mGe=!1,gGe=rr(sb,mGe,"bool"),yGe=pn(Ef),bGe=pn($f,"float32");function JD(e){let{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(F.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),Xs({inputs:{x:r},backend:a,attrs:{shape:o}})}var xGe={kernelName:ib,backendName:"wasm",kernelFunc:JD},vGe=pn(_f,"float32");function OQ(e){let{attrs:{shape:t,value:n},backend:a}=e,{attrs:{dtype:r}}=e;r=r||F.inferDtype(n);let s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var wGe={kernelName:qw,backendName:"wasm",kernelFunc:OQ},FQ;function AGe(e){FQ=e.wasm.cwrap(ob,null,["number","number","number","number","number","number"])}function SGe(e){let{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[o,l,u,c]=a.shape;return FQ(s,o,l,u,c,i),r}var kGe={kernelName:ob,backendName:"wasm",kernelFunc:SGe,setupFunc:AGe},IGe=pn(Rf),NGe=rr(Df),MQ;function CGe(e){MQ=e.wasm.cwrap(Of,null,["number","number","number","number","number","number","number"])}function TGe(e){let{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(i.dataId).id,p=t.dataIdMap.get(o.dataId).id,m=l!=null?t.dataIdMap.get(l.dataId).id:0,g=u!=null?t.dataIdMap.get(u.dataId).id:0,y=t.makeOutput(s.shape,s.dtype);if(F.sizeFromShape(s.shape)===0)return y;let b=t.dataIdMap.get(y.dataId).id;return MQ(c,h,p,m,g,r,b),y}var EGe={kernelName:Of,backendName:"wasm",setupFunc:CGe,kernelFunc:TGe},LQ;function $Ge(e){LQ=e.wasm.cwrap(Sp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _Ge(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=n,y=G.computeConv2DInfo(r.shape,s.shape,l,c,u,p),b=gw[m];if(b==null)throw new Error(`${m} activation not yet supported for FusedConv2D in the wasm backend.`);let v=a.dataIdMap.get(r.dataId).id,w=a.dataIdMap.get(s.dataId).id,S=y.outChannels,k=0;if(i!=null){let ee=a.dataIdMap.get(i.dataId);if(ee.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ee.shape.length}.`);if(ee.shape[0]!==S)throw new Error(`FusedConv2D bias shape (${ee.shape}) does not match the number of output channels (${S})`);k=ee.id}let I=y.filterHeight,T=y.filterWidth,E=y.padInfo.top,R=y.padInfo.right,D=y.padInfo.bottom,O=y.padInfo.left,$=y.dilationHeight,_=y.dilationWidth,P=y.strideHeight,U=y.strideWidth,W=y.inChannels,B=y.padInfo.type==="SAME"?1:0,H=y.batchSize,j=y.inHeight,Z=y.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let te=a.makeOutput(y.outShape,"float32"),V=a.dataIdMap.get(te.dataId).id,Q=o==null?0:a.dataIdMap.get(o.dataId).id;return LQ(v,H,j,Z,w,I,T,k,E,R,D,O,B,$,_,P,U,W,S,b,Q,g||0,V),te}var RGe={kernelName:Sp,backendName:"wasm",setupFunc:$Ge,kernelFunc:_Ge},zQ;function DGe(e){zQ=e.wasm.cwrap(kp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function OGe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=n,y=G.computeConv2DInfo(r.shape,s.shape,l,c,u,p,!0),b=gw[m];if(b==null)throw new Error(`${m} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let v=a.dataIdMap.get(r.dataId).id,w=a.dataIdMap.get(s.dataId).id,S=y.outChannels,k=0;if(i!=null){let ee=a.dataIdMap.get(i.dataId);if(ee.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ee.shape.length}.`);if(ee.shape[0]!==S)throw new Error(`FusedDepthwiseConv2D bias shape (${ee.shape}) does not match the number of output channels (${S})`);k=ee.id}let I=y.filterHeight,T=y.filterWidth,E=y.padInfo.top,R=y.padInfo.right,D=y.padInfo.bottom,O=y.padInfo.left,$=y.dilationHeight,_=y.dilationWidth,P=y.strideHeight,U=y.strideWidth,W=y.inChannels,B=y.padInfo.type==="SAME"?1:0,H=y.batchSize,j=y.inHeight,Z=y.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let te=a.makeOutput(y.outShape,"float32"),V=a.dataIdMap.get(te.dataId).id,Q=o==null?0:a.dataIdMap.get(o.dataId).id;return zQ(v,H,j,Z,w,I,T,k,E,R,D,O,B,$,_,P,U,W,S,b,Q,g||0,V),te}var FGe={kernelName:kp,backendName:"wasm",setupFunc:DGe,kernelFunc:OGe},BQ;function MGe(e){BQ=e.wasm.cwrap(ub,null,["number","number","number","number","number","number","array","number"])}function LGe(e){let{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,i,o,l]=GM.prepareAndValidate(a,r),u=t.makeOutput(s,a.dtype);if(i===0)return u;let c=r.shape,h=c[c.length-1],p=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(l).buffer),y=t.dataIdMap.get(u.dataId).id;return BQ(p,xn[a.dtype],m,i,h,o,g,y),u}var zGe={kernelName:ub,backendName:"wasm",setupFunc:MGe,kernelFunc:LGe},PQ;function BGe(e){PQ=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function PGe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:i,batchDims:o}=a,l=F.parseAxisParam(i,r.shape)[0],u=t.readSync(s.dataId),c=r.shape[l];for(let E=0;E<u.length;++E){let R=u[E];F.assert(R<=c-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${c-1}]`)}let h=G.segment_util.collectGatherOpShapeInfo(r,s,l,o),p=Xs({inputs:{x:r},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:t}),m=F.sizeFromShape(s.shape),g=Xs({inputs:{x:s},attrs:{shape:[h.batchSize,m/h.batchSize]},backend:t}),y=[h.batchSize,h.outerSize,m/h.batchSize,h.sliceSize],b=t.makeOutput(y,r.dtype);if(F.sizeFromShape(r.shape)===0)return b;let v=p.shape.length-1,w=t.dataIdMap.get(p.dataId).id,S=t.dataIdMap.get(g.dataId).id,k=t.dataIdMap.get(b.dataId).id,I=new Uint8Array(new Int32Array(F.computeStrides(p.shape)).buffer),T=new Uint8Array(new Int32Array(F.computeStrides(y)).buffer);return PQ(w,xn[r.dtype],I,v,S,h.batchSize,T,k),t.disposeData(p.dataId),t.disposeData(g.dataId),b.shape=h.outputShape,b}var VGe={kernelName:lb,backendName:"wasm",setupFunc:BGe,kernelFunc:PGe},UGe=!1,WGe=rr(cb,UGe,"bool"),GGe=!1,HGe=rr(Ff,GGe,"bool"),jGe=pn(Lf,"bool"),qGe=pn(zf,"bool"),KGe=pn(Bf,"bool"),VQ;function XGe(e){VQ=e.wasm.cwrap(Pf,null,["number","number","number","number"])}function YGe(e){let{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,"float32");if(F.sizeFromShape(t.shape)!==0){let i=a.dataIdMap.get(s.dataId).id;VQ(r,xn[t.dtype],n,i)}return s}var QGe={kernelName:Pf,backendName:"wasm",setupFunc:XGe,kernelFunc:YGe},ZGe=!1,JGe=rr(hb,ZGe,"bool"),eHe=!1,tHe=rr(db,eHe,"bool"),UQ;function nHe(e){UQ=e.wasm.cwrap(pb,null,["number","number","number","number"])}function aHe(e){let{attrs:t,backend:n}=e,{start:a,stop:r,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return UQ(n.dataIdMap.get(o.dataId).id,a,r,i),o}var rHe={kernelName:pb,backendName:"wasm",setupFunc:nHe,kernelFunc:aHe},sHe=pn(Vf),iHe=pn(Uf),oHe=!1,lHe=rr(fb,oHe,"bool"),uHe=pn(mb),cHe=!1,hHe=rr(gb,cHe,"bool"),dHe=!1,pHe=rr(V5,dHe,"bool"),WQ;function fHe(e){WQ=e.wasm.cwrap(Wf,null,["number","number","number","number","number","number","number"])}function mHe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;if(r.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(r.shape,r.dtype);return WQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,r.shape[3],s,i,o,l),u}var gHe={kernelName:Wf,backendName:"wasm",setupFunc:fHe,kernelFunc:mHe},GQ;function yHe(e){GQ=e.wasm.cwrap(yb,null,["number","number","number","number","number","number","number","number","number"])}function bHe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=a;if(r.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let h=n.makeOutput(r.shape,r.dtype);return GQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,i.shape[3],o,l,u,c),h}var xHe={kernelName:yb,backendName:"wasm",setupFunc:yHe,kernelFunc:bHe},HQ;function vHe(e){HQ=e.wasm.cwrap(Gf,null,["number","number","number","number"])}function wHe(e){let{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:h,inputWasTransposed:p}=id(i,r,t);if(p){let w=t.dataIdMap.get(u.dataId).id;l=u,o=w}let m=l.shape.length;G.assertAxesAreInnerMostDims("max",c,m);let[g,y]=G.computeOutAndReduceShapes(l.shape,c),b=F.sizeFromShape(y),v=t.makeOutput(g,i.dtype);if(F.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(v.dataId).id;HQ(o,xn[i.dtype],b,w)}if(p&&t.disposeData(u.dataId),s){let w=G.expandShapeToKeepDim(v.shape,h);v.shape=w}return v}var AHe={kernelName:Gf,backendName:"wasm",setupFunc:vHe,kernelFunc:wHe},SHe=rr(Hf),jQ;function kHe(e){jQ=e.wasm.cwrap(jf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function IHe(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;F.assert(r.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=G.computePool2DInfo(r.shape,i,o,1,l,u),h=c.filterHeight,p=c.filterWidth,m=c.padInfo.top,g=c.padInfo.right,y=c.padInfo.bottom,b=c.padInfo.left,v=c.dilationHeight,w=c.dilationWidth,S=c.strideHeight,k=c.strideWidth,I=c.inChannels,T=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let E=a.makeOutput(c.outShape,"float32"),R=a.dataIdMap.get(E.dataId).id;return jQ(s,r.shape[0],r.shape[1],r.shape[2],h,p,m,g,y,b,v,w,S,k,I,T,R),E}var NHe={kernelName:jf,backendName:"wasm",setupFunc:kHe,kernelFunc:IHe},qQ;function CHe(e){qQ=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function THe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,c=G.computePool3DInfo(r.shape,s,i,1,o,l,u),h=n.makeOutput(c.outShape,r.dtype);return qQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var EHe={kernelName:bb,backendName:"wasm",setupFunc:CHe,kernelFunc:THe},KQ;function $He(e){KQ=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _He(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,c=G.computePool3DInfo(s.shape,i,o,1,l,u),h=n.makeOutput(s.shape,s.dtype);return KQ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),h}var RHe={kernelName:Xw,backendName:"wasm",setupFunc:$He,kernelFunc:_He},XQ;function DHe(e){XQ=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function OHe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,c=G.computePool2DInfo(s.shape,i,o,1,l,u),h=n.makeOutput(s.shape,s.dtype);return XQ(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),h}var FHe={kernelName:Kw,backendName:"wasm",setupFunc:DHe,kernelFunc:OHe},YQ;function MHe(e){YQ=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function LHe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=a;F.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];F.assert(G.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=G.computePool2DInfo(r.shape,s,i,[1,1],o),h=n.makeOutput(c.outShape,r.dtype),p=n.makeOutput(c.outShape,"int32");return YQ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,n.dataIdMap.get(p.dataId).id,xn[r.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[h,p]}var zHe={kernelName:Yw,backendName:"wasm",setupFunc:MHe,kernelFunc:LHe},QQ;function BHe(e){QQ=e.wasm.cwrap(qf,null,["number, number, number"])}function PHe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:h,originalAxes:p,inputWasTransposed:m}=id(i,r,t),g=h;if(m){let k=t.dataIdMap.get(c.dataId).id;k!==o&&(u=c,l=k,g=G.getInnerMostAxes(g.length,u.shape.length))}G.assertAxesAreInnerMostDims("mean",g,u.shape.length);let[y,b]=G.computeOutAndReduceShapes(u.shape,g),v=F.sizeFromShape(b),w=u;u.dtype!=="float32"&&(w=od({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(w.dataId).id);let S=t.makeOutput(y,"float32");if(F.sizeFromShape(u.shape)!==0){let k=t.dataIdMap.get(S.dataId).id;QQ(l,v,k)}if(m&&t.disposeData(c.dataId),s){let k=G.expandShapeToKeepDim(S.shape,p);S.shape=k}return u.dtype!=="float32"&&t.disposeData(w.dataId),S}var VHe={kernelName:qf,backendName:"wasm",setupFunc:BHe,kernelFunc:PHe},ZQ;function UHe(e){ZQ=e.wasm.cwrap(Kf,null,["number","number","number","number"])}function WHe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:h,originalAxes:p,inputWasTransposed:m}=id(i,r,t);if(m){let S=t.dataIdMap.get(c.dataId).id;S!==o&&(u=c,l=S)}let g=u.shape.length;G.assertAxesAreInnerMostDims("min",h,g);let[y,b]=G.computeOutAndReduceShapes(u.shape,h),v=F.sizeFromShape(b),w=t.makeOutput(y,u.dtype);if(F.sizeFromShape(u.shape)!==0){let S=t.dataIdMap.get(w.dataId).id;ZQ(l,xn[i.dtype],v,S)}if(m&&t.disposeData(c.dataId),s){let S=G.expandShapeToKeepDim(w.shape,p);w.shape=S}return w}var GHe={kernelName:Kf,backendName:"wasm",setupFunc:UHe,kernelFunc:WHe},HHe=rr(Xf),eO;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(eO||(eO={}));var JQ;function jHe(e){JQ=e.wasm.cwrap(Yf,null,["number","array","number","number","array","array","number","number"])}function qHe(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map((g,y)=>g[0]+t.shape[y]+g[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map(g=>g[0]),h=a.map(g=>g[1]),p=new Uint8Array(new Int32Array(c).buffer),m=new Uint8Array(new Int32Array(h).buffer);return JQ(i,u,t.shape.length,xn[t.dtype],p,m,eO[r],l),o}var KHe={kernelName:Yf,backendName:"wasm",kernelFunc:qHe,setupFunc:jHe},eZ;function XHe(e){eZ=e.wasm.cwrap(vm,null,["number","number","number","number"])}function tZ(e){let{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[a],l=F.sizeFromShape(n.shape)/o;return F.sizeFromShape(s.shape)===0||eZ(r,i,o,l),s}var YHe={kernelName:vm,backendName:"wasm",setupFunc:XHe,kernelFunc:tZ},nZ;function QHe(e){nZ=e.wasm.cwrap(xb,null,["number","number","number","number","number","number"])}function ZHe(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;if(r.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);let l=o?r:tZ({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[u,c]=l.shape,h=n.makeOutput([u,s],"int32");return nZ(n.dataIdMap.get(l.dataId).id,u,c,s,i,n.dataIdMap.get(h.dataId).id),o||n.disposeData(l.dataId),h}var JHe={kernelName:xb,backendName:"wasm",setupFunc:QHe,kernelFunc:ZHe},e6e=rr(Qf),t6e=rr(Zf),n6e=pn(vb);function oz(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}var aZ;function a6e(e){aZ=e.wasm.cwrap(Ab,"number",["number","number","number","number","number"])}function r6e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=a,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,h=aZ(u,c,s,r,i),{pSelectedIndices:p,selectedSize:m,pSelectedScores:g,pValidOutputs:y}=oz(t,h);return t.wasm._free(g),t.wasm._free(y),t.makeOutput([m],"int32",p)}var s6e={kernelName:Ab,backendName:"wasm",setupFunc:a6e,kernelFunc:r6e},rZ;function i6e(e){rZ=e.wasm.cwrap(Sb,"number",["number","number","number","number","number","bool"])}function o6e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=a,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(u.dataId).id,p=rZ(c,h,s,r,i,o),{pSelectedIndices:m,selectedSize:g,pSelectedScores:y,pValidOutputs:b}=oz(t,p);t.wasm._free(y);let v=t.makeOutput([g],"int32",m),w=t.makeOutput([],"int32",b);return[v,w]}var l6e={kernelName:Sb,backendName:"wasm",setupFunc:i6e,kernelFunc:o6e},sZ;function u6e(e){sZ=e.wasm.cwrap(kb,"number",["number","number","number","number","number","number"])}function c6e(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=a,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(u.dataId).id,p=sZ(c,h,s,r,i,o),{pSelectedIndices:m,selectedSize:g,pSelectedScores:y,pValidOutputs:b}=oz(t,p);t.wasm._free(b);let v=t.makeOutput([g],"int32",m),w=t.makeOutput([g],"float32",y);return[v,w]}var h6e={kernelName:kb,backendName:"wasm",setupFunc:u6e,kernelFunc:c6e},d6e=!1,p6e=rr(wb,d6e,"bool"),iZ;function f6e(e){iZ=e.wasm.cwrap(Jf,null,["number","number","number","number","number"])}function m6e(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,u=n.makeOutput([...r.shape,i],s),c=n.dataIdMap.get(u.dataId).id,h=n.dataIdMap.get(r.dataId).id;return iZ(h,i,o,l,c),u}var g6e={kernelName:Jf,backendName:"wasm",setupFunc:f6e,kernelFunc:m6e};function y6e(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}var b6e={kernelName:Ib,backendName:"wasm",kernelFunc:y6e};function x6e(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return JD({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{F.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),F.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let h=JD({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),u=yQ({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeData(c.dataId)),u}var v6e={kernelName:Nb,backendName:"wasm",kernelFunc:x6e},oZ;function w6e(e){oZ=e.wasm.cwrap(em,null,["number","array","number","number","array","array","number","number"])}function A6e(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map((g,y)=>g[0]+t.shape[y]+g[1]);if(F.sizeFromShape(t.shape)===0)return OQ({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=a.map(g=>g[0]),h=a.map(g=>g[1]),p=new Uint8Array(new Int32Array(c).buffer),m=new Uint8Array(new Int32Array(h).buffer);return oZ(i,u,t.shape.length,xn[t.dtype],p,m,r,l),o}var lZ={kernelName:em,backendName:"wasm",kernelFunc:A6e,setupFunc:w6e},S6e=rr(tm),uZ;function k6e(e){uZ=e.wasm.cwrap(nm,null,["number","number","number"])}function I6e(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,o=s,l=a,u=l;l.dtype!=="float32"&&(u=od({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(a.shape,"float32"),h=n.dataIdMap.get(c.dataId).id;return uZ(o,i,h),l.dtype!=="float32"&&n.disposeData(u.dataId),c}var N6e={kernelName:nm,backendName:"wasm",setupFunc:k6e,kernelFunc:I6e},cZ;function C6e(e){cZ=e.wasm.cwrap(am,null,["number","number","number","number"])}function T6e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:h,originalAxes:p,inputWasTransposed:m}=id(i,r,t),g=h;if(m){let S=t.dataIdMap.get(c.dataId).id;S!==o&&(u=c,l=S,g=G.getInnerMostAxes(g.length,u.shape.length))}G.assertAxesAreInnerMostDims("prod",g,u.shape.length);let[y,b]=G.computeOutAndReduceShapes(u.shape,g),v=F.sizeFromShape(b),w=t.makeOutput(y,u.dtype);if(F.sizeFromShape(u.shape)!==0){let S=t.dataIdMap.get(w.dataId).id;cZ(l,v,xn[w.dtype],S)}if(m&&t.disposeData(c.dataId),s){let S=G.expandShapeToKeepDim(w.shape,p);w.shape=S}return w}var E6e={kernelName:am,backendName:"wasm",setupFunc:C6e,kernelFunc:T6e},$6e=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=FL(a,r,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},_6e={kernelName:Qw,backendName:"wasm",kernelFunc:$6e},R6e=rr(Cf),D6e=pn(rm),O6e=pn(sm),F6e=pn(lm),hZ;function M6e(e){hZ=e.wasm.cwrap(om,null,["number","number","number","number","number","number","number","number","number","number"])}function L6e(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,[c,h,p,m]=r.shape,g=[c,l,u,m],y=t.dataIdMap.get(r.dataId),b;y.dtype!=="float32"&&(b=od({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(b.dataId));let v=y.id,w=t.makeOutput(g,"float32");if(F.sizeFromShape(r.shape)===0)return w;let S=t.dataIdMap.get(w.dataId).id;return hZ(v,c,h,p,m,l,u,s?1:0,i?1:0,S),b!=null&&t.disposeData(b.dataId),w}var z6e={kernelName:om,backendName:"wasm",setupFunc:M6e,kernelFunc:L6e},dZ;function B6e(e){dZ=e.wasm.cwrap(Eb,null,["number","number","number","array","array","boolean"])}function P6e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,"float32"),l=n.dataIdMap.get(r.dataId),u;return l.dtype!=="float32"&&(u=od({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),dZ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var V6e={kernelName:Eb,backendName:"wasm",setupFunc:B6e,kernelFunc:P6e},pZ;function U6e(e){pZ=e.wasm.cwrap(im,null,["number","number","number","number","number","number","number","number","number","number"])}function W6e(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,[c,h,p,m]=r.shape,g=[c,l,u,m],y=t.makeOutput(g,"float32");if(F.sizeFromShape(r.shape)===0)return y;let b=t.dataIdMap.get(r.dataId),v;b.dtype!=="float32"&&(v=od({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),b=t.dataIdMap.get(v.dataId));let w=b.id,S=t.dataIdMap.get(y.dataId).id;return pZ(w,c,h,p,m,l,u,s?1:0,i?1:0,S),v!=null&&t.disposeData(v.dataId),y}var G6e={kernelName:im,backendName:"wasm",setupFunc:U6e,kernelFunc:W6e},fZ;function H6e(e){fZ=e.wasm.cwrap(Tb,null,["number","number","number","array","array","boolean"])}function j6e(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,"float32"),l=n.dataIdMap.get(r.dataId),u;return l.dtype!=="float32"&&(u=od({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),fZ(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var q6e={kernelName:Tb,backendName:"wasm",setupFunc:H6e,kernelFunc:j6e},mZ;function K6e(e){mZ=e.wasm.cwrap(um,null,["number","array","number","array","number","number"])}function X6e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=F.parseAxisParam(s,r.shape);if(r.shape.length===0)return OC({inputs:{x:r},backend:n});let o=n.makeOutput(r.shape,r.dtype),l=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(r.shape).buffer);mZ(l,c,i.length,h,r.shape.length,u);let p=Xs({inputs:{x:o},attrs:{shape:r.shape},backend:n});return n.disposeData(o.dataId),p}var Y6e={kernelName:um,backendName:"wasm",kernelFunc:X6e,setupFunc:K6e},gZ;function Q6e(e){gZ=e.wasm.cwrap(Gb,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Z6e(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=a,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(l.dataId).id,[h,p,m,g]=r.shape,[y,b]=G.getImageCenter(o,p,m),v=i===0,w=255,S=typeof i=="number"?[i,i,i,v?0:w]:[...i,w],k=new Uint8Array(new Int32Array(S).buffer);return gZ(u,h,p,m,g,s,y,b,k,S.length,c),l}var J6e={kernelName:Gb,backendName:"wasm",kernelFunc:Z6e,setupFunc:Q6e},eje=pn(cm),tje=pn(hm),yZ;function nje(e){yZ=e.wasm.cwrap($b,null,["number","number","number","number","number","number","array","number","number"])}function aje(e){let{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:i}=a,o=t.makeOutput(i,s.dtype);if(F.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=Y2.calculateShapes(s,r,i),m=t.dataIdMap.get(r.dataId).id,g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(o.dataId).id;return yZ(m,g,xn[s.dtype],l,u,c,y,p,b),o}var rje={kernelName:$b,backendName:"wasm",setupFunc:nje,kernelFunc:aje},bZ;function sje(e){bZ=e.wasm.cwrap(Rb,null,["number","number","number","number","number","number","bool","number"])}function ije(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a;if(r.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(u){return n.dataIdMap.get(u.dataId).id}return bZ(l(r),l(s),r.shape[0],r.shape[1],s.shape[1],xn[r.dtype],i==="left",l(o)),o}var oje={kernelName:Rb,backendName:"wasm",setupFunc:sje,kernelFunc:ije},xZ;function lje(e){xZ=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function uje(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(r.shape,r.dtype),c=n.dataIdMap.get(u.dataId).id,h=a.shape.length,p=r.shape.length,m=h===0||h>1||p===1?1:F.sizeFromShape(r.shape.slice(1));return xZ(i,o,l,m,c),u}var cje={kernelName:Db,backendName:"wasm",kernelFunc:uje,setupFunc:lje},hje=pn(dm),vZ;function dje(e){vZ=e.wasm.cwrap(gm,null,["number","number"])}function pje(e){let{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return F.sizeFromShape(r.shape)===0||vZ(a,s),r}var fje={kernelName:"Sigmoid",backendName:"wasm",setupFunc:dje,kernelFunc:pje},mje=pn(mm),gje=pn(pm),yje=pn(fm),bje=pn(ym);function xje(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a,o=F.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let b=1+s.length;b<r.shape.length;++b)l.push([0,0]);let u=lZ.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=G.getReshaped(u.shape,s,o,!1),h=G.getPermuted(c.length,s.length,!1),p=G.getReshapedPermuted(u.shape,s,o,!1),m=Xs({inputs:{x:u},backend:n,attrs:{shape:c}}),g=Oh({inputs:{x:m},backend:n,attrs:{perm:h}}),y=Xs({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeData(u.dataId),n.disposeData(m.dataId),n.disposeData(g.dataId),y}var vje={kernelName:Fb,backendName:"wasm",kernelFunc:xje},wZ;function wje(e){wZ=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Aje(e){let{backend:t,inputs:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=n,o=a.shape[0],l=a.shape[1],u=t.readSync(s.dataId)[0],c=[o+u,l],h=t.dataIdMap.get(a.dataId).id,p=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(i.dataId).id,g=t.makeOutput(c,a.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput(c.slice(0,1),r.dtype),v=t.dataIdMap.get(b.dataId).id,w=t.makeOutput([u],"bool"),S=t.dataIdMap.get(w.dataId).id,k=t.makeOutput([o],a.dtype),I=t.dataIdMap.get(k.dataId).id,T=t.makeOutput([4],"int32"),E=t.dataIdMap.get(T.dataId).id,R=wZ(h,p,xn[r.dtype],o,u,l,m,y,v,S,I,E),D=t.readSync(T.dataId),O;switch(D[0]){case 1:{O=G.getSparseFillEmptyRowsIndicesDenseShapeMismatch(D[1]);break}case 2:{O=G.getSparseFillEmptyRowsNegativeIndexErrorMessage(D[1],D[2]);break}case 3:O=G.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(D[1],D[2],D[3]);break;default:O=""}if(t.disposeData(T.dataId),O)throw t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),t.disposeData(k.dataId),new Error(O);let $=g,_=b;return R!==c[0]&&($=Pp({inputs:{x:g},attrs:{begin:0,size:[R,l]},backend:t}),_=Pp({inputs:{x:b},attrs:{begin:0,size:R},backend:t}),t.disposeData(g.dataId),t.disposeData(b.dataId)),[$,_,w,k]}var Sje={kernelName:Zw,backendName:"wasm",setupFunc:wje,kernelFunc:Aje},AZ;function kje(e){AZ=e.wasm.cwrap(Lb,null,["number","number","number","number","number","number","number"])}function Ije(e){let{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:s}=n;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(a.dataId).id,o=t.dataIdMap.get(r.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=a.shape[0],c=F.sizeFromShape(s.shape),h=t.makeOutput([u,c],a.dtype),p=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([c],s.dtype),g=t.dataIdMap.get(m.dataId).id,y=t.makeOutput([3],"int32"),b=t.dataIdMap.get(y.dataId).id;AZ(i,o,l,u,p,g,b);let v=t.readSync(y.dataId),w;switch(v[0]){case 0:{w=G.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(v[1],v[2]);break}case 1:{w=G.getSparseReshapeNegativeOutputDimErrorMessage(v[1],v[2]);break}case 2:w=G.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let S=Array.from(t.readSync(r.dataId)),k=Array.from(t.readSync(m.dataId));w=G.getSparseReshapeInputOutputMultipleErrorMessage(S,k);break}case 4:{let S=Array.from(t.readSync(r.dataId)),k=Array.from(t.readSync(m.dataId));w=G.getSparseReshapeInputOutputMismatchErrorMessage(S,k);break}default:w=""}if(t.disposeData(y.dataId),w)throw t.disposeData(h.dataId),t.disposeData(m.dataId),new Error(w);return[h,m]}var Nje={kernelName:Lb,backendName:"wasm",setupFunc:kje,kernelFunc:Ije},SZ;function kZ(e){SZ=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function IZ(e,t){let{backend:n,inputs:a}=e,{data:r,indices:s,segmentIds:i}=a,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(G.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=r.shape.slice();c[0]=u;let h=n.dataIdMap.get(r.dataId).id,p=n.dataIdMap.get(s.dataId).id,m=n.dataIdMap.get(i.dataId).id,g=n.makeOutput(c,r.dtype),y=n.dataIdMap.get(g.dataId).id,b=n.makeOutput([4],"int32"),v=n.dataIdMap.get(b.dataId).id;SZ(h,xn[r.dtype],r.shape[0],p,m,y,v,t,0);let w=n.readSync(b.dataId),S;switch(w[0]){case 0:{S=G.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{S=G.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:S=G.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1],w[2]);break;case 3:S=G.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1],w[2],w[3]);break;default:S=""}if(n.disposeData(b.dataId),S)throw n.disposeData(g.dataId),new Error(S);return g}function Cje(e){return IZ(e,!0)}var Tje={kernelName:Jw,backendName:"wasm",setupFunc:kZ,kernelFunc:Cje};function Eje(e){return IZ(e,!1)}var $je={kernelName:e1,backendName:"wasm",setupFunc:kZ,kernelFunc:Eje},NZ;function _je(e){NZ=e.wasm.cwrap(zb,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Rje(e){let{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=n,{outputShape:o}=a,l=t.makeOutput(o,i.dtype);if(F.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:c,sliceSize:h,strides:p,outputSize:m}=G.calculateShapes(s,r,o),g=t.dataIdMap.get(r.dataId).id,y=t.dataIdMap.get(s.dataId).id,b=t.dataIdMap.get(i.dataId).id,v=new Uint8Array(new Int32Array(p).buffer),w=t.dataIdMap.get(l.dataId).id;return NZ(g,y,s.shape.length,b,xn[i.dtype],u,c,h,v,m,w),l}var Dje={kernelName:zb,backendName:"wasm",setupFunc:_je,kernelFunc:Rje};function Oje(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=F.parseAxisParam(i,r.shape)[0],l=G.prepareSplitSize(r,s,o),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{let p=[...c];p[o]=h;let m=Pp({inputs:{x:r},attrs:{begin:u,size:p},backend:a});return u[o]+=h,m})}var Fje={kernelName:Mb,backendName:"wasm",kernelFunc:Oje},Mje=pn(bm),Lje=pn(t1),zje=rr(wm),CZ;function Bje(e){CZ=e.wasm.cwrap(Zh,null,["number","number","number","number"])}function Pje(e){let{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return CZ(i,r,xn[s.dtype],l),o}var Vje={kernelName:Zh,backendName:"wasm",setupFunc:Bje,kernelFunc:Pje},TZ;function Uje(e){TZ=e.wasm.cwrap(Bb,null,["number","array","number","array","array","array","array","array","number","number"])}function Wje(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:b,isSimpleSlice:v,begin:w,end:S,strides:k}=mr.sliceInfo(r.shape,s,i,o,l,u,c,h,p),I;if(y)I=Xs({inputs:{x:r},backend:t,attrs:{shape:g}});else if(b||v){F.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let T=mr.computeOutShape(w,S,k),E=Pp({inputs:{x:r},backend:t,attrs:{begin:w,size:T}});I=Xs({inputs:{x:E},backend:t,attrs:{shape:g}}),t.disposeData(E.dataId)}else{let T=t.makeOutput(m,"float32"),E=t.dataIdMap.get(r.dataId).id,R=new Uint8Array(new Int32Array(F.computeStrides(r.shape)).buffer),D=new Uint8Array(new Int32Array(w).buffer),O=new Uint8Array(new Int32Array(S).buffer),$=new Uint8Array(new Int32Array(k).buffer),_=new Uint8Array(new Int32Array(m).buffer),P=new Uint8Array(new Int32Array(F.computeStrides(m)).buffer),U=t.dataIdMap.get(T.dataId).id;TZ(E,R,r.shape.length,D,O,$,_,P,m.length,U),I=Xs({inputs:{x:T},backend:t,attrs:{shape:g}}),t.disposeData(T.dataId)}return I}var Gje={kernelName:Bb,backendName:"wasm",setupFunc:Uje,kernelFunc:Wje};function Hje(e){let{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:h}=a,p=t.readSync(r.dataId),m=t.readSync(s.dataId),[g,y]=LL(p,m,i,o,l,u,c,h),b=t.makeOutput([g.length],"string"),v=t.dataIdMap.get(b.dataId);v.stringBytes=g;let w=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(w).set(y),[b,w]}var jje={kernelName:a1,backendName:"wasm",kernelFunc:Hje};function qje(e){let{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:s}=n,{skipEmpty:i}=a,o=t.readSync(r.dataId),l=t.readSync(s.dataId),[u,c,h]=zL(o,l[0],i),p=c.length,m=t.makeOutput([p,2],"int32");t.typedArrayFromHeap(m).set(u);let g=t.makeOutput([p],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=c;let b=t.makeOutput([2],"int32");return t.typedArrayFromHeap(b).set(h),[m,g,b]}var Kje={kernelName:r1,backendName:"wasm",kernelFunc:qje};function Xje(e){let{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:s}=a,i=t.readSync(r.dataId),o=BL(i,s),l=t.makeOutput(r.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var Yje={kernelName:s1,backendName:"wasm",kernelFunc:Xje},Qje=rr(Am),EZ;function Zje(e){EZ=e.wasm.cwrap(xm,null,["number","number","number","number"])}function Jje(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:h,originalAxes:p,inputWasTransposed:m}=id(i,r,t),g=h;if(m){let S=t.dataIdMap.get(c.dataId).id;S!==o&&(u=c,l=S,g=G.getInnerMostAxes(g.length,u.shape.length))}G.assertAxesAreInnerMostDims("sum",g,u.shape.length);let[y,b]=G.computeOutAndReduceShapes(u.shape,g),v=F.sizeFromShape(b),w=t.makeOutput(y,u.dtype);if(F.sizeFromShape(u.shape)!==0){let S=t.dataIdMap.get(w.dataId).id;EZ(l,v,xn[w.dtype],S)}if(m&&t.disposeData(c.dataId),s){let S=G.expandShapeToKeepDim(w.shape,p);w.shape=S}return w}var e5e={kernelName:xm,backendName:"wasm",setupFunc:Zje,kernelFunc:Jje},t5e=pn(Sm),n5e=pn(km),$Z;function a5e(e){$Z=e.wasm.cwrap(_b,null,["number","number","number","number","number","number","array","number","number","number"])}function r5e(e){let{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=n,o=t.makeOutput(r.shape,r.dtype);if(F.sizeFromShape(r.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=Y2.calculateShapes(i,s,r.shape),m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=t.dataIdMap.get(r.dataId).id,b=new Uint8Array(new Int32Array(h).buffer),v=t.dataIdMap.get(o.dataId).id;return $Z(m,g,xn[i.dtype],l,u,c,b,p,v,y),o}var s5e={kernelName:_b,backendName:"wasm",setupFunc:a5e,kernelFunc:r5e},_Z;function i5e(e){_Z=e.wasm.cwrap(Qh,null,["number","array","number","array","number","number"])}function o5e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:i}=a,o=new Array(r.shape.length);for(let p=0;p<o.length;p++)o[p]=r.shape[p]*i[p];let l=new Uint8Array(new Int32Array(r.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,r.dtype),h=n.dataIdMap.get(c.dataId).id;return _Z(s,l,r.shape.length,u,o.length,xn[c.dtype],h),c}var l5e={kernelName:Qh,backendName:"wasm",setupFunc:i5e,kernelFunc:o5e},RZ;function u5e(e){RZ=e.wasm.cwrap(Pb,null,["number","array","number","number","number","bool","number","number"])}var c5e=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{k:r,sorted:s}=n,i=t.dataIdMap.get(a.dataId).id,o=new Uint8Array(new Int32Array(a.shape).buffer),l=a.shape.slice();l[l.length-1]=r;let u=t.makeOutput(l,a.dtype),c=t.dataIdMap.get(u.dataId).id,h=t.makeOutput(l,"int32"),p=t.dataIdMap.get(h.dataId).id;return RZ(i,o,a.shape.length,xn[a.dtype],r,s,c,p),[u,h]},h5e={kernelName:Pb,backendName:"wasm",setupFunc:u5e,kernelFunc:c5e},DZ;function d5e(e){DZ=e.wasm.cwrap(Vb,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function p5e(e){let{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=a,[c,h,p,m]=r.shape,[g,y]=u??[h,p],b=[c,g,y,m],v=new Uint8Array(new Int32Array(F.computeStrides(r.shape)).buffer),w=new Uint8Array(new Int32Array(F.computeStrides(b)).buffer),S=t.makeOutput(b,r.dtype),k=t.dataIdMap.get(S.dataId).id,I=t.dataIdMap.get(r.dataId).id,T=t.dataIdMap.get(s.dataId).id,E=i==="nearest"?1:2,R;switch(o){case"constant":R=1;break;case"reflect":R=2;break;case"wrap":R=3;break;case"nearest":R=4;break;default:R=1;break}return DZ(I,T,s.shape[0]>1,c,g,y,m,p,h,v,r.shape.length-1,w,b.length-1,E,R,l,k),S}var f5e={kernelName:Vb,backendName:"wasm",setupFunc:d5e,kernelFunc:p5e};function m5e(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=VL(a.readSync(s.dataId),r,s.shape,s.dtype);return[a.makeOutput(o,s.dtype,void 0,i),a.makeOutput([l.length],"int32",void 0,l)]}var g5e={kernelName:i1,backendName:"wasm",kernelFunc:m5e};function y5e(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape[s],o=r.shape.length,l=new Array(o-1),u=0;for(let m=0;m<o;m++)m!==s&&(l[u++]=r.shape[m]);let c=new Array(i),h=new Array(o).fill(0),p=r.shape.slice();p[s]=1;for(let m=0;m<c.length;m++)h[s]=m,c[m]=Pp({inputs:{x:r},attrs:{begin:h,size:p},backend:n});return c.map(({dataId:m,dtype:g})=>({dataId:m,dtype:g,shape:l}))}var b5e={kernelName:Ub,backendName:"wasm",kernelFunc:y5e};function x5e(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}var v5e={kernelName:Wb,backendName:"wasm",kernelFunc:x5e},w5e=[dUe,pUe,fUe,mUe,gUe,xUe,CUe,$Ue,_Ue,RUe,DUe,OUe,FUe,MUe,LUe,PUe,XUe,WUe,jUe,JUe,sWe,lWe,uWe,hWe,dWe,pWe,gWe,yWe,vWe,SWe,NWe,EWe,RWe,DWe,OWe,LWe,PWe,WWe,jWe,XWe,ZWe,tGe,rGe,oGe,cGe,hGe,fGe,gGe,yGe,bGe,xGe,vGe,wGe,kGe,IGe,NGe,EGe,RGe,FGe,zGe,VGe,WGe,HGe,vUe,jGe,qGe,KGe,QGe,JGe,tHe,rHe,iHe,sHe,lHe,uHe,hHe,pHe,gHe,xHe,AHe,SHe,NHe,EHe,RHe,FHe,zHe,VHe,GHe,HHe,KHe,JHe,e6e,t6e,n6e,s6e,l6e,h6e,p6e,g6e,b6e,v6e,lZ,S6e,N6e,E6e,_6e,R6e,D6e,O6e,F6e,YUe,z6e,V6e,G6e,q6e,Y6e,J6e,eje,tje,rje,oje,cje,hje,fje,mje,gje,yje,aWe,YHe,bje,vje,Sje,Nje,Tje,$je,Dje,Fje,Mje,Lje,zje,Vje,Gje,jje,Kje,Yje,Qje,e5e,t5e,n5e,s5e,l5e,h5e,f5e,kUe,g5e,b5e,v5e];for(let e of w5e)l1(e);var tO=xe();tO.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});tO.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(tO.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var JH=Kh(nde()),A5e=Kh(ade()),e6=Kh(rde()),t6=JH.default||JH,S5e=e6.default||e6,OZ=class extends Bw{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(FZ),nO=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new l2(this,_o())}write(e,t,n){let a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=F.now();return e(),{kernelMs:F.now()-t}}move(e,t,n,a,r){let s=this.dataIdNextNumber++;if(a==="string"){let u=t;this.dataIdMap.set(e,{id:s,stringBytes:u,shape:n,dtype:a,memoryOffset:null,refCount:r});return}let i=F.sizeFromShape(n),o=i*F.bytesPerElement(a),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:a,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(r==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||F.sizeFromShape(s);let o=F.bytesPerElement(r),l=this.wasm.HEAPU8.slice(a+t*o,a+n*o);return N5e(l.buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(n==null)r=this.write(a??null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=F.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),s=F.sizeFromShape(e);switch(t){case"float32":return new Float32Array(a,r,s);case"int32":return new Int32Array(a,r,s);case"bool":return new Uint8Array(a,r,s);default:throw new Error(`Unknown dtype ${t}`)}}};function k5e(e){return(t,n)=>(F.fetch(e,{credentials:"same-origin"}).then(a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then(r=>{WebAssembly.instantiate(r,t).then(s=>{n(s.instance,s.module)})})}),{})}function n6(e,t,n){if(vN!=null)return vN;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),Kv!=null&&Kv[a]!=null?Kv[a]:n+a}async function I5e(){let[e,t]=await Promise.all([xe().getAsync("WASM_HAS_SIMD_SUPPORT"),xe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,a)=>{let r={};r.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let u=A5e.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?n6(e,t,zv??l):l+o},lz&&(r.instantiateWasm=k5e(n6(e,t,zv??"")));let s=!1;r.onAbort=()=>{s||Xv||(Xv=!0,a({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&vN==null?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+t6.toString()],{type:"text/javascript"}),i=t6(r)):i=S5e(r),i.then(o=>{s=!0,Xv=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(a)})}function N5e(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var C5e=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],vN=null,zv=null,Kv={},Xv=!1,lz=!1;function T5e(e,t=!1){if(nq("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Xv)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");vN=e,lz=t}function E5e(e,t=!1){if(Xv)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")zv=e;else{Kv=e;let n=C5e.filter(a=>Kv[a]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}lz=t}var FZ=-1,nO=-1;function $5e(e){FZ=e}function _5e(){if(nO===-1)throw new Error("WASM backend not initialized.");return nO}var R5e="4.22.0",D5e=2;N2("wasm",async()=>{let{wasm:e}=await I5e();return new OZ(e)},D5e);var a6="4.22.0",O5e="4.22.0",F5e="4.22.0",M5e="4.22.0",L5e="4.22.0",z5e={tfjs:a6,"tfjs-core":a6,"tfjs-converter":O5e,"tfjs-backend-cpu":F5e,"tfjs-backend-webgl":M5e,"tfjs-backend-wasm":L5e},B5e={};mF(B5e,{AnchorPosition:()=>QZ,DrawBox:()=>eJ,DrawBoxOptions:()=>JZ,DrawFaceLandmarks:()=>bJ,DrawFaceLandmarksOptions:()=>yJ,DrawTextField:()=>mz,DrawTextFieldOptions:()=>fz,drawContour:()=>ah,drawDetections:()=>Z5e,drawFaceExpressions:()=>dqe,drawFaceLandmarks:()=>fqe});function ah(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:a,y:r},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(a,r)}),n){let a=t[t.length-1],r=t[0];if(!a||!r)return;e.moveTo(a.x,a.y),e.lineTo(r.x,r.y)}e.stroke()}var P5e={};mF(P5e,{computeReshapedDimensions:()=>BZ,getCenterPoint:()=>cz,isDimensions:()=>rO,isEven:()=>aO,isFloat:()=>zZ,isTensor:()=>hx,isTensor1D:()=>V5e,isTensor2D:()=>LZ,isTensor3D:()=>V1,isTensor4D:()=>Yu,isValidNumber:()=>gp,isValidProbablitiy:()=>U5e,range:()=>Iy,round:()=>uz});var ny=class MZ{constructor(t,n){if(!gp(t)||!gp(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new MZ(1/this.width,1/this.height)}};function hx(e,t){return e instanceof Bt&&e.shape.length===t}function V5e(e){return hx(e,1)}function LZ(e){return hx(e,2)}function V1(e){return hx(e,3)}function Yu(e){return hx(e,4)}function zZ(e){return e%1!==0}function aO(e){return e%2===0}function uz(e,t=2){let n=10**t;return Math.floor(e*n)/n}function rO(e){return e&&e.width&&e.height}function BZ({width:e,height:t},n){let a=n/Math.max(t,e);return new ny(Math.round(e*a),Math.round(t*a))}function cz(e){return e.reduce((t,n)=>t.add(n),new Bn(0,0)).div(new Bn(e.length,e.length))}function Iy(e,t,n){return Array(e).fill(0).map((a,r)=>t+r*n)}function gp(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function U5e(e){return gp(e)&&e>=0&&e<=1}var Bn=class Yd{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Yd(this.x+t.x,this.y+t.y)}sub(t){return new Yd(this.x-t.x,this.y-t.y)}mul(t){return new Yd(this.x*t.x,this.y*t.y)}div(t){return new Yd(this.x/t.x,this.y/t.y)}abs(){return new Yd(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Yd(Math.floor(this.x),Math.floor(this.y))}},Vp=class Jo{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(gp)}static assertIsValidBox(t,n,a=!1){if(!Jo.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!a&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let a=t||{},r=[a.left,a.top,a.right,a.bottom].every(gp),s=[a.x,a.y,a.width,a.height].every(gp);if(!s&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(a)}`);let[i,o,l,u]=s?[a.x,a.y,a.width,a.height]:[a.left,a.top,a.right-a.left,a.bottom-a.top];Jo.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Bn(this.left,this.top)}get topRight(){return new Bn(this.right,this.top)}get bottomLeft(){return new Bn(this.left,this.bottom)}get bottomRight(){return new Bn(this.right,this.bottom)}round(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new Jo({x:t,y:n,width:a,height:r})}floor(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new Jo({x:t,y:n,width:a,height:r})}toSquare(){let{x:t,y:n,width:a,height:r}=this,s=Math.abs(a-r);return a<r&&(t-=s/2,a+=s),r<a&&(n-=s/2,r+=s),new Jo({x:t,y:n,width:a,height:r})}rescale(t){let n=rO(t)?t.width:t,a=rO(t)?t.height:t;return new Jo({x:this.x*n,y:this.y*a,width:this.width*n,height:this.height*a})}pad(t,n){let[a,r,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new Jo({x:a,y:r,width:s,height:i})}clipAtImageBorders(t,n){let{x:a,y:r,right:s,bottom:i}=this,o=Math.max(a,0),l=Math.max(r,0),u=s-o,c=i-l,h=Math.min(u,t-o),p=Math.min(c,n-l);return new Jo({x:o,y:l,width:h,height:p}).floor()}shift(t,n){let{width:a,height:r}=this,s=this.x+t,i=this.y+n;return new Jo({x:s,y:i,width:a,height:r})}padAtBorders(t,n){let a=this.width+1,r=this.height+1,s=1,i=1,o=a,l=r,u=this.left,c=this.top,h=this.right,p=this.bottom;return h>n&&(o=-h+n+a,h=n),p>t&&(l=-p+t+r,p=t),u<1&&(l=2-u,u=1),c<1&&(l=2-c,c=1),{dy:i,edy:l,dx:s,edx:o,y:c,ey:p,x:u,ex:h,w:a,h:r}}calibrate(t){return new Jo({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},PZ=class extends Vp{constructor(e,t,n,a,r=!1){super({left:e,top:t,right:n,bottom:a},r)}},VZ=class UZ{constructor(t,n,a,r,s){this._imageDims=new ny(s.width,s.height),this._score=t,this._classScore=n,this._className=a,this._box=new Vp(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Vp(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new UZ(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},gl=class WZ extends VZ{constructor(t,n,a){super(t,t,"",n,a)}forSize(t,n){let{score:a,relativeBox:r,imageDims:s}=super.forSize(t,n);return new WZ(a,r,s)}};function W5e(e,t,n=!0){let a=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=a*r;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function G5e(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),a=t.reduce((o,l)=>l<o?l:o,1/0),r=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new PZ(a,r,s,i)}function H5e(e,t,n,a=!0){let r=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;r.length>0;){let i=r.pop();s.push(i);let o=r,l=[];for(let u=0;u<o.length;u++){let c=o[u],h=e[i],p=e[c];l.push(W5e(h,p,a))}r=r.filter((u,c)=>l[c]<=n)}return s}function U1(e,t){return fe(()=>{let[n,a,r]=t,s=Ni([...e.shape.slice(0,3),1],n,"float32"),i=Ni([...e.shape.slice(0,3),1],a,"float32"),o=Ni([...e.shape.slice(0,3),1],r,"float32"),l=Un([s,i,o],3);return nt(e,l)})}function j5e(e,t=!1){return fe(()=>{let[n,a]=e.shape.slice(1);if(n===a)return e;let r=Math.abs(n-a),s=Math.round(r*(t?.5:1)),i=n>a?2:1,o=h=>{let p=e.shape.slice();return p[i]=h,Ni(p,0,"float32")},l=o(s),u=r-l.shape[i],c=[t&&u?o(u):null,e,l].filter(h=>!!h).map(h=>He(h,"float32"));return Un(c,i)})}function kR(e){return 1/(1+Math.exp(-e))}var GZ=class extends Vp{constructor(e,t,n,a,r=!1){super({x:e,y:t,width:n,height:a},r)}},q5e=.5,K5e=.43,X5e=.45,wN=class{constructor(e,t,n=new Bn(0,0)){let{width:a,height:r}=t;this._imgDims=new ny(a,r),this._shift=n,this._positions=e.map(s=>s.mul(new Bn(a,r)).add(n))}get shift(){return new Bn(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Bn(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Bn(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let r=e instanceof gl?e.box.floor():new Vp(e);return this.shiftBy(r.x,r.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:a}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(a)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,a]=e,r=c=>a.sub(c).magnitude(),s=(r(t)+r(n))/2,i=Math.floor(s/X5e),o=cz(e),l=Math.floor(Math.max(0,o.x-q5e*i)),u=Math.floor(Math.max(0,o.y-K5e*i));return new GZ(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=G5e(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},HZ=class extends wN{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(cz)}};function AN(e){return e.detection instanceof gl}function jZ(e,t){return{...e,detection:t}}function qZ(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function hz(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function KZ(e){let t="";if(!e&&hz())try{e=Fhe("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((a,r)=>{e.readFile(n,(s,i)=>s?r(s):a(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function XZ(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},r=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=KZ();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:r,createVideoElement:s,fetch:i,...o}}function YZ(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Sr;function Y5e(){if(!Sr)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Sr}function sO(e){Sr=e}function dz(){return YZ()?sO(qZ()):hz()?sO(XZ()):null}function Q5e(e){if(Sr||dz(),!Sr)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Sr.Canvas,Image:n=Sr.Image}=e;Sr.Canvas=t,Sr.Image=n,Sr.createCanvasElement=e.createCanvasElement||(()=>new t),Sr.createImageElement=e.createImageElement||(()=>new n),Sr.ImageData=e.ImageData||Sr.ImageData,Sr.Video=e.Video||Sr.Video,Sr.fetch=e.fetch||Sr.fetch,Sr.readFile=e.readFile||Sr.readFile}var $s={getEnv:Y5e,setEnv:sO,initialize:dz,createBrowserEnv:qZ,createFileSystem:KZ,createNodejsEnv:XZ,monkeyPatch:Q5e,isBrowser:YZ,isNodejs:hz};dz();function pz(e){return!$s.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Fh(e){let{Canvas:t,CanvasRenderingContext2D:n}=$s.getEnv();if(e instanceof n)return e;let a=pz(e);if(!(a instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let r=a.getContext("2d",{willReadFrequently:!0});if(!r)throw new Error("resolveContext2d - canvas 2d context is null");return r}var QZ=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(QZ||{}),fz=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:a,fontSize:r,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=a||"rgba(255, 255, 255, 1)",this.fontSize=r||14,this.fontStyle=s||"Georgia",this.padding=i||4}},mz=class ZZ{constructor(t,n,a={}){this.text=typeof t=="string"?[t]:t instanceof ZZ?t.text:t,this.anchor=n,this.options=new fz(a)}measureWidth(t){let{padding:n}=this.options;return this.text.map(a=>t.measureText(a).width).reduce((a,r)=>a<r?r:a,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:a}=this.options,r=a==="BOTTOM_RIGHT"||a==="TOP_RIGHT",s=a==="BOTTOM_LEFT"||a==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=r?this.anchor.x-i:this.anchor.x,u=s?this.anchor.y-o:this.anchor.y;if(n){let{width:c,height:h}=n,p=Math.max(Math.min(l,c-i),0),m=Math.max(Math.min(u,h-o),0);return{x:p,y:m}}return{x:l,y:u}}draw(t){let n=pz(t),a=Fh(n),{backgroundColor:r,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;a.font=`${i}px ${o}`;let u=this.measureWidth(a),c=this.measureHeight();a.fillStyle=r;let h=this.getUpperLeft(a,n);a.fillRect(h.x,h.y,u,c),a.fillStyle=s,this.text.forEach((p,m)=>{let g=l+h.x,y=l+h.y+(m+1)*i;a.fillText(p,g,y)})}},JZ=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:a,drawLabelOptions:r}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=a;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new fz({...s,...r})}},eJ=class{constructor(e,t={}){this.box=new Vp(e),this.options=new JZ(t)}draw(e){let t=Fh(e),{boxColor:n,lineWidth:a}=this.options,{x:r,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=a,t.strokeRect(r,s,i,o);let{label:l}=this.options;l&&new mz([l],{x:r-a/2,y:s},this.options.drawLabelOptions).draw(e)}};function Z5e(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof gl?n.score:AN(n)?n.detection.score:void 0,r=n instanceof gl?n.box:AN(n)?n.detection.box:new Vp(n),s=a?`${uz(a)}`:void 0;new eJ(r,{label:s}).draw(e)})}function tJ(e){let{Image:t,Video:n}=$s.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function J5e(e){return new Promise((t,n)=>{if(e instanceof $s.getEnv().Canvas||tJ(e)){t(null);return}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),n(s))}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),t(s))}e.addEventListener("load",r),e.addEventListener("error",a)})}function eqe(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let a=new FileReader;a.onload=()=>{typeof a.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let r=$s.getEnv().createImageElement();r.onload=()=>t(r),r.onerror=n,r.src=a.result},a.onerror=n,a.readAsDataURL(e)})}function nJ(e){let{Image:t,Video:n}=$s.getEnv();return e instanceof t?new ny(e.naturalWidth,e.naturalHeight):e instanceof n?new ny(e.videoWidth,e.videoHeight):new ny(e.width,e.height)}function SN({width:e,height:t}){let{createCanvasElement:n}=$s.getEnv(),a=n();return a.width=e,a.height=t,a}function aJ(e,t){let{ImageData:n}=$s.getEnv();if(!(e instanceof n)&&!tJ(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:a,height:r}=nJ(e),s=SN({width:a,height:r});return e instanceof n?Fh(s).putImageData(e,0,0):Fh(s).drawImage(e,0,0,a,r),s}async function tqe(e,t){let n=t||$s.getEnv().createCanvasElement(),[a,r,s]=e.shape.slice(Yu(e)?1:0),i=fe(()=>e.as3D(a,r,s).toInt());return await C1.toPixels(i,n),i.dispose(),n}function r6(e){let{Image:t,Canvas:n,Video:a}=$s.getEnv();return e instanceof t||e instanceof n||e instanceof a}function nqe(e,t,n=!1){let{Image:a,Canvas:r}=$s.getEnv();if(!(e instanceof a||e instanceof r))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return SN({width:1,height:1});let s=nJ(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=SN({width:t,height:t}),c=e instanceof r?e:aJ(e),h=Math.abs(o-l)/2,p=n&&o<l?h:0,m=n&&l<o?h:0;return c.width>0&&c.height>0&&Fh(u).drawImage(c,p,m,o,l),u}var kN=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,a)=>{if(V1(n)){this._imageTensors[a]=n,this._inputDimensions[a]=n.shape;return}if(Yu(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[a]=n,this._inputDimensions[a]=n.shape.slice(1);return}let r=n instanceof $s.getEnv().Canvas?n:aJ(n);this._canvases[a]=r,this._inputDimensions[a]=[r.height,r.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Iy(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return BZ({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,fe(()=>{let n=Iy(this.batchSize,0,1).map(a=>{let r=this.getInput(a);if(r instanceof Bt){let s=Yu(r)?r:Tr(r);return s=j5e(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=Xi.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(r instanceof $s.getEnv().Canvas)return C1.fromPixels(nqe(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${a}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)});return Ja(n.map(a=>He(a,"float32"))).as4D(this.batchSize,e,e,3)})}};async function _s(e){if(e instanceof kN)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=r=>Array.isArray(e)?` at input index ${r}:`:"",a=t.map(pz);return a.forEach((r,s)=>{if(!r6(r)&&!V1(r)&&!Yu(r))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(Yu(r)){let i=r.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(a.map(r=>r6(r)&&J5e(r))),new kN(a,Array.isArray(e))}async function gz(e,t){let{Canvas:n}=$s.getEnv(),a=e;if(!(e instanceof n)){let s=await _s(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);a=i instanceof n?i:await tqe(i)}let r=Fh(a);return t.map(s=>s instanceof gl?s.forSize(a.width,a.height).box.floor():s).map(s=>s.clipAtImageBorders(a.width,a.height)).map(({x:s,y:i,width:o,height:l})=>{let u=SN({width:o,height:l});return o>0&&l>0&&Fh(u).putImageData(r.getImageData(s,i,o,l),0,0),u})}async function yz(e,t){if(!V1(e)&&!Yu(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(Yu(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return fe(()=>{let[n,a,r]=e.shape.slice(Yu(e)?1:0);return t.map(s=>s instanceof gl?s.forSize(a,n).box:s).map(s=>s.clipAtImageBorders(a,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:l})=>Qb(e.as3D(n,a,r),[i,s,0],[l,o,r]))})}async function rJ(e,t){let{fetch:n}=$s.getEnv(),a=await n(e,t);if(!(a.status<400))throw new Error(`failed to fetch: (${a.status}) ${a.statusText}, from url: ${a.url}`);return a}async function aqe(e){let t=await rJ(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return eqe(n)}async function rqe(e){return(await rJ(e)).json()}function sJ(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let a=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(a,"");let r=e.split("/").filter(o=>o),s=e.endsWith(".json")?r[r.length-1]:n,i=a+(e.endsWith(".json")?r.slice(0,r.length-1):r).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function sqe(e,t){let{manifestUri:n,modelBaseUri:a}=sJ(e,t),r=await rqe(n);return Kr.loadWeights(r,a)}var ld=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:a}=this.traversePropertyPath(e);n[a].dispose(),n[a]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Ip)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Ip))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=Cs(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await sqe(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=$s.getEnv(),{manifestUri:n,modelBaseUri:a}=sJ(e,this.getDefaultModelName()),r=l=>Promise.all(l.map(u=>t(u).then(c=>typeof c=="string"?Buffer.from(c):c.buffer))),s=Kr.weightsLoaderFactory(r),i=JSON.parse((await t(n)).toString()),o=await s(i,a);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((r,s)=>{if(!r.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:r.nextObj,objProp:s,nextObj:r.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:a}=t;if(!n||!a||!(n[a]instanceof Bt))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:a}}};function Zi(e,t,n){return fe(()=>{let a=Yb(e,t.depthwise_filter,t.pointwise_filter,n,"same");return a=Re(a,t.bias),a})}function IR(e,t,n=!1){return fe(()=>{let a=_n(n?Re(Ts(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Zi(e,t.conv0,[2,2])),r=Zi(a,t.conv1,[1,1]),s=_n(Re(a,r)),i=Zi(s,t.conv2,[1,1]);return _n(Re(a,Re(r,i)))})}function nI(e,t,n=!1,a=!0){return fe(()=>{let r=_n(n?Re(Ts(e,t.conv0.filters,a?[2,2]:[1,1],"same"),t.conv0.bias):Zi(e,t.conv0,a?[2,2]:[1,1])),s=Zi(r,t.conv1,[1,1]),i=_n(Re(r,s)),o=Zi(i,t.conv2,[1,1]),l=_n(Re(r,Re(s,o))),u=Zi(l,t.conv3,[1,1]);return _n(Re(r,Re(s,Re(o,u))))})}function Yv(e,t,n="same",a=!1){return fe(()=>{let r=Re(Ts(e,t.filters,[1,1],n),t.bias);return a?_n(r):r})}function ud(e,t){Object.keys(e).forEach(n=>{t.some(a=>a.originalPath===n)||e[n].dispose()})}function bz(e,t){return(n,a,r,s)=>{let i=Th(e(n*a*r*r),[r,r,n,a]),o=Nn(e(a));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function iJ(e,t){return(n,a,r)=>{let s=ql(e(n*a),[n,a]),i=Nn(e(a));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/bias`}),{weights:s,bias:i}}}var oJ=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function xz(e,t){return(n,a,r)=>{let s=Th(e(9*n),[3,3,n,1]),i=Th(e(n*a),[1,1,n,a]),o=Nn(e(a));return t.push({paramPath:`${r}/depthwise_filter`},{paramPath:`${r}/pointwise_filter`},{paramPath:`${r}/bias`}),new oJ(s,i,o)}}function vz(e){return t=>{let n=e(`${t}/depthwise_filter`,4),a=e(`${t}/pointwise_filter`,4),r=e(`${t}/bias`,1);return new oJ(n,a,r)}}function Mm(e,t){return(n,a,r)=>{let s=e[n];if(!hx(s,a))throw new Error(`expected weightMap[${n}] to be a Tensor${a}D, instead have ${s}`);return t.push({originalPath:n,paramPath:r||n}),s}}function cd(e){let t=e;function n(r){let s=t.slice(0,r);return t=t.slice(r),s}function a(){return t}return{extractWeights:n,getRemainingWeights:a}}function lJ(e,t){let n=bz(e,t),a=xz(e,t);function r(i,o,l,u=!1){let c=u?n(i,o,3,`${l}/conv0`):a(i,o,`${l}/conv0`),h=a(o,o,`${l}/conv1`),p=a(o,o,`${l}/conv2`);return{conv0:c,conv1:h,conv2:p}}function s(i,o,l,u=!1){let{conv0:c,conv1:h,conv2:p}=r(i,o,l,u),m=a(o,o,`${l}/conv3`);return{conv0:c,conv1:h,conv2:p,conv3:m}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:s}}function iqe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=cd(e),{extractDenseBlock4Params:r}=lJ(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2"),l=r(128,256,"dense3");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function uJ(e){return t=>{let n=e(`${t}/filters`,4),a=e(`${t}/bias`,1);return{filters:n,bias:a}}}function cJ(e,t){let n=Mm(e,t),a=uJ(n),r=vz(n);function s(o,l=!1){let u=l?a(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),h=r(`${o}/conv2`);return{conv0:u,conv1:c,conv2:h}}function i(o,l=!1){let u=l?a(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),h=r(`${o}/conv2`),p=r(`${o}/conv3`);return{conv0:u,conv1:c,conv2:h,conv3:p}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function oqe(e){let t=[],{extractDenseBlock4Params:n}=cJ(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return ud(e,t),{params:a,paramMappings:t}}var hJ=class extends ld{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return fe(()=>{let n=He(e.toBatchTensor(112,!0),"float32"),a=U1(n,[122.782,117.001,104.298]).div(255),r=nI(a,t.dense0,!0);return r=nI(r,t.dense1),r=nI(r,t.dense2),r=nI(r,t.dense3),r=uc(r,[7,7],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await _s(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return oqe(e)}extractParams(e){return iqe(e)}};function iO(e,t){return fe(()=>Re(Vt(e,t.weights),t.bias))}function lqe(e,t,n){let a=[],{extractWeights:r,getRemainingWeights:s}=cd(e),i=iJ(r,a)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:a,params:{fc:i}}}function uqe(e){let t=[],n=Mm(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:a("fc")};return ud(e,t),{params:r,paramMappings:t}}function dJ(e){let t={},n={};return Object.keys(e).forEach(a=>{let r=a.startsWith("fc")?n:t;r[a]=e[a]}),{featureExtractorMap:t,classifierMap:n}}var pJ=class extends ld{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return fe(()=>{let n=e instanceof kN?this.faceFeatureExtractor.forwardInput(e):e;return iO(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return lqe(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=dJ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),uqe(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),a=n*t+n,r=e.slice(0,e.length-a),s=e.slice(e.length-a);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(s)}},s6=["neutral","happy","sad","angry","fearful","disgusted","surprised"],wz=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);s6.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return s6.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},cqe=class extends pJ{constructor(e=new hJ){super("FaceExpressionNet",e)}forwardInput(e){return fe(()=>nd(this.runNet(e)))}async forward(e){return this.forwardInput(await _s(e))}async predictExpressions(e){let t=await _s(e),n=await this.forwardInput(t),a=await Promise.all(Ra(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let r=a.map(s=>new wz(s));return t.isBatchInput?r:r[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function hqe(e){return e.expressions instanceof wz}function fJ(e,t){return{...e,expressions:t}}function dqe(e,t,n=.1,a){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof wz?r:hqe(r)?r.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(l=>l.probability>n),o=AN(r)?r.detection.box.bottomLeft:a||new Bn(0,0);new mz(i.map(l=>`${l.expression} (${uz(l.probability)})`),o).draw(e)})}function mJ(e){return AN(e)&&e.landmarks instanceof wN&&e.unshiftedLandmarks instanceof wN&&e.alignedRect instanceof gl}function pqe(e){let t=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),a={roll:void 0,pitch:void 0,yaw:void 0},r=(l,u,c)=>{let h=Math.floor(l.x-u.x),p=Math.floor(u.x-c.x);return h-p},s=(l,u)=>{let c=Math.hypot(u.x-l.x,u.y-l.y),h=u.y-l.y,p=Math.asin(h/c),m=t(p),g=Math.floor(90-m),y=u.x-l.x<0?-1:1;return g*y},i=(l,u,c)=>{let h=n(l,c),p=new Bn((l.x+c.x)/2,(l.y+c.y)/2),m=n(u,p),g=Math.atan(m/h),y=Math.floor(t(g)),b=p.y-u.y<0?-1:1;return y*b};if(!e||!e.positions||e.positions.length!==68)return a;let o=e.positions;return a.roll=s(o[27],o[66]),a.pitch=i(o[14],o[30],o[2]),a.yaw=r(o[14],o[33],o[2]),a}function gJ(e,t){let{box:n}=e.detection,a=t.shiftBy(n.x,n.y),r=a.align(),{imageDims:s}=e.detection,i=new gl(e.detection.score,r.rescale(s.reverse()),s),o=pqe(t);return{...e,landmarks:a,unshiftedLandmarks:t,alignedRect:i,angle:o}}var yJ=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:a,lineColor:r,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=a||1,this.pointSize=s||2,this.lineColor=r||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},bJ=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new yJ(t)}draw(e){let t=Fh(e),{drawLines:n,drawPoints:a,lineWidth:r,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof HZ&&(t.strokeStyle=s,t.lineWidth=r,ah(t,this.faceLandmarks.getJawOutline()),ah(t,this.faceLandmarks.getLeftEyeBrow()),ah(t,this.faceLandmarks.getRightEyeBrow()),ah(t,this.faceLandmarks.getNose()),ah(t,this.faceLandmarks.getLeftEye(),!0),ah(t,this.faceLandmarks.getRightEye(),!0),ah(t,this.faceLandmarks.getMouth(),!0)),a){t.strokeStyle=o,t.fillStyle=o;let l=u=>{t.beginPath(),t.arc(u.x,u.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function fqe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof wN?n:mJ(n)?n.landmarks:void 0;if(!a)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new bJ(a).draw(e)})}function mqe(e,t){let n=bz(e,t),a=xz(e,t);function r(i,o,l){let u=a(i,o,`${l}/separable_conv0`),c=a(o,o,`${l}/separable_conv1`),h=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:c,expansion_conv:h}}function s(i,o){let l=a(i,i,`${o}/separable_conv0`),u=a(i,i,`${o}/separable_conv1`),c=a(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:a,extractReductionBlockParams:r,extractMainBlockParams:s}}function gqe(e,t){let n=[],{extractWeights:a,getRemainingWeights:r}=cd(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=mqe(a,n),u=s(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),h=o(64,128,"entry_flow/reduction_block_1"),p={conv_in:u,reduction_block_0:c,reduction_block_1:h},m={};Iy(t,0,1).forEach(v=>{m[`main_block_${v}`]=l(128,`middle_flow/main_block_${v}`)});let g=o(128,256,"exit_flow/reduction_block"),y=i(256,512,"exit_flow/separable_conv"),b={reduction_block:g,separable_conv:y};if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:n,params:{entry_flow:p,middle_flow:m,exit_flow:b}}}function yqe(e,t){let n=Mm(e,t),a=uJ(n),r=vz(n);function s(o){let l=r(`${o}/separable_conv0`),u=r(`${o}/separable_conv1`),c=a(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:c}}function i(o){let l=r(`${o}/separable_conv0`),u=r(`${o}/separable_conv1`),c=r(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}}function bqe(e,t){let n=[],{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}=yqe(e,n),o=a("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),u=s("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:l,reduction_block_1:u},h={};Iy(t,0,1).forEach(y=>{h[`main_block_${y}`]=i(`middle_flow/main_block_${y}`)});let p=s("exit_flow/reduction_block"),m=r("exit_flow/separable_conv"),g={reduction_block:p,separable_conv:m};return ud(e,n),{params:{entry_flow:c,middle_flow:h,exit_flow:g},paramMappings:n}}function xJ(e,t,n){return Re(Ts(e,t.filters,n,"same"),t.bias)}function NR(e,t,n=!0){let a=n?_n(e):e;return a=Zi(a,t.separable_conv0,[1,1]),a=Zi(_n(a),t.separable_conv1,[1,1]),a=kr(a,[3,3],[2,2],"same"),a=Re(a,xJ(e,t.expansion_conv,[2,2])),a}function xqe(e,t){let n=Zi(_n(e),t.separable_conv0,[1,1]);return n=Zi(_n(n),t.separable_conv1,[1,1]),n=Zi(_n(n),t.separable_conv2,[1,1]),n=Re(n,e),n}var vqe=class extends ld{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return fe(()=>{let n=He(e.toBatchTensor(112,!0),"float32"),a=U1(n,[122.782,117.001,104.298]).div(255),r=_n(xJ(a,t.entry_flow.conv_in,[2,2]));return r=NR(r,t.entry_flow.reduction_block_0,!1),r=NR(r,t.entry_flow.reduction_block_1),Iy(this._numMainBlocks,0,1).forEach(s=>{r=xqe(r,t.middle_flow[`main_block_${s}`])}),r=NR(r,t.exit_flow.reduction_block),r=_n(Zi(r,t.exit_flow.separable_conv,[1,1])),r})}async forward(e){return this.forwardInput(await _s(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return bqe(e,this._numMainBlocks)}extractParams(e){return gqe(e,this._numMainBlocks)}};function wqe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=cd(e),r=iJ(n,t),s=r(512,1,"fc/age"),i=r(512,2,"fc/gender");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function Aqe(e){let t=[],n=Mm(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:{age:a("fc/age"),gender:a("fc/gender")}};return ud(e,t),{params:r,paramMappings:t}}var Sqe=(e=>(e.FEMALE="female",e.MALE="male",e))(Sqe||{}),kqe=class extends ld{constructor(e=new vqe(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return fe(()=>{let n=e instanceof kN?this.faceFeatureExtractor.forwardInput(e):e,a=uc(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),r=iO(a,t.fc.age).as1D(),s=iO(a,t.fc.gender);return{age:r,gender:s}})}forwardInput(e){return fe(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:nd(n)}})}async forward(e){return this.forwardInput(await _s(e))}async predictAgeAndGender(e){let t=await _s(e),n=await this.forwardInput(t),a=Ra(n.age),r=Ra(n.gender),s=a.map((o,l)=>({ageTensor:o,genderTensor:r[l]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let u=o.dataSync()[0],c=l.dataSync()[0],h=c>.5,p=h?"male":"female",m=h?c:1-c;return o.dispose(),l.dispose(),{age:u,gender:p,genderProbability:m}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return wqe(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=dJ(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Aqe(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},vJ=class extends pJ{postProcess(e,t,n){let a=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),r=a.length;return fe(()=>{let s=(u,c)=>Ja([Ni([68],u,"float32"),Ni([68],c,"float32")],1).as2D(1,136).as1D(),i=(u,c)=>{let{width:h,height:p}=a[u];return c(h,p)?Math.abs(h-p)/2:0},o=u=>i(u,(c,h)=>c<h),l=u=>i(u,(c,h)=>h<c);return e.mul(Ni([r,136],t,"float32")).sub(Ja(Array.from(Array(r),(u,c)=>s(o(c),l(c))))).div(Ja(Array.from(Array(r),(u,c)=>s(a[c].width,a[c].height))))})}forwardInput(e){return fe(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,a])=>({height:n,width:a})))})}async forward(e){return this.forwardInput(await _s(e))}async detectLandmarks(e){let t=await _s(e),n=fe(()=>Ra(this.forwardInput(t))),a=await Promise.all(n.map(async(r,s)=>{let i=Array.from(r.dataSync()),o=i.filter((u,c)=>aO(c)),l=i.filter((u,c)=>!aO(c));return new HZ(Array(68).fill(0).map((u,c)=>new Bn(o[c],l[c])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(r=>r.dispose()),t.isBatchInput?a:a[0]}getClassifierChannelsOut(){return 136}},Iqe=class extends vJ{constructor(e=new hJ){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function Nqe(e){let t=[],{extractDenseBlock3Params:n}=cJ(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return ud(e,t),{params:a,paramMappings:t}}function Cqe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=cd(e),{extractDenseBlock3Params:r}=lJ(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var Tqe=class extends ld{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return fe(()=>{let n=He(e.toBatchTensor(112,!0),"float32"),a=U1(n,[122.782,117.001,104.298]).div(255),r=IR(a,t.dense0,!0);return r=IR(r,t.dense1),r=IR(r,t.dense2),r=uc(r,[14,14],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await _s(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return Nqe(e)}extractParams(e){return Cqe(e)}},Eqe=class extends vJ{constructor(e=new Tqe){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function $qe(e,t){return Re(le(e,t.weights),t.biases)}function Az(e,t,n,a,r="same"){let{filters:s,bias:i}=t.conv,o=Ts(e,s,n,r);return o=Re(o,i),o=$qe(o,t.scale),a?_n(o):o}function _qe(e,t){return Az(e,t,[1,1],!0)}function wJ(e,t){return Az(e,t,[1,1],!1)}function AJ(e,t){return Az(e,t,[2,2],!0,"valid")}function Rqe(e,t){function n(o,l,u){let c=e(o),h=c.length/(l*u*u);if(zZ(h))throw new Error(`depth has to be an integer: ${h}, weights.length: ${c.length}, numFilters: ${l}, filterSize: ${u}`);return fe(()=>Ut(Th(c,[l,h,u,u]),[2,3,1,0]))}function a(o,l,u,c){let h=n(o,l,u),p=Nn(e(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:h,bias:p}}function r(o,l){let u=Nn(e(o)),c=Nn(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:c}}function s(o,l,u,c){let h=a(o,l,u,`${c}/conv`),p=r(l,`${c}/scale`);return{conv:h,scale:p}}function i(o,l,u,c,h=!1){let p=s((h?.5:1)*o,l,u,`${c}/conv1`),m=s(o,l,u,`${c}/conv2`);return{conv1:p,conv2:m}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function Dqe(e){let{extractWeights:t,getRemainingWeights:n}=cd(e),a=[],{extractConvLayerParams:r,extractResidualLayerParams:s}=Rqe(t,a),i=r(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),h=s(36864,64,3,"conv64_1"),p=s(36864,64,3,"conv64_2"),m=s(36864,64,3,"conv64_3"),g=s(147456,128,3,"conv128_down",!0),y=s(147456,128,3,"conv128_1"),b=s(147456,128,3,"conv128_2"),v=s(589824,256,3,"conv256_down",!0),w=s(589824,256,3,"conv256_1"),S=s(589824,256,3,"conv256_2"),k=s(589824,256,3,"conv256_down_out"),I=fe(()=>Ut(ql(t(256*128),[128,256]),[1,0]));if(a.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:h,conv64_2:p,conv64_3:m,conv128_down:g,conv128_1:y,conv128_2:b,conv256_down:v,conv256_1:w,conv256_2:S,conv256_down_out:k,fc:I},paramMappings:a}}function Oqe(e,t){let n=Mm(e,t);function a(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function r(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),u=a(i);return{conv:{filters:o,bias:l},scale:u}}function s(i){return{conv1:r(`${i}/conv1`),conv2:r(`${i}/conv2`)}}return{extractConvLayerParams:r,extractResidualLayerParams:s}}function Fqe(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:a}=Oqe(e,t),r=n("conv32_down"),s=a("conv32_1"),i=a("conv32_2"),o=a("conv32_3"),l=a("conv64_down"),u=a("conv64_1"),c=a("conv64_2"),h=a("conv64_3"),p=a("conv128_down"),m=a("conv128_1"),g=a("conv128_2"),y=a("conv256_down"),b=a("conv256_1"),v=a("conv256_2"),w=a("conv256_down_out"),{fc:S}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!LZ(S))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${S}`);let k={conv32_down:r,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:h,conv128_down:p,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:v,conv256_down_out:w,fc:S};return ud(e,t),{params:k,paramMappings:t}}function Rl(e,t){let n=_qe(e,t.conv1);return n=wJ(n,t.conv2),n=Re(n,e),n=_n(n),n}function aI(e,t){let n=AJ(e,t.conv1);n=wJ(n,t.conv2);let a=uc(e,2,2,"valid"),r=Aa(a.shape),s=a.shape[3]!==n.shape[3];if(a.shape[1]!==n.shape[1]||a.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=Aa(i);n=Un([n,o],1);let l=[...n.shape];l[2]=1;let u=Aa(l);n=Un([n,u],2)}return a=s?Un([a,r],3):a,n=Re(a,n),n=_n(n),n}var Mqe=class extends ld{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return fe(()=>{let n=He(e.toBatchTensor(150,!0),"float32"),a=U1(n,[122.782,117.001,104.298]).div(255),r=AJ(a,t.conv32_down);r=kr(r,3,2,"valid"),r=Rl(r,t.conv32_1),r=Rl(r,t.conv32_2),r=Rl(r,t.conv32_3),r=aI(r,t.conv64_down),r=Rl(r,t.conv64_1),r=Rl(r,t.conv64_2),r=Rl(r,t.conv64_3),r=aI(r,t.conv128_down),r=Rl(r,t.conv128_1),r=Rl(r,t.conv128_2),r=aI(r,t.conv256_down),r=Rl(r,t.conv256_1),r=Rl(r,t.conv256_2),r=aI(r,t.conv256_down_out);let s=r.mean([1,2]);return Vt(s,t.fc)})}async forward(e){return this.forwardInput(await _s(e))}async computeFaceDescriptor(e){var t;if((t=e?.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await _s(e),a=fe(()=>Ra(this.forwardInput(n))),r=await Promise.all(a.map(s=>s.data()));return a.forEach(s=>s.dispose()),n.isBatchInput?r:r[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return Fqe(e)}extractParams(e){return Dqe(e)}};function SJ(e,t){return{...e,descriptor:t}}function kJ(e,t){return{...e,age:t}}function IJ(e,t,n){return{...e,gender:t,genderProbability:n}}function Lqe(e,t){function n(l,u){let c=Th(e(9*l),[3,3,l,1]),h=Nn(e(l)),p=Nn(e(l)),m=Nn(e(l)),g=Nn(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:c,batch_norm_scale:h,batch_norm_offset:p,batch_norm_mean:m,batch_norm_variance:g}}function a(l,u,c,h,p){let m=Th(e(l*u*c*c),[c,c,l,u]),g=Nn(e(u));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/${p?"batch_norm_offset":"bias"}`}),{filters:m,bias:g}}function r(l,u,c,h){let{filters:p,bias:m}=a(l,u,c,h,!0);return{filters:p,batch_norm_offset:m}}function s(l,u,c){let h=n(l,`${c}/depthwise_conv`),p=r(l,u,1,`${c}/pointwise_conv`);return{depthwise_conv:h,pointwise_conv:p}}function i(){let l=r(3,32,3,"mobilenetv1/conv_0"),u=s(32,64,"mobilenetv1/conv_1"),c=s(64,128,"mobilenetv1/conv_2"),h=s(128,128,"mobilenetv1/conv_3"),p=s(128,256,"mobilenetv1/conv_4"),m=s(256,256,"mobilenetv1/conv_5"),g=s(256,512,"mobilenetv1/conv_6"),y=s(512,512,"mobilenetv1/conv_7"),b=s(512,512,"mobilenetv1/conv_8"),v=s(512,512,"mobilenetv1/conv_9"),w=s(512,512,"mobilenetv1/conv_10"),S=s(512,512,"mobilenetv1/conv_11"),k=s(512,1024,"mobilenetv1/conv_12"),I=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:u,conv_2:c,conv_3:h,conv_4:p,conv_5:m,conv_6:g,conv_7:y,conv_8:b,conv_9:v,conv_10:w,conv_11:S,conv_12:k,conv_13:I}}function o(){let l=r(1024,256,1,"prediction_layer/conv_0"),u=r(256,512,3,"prediction_layer/conv_1"),c=r(512,128,1,"prediction_layer/conv_2"),h=r(128,256,3,"prediction_layer/conv_3"),p=r(256,128,1,"prediction_layer/conv_4"),m=r(128,256,3,"prediction_layer/conv_5"),g=r(256,64,1,"prediction_layer/conv_6"),y=r(64,128,3,"prediction_layer/conv_7"),b=a(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),v=a(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),w=a(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),S=a(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),k=a(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),I=a(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),T=a(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),E=a(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),R=a(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),D=a(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),O=a(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),$=a(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:u,conv_2:c,conv_3:h,conv_4:p,conv_5:m,conv_6:g,conv_7:y,box_predictor_0:{box_encoding_predictor:b,class_predictor:v},box_predictor_1:{box_encoding_predictor:w,class_predictor:S},box_predictor_2:{box_encoding_predictor:k,class_predictor:I},box_predictor_3:{box_encoding_predictor:T,class_predictor:E},box_predictor_4:{box_encoding_predictor:R,class_predictor:D},box_predictor_5:{box_encoding_predictor:O,class_predictor:$}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function zqe(e){let t=[],{extractWeights:n,getRemainingWeights:a}=cd(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:s}=Lqe(n,t),i=r(),o=s(),l={extra_dim:X2(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function Bqe(e,t){let n=Mm(e,t);function a(u,c,h){let p=n(`${u}/Conv2d_${c}_pointwise/weights`,4,`${h}/filters`),m=n(`${u}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${h}/batch_norm_offset`);return{filters:p,batch_norm_offset:m}}function r(u){let c=`mobilenetv1/conv_${u}`,h=`MobilenetV1/Conv2d_${u}_depthwise`,p=`${c}/depthwise_conv`,m=`${c}/pointwise_conv`,g=n(`${h}/depthwise_weights`,4,`${p}/filters`),y=n(`${h}/BatchNorm/gamma`,1,`${p}/batch_norm_scale`),b=n(`${h}/BatchNorm/beta`,1,`${p}/batch_norm_offset`),v=n(`${h}/BatchNorm/moving_mean`,1,`${p}/batch_norm_mean`),w=n(`${h}/BatchNorm/moving_variance`,1,`${p}/batch_norm_variance`);return{depthwise_conv:{filters:g,batch_norm_scale:y,batch_norm_offset:b,batch_norm_mean:v,batch_norm_variance:w},pointwise_conv:a("MobilenetV1",u,m)}}function s(){return{conv_0:a("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}}function i(u,c){let h=n(`${u}/weights`,4,`${c}/filters`),p=n(`${u}/biases`,1,`${c}/bias`);return{filters:h,bias:p}}function o(u){let c=i(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),h=i(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:c,class_predictor:h}}function l(){return{conv_0:a("Prediction",0,"prediction_layer/conv_0"),conv_1:a("Prediction",1,"prediction_layer/conv_1"),conv_2:a("Prediction",2,"prediction_layer/conv_2"),conv_3:a("Prediction",3,"prediction_layer/conv_3"),conv_4:a("Prediction",4,"prediction_layer/conv_4"),conv_5:a("Prediction",5,"prediction_layer/conv_5"),conv_6:a("Prediction",6,"prediction_layer/conv_6"),conv_7:a("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function Pqe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:a}=Bqe(e,t),r=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!V1(r))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${r}`);let s={mobilenetv1:n(),prediction_layer:a(),output_layer:{extra_dim:r}};return ud(e,t),{params:s,paramMappings:t}}function Fl(e,t,n){return fe(()=>{let a=Ts(e,t.filters,n,"same");return a=Re(a,t.batch_norm_offset),hs(a,0,6)})}var Vqe=.0010000000474974513;function Uqe(e,t,n){return fe(()=>{let a=Nm(e,t.filters,n,"same");return a=Im(a,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Vqe),hs(a,0,6)})}function Wqe(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function Gqe(e,t){return fe(()=>{let n,a=Fl(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((r,s)=>{let i=s+1,o=Wqe(i);a=Uqe(a,r.depthwise_conv,o),a=Fl(a,r.pointwise_conv,[1,1]),i===11&&(n=a)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:a,conv11:n}})}function Hqe(e,t,n){let a=e.arraySync(),r=Math.min(a[t][0],a[t][2]),s=Math.min(a[t][1],a[t][3]),i=Math.max(a[t][0],a[t][2]),o=Math.max(a[t][1],a[t][3]),l=Math.min(a[n][0],a[n][2]),u=Math.min(a[n][1],a[n][3]),c=Math.max(a[n][0],a[n][2]),h=Math.max(a[n][1],a[n][3]),p=(i-r)*(o-s),m=(c-l)*(h-u);if(p<=0||m<=0)return 0;let g=Math.max(r,l),y=Math.max(s,u),b=Math.min(i,c),v=Math.min(o,h),w=Math.max(b-g,0)*Math.max(v-y,0);return w/(p+m-w)}function jqe(e,t,n,a,r){let s=e.shape[0],i=Math.min(n,s),o=t.map((c,h)=>({score:c,boxIndex:h})).filter(c=>c.score>r).sort((c,h)=>h.score-c.score),l=c=>c<=a?1:0,u=[];return o.forEach(c=>{if(u.length>=i)return;let h=c.score;for(let p=u.length-1;p>=0;--p){let m=Hqe(e,c.boxIndex,u[p]);if(m!==0&&(c.score*=l(m),c.score<=r))break}h===c.score&&u.push(c.boxIndex)}),u}function qqe(e){let t=Ra(Ut(e,[1,0])),n=[nt(t[2],t[0]),nt(t[3],t[1])],a=[Re(t[0],st(n[0],2)),Re(t[1],st(n[1],2))];return{sizes:n,centers:a}}function Kqe(e,t){let{sizes:n,centers:a}=qqe(e),r=Ra(Ut(t,[1,0])),s=st(le(ds(st(r[2],5)),n[0]),2),i=Re(le(st(r[0],10),n[0]),a[0]),o=st(le(ds(st(r[3],5)),n[1]),2),l=Re(le(st(r[1],10),n[1]),a[1]);return Ut(Ja([nt(i,s),nt(l,o),Re(i,s),Re(l,o)]),[1,0])}function Xqe(e,t,n){return fe(()=>{let a=e.shape[0],r=Kqe(pe(Ii(n.extra_dim,[a,1,1]),[-1,4]),pe(e,[-1,4]));r=pe(r,[a,r.shape[0]/a,4]);let s=Mo(en(t,[0,0,1],[-1,-1,-1])),i=en(s,[0,0,0],[-1,-1,1]);i=pe(i,[a,i.shape[1]]);let o=Ra(r),l=Ra(i);return{boxes:o,scores:l}})}function Ug(e,t){return fe(()=>{let n=e.shape[0],a=pe(Yv(e,t.box_encoding_predictor),[n,-1,1,4]),r=pe(Yv(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:a,classPrediction:r}})}function Yqe(e,t,n){return fe(()=>{let a=Fl(e,n.conv_0,[1,1]),r=Fl(a,n.conv_1,[2,2]),s=Fl(r,n.conv_2,[1,1]),i=Fl(s,n.conv_3,[2,2]),o=Fl(i,n.conv_4,[1,1]),l=Fl(o,n.conv_5,[2,2]),u=Fl(l,n.conv_6,[1,1]),c=Fl(u,n.conv_7,[2,2]),h=Ug(t,n.box_predictor_0),p=Ug(e,n.box_predictor_1),m=Ug(r,n.box_predictor_2),g=Ug(i,n.box_predictor_3),y=Ug(l,n.box_predictor_4),b=Ug(c,n.box_predictor_5),v=Un([h.boxPredictionEncoding,p.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding,y.boxPredictionEncoding,b.boxPredictionEncoding],1),w=Un([h.classPrediction,p.classPrediction,m.classPrediction,g.classPrediction,y.classPrediction,b.classPrediction],1);return{boxPredictions:v,classPredictions:w}})}var W1=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},Qqe=class extends ld{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return fe(()=>{let n=He(e.toBatchTensor(512,!1),"float32"),a=nt(st(n,127.5),1),r=Gqe(a,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=Yqe(r.out,r.conv11,t.prediction_layer);return Xqe(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await _s(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:a}=new W1(t),r=await _s(e),{boxes:s,scores:i}=this.forwardInput(r),o=s[0],l=i[0];for(let v=1;v<s.length;v++)s[v].dispose(),i[v].dispose();let u=Array.from(l.dataSync()),c=jqe(o,u,n,.5,a),h=r.getReshapedInputDimensions(0),p=r.inputSize,m=p/h.width,g=p/h.height,y=o.arraySync(),b=c.map(v=>{let[w,S]=[Math.max(0,y[v][0]),Math.min(1,y[v][2])].map(T=>T*g),[k,I]=[Math.max(0,y[v][1]),Math.min(1,y[v][3])].map(T=>T*m);return new gl(u[v],new GZ(k,w,I-k,S-w),{height:r.getInputHeight(0),width:r.getInputWidth(0)})});return o.dispose(),l.dispose(),b}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return Pqe(e)}extractParams(e){return zqe(e)}},Zqe=.4,Jqe=[new Bn(.738768,.874946),new Bn(2.42204,2.65704),new Bn(4.30971,7.04493),new Bn(10.246,4.59428),new Bn(12.6868,11.8741)],e8e=[new Bn(1.603231,2.094468),new Bn(6.041143,7.080126),new Bn(2.882459,3.518061),new Bn(4.266906,5.178857),new Bn(9.041765,10.66308)],t8e=[117.001,114.697,97.404],n8e="tiny_yolov2_model",a8e="tiny_yolov2_separable_conv_model",rI=e=>typeof e=="number";function r8e(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!rI(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>rI(t.x)&&rI(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(rI)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function Sz(e){return fe(()=>{let t=le(e,xt(.10000000149011612));return Re(_n(nt(e,t)),t)})}function Jc(e,t){return fe(()=>{let n=wl(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Ts(n,t.conv.filters,[1,1],"valid"),n=nt(n,t.bn.sub),n=le(n,t.bn.truediv),n=Re(n,t.conv.bias),Sz(n)})}function eh(e,t){return fe(()=>{let n=wl(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Yb(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Re(n,t.bias),Sz(n)})}function s8e(e,t){let n=bz(e,t);function a(i,o){let l=Nn(e(i)),u=Nn(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function r(i,o,l){let u=n(i,o,3,`${l}/conv`),c=a(o,`${l}/bn`);return{conv:u,bn:c}}let s=xz(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}}function i8e(e,t,n,a){let{extractWeights:r,getRemainingWeights:s}=cd(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=s8e(r,i),c;if(t.withSeparableConvs){let[h,p,m,g,y,b,v,w,S]=a,k=t.isFirstLayerConv2d?o(h,p,3,"conv0"):u(h,p,"conv0"),I=u(p,m,"conv1"),T=u(m,g,"conv2"),E=u(g,y,"conv3"),R=u(y,b,"conv4"),D=u(b,v,"conv5"),O=w?u(v,w,"conv6"):void 0,$=S?u(w,S,"conv7"):void 0,_=o(S||w||v,5*n,1,"conv8");c={conv0:k,conv1:I,conv2:T,conv3:E,conv4:R,conv5:D,conv6:O,conv7:$,conv8:_}}else{let[h,p,m,g,y,b,v,w,S]=a,k=l(h,p,"conv0"),I=l(p,m,"conv1"),T=l(m,g,"conv2"),E=l(g,y,"conv3"),R=l(y,b,"conv4"),D=l(b,v,"conv5"),O=l(v,w,"conv6"),$=l(w,S,"conv7"),_=o(S,5*n,1,"conv8");c={conv0:k,conv1:I,conv2:T,conv3:E,conv4:R,conv5:D,conv6:O,conv7:$,conv8:_}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:c,paramMappings:i}}function o8e(e,t){let n=Mm(e,t);function a(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function r(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function s(o){let l=r(`${o}/conv`),u=a(`${o}/bn`);return{conv:l,bn:u}}let i=vz(n);return{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function l8e(e,t){let n=[],{extractConvParams:a,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}=o8e(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?a("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:a("conv8")}}else i={conv0:r("conv0"),conv1:r("conv1"),conv2:r("conv2"),conv3:r("conv3"),conv4:r("conv4"),conv5:r("conv5"),conv6:r("conv6"),conv7:r("conv7"),conv8:a("conv8")};return ud(e,n),{params:i,paramMappings:n}}var kz=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},NJ=class CJ extends ld{constructor(t){super("TinyYolov2"),r8e(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let a=Jc(t,n.conv0);return a=kr(a,[2,2],[2,2],"same"),a=Jc(a,n.conv1),a=kr(a,[2,2],[2,2],"same"),a=Jc(a,n.conv2),a=kr(a,[2,2],[2,2],"same"),a=Jc(a,n.conv3),a=kr(a,[2,2],[2,2],"same"),a=Jc(a,n.conv4),a=kr(a,[2,2],[2,2],"same"),a=Jc(a,n.conv5),a=kr(a,[2,2],[1,1],"same"),a=Jc(a,n.conv6),a=Jc(a,n.conv7),Yv(a,n.conv8,"valid",!1)}runMobilenet(t,n){let a=this.config.isFirstLayerConv2d?Sz(Yv(t,n.conv0,"valid",!1)):eh(t,n.conv0);return a=kr(a,[2,2],[2,2],"same"),a=eh(a,n.conv1),a=kr(a,[2,2],[2,2],"same"),a=eh(a,n.conv2),a=kr(a,[2,2],[2,2],"same"),a=eh(a,n.conv3),a=kr(a,[2,2],[2,2],"same"),a=eh(a,n.conv4),a=kr(a,[2,2],[2,2],"same"),a=eh(a,n.conv5),a=kr(a,[2,2],[1,1],"same"),a=n.conv6?eh(a,n.conv6):a,a=n.conv7?eh(a,n.conv7):a,Yv(a,n.conv8,"valid",!1)}forwardInput(t,n){let{params:a}=this;if(!a)throw new Error("TinyYolov2 - load model before inference");return fe(()=>{let r=He(t.toBatchTensor(n,!1),"float32");return r=this.config.meanRgb?U1(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,a):this.runTinyYolov2(r,a)})}async forward(t,n){return this.forwardInput(await _s(t),n)}async detect(t,n={}){let{inputSize:a,scoreThreshold:r}=new kz(n),s=await _s(t),i=await this.forwardInput(s,a),o=fe(()=>Ra(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},u=await this.extractBoxes(o,s.getReshapedInputDimensions(0),r);i.dispose(),o.dispose();let c=u.map(g=>g.box),h=u.map(g=>g.score),p=u.map(g=>g.classScore),m=u.map(g=>this.config.classes[g.label]);return H5e(c.map(g=>g.rescale(a)),h,this.config.iouThreshold,!0).map(g=>new VZ(h[g],p[g],m[g],c[g],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return l8e(t,this.config)}extractParams(t){let n=this.config.filterSizes||CJ.DEFAULT_FILTER_SIZES,a=n?n.length:void 0;if(a!==7&&a!==8&&a!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${a} filterSizes in config`);return i8e(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,a){let{width:r,height:s}=n,i=Math.max(r,s),o=i/r,l=i/s,u=t.shape[1],c=this.config.anchors.length,[h,p,m]=fe(()=>{let v=t.reshape([u,u,c,this.boxEncodingSize]),w=v.slice([0,0,0,0],[u,u,c,4]),S=v.slice([0,0,0,4],[u,u,c,1]),k=this.withClassScores?nd(v.slice([0,0,0,5],[u,u,c,this.config.classes.length]),3):xt(0);return[w,S,k]}),g=[],y=await p.array(),b=await h.array();for(let v=0;v<u;v++)for(let w=0;w<u;w++)for(let S=0;S<c;S++){let k=kR(y[v][w][S][0]);if(!a||k>a){let I=(w+kR(b[v][w][S][0]))/u*o,T=(v+kR(b[v][w][S][1]))/u*l,E=Math.exp(b[v][w][S][2])*this.config.anchors[S].x/u*o,R=Math.exp(b[v][w][S][3])*this.config.anchors[S].y/u*l,D=I-E/2,O=T-R/2,$={row:v,col:w,anchor:S},{classScore:_,label:P}=this.withClassScores?await this.extractPredictedClass(m,$):{classScore:1,label:0};g.push({box:new PZ(D,O,D+E,O+R),score:k,classScore:k*_,label:P,...$})}}return h.dispose(),p.dispose(),m.dispose(),g}async extractPredictedClass(t,n){let{row:a,col:r,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[a][r][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};NJ.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var TJ=NJ,u8e=class extends TJ{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:Zqe,classes:["face"],...e?{anchors:e8e,meanRgb:t8e}:{anchors:Jqe,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new gl(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?a8e:n8e}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},c8e=class extends kz{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},G1=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function FC(e,t,n,a,r=({alignedRect:s})=>s){let s=e.map(l=>mJ(l)?r(l):l.detection),i=a||(t instanceof Bt?await yz(t,s):await gz(t,s)),o=await n(i);return i.forEach(l=>l instanceof Bt&&l.dispose()),o}async function Iz(e,t,n,a,r){return FC([e],t,async s=>n(s[0]),a,r)}var h8e=.4,d8e=[new Bn(1.603231,2.094468),new Bn(6.041143,7.080126),new Bn(2.882459,3.518061),new Bn(4.266906,5.178857),new Bn(9.041765,10.66308)],p8e=[117.001,114.697,97.404],f8e=class extends TJ{constructor(){let e={withSeparableConvs:!0,iouThreshold:h8e,classes:["face"],anchors:d8e,meanRgb:p8e,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new gl(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Ci={ssdMobilenetv1:new Qqe,tinyFaceDetector:new f8e,tinyYolov2:new u8e,faceLandmark68Net:new Iqe,faceLandmark68TinyNet:new Eqe,faceRecognitionNet:new Mqe,faceExpressionNet:new cqe,ageGenderNet:new kqe},EJ=class extends G1{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Nz=class extends EJ{async run(){let e=await this.parentTask,t=await FC(e,this.input,async n=>Promise.all(n.map(a=>Ci.faceExpressionNet.predictExpressions(a))),this.extractedFaces);return e.map((n,a)=>fJ(n,t[a]))}withAgeAndGender(){return new $z(this,this.input)}},Cz=class extends EJ{async run(){let e=await this.parentTask;if(!e)return;let t=await Iz(e,this.input,n=>Ci.faceExpressionNet.predictExpressions(n),this.extractedFaces);return fJ(e,t)}withAgeAndGender(){return new _z(this,this.input)}},Tz=class extends Nz{withAgeAndGender(){return new Rz(this,this.input)}withFaceDescriptors(){return new Oz(this,this.input)}},Ez=class extends Cz{withAgeAndGender(){return new Dz(this,this.input)}withFaceDescriptor(){return new Fz(this,this.input)}},$J=class extends G1{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},$z=class extends $J{async run(){let e=await this.parentTask,t=await FC(e,this.input,async n=>Promise.all(n.map(a=>Ci.ageGenderNet.predictAgeAndGender(a))),this.extractedFaces);return e.map((n,a)=>{let{age:r,gender:s,genderProbability:i}=t[a];return kJ(IJ(n,s,i),r)})}withFaceExpressions(){return new Nz(this,this.input)}},_z=class extends $J{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:a}=await Iz(e,this.input,r=>Ci.ageGenderNet.predictAgeAndGender(r),this.extractedFaces);return kJ(IJ(e,n,a),t)}withFaceExpressions(){return new Cz(this,this.input)}},Rz=class extends $z{withFaceExpressions(){return new Tz(this,this.input)}withFaceDescriptors(){return new Oz(this,this.input)}},Dz=class extends _z{withFaceExpressions(){return new Ez(this,this.input)}withFaceDescriptor(){return new Fz(this,this.input)}},_J=class extends G1{constructor(e,t){super(),this.parentTask=e,this.input=t}},Oz=class extends _J{async run(){let e=await this.parentTask;return(await FC(e,this.input,t=>Promise.all(t.map(n=>Ci.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>SJ(e[n],t))}withFaceExpressions(){return new Tz(this,this.input)}withAgeAndGender(){return new Rz(this,this.input)}},Fz=class extends _J{async run(){let e=await this.parentTask;if(!e)return;let t=await Iz(e,this.input,n=>Ci.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return SJ(e,t)}withFaceExpressions(){return new Ez(this,this.input)}withAgeAndGender(){return new Dz(this,this.input)}},RJ=class extends G1{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Ci.faceLandmark68TinyNet:Ci.faceLandmark68Net}},m8e=class extends RJ{async run(){let e=await this.parentTask,t=e.map(r=>r.detection),n=this.input instanceof Bt?await yz(this.input,t):await gz(this.input,t),a=await Promise.all(n.map(r=>this.landmarkNet.detectLandmarks(r)));return n.forEach(r=>r instanceof Bt&&r.dispose()),e.filter((r,s)=>a[s]).map((r,s)=>gJ(r,a[s]))}withFaceExpressions(){return new Tz(this,this.input)}withAgeAndGender(){return new Rz(this,this.input)}withFaceDescriptors(){return new Oz(this,this.input)}},g8e=class extends RJ{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof Bt?await yz(this.input,[t]):await gz(this.input,[t]),a=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(r=>r instanceof Bt&&r.dispose()),gJ(e,a)}withFaceExpressions(){return new Ez(this,this.input)}withAgeAndGender(){return new Dz(this,this.input)}withFaceDescriptor(){return new Fz(this,this.input)}},DJ=class extends G1{constructor(e,t=new W1){super(),this.input=e,this.options=t}},OJ=class extends DJ{async run(){let{input:e,options:t}=this,n;if(t instanceof c8e)n=Ci.tinyFaceDetector.locateFaces(e,t);else if(t instanceof W1)n=Ci.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof kz)n=Ci.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(a=>jZ({},a)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new m8e(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Nz(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new $z(this.runAndExtendWithFaceDetections(),this.input)}},y8e=class extends DJ{async run(){let e=await new OJ(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?jZ({},t):void 0)})}withFaceLandmarks(e=!1){return new g8e(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new Cz(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new _z(this.runAndExtendWithFaceDetection(),this.input)}};function i6(e,t=new W1){return new y8e(e,t)}function b8e(e,t=new W1){return new OJ(e,t)}function x8e(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),a=Array.from(t);return Math.sqrt(n.map((r,s)=>r-a[s]).reduce((r,s)=>r+s*s,0))}var v8e=Object.defineProperty,IN=Object.getOwnPropertySymbols,FJ=Object.prototype.hasOwnProperty,MJ=Object.prototype.propertyIsEnumerable,o6=(e,t,n)=>t in e?v8e(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,oO=(e,t)=>{for(var n in t||(t={}))FJ.call(t,n)&&o6(e,n,t[n]);if(IN)for(var n of IN(t))MJ.call(t,n)&&o6(e,n,t[n]);return e},lO=(e,t)=>{var n={};for(var a in e)FJ.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&IN)for(var a of IN(e))t.indexOf(a)<0&&MJ.call(e,a)&&(n[a]=e[a]);return n};var Up;(e=>{const t=class on{constructor(l,u,c,h){if(this.version=l,this.errorCorrectionLevel=u,this.modules=[],this.isFunction=[],l<on.MIN_VERSION||l>on.MAX_VERSION)throw new RangeError("Version value out of range");if(h<-1||h>7)throw new RangeError("Mask value out of range");this.size=l*4+17;let p=[];for(let g=0;g<this.size;g++)p.push(!1);for(let g=0;g<this.size;g++)this.modules.push(p.slice()),this.isFunction.push(p.slice());this.drawFunctionPatterns();const m=this.addEccAndInterleave(c);if(this.drawCodewords(m),h==-1){let g=1e9;for(let y=0;y<8;y++){this.applyMask(y),this.drawFormatBits(y);const b=this.getPenaltyScore();b<g&&(h=y,g=b),this.applyMask(y)}}r(0<=h&&h<=7),this.mask=h,this.applyMask(h),this.drawFormatBits(h),this.isFunction=[]}static encodeText(l,u){const c=e.QrSegment.makeSegments(l);return on.encodeSegments(c,u)}static encodeBinary(l,u){const c=e.QrSegment.makeBytes(l);return on.encodeSegments([c],u)}static encodeSegments(l,u,c=1,h=40,p=-1,m=!0){if(!(on.MIN_VERSION<=c&&c<=h&&h<=on.MAX_VERSION)||p<-1||p>7)throw new RangeError("Invalid value");let g,y;for(g=c;;g++){const S=on.getNumDataCodewords(g,u)*8,k=i.getTotalBits(l,g);if(k<=S){y=k;break}if(g>=h)throw new RangeError("Data too long")}for(const S of[on.Ecc.MEDIUM,on.Ecc.QUARTILE,on.Ecc.HIGH])m&&y<=on.getNumDataCodewords(g,S)*8&&(u=S);let b=[];for(const S of l){n(S.mode.modeBits,4,b),n(S.numChars,S.mode.numCharCountBits(g),b);for(const k of S.getData())b.push(k)}r(b.length==y);const v=on.getNumDataCodewords(g,u)*8;r(b.length<=v),n(0,Math.min(4,v-b.length),b),n(0,(8-b.length%8)%8,b),r(b.length%8==0);for(let S=236;b.length<v;S^=253)n(S,8,b);let w=[];for(;w.length*8<b.length;)w.push(0);return b.forEach((S,k)=>w[k>>>3]|=S<<7-(k&7)),new on(g,u,w,p)}getModule(l,u){return 0<=l&&l<this.size&&0<=u&&u<this.size&&this.modules[u][l]}getModules(){return this.modules}drawFunctionPatterns(){for(let c=0;c<this.size;c++)this.setFunctionModule(6,c,c%2==0),this.setFunctionModule(c,6,c%2==0);this.drawFinderPattern(3,3),this.drawFinderPattern(this.size-4,3),this.drawFinderPattern(3,this.size-4);const l=this.getAlignmentPatternPositions(),u=l.length;for(let c=0;c<u;c++)for(let h=0;h<u;h++)c==0&&h==0||c==0&&h==u-1||c==u-1&&h==0||this.drawAlignmentPattern(l[c],l[h]);this.drawFormatBits(0),this.drawVersion()}drawFormatBits(l){const u=this.errorCorrectionLevel.formatBits<<3|l;let c=u;for(let p=0;p<10;p++)c=c<<1^(c>>>9)*1335;const h=(u<<10|c)^21522;r(h>>>15==0);for(let p=0;p<=5;p++)this.setFunctionModule(8,p,a(h,p));this.setFunctionModule(8,7,a(h,6)),this.setFunctionModule(8,8,a(h,7)),this.setFunctionModule(7,8,a(h,8));for(let p=9;p<15;p++)this.setFunctionModule(14-p,8,a(h,p));for(let p=0;p<8;p++)this.setFunctionModule(this.size-1-p,8,a(h,p));for(let p=8;p<15;p++)this.setFunctionModule(8,this.size-15+p,a(h,p));this.setFunctionModule(8,this.size-8,!0)}drawVersion(){if(this.version<7)return;let l=this.version;for(let c=0;c<12;c++)l=l<<1^(l>>>11)*7973;const u=this.version<<12|l;r(u>>>18==0);for(let c=0;c<18;c++){const h=a(u,c),p=this.size-11+c%3,m=Math.floor(c/3);this.setFunctionModule(p,m,h),this.setFunctionModule(m,p,h)}}drawFinderPattern(l,u){for(let c=-4;c<=4;c++)for(let h=-4;h<=4;h++){const p=Math.max(Math.abs(h),Math.abs(c)),m=l+h,g=u+c;0<=m&&m<this.size&&0<=g&&g<this.size&&this.setFunctionModule(m,g,p!=2&&p!=4)}}drawAlignmentPattern(l,u){for(let c=-2;c<=2;c++)for(let h=-2;h<=2;h++)this.setFunctionModule(l+h,u+c,Math.max(Math.abs(h),Math.abs(c))!=1)}setFunctionModule(l,u,c){this.modules[u][l]=c,this.isFunction[u][l]=!0}addEccAndInterleave(l){const u=this.version,c=this.errorCorrectionLevel;if(l.length!=on.getNumDataCodewords(u,c))throw new RangeError("Invalid argument");const h=on.NUM_ERROR_CORRECTION_BLOCKS[c.ordinal][u],p=on.ECC_CODEWORDS_PER_BLOCK[c.ordinal][u],m=Math.floor(on.getNumRawDataModules(u)/8),g=h-m%h,y=Math.floor(m/h);let b=[];const v=on.reedSolomonComputeDivisor(p);for(let S=0,k=0;S<h;S++){let I=l.slice(k,k+y-p+(S<g?0:1));k+=I.length;const T=on.reedSolomonComputeRemainder(I,v);S<g&&I.push(0),b.push(I.concat(T))}let w=[];for(let S=0;S<b[0].length;S++)b.forEach((k,I)=>{(S!=y-p||I>=g)&&w.push(k[S])});return r(w.length==m),w}drawCodewords(l){if(l.length!=Math.floor(on.getNumRawDataModules(this.version)/8))throw new RangeError("Invalid argument");let u=0;for(let c=this.size-1;c>=1;c-=2){c==6&&(c=5);for(let h=0;h<this.size;h++)for(let p=0;p<2;p++){const m=c-p,y=(c+1&2)==0?this.size-1-h:h;!this.isFunction[y][m]&&u<l.length*8&&(this.modules[y][m]=a(l[u>>>3],7-(u&7)),u++)}}r(u==l.length*8)}applyMask(l){if(l<0||l>7)throw new RangeError("Mask value out of range");for(let u=0;u<this.size;u++)for(let c=0;c<this.size;c++){let h;switch(l){case 0:h=(c+u)%2==0;break;case 1:h=u%2==0;break;case 2:h=c%3==0;break;case 3:h=(c+u)%3==0;break;case 4:h=(Math.floor(c/3)+Math.floor(u/2))%2==0;break;case 5:h=c*u%2+c*u%3==0;break;case 6:h=(c*u%2+c*u%3)%2==0;break;case 7:h=((c+u)%2+c*u%3)%2==0;break;default:throw new Error("Unreachable")}!this.isFunction[u][c]&&h&&(this.modules[u][c]=!this.modules[u][c])}}getPenaltyScore(){let l=0;for(let p=0;p<this.size;p++){let m=!1,g=0,y=[0,0,0,0,0,0,0];for(let b=0;b<this.size;b++)this.modules[p][b]==m?(g++,g==5?l+=on.PENALTY_N1:g>5&&l++):(this.finderPenaltyAddHistory(g,y),m||(l+=this.finderPenaltyCountPatterns(y)*on.PENALTY_N3),m=this.modules[p][b],g=1);l+=this.finderPenaltyTerminateAndCount(m,g,y)*on.PENALTY_N3}for(let p=0;p<this.size;p++){let m=!1,g=0,y=[0,0,0,0,0,0,0];for(let b=0;b<this.size;b++)this.modules[b][p]==m?(g++,g==5?l+=on.PENALTY_N1:g>5&&l++):(this.finderPenaltyAddHistory(g,y),m||(l+=this.finderPenaltyCountPatterns(y)*on.PENALTY_N3),m=this.modules[b][p],g=1);l+=this.finderPenaltyTerminateAndCount(m,g,y)*on.PENALTY_N3}for(let p=0;p<this.size-1;p++)for(let m=0;m<this.size-1;m++){const g=this.modules[p][m];g==this.modules[p][m+1]&&g==this.modules[p+1][m]&&g==this.modules[p+1][m+1]&&(l+=on.PENALTY_N2)}let u=0;for(const p of this.modules)u=p.reduce((m,g)=>m+(g?1:0),u);const c=this.size*this.size,h=Math.ceil(Math.abs(u*20-c*10)/c)-1;return r(0<=h&&h<=9),l+=h*on.PENALTY_N4,r(0<=l&&l<=2568888),l}getAlignmentPatternPositions(){if(this.version==1)return[];{const l=Math.floor(this.version/7)+2,u=this.version==32?26:Math.ceil((this.version*4+4)/(l*2-2))*2;let c=[6];for(let h=this.size-7;c.length<l;h-=u)c.splice(1,0,h);return c}}static getNumRawDataModules(l){if(l<on.MIN_VERSION||l>on.MAX_VERSION)throw new RangeError("Version number out of range");let u=(16*l+128)*l+64;if(l>=2){const c=Math.floor(l/7)+2;u-=(25*c-10)*c-55,l>=7&&(u-=36)}return r(208<=u&&u<=29648),u}static getNumDataCodewords(l,u){return Math.floor(on.getNumRawDataModules(l)/8)-on.ECC_CODEWORDS_PER_BLOCK[u.ordinal][l]*on.NUM_ERROR_CORRECTION_BLOCKS[u.ordinal][l]}static reedSolomonComputeDivisor(l){if(l<1||l>255)throw new RangeError("Degree out of range");let u=[];for(let h=0;h<l-1;h++)u.push(0);u.push(1);let c=1;for(let h=0;h<l;h++){for(let p=0;p<u.length;p++)u[p]=on.reedSolomonMultiply(u[p],c),p+1<u.length&&(u[p]^=u[p+1]);c=on.reedSolomonMultiply(c,2)}return u}static reedSolomonComputeRemainder(l,u){let c=u.map(h=>0);for(const h of l){const p=h^c.shift();c.push(0),u.forEach((m,g)=>c[g]^=on.reedSolomonMultiply(m,p))}return c}static reedSolomonMultiply(l,u){if(l>>>8||u>>>8)throw new RangeError("Byte out of range");let c=0;for(let h=7;h>=0;h--)c=c<<1^(c>>>7)*285,c^=(u>>>h&1)*l;return r(c>>>8==0),c}finderPenaltyCountPatterns(l){const u=l[1];r(u<=this.size*3);const c=u>0&&l[2]==u&&l[3]==u*3&&l[4]==u&&l[5]==u;return(c&&l[0]>=u*4&&l[6]>=u?1:0)+(c&&l[6]>=u*4&&l[0]>=u?1:0)}finderPenaltyTerminateAndCount(l,u,c){return l&&(this.finderPenaltyAddHistory(u,c),u=0),u+=this.size,this.finderPenaltyAddHistory(u,c),this.finderPenaltyCountPatterns(c)}finderPenaltyAddHistory(l,u){u[0]==0&&(l+=this.size),u.pop(),u.unshift(l)}};t.MIN_VERSION=1,t.MAX_VERSION=40,t.PENALTY_N1=3,t.PENALTY_N2=3,t.PENALTY_N3=40,t.PENALTY_N4=10,t.ECC_CODEWORDS_PER_BLOCK=[[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30]],t.NUM_ERROR_CORRECTION_BLOCKS=[[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25],[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49],[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68],[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]],e.QrCode=t;function n(o,l,u){if(l<0||l>31||o>>>l)throw new RangeError("Value out of range");for(let c=l-1;c>=0;c--)u.push(o>>>c&1)}function a(o,l){return(o>>>l&1)!=0}function r(o){if(!o)throw new Error("Assertion error")}const s=class La{constructor(l,u,c){if(this.mode=l,this.numChars=u,this.bitData=c,u<0)throw new RangeError("Invalid argument");this.bitData=c.slice()}static makeBytes(l){let u=[];for(const c of l)n(c,8,u);return new La(La.Mode.BYTE,l.length,u)}static makeNumeric(l){if(!La.isNumeric(l))throw new RangeError("String contains non-numeric characters");let u=[];for(let c=0;c<l.length;){const h=Math.min(l.length-c,3);n(parseInt(l.substring(c,c+h),10),h*3+1,u),c+=h}return new La(La.Mode.NUMERIC,l.length,u)}static makeAlphanumeric(l){if(!La.isAlphanumeric(l))throw new RangeError("String contains unencodable characters in alphanumeric mode");let u=[],c;for(c=0;c+2<=l.length;c+=2){let h=La.ALPHANUMERIC_CHARSET.indexOf(l.charAt(c))*45;h+=La.ALPHANUMERIC_CHARSET.indexOf(l.charAt(c+1)),n(h,11,u)}return c<l.length&&n(La.ALPHANUMERIC_CHARSET.indexOf(l.charAt(c)),6,u),new La(La.Mode.ALPHANUMERIC,l.length,u)}static makeSegments(l){return l==""?[]:La.isNumeric(l)?[La.makeNumeric(l)]:La.isAlphanumeric(l)?[La.makeAlphanumeric(l)]:[La.makeBytes(La.toUtf8ByteArray(l))]}static makeEci(l){let u=[];if(l<0)throw new RangeError("ECI assignment value out of range");if(l<128)n(l,8,u);else if(l<16384)n(2,2,u),n(l,14,u);else if(l<1e6)n(6,3,u),n(l,21,u);else throw new RangeError("ECI assignment value out of range");return new La(La.Mode.ECI,0,u)}static isNumeric(l){return La.NUMERIC_REGEX.test(l)}static isAlphanumeric(l){return La.ALPHANUMERIC_REGEX.test(l)}getData(){return this.bitData.slice()}static getTotalBits(l,u){let c=0;for(const h of l){const p=h.mode.numCharCountBits(u);if(h.numChars>=1<<p)return 1/0;c+=4+p+h.bitData.length}return c}static toUtf8ByteArray(l){l=encodeURI(l);let u=[];for(let c=0;c<l.length;c++)l.charAt(c)!="%"?u.push(l.charCodeAt(c)):(u.push(parseInt(l.substring(c+1,c+3),16)),c+=2);return u}};s.NUMERIC_REGEX=/^[0-9]*$/,s.ALPHANUMERIC_REGEX=/^[A-Z0-9 $%*+.\/:-]*$/,s.ALPHANUMERIC_CHARSET="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";let i=s;e.QrSegment=s})(Up||(Up={}));(e=>{(t=>{const n=class{constructor(r,s){this.ordinal=r,this.formatBits=s}};n.LOW=new n(0,1),n.MEDIUM=new n(1,0),n.QUARTILE=new n(2,3),n.HIGH=new n(3,2),t.Ecc=n})(e.QrCode||(e.QrCode={}))})(Up||(Up={}));(e=>{(t=>{const n=class{constructor(r,s){this.modeBits=r,this.numBitsCharCount=s}numCharCountBits(r){return this.numBitsCharCount[Math.floor((r+7)/17)]}};n.NUMERIC=new n(1,[10,12,14]),n.ALPHANUMERIC=new n(2,[9,11,13]),n.BYTE=new n(4,[8,16,16]),n.KANJI=new n(8,[8,10,12]),n.ECI=new n(7,[0,0,0]),t.Mode=n})(e.QrSegment||(e.QrSegment={}))})(Up||(Up={}));var Qg=Up;var w8e={L:Qg.QrCode.Ecc.LOW,M:Qg.QrCode.Ecc.MEDIUM,Q:Qg.QrCode.Ecc.QUARTILE,H:Qg.QrCode.Ecc.HIGH},LJ=128,zJ="L",BJ="#FFFFFF",PJ="#000000",VJ=!1,UJ=1,A8e=4,S8e=0,k8e=.1;function WJ(e,t=0){const n=[];return e.forEach(function(a,r){let s=null;a.forEach(function(i,o){if(!i&&s!==null){n.push(`M${s+t} ${r+t}h${o-s}v1H${s+t}z`),s=null;return}if(o===a.length-1){if(!i)return;s===null?n.push(`M${o+t},${r+t} h1v1H${o+t}z`):n.push(`M${s+t},${r+t} h${o+1-s}v1H${s+t}z`);return}i&&s===null&&(s=o)})}),n.join("")}function GJ(e,t){return e.slice().map((n,a)=>a<t.y||a>=t.y+t.h?n:n.map((r,s)=>s<t.x||s>=t.x+t.w?r:!1))}function I8e(e,t,n,a){if(a==null)return null;const r=e.length+n*2,s=Math.floor(t*k8e),i=r/t,o=(a.width||s)*i,l=(a.height||s)*i,u=a.x==null?e.length/2-o/2:a.x*i,c=a.y==null?e.length/2-l/2:a.y*i,h=a.opacity==null?1:a.opacity;let p=null;if(a.excavate){let g=Math.floor(u),y=Math.floor(c),b=Math.ceil(o+u-g),v=Math.ceil(l+c-y);p={x:g,y,w:b,h:v}}const m=a.crossOrigin;return{x:u,y:c,h:l,w:o,excavation:p,opacity:h,crossOrigin:m}}function N8e(e,t){return t!=null?Math.max(Math.floor(t),0):e?A8e:S8e}function HJ({value:e,level:t,minVersion:n,includeMargin:a,marginSize:r,imageSettings:s,size:i,boostLevel:o}){let l=Ir.useMemo(()=>{const g=(Array.isArray(e)?e:[e]).reduce((y,b)=>(y.push(...Qg.QrSegment.makeSegments(b)),y),[]);return Qg.QrCode.encodeSegments(g,w8e[t],n,void 0,void 0,o)},[e,t,n,o]);const{cells:u,margin:c,numCells:h,calculatedImageSettings:p}=Ir.useMemo(()=>{let m=l.getModules();const g=N8e(a,r),y=m.length+g*2,b=I8e(m,i,g,s);return{cells:m,margin:g,numCells:y,calculatedImageSettings:b}},[l,i,s,a,r]);return{qrcode:l,margin:c,cells:u,numCells:h,calculatedImageSettings:p}}var C8e=(function(){try{new Path2D().addPath(new Path2D)}catch{return!1}return!0})(),T8e=Ir.forwardRef(function(t,n){const a=t,{value:r,size:s=LJ,level:i=zJ,bgColor:o=BJ,fgColor:l=PJ,includeMargin:u=VJ,minVersion:c=UJ,boostLevel:h,marginSize:p,imageSettings:m}=a,y=lO(a,["value","size","level","bgColor","fgColor","includeMargin","minVersion","boostLevel","marginSize","imageSettings"]),{style:b}=y,v=lO(y,["style"]),w=m?.src,S=Ir.useRef(null),k=Ir.useRef(null),I=Ir.useCallback(U=>{S.current=U,typeof n=="function"?n(U):n&&(n.current=U)},[n]),[T,E]=Ir.useState(!1),{margin:R,cells:D,numCells:O,calculatedImageSettings:$}=HJ({value:r,level:i,minVersion:c,boostLevel:h,includeMargin:u,marginSize:p,imageSettings:m,size:s});Ir.useEffect(()=>{if(S.current!=null){const U=S.current,W=U.getContext("2d");if(!W)return;let B=D;const H=k.current,j=$!=null&&H!==null&&H.complete&&H.naturalHeight!==0&&H.naturalWidth!==0;j&&$.excavation!=null&&(B=GJ(D,$.excavation));const Z=window.devicePixelRatio||1;U.height=U.width=s*Z;const te=s/O*Z;W.scale(te,te),W.fillStyle=o,W.fillRect(0,0,O,O),W.fillStyle=l,C8e?W.fill(new Path2D(WJ(B,R))):D.forEach(function(V,Q){V.forEach(function(ee,ae){ee&&W.fillRect(ae+R,Q+R,1,1)})}),$&&(W.globalAlpha=$.opacity),j&&W.drawImage(H,$.x+R,$.y+R,$.w,$.h)}}),Ir.useEffect(()=>{E(!1)},[w]);const _=oO({height:s,width:s},b);let P=null;return w!=null&&(P=Ir.createElement("img",{src:w,key:w,style:{display:"none"},onLoad:()=>{E(!0)},ref:k,crossOrigin:$?.crossOrigin})),Ir.createElement(Ir.Fragment,null,Ir.createElement("canvas",oO({style:_,height:s,width:s,ref:I,role:"img"},v)),P)});T8e.displayName="QRCodeCanvas";var jJ=Ir.forwardRef(function(t,n){const a=t,{value:r,size:s=LJ,level:i=zJ,bgColor:o=BJ,fgColor:l=PJ,includeMargin:u=VJ,minVersion:c=UJ,boostLevel:h,title:p,marginSize:m,imageSettings:g}=a,y=lO(a,["value","size","level","bgColor","fgColor","includeMargin","minVersion","boostLevel","title","marginSize","imageSettings"]),{margin:b,cells:v,numCells:w,calculatedImageSettings:S}=HJ({value:r,level:i,minVersion:c,boostLevel:h,includeMargin:u,marginSize:m,imageSettings:g,size:s});let k=v,I=null;g!=null&&S!=null&&(S.excavation!=null&&(k=GJ(v,S.excavation)),I=Ir.createElement("image",{href:g.src,height:S.h,width:S.w,x:S.x+b,y:S.y+b,preserveAspectRatio:"none",opacity:S.opacity,crossOrigin:S.crossOrigin}));const T=WJ(k,b);return Ir.createElement("svg",oO({height:s,width:s,viewBox:`0 0 ${w} ${w}`,ref:n,role:"img"},y),!!p&&Ir.createElement("title",null,p),Ir.createElement("path",{fill:o,d:`M0,0 h${w}v${w}H0z`,shapeRendering:"crispEdges"}),Ir.createElement("path",{fill:l,d:T,shapeRendering:"crispEdges"}),I)});jJ.displayName="QRCodeSVG";const CR="/proctoring-ai/models",E8e=({onVerified:e,onLogout:t})=>{const n=Ae.useRef(null),[a]=Ae.useState(()=>{const v=sessionStorage.getItem("loggedInUser");return v?JSON.parse(v):null}),[r,s]=Ae.useState("Menginisialisasi AI..."),[i,o]=Ae.useState(!1),[l,u]=Ae.useState(!1),[c,h]=Ae.useState(!1),[p,m]=Ae.useState("user"),g=()=>{m(v=>v==="user"?"environment":"user")},y=()=>`${window.location.origin+window.location.pathname}#/rear-proctoring?userId=${a?.id||"peserta"}`;Ae.useEffect(()=>{let v=!0;return(async()=>{try{s("Sinkronisasi Engine..."),await gF.ready(),await Promise.all([Ci.ssdMobilenetv1.loadFromUri(CR),Ci.faceLandmark68Net.loadFromUri(CR),Ci.faceRecognitionNet.loadFromUri(CR)]),v&&(o(!0),s("Sistem Siap."))}catch(S){console.error("AI Load Error:",S),v&&s("Gagal memuat AI.")}})(),()=>{v=!1}},[]);const b=async()=>{if(!i||l||!c)return;const v=n.current?.video;if(!v||v.readyState!==4){s("Kamera belum siap...");return}u(!0),s("Menganalisis wajah...");try{const w=await aqe(a.photo),[S,k]=await Promise.all([i6(w).withFaceLandmarks().withFaceDescriptor(),i6(v).withFaceLandmarks().withFaceDescriptor()]);if(!S||!k){s(S?"Wajah tidak terdeteksi!":"Foto profil tidak valid."),u(!1);return}x8e(S.descriptor,k.descriptor)<.55?(s("Verifikasi Berhasil!"),setTimeout(()=>e(),1e3)):(s("Wajah tidak cocok!"),u(!1))}catch(w){s("Kesalahan teknis."),u(!1),console.error("Verification System Error:",w)}};return ce.jsxs("div",{className:"min-h-screen bg-slate-50 flex flex-col font-sans",children:[ce.jsxs("header",{className:"w-full bg-indigo-600 shadow-lg px-6 py-4 flex justify-between items-center text-white",children:[ce.jsxs("div",{className:"flex items-center gap-4",children:[ce.jsx("div",{className:"bg-white/20 p-2 rounded-xl",children:ce.jsx(w5,{size:24})}),ce.jsxs("div",{children:[ce.jsx("p",{className:"text-[10px] uppercase tracking-widest font-bold opacity-70",children:"Identity Check"}),ce.jsx("p",{className:"text-lg font-black tracking-tight leading-none italic",children:a?.name||"User"})]})]}),ce.jsxs("button",{onClick:t,className:"bg-white/10 hover:bg-white/20 px-4 py-2 rounded-xl flex items-center gap-2 font-bold transition-all border border-white/20 text-xs uppercase",children:[ce.jsx(S5,{size:16}),ce.jsx("span",{children:"Keluar"})]})]}),ce.jsxs("div",{className:"flex-1 flex flex-col lg:flex-row items-center justify-center p-6 gap-8 max-w-6xl mx-auto w-full",children:[ce.jsx("div",{className:"w-full lg:w-1/3",children:ce.jsxs("div",{className:`bg-white p-8 rounded-[2.5rem] shadow-xl border-2 transition-all ${c?"border-emerald-500":"border-slate-100"}`,children:[ce.jsxs("div",{className:"text-center mb-6",children:[ce.jsx("div",{className:`w-12 h-12 rounded-2xl flex items-center justify-center mx-auto mb-4 ${c?"bg-emerald-500 text-white":"bg-indigo-600 text-white"}`,children:c?ce.jsx(v5,{size:24}):ce.jsx(I5,{size:24})}),ce.jsx("h3",{className:"text-xl font-black text-slate-900 tracking-tighter uppercase italic",children:"1. Sinkron HP"}),ce.jsx("p",{className:"text-slate-400 text-[10px] font-bold mt-2 leading-relaxed px-4 uppercase tracking-widest",children:"Scan QR untuk mengaktifkan proctoring."})]}),ce.jsxs("div",{className:"relative group p-4 bg-slate-50 rounded-[2rem] border-2 border-dashed border-slate-200 flex justify-center items-center",children:[ce.jsx(jJ,{value:y(),size:180,className:c?"opacity-10 grayscale":""}),c&&ce.jsxs("div",{className:"absolute inset-0 flex flex-col items-center justify-center text-emerald-600 font-black text-[10px] uppercase tracking-widest",children:[ce.jsx(pF,{size:48,className:"mb-2"}),"Connected"]})]}),ce.jsx("button",{onClick:()=>h(!c),className:`w-full mt-6 py-4 rounded-2xl font-black text-[10px] uppercase tracking-widest transition-all ${c?"bg-emerald-50 text-emerald-600":"bg-slate-900 text-white"}`,children:c?"Reset":"Sudah Scan"})]})}),ce.jsxs("div",{className:"w-full lg:w-2/3 space-y-6 flex flex-col items-center",children:[ce.jsxs("div",{className:"w-full relative aspect-video rounded-[3rem] overflow-hidden bg-slate-900 shadow-2xl border-8 border-white ring-1 ring-slate-100",children:[ce.jsx(i2,{ref:n,mirrored:p==="user",videoConstraints:{facingMode:p},className:"w-full h-full object-cover"}),c&&!l&&ce.jsx("button",{onClick:g,className:"absolute top-6 right-6 z-40 bg-black/40 p-3 rounded-2xl border border-white/20 text-white transition-all active:rotate-180",children:ce.jsx(k5,{size:20})}),l&&ce.jsx("div",{className:"absolute inset-0 z-20 pointer-events-none",children:ce.jsx("div",{className:"w-full h-1.5 bg-indigo-500 shadow-[0_0_30px_#6366f1] animate-scan-line relative"})}),!c&&ce.jsxs("div",{className:"absolute inset-0 bg-slate-900/90 backdrop-blur-md z-30 flex flex-col items-center justify-center text-white text-center",children:[ce.jsx(x5,{size:44,className:"text-indigo-400 mb-4 animate-pulse"}),ce.jsx("h4",{className:"text-xl font-black mb-1 uppercase tracking-tighter italic",children:"Langkah 1 Belum Selesai"})]})]}),ce.jsxs("div",{className:"w-full max-w-md space-y-4 text-center",children:[ce.jsxs("div",{className:"inline-flex items-center gap-3 font-black uppercase tracking-widest py-3 px-8 rounded-2xl border bg-white text-slate-400 border-slate-200 shadow-sm",children:[l?ce.jsx(dF,{className:"animate-spin text-indigo-600",size:16}):ce.jsx("div",{className:"w-2 h-2 rounded-full bg-indigo-500 animate-ping"}),ce.jsx("span",{className:"text-[10px]",children:r})]}),ce.jsxs("button",{onClick:b,disabled:l||!c||!i,className:`w-full py-5 rounded-[2.5rem] font-black text-xl flex items-center justify-center gap-4 transition-all shadow-2xl active:scale-[0.97] ${!c||l||!i?"bg-slate-200 text-slate-400 cursor-not-allowed shadow-none":"bg-indigo-600 hover:bg-indigo-700 text-white shadow-indigo-200"}`,children:[ce.jsx(vhe,{size:32})," ",ce.jsx("span",{className:"italic uppercase tracking-tighter",children:l?"Wait...":"Verify Wajah"})]})]})]})]}),ce.jsx("style",{children:"@keyframes scan { 0% { top: 0; opacity: 0; } 50% { opacity: 1; } 100% { top: 100%; opacity: 0; } } .animate-scan-line { animation: scan 1.8s ease-in-out infinite; }"})]})},sI=[{id:1,question:"Apa nama planet terbesar di tata surya kita?",options:["Mars","Saturnus","Yupiter","Neptunus"],correct:2},{id:2,question:"Siapakah pencipta lagu kebangsaan Indonesia Raya?",options:["W.R. Supratman","Ismail Marzuki","Moh. Hatta","Sudirman"],correct:0},{id:3,question:"Negara mana yang memiliki wilayah terluas di dunia?",options:["Amerika Serikat","Tiongkok","Kanada","Rusia"],correct:3}],$8e=600,_8e=({onLogout:e})=>{const t=Ae.useRef(null),n=Ae.useRef(null),a=Ae.useRef(null),r=Ae.useRef({faceMissing:null,multiplePeople:null,notFocus:null,noise:null}),s=Ae.useRef({}),[i,o]=Ae.useState(0),[l,u]=Ae.useState({}),[c,h]=Ae.useState(0),[p,m]=Ae.useState($8e),[g,y]=Ae.useState(0),[b,v]=Ae.useState(!1),[w,S]=Ae.useState({faceDetected:!0,lookingCenter:!0,singlePerson:!0,isQuiet:!0}),[k]=Ae.useState(()=>{const T=sessionStorage.getItem("loggedInUser");return T?JSON.parse(T):{name:"Peserta"}});Ae.useEffect(()=>((async()=>{try{const E=await navigator.mediaDevices.getUserMedia({audio:!0});n.current=new(window.AudioContext||window.webkitAudioContext),a.current=n.current.createAnalyser(),n.current.createMediaStreamSource(E).connect(a.current),a.current.fftSize=512,await gF.ready(),v(!0)}catch(E){console.error("Sistem gagal inisialisasi:",E)}})(),()=>{n.current?.close(),Object.values(r.current).forEach(E=>clearTimeout(E))}),[]),Ae.useEffect(()=>{if(i===1||!b)return;const T=(D,O,$=2500,_=5e3)=>{const P=Date.now();D?r.current[O]=null:r.current[O]?P-r.current[O]>$&&(!s.current[O]||P-s.current[O]>_)&&(y(U=>{const W=U+1;return W>=10&&I(),W}),s.current[O]=P,r.current[O]=null):r.current[O]=P},R=setInterval(async()=>{const D=t.current?.video;if(D&&D.readyState===4){const O=await b8e(D).withFaceLandmarks();let $=O.length>0,_=O.length<=1,P=!0;if($){const W=O[0].landmarks,B=W.getNose(),H=W.getLeftEye(),j=W.getRightEye(),Z=Math.abs(B[0].x-H[0].x),te=Math.abs(B[0].x-j[3].x),V=Z/te;(V<.4||V>2.5)&&(P=!1)}let U=!0;if(a.current){const W=new Uint8Array(a.current.frequencyBinCount);a.current.getByteFrequencyData(W),W.slice(10,60).reduce((H,j)=>H+j,0)/50>35&&(U=!1)}S({faceDetected:$,lookingCenter:P,singlePerson:_,isQuiet:U}),T($,"faceMissing"),T(P,"notFocus"),T(_,"multiplePeople"),T(U,"noise",2e3,6e3)}},600);return()=>clearInterval(R)},[b,i]),Ae.useEffect(()=>{if(i===1||p<=0)return;const T=setInterval(()=>{m(E=>(E<=1&&I(),E-1))},1e3);return()=>clearInterval(T)},[i]);const I=()=>{let T=0;sI.forEach(E=>{l[E.id]===E.correct&&T++}),h(Math.round(T/sI.length*100)),o(1)};return i===1?ce.jsx("div",{className:"min-h-screen bg-slate-950 flex items-center justify-center p-6 text-center",children:ce.jsxs("div",{className:"bg-white p-12 rounded-[4rem] shadow-[0_0_50px_rgba(99,102,241,0.2)] max-w-md w-full border border-indigo-100",children:[ce.jsx(Qce,{size:80,className:"mx-auto text-indigo-600 mb-6 animate-bounce"}),ce.jsx("h2",{className:"text-3xl font-black text-slate-900 tracking-tighter uppercase italic",children:"Exam Result"}),ce.jsxs("div",{className:"my-8 py-10 bg-indigo-50 rounded-[3rem] border-2 border-dashed border-indigo-200",children:[ce.jsx("h1",{className:"text-8xl font-black text-indigo-600 tracking-tighter",children:c}),ce.jsx("p",{className:"text-slate-400 font-black uppercase text-[10px] mt-2 tracking-[0.3em]",children:"Total Score"})]}),ce.jsx("button",{onClick:e,className:"w-full bg-slate-900 text-white py-5 rounded-[2rem] font-black uppercase tracking-widest text-xs hover:bg-indigo-600 transition-all shadow-xl",children:"Keluar Sistem"})]})}):ce.jsxs("div",{className:"min-h-screen bg-slate-50 flex flex-col font-sans selection:bg-indigo-100",children:[!b&&ce.jsxs("div",{className:"fixed inset-0 z-[100] bg-white flex flex-col items-center justify-center",children:[ce.jsx(dF,{className:"animate-spin text-indigo-600 mb-4",size:40}),ce.jsx("p",{className:"font-black text-xs uppercase tracking-[0.3em] text-slate-400",children:"Booting AI Guard..."})]}),ce.jsxs("header",{className:"w-full bg-indigo-600 shadow-xl px-8 py-5 flex justify-between items-center text-white sticky top-0 z-50",children:[ce.jsxs("div",{className:"flex items-center gap-4",children:[ce.jsx("div",{className:"bg-white/20 p-2.5 rounded-2xl backdrop-blur-md",children:ce.jsx(lhe,{size:22})}),ce.jsxs("div",{children:[ce.jsx("p",{className:"text-[10px] uppercase font-black opacity-60 tracking-[0.2em] mb-1 leading-none",children:"Smart Proctoring v2"}),ce.jsx("p",{className:"text-xl font-black leading-none italic uppercase tracking-tighter",children:k.name})]})]}),ce.jsxs("div",{className:"flex items-center gap-5",children:[ce.jsxs("div",{className:`px-6 py-2.5 rounded-2xl font-mono font-black flex items-center gap-3 border-2 transition-all shadow-inner ${p<60?"bg-red-500 border-red-400 animate-pulse":"bg-black/20 border-white/10"}`,children:[ce.jsx(Nhe,{size:20}),ce.jsxs("span",{className:"text-lg",children:[Math.floor(p/60),":",(p%60).toString().padStart(2,"0")]})]}),ce.jsx("button",{onClick:e,className:"bg-white/10 p-2.5 rounded-2xl hover:bg-red-500 transition-all border border-white/10",children:ce.jsx(S5,{size:22})})]})]}),ce.jsxs("div",{className:"flex flex-col lg:flex-row max-w-[90rem] mx-auto w-full p-8 gap-10",children:[ce.jsx("div",{className:"flex-1",children:ce.jsxs("div",{className:"bg-white p-12 rounded-[3.5rem] border border-slate-200 shadow-2xl shadow-slate-200/50",children:[ce.jsxs("div",{className:"flex items-center gap-3 text-indigo-600 font-black uppercase text-xs tracking-[0.3em] mb-12 italic",children:[ce.jsx(Jce,{size:20})," ",ce.jsx("span",{children:"Core Examination"})]}),ce.jsx("div",{className:"space-y-6",children:sI.map((T,E)=>ce.jsxs("div",{className:"relative group",children:[ce.jsxs("h3",{className:"text-lg font-black text-slate-800 mb-2 leading-tight flex items-start gap-2",children:[ce.jsx("span",{className:"flex-shrink-0 w-10 h-10 bg-indigo-50 text-indigo-600 rounded-xl flex items-center justify-center text-md italic",children:E+1}),T.question]}),ce.jsx("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-4",children:T.options.map((R,D)=>ce.jsxs("button",{onClick:()=>u({...l,[T.id]:D}),className:`group p-2 rounded-[1.5rem] border-2 text-left font-black transition-all duration-300 flex items-center gap-2 ${l[T.id]===D?"border-indigo-600 bg-indigo-600 text-white shadow-xl shadow-indigo-100":"border-slate-50 bg-slate-50/50 hover:border-indigo-200 text-slate-400 hover:bg-white"}`,children:[ce.jsx("div",{className:`w-6 h-6 rounded-lg border-2 flex items-center justify-center text-[10px] ${l[T.id]===D?"border-white bg-white/20":"border-slate-200 text-slate-300"}`,children:String.fromCharCode(65+D)}),R]},D))})]},T.id))}),ce.jsx("button",{onClick:I,disabled:Object.keys(l).length<sI.length,className:"w-full mt-8 bg-indigo-600 hover:bg-indigo-700 text-white py-6 rounded-[2rem] font-black text-lg disabled:bg-slate-100 disabled:text-slate-300 shadow-[0_20px_40px_rgba(79,70,229,0.3)] transition-all active:scale-[0.98] uppercase tracking-widest italic",children:"Finish & Submit"})]})}),ce.jsx("div",{className:"w-full lg:w-96",children:ce.jsxs("div",{className:"bg-white p-8 rounded-[3.5rem] border border-slate-200 sticky top-32 shadow-2xl shadow-slate-200/60",children:[ce.jsxs("div",{className:"relative aspect-video rounded-[2.5rem] overflow-hidden bg-slate-950 border-4 border-white shadow-2xl mb-8 group",children:[ce.jsx(i2,{ref:t,audio:!1,mirrored:!0,className:"w-full h-full object-cover opacity-80"}),ce.jsxs("div",{className:"absolute top-5 left-5 bg-red-600 text-[9px] text-white px-4 py-2 rounded-full font-black flex items-center gap-2 shadow-xl tracking-widest uppercase italic",children:[ce.jsx("div",{className:"w-1.5 h-1.5 bg-white rounded-full animate-ping"})," AI Guard Active"]})]}),ce.jsxs("div",{className:"space-y-3",children:[ce.jsx(iI,{icon:ce.jsx(fF,{size:16}),label:"Wajah",status:w.faceDetected}),ce.jsx(iI,{icon:ce.jsx(ihe,{size:16}),label:"Fokus",status:w.lookingCenter}),ce.jsx(iI,{icon:ce.jsx(Ehe,{size:16}),label:"Person",status:w.singlePerson}),ce.jsx(iI,{icon:ce.jsx(mhe,{size:16}),label:"Voice",status:w.isQuiet})]}),ce.jsxs("div",{className:"mt-10 p-8 bg-slate-900 rounded-[3rem] text-white shadow-2xl relative overflow-hidden group hover:scale-[1.02] transition-transform",children:[ce.jsx("div",{className:"absolute -top-10 -right-10 w-32 h-32 bg-indigo-500/10 rounded-full"}),ce.jsx("p",{className:"text-[10px] text-slate-500 font-black uppercase tracking-[0.3em] italic mb-2 opacity-50",children:"Violation Meter"}),ce.jsxs("div",{className:"flex items-end justify-between",children:[ce.jsx("h2",{className:`text-6xl font-black leading-none italic tracking-tighter ${g>7?"text-red-500":"text-indigo-400"}`,children:g}),ce.jsx("p",{className:"text-[11px] text-slate-500 mb-1 font-black tracking-[0.2em]",children:"MAX: 10"})]}),ce.jsx("div",{className:"w-full bg-white/5 h-3 rounded-full mt-6 overflow-hidden border border-white/5",children:ce.jsx("div",{className:"bg-indigo-500 h-full transition-all duration-1000 ease-out shadow-[0_0_20px_#6366f1]",style:{width:`${g/10*100}%`}})})]})]})})]})]})},iI=({icon:e,label:t,status:n})=>ce.jsxs("div",{className:`flex items-center justify-between p-4 rounded-[1.5rem] border-2 transition-all duration-500 ${n?"bg-slate-50 border-slate-50":"bg-red-50 border-red-100 shadow-lg translate-x-2"}`,children:[ce.jsxs("div",{className:"flex items-center gap-4",children:[ce.jsx("div",{className:`${n?"text-slate-400":"text-red-500"} transition-colors`,children:e}),ce.jsx("span",{className:`text-xs font-black uppercase tracking-widest ${n?"text-slate-600":"text-red-700 italic"}`,children:t})]}),ce.jsx("div",{className:`w-3 h-3 rounded-full shadow-lg ${n?"bg-emerald-500":"bg-red-500 animate-pulse"}`})]});var TR,l6;function R8e(){return l6||(l6=1,TR={webm:"data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAVkhFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsghV17AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU1LjMzLjEwMFdBjUxhdmY1NS4zMy4xMDBzpJBlrrXf3DCDVB8KcgbMpcr+RImIQJBgAAAAAAAWVK5rAQAAAAAAD++uAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDiDgQEj44OEAmJaAOABAAAAAAAABrCBsLqBkK4BAAAAAAAPq9eBAnPFgQKcgQAitZyDdW5khohBX1ZPUkJJU4OBAuEBAAAAAAAAEZ+BArWIQOdwAAAAAABiZIEgY6JPbwIeVgF2b3JiaXMAAAAAAoC7AAAAAAAAgLUBAAAAAAC4AQN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAQAAABUAAABlbmNvZGVyPUxhdmM1NS41Mi4xMDIBBXZvcmJpcyVCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAkAEAkBBTLS3GmgmLJGLSaqugYwxS7KWxSCpntbfKMYUYtV4ah5RREHupJGOKQcwtpNApJq3WVEKFFKSYYyoVUg5SIDRkhQAQmgHgcBxAsixAsiwAAAAAAAAAkDQN0DwPsDQPAAAAAAAAACRNAyxPAzTPAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAA0DwP8DwR8EQRAAAAAAAAACzPAzTRAzxRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAAsDwP8EQR0DwRAAAAAAAAACzPAzxRBDzRAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEOAAABBgIRQasiIAiBMAcEgSJAmSBM0DSJYFTYOmwTQBkmVB06BpME0AAAAAAAAAAAAAJE2DpkHTIIoASdOgadA0iCIAAAAAAAAAAAAAkqZB06BpEEWApGnQNGgaRBEAAAAAAAAAAAAAzzQhihBFmCbAM02IIkQRpgkAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrIiAIgTAHA4imUBAIDjOJYFAACO41gWAABYliWKAABgWZooAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAYcAAACDChDBQashIAiAIAcCiKZQHHsSzgOJYFJMmyAJYF0DyApgFEEQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADADwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABcAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBB9DtnUBAAAAAAAEPueBAKOFggAAgACjzoEAA4BwBwCdASqwAJAAAEcIhYWIhYSIAgIABhwJ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99YAD+/6tQgKOFggADgAqjhYIAD4AOo4WCACSADqOZgQArADECAAEQEAAYABhYL/QACIBDmAYAAKOFggA6gA6jhYIAT4AOo5mBAFMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAGSADqOFggB6gA6jmYEAewAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAj4AOo5mBAKMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAKSADqOFggC6gA6jmYEAywAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAz4AOo4WCAOSADqOZgQDzADECAAEQEAAYABhYL/QACIBDmAYAAKOFggD6gA6jhYIBD4AOo5iBARsAEQIAARAQFGAAYWC/0AAiAQ5gGACjhYIBJIAOo4WCATqADqOZgQFDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggFPgA6jhYIBZIAOo5mBAWsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAXqADqOFggGPgA6jmYEBkwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIBpIAOo4WCAbqADqOZgQG7ADECAAEQEAAYABhYL/QACIBDmAYAAKOFggHPgA6jmYEB4wAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIB5IAOo4WCAfqADqOZgQILADECAAEQEAAYABhYL/QACIBDmAYAAKOFggIPgA6jhYICJIAOo5mBAjMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAjqADqOFggJPgA6jmYECWwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYICZIAOo4WCAnqADqOZgQKDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggKPgA6jhYICpIAOo5mBAqsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCArqADqOFggLPgA6jmIEC0wARAgABEBAUYABhYL/QACIBDmAYAKOFggLkgA6jhYIC+oAOo5mBAvsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAw+ADqOZgQMjADECAAEQEAAYABhYL/QACIBDmAYAAKOFggMkgA6jhYIDOoAOo5mBA0sAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA0+ADqOFggNkgA6jmYEDcwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIDeoAOo4WCA4+ADqOZgQObADECAAEQEAAYABhYL/QACIBDmAYAAKOFggOkgA6jhYIDuoAOo5mBA8MAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA8+ADqOFggPkgA6jhYID+oAOo4WCBA+ADhxTu2sBAAAAAAAAEbuPs4EDt4r3gQHxghEr8IEK",mp4:"data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw"}),TR}var ER,u6;function D8e(){if(u6)return ER;u6=1;const{webm:e,mp4:t}=R8e(),n=()=>typeof navigator<"u"&&parseFloat((""+(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent)||[0,""])[1]).replace("undefined","3_2").replace("_",".").replace("_",""))<10&&!window.MSStream,a=()=>"wakeLock"in navigator;class r{constructor(){if(this.enabled=!1,a()){this._wakeLock=null;const i=()=>{this._wakeLock!==null&&document.visibilityState==="visible"&&this.enable()};document.addEventListener("visibilitychange",i),document.addEventListener("fullscreenchange",i)}else n()?this.noSleepTimer=null:(this.noSleepVideo=document.createElement("video"),this.noSleepVideo.setAttribute("title","No Sleep"),this.noSleepVideo.setAttribute("playsinline",""),this._addSourceToVideo(this.noSleepVideo,"webm",e),this._addSourceToVideo(this.noSleepVideo,"mp4",t),this.noSleepVideo.addEventListener("loadedmetadata",()=>{this.noSleepVideo.duration<=1?this.noSleepVideo.setAttribute("loop",""):this.noSleepVideo.addEventListener("timeupdate",()=>{this.noSleepVideo.currentTime>.5&&(this.noSleepVideo.currentTime=Math.random())})}))}_addSourceToVideo(i,o,l){var u=document.createElement("source");u.src=l,u.type=`video/${o}`,i.appendChild(u)}get isEnabled(){return this.enabled}enable(){return a()?navigator.wakeLock.request("screen").then(i=>{this._wakeLock=i,this.enabled=!0,console.log("Wake Lock active."),this._wakeLock.addEventListener("release",()=>{console.log("Wake Lock released.")})}).catch(i=>{throw this.enabled=!1,console.error(`${i.name}, ${i.message}`),i}):n()?(this.disable(),console.warn(`
        NoSleep enabled for older iOS devices. This can interrupt
        active or long-running network requests from completing successfully.
        See https://github.com/richtr/NoSleep.js/issues/15 for more details.
      `),this.noSleepTimer=window.setInterval(()=>{document.hidden||(window.location.href=window.location.href.split("#")[0],window.setTimeout(window.stop,0))},15e3),this.enabled=!0,Promise.resolve()):this.noSleepVideo.play().then(o=>(this.enabled=!0,o)).catch(o=>{throw this.enabled=!1,o})}disable(){a()?(this._wakeLock&&this._wakeLock.release(),this._wakeLock=null):n()?this.noSleepTimer&&(console.warn(`
          NoSleep now disabled for older iOS devices.
        `),window.clearInterval(this.noSleepTimer),this.noSleepTimer=null):this.noSleepVideo.pause(),this.enabled=!1}}return ER=r,ER}var O8e=D8e();const F8e=n2(O8e);const M8e=1e-7,L8e=1e-4;class Mz{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class MC{refCount(t){return yi("refCount")}incRef(t){return yi("incRef")}timerAvailable(){return!0}time(t){return yi("time")}read(t){return yi("read")}readSync(t){return yi("readSync")}readToGPU(t,n){return yi("readToGPU")}numDataIds(){return yi("numDataIds")}disposeData(t,n){return yi("disposeData")}write(t,n,a){return yi("write")}move(t,n,a,r,s){return yi("move")}createTensorFromGPUData(t,n,a){return yi("createTensorFromGPUData")}memory(){return yi("memory")}floatPrecision(){return yi("floatPrecision")}epsilon(){return this.floatPrecision()===32?M8e:L8e}dispose(){return yi("dispose")}}function yi(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Lz(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Hu(e,t,n)}function z8e(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,Hu(e,n,a),Hu(t,n,a)}function Mh(e,t,n){return Math.max(e,Math.min(t,n))}function LC(e){return e%2===0?e:e+1}function Hu(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function qJ(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function B8e(e,t){const n=Math.random();return t*n+(1-n)*e}function P8e(e,t){let n=0;for(let a=0;a<e.length;a++){const r=Number(e[a])-Number(t[a]);n+=r*r}return n}function q(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function Zr(e,t,n=""){q(tn(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Lm(e){q(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function _e(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function V8e(e){return e.length===0}function KJ(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function tn(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Wp(e){return e%1===0}function U8e(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function NN(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function W8e(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Lz(t),t}function yp(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function uO(e,t=r=>0,n,a){return new Promise((r,s)=>{let i=0;const o=()=>{if(e()){r();return}i++;const l=t(i);if(n!=null&&i>=n){s();return}a!=null?a(o,l):setTimeout(o,l)};o()})}function zz(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(a!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${s}`);a=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(a===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[a]=t/n,r}function Zt(e,t){const n=t.length;return e=e==null?t.map((a,r)=>r):[].concat(e),q(e.every(a=>a>=-n&&a<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),q(e.every(a=>Wp(a)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(a=>a<0?n+a:a)}function mc(e,t){const n=[],a=[],r=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||r?null:Zt(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function Mr(e,t){return _a(e,t)}function _a(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function XJ(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function YJ(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function Bz(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function yw(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function QJ(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Gl(e){return typeof e=="string"||e instanceof String}function ZJ(e){return typeof e=="boolean"}function CN(e){return typeof e=="number"}function zm(e){return Array.isArray(e)?zm(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":CN(e)?"float32":Gl(e)?"string":ZJ(e)?"bool":"float32"}function Lh(e){return!!(e&&e.constructor&&e.call&&e.apply)}function TN(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function St(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function JJ(e,t,n,a=!1){const r=new Array;if(t.length===1){const s=t[0]*(a?2:1);for(let i=0;i<s;i++)r[i]=n[e+i]}else{const s=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(a?2:1);for(let l=0;l<s;l++)r[l]=JJ(e+l*o,i,n,a)}return r}function no(e,t,n=!1){if(e.length===0)return t[0];const a=e.reduce((r,s)=>r*s)*(n?2:1);if(a===0)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return JJ(0,e,t,n)}function eee(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function zC(e,t){const n=Yr(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function Yr(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Pz(e,t){const n=e.reduce((a,r)=>a*r,1);if(t==null||t==="float32")return no(e,new Float32Array(n));if(t==="int32")return no(e,new Int32Array(n));if(t==="bool")return no(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function zi(e){e.forEach(t=>{q(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function ul(e,t,n){if(t===0)return 0;if(t===1)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function Bm(e,t,n){if(t===0)return[];if(t===1)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function zh(e){return e&&e.then&&typeof e.then=="function"}const c6="tfjsflags";class tee{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=G8e,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,a){if(this.flagRegistry[t]={evaluationFn:n,setHook:a},this.urlFlags[t]!=null){const r=this.urlFlags[t];Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(zh(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);c6 in t&&t[c6].split(",").forEach(a=>{const[r,s]=a.split(":");this.urlFlags[r]=j8e(r,s)})}}function G8e(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...a)=>(H8e(t,a[0],a[1]),a.join("="))),t}function H8e(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function j8e(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function Ie(){return Vz}let Vz=null;function q8e(e){Vz=e}let $R;function nee(){if($R==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");$R=e}return $R}function K8e(){const e=nee();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Uz(e,t){const n=K8e();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const H1="Abs",dx="Acos",px="Acosh",Pm="Add",j1="AddN",BC="All",PC="Any",q1="ArgMax",K1="ArgMin",fx="Asin",mx="Asinh",gx="Atan",yx="Atanh",bx="Atan2",X1="AvgPool",VC="AvgPoolGrad",Y1="AvgPool3D",UC="AvgPool3DGrad",Q1="BatchMatMul",Z1="BatchToSpaceND",WC="Bincount",J1="BitwiseAnd",aee="BroadcastTo",GC="BroadcastArgs",xx="Cast",vx="Ceil",wx="ClipByValue",HC="Complex",eA="ComplexAbs",tA="Concat",nA="Conv2D",jC="Conv2DBackpropFilter",aA="Conv2DBackpropInput",rA="Conv3D",qC="Conv3DBackpropFilterV2",KC="Conv3DBackpropInputV2",Ax="Cos",Sx="Cosh",XC="Cumprod",sA="Cumsum",YC="CropAndResize",QC="DenseBincount",ZC="DepthToSpace",iA="DepthwiseConv2dNative",JC="DepthwiseConv2dNativeBackpropFilter",eT="DepthwiseConv2dNativeBackpropInput",tT="Diag",oA="Dilation2D",EN="Dilation2DBackpropInput",$N="Dilation2DBackpropFilter",nT="Draw",kx="RealDiv",aT="Einsum",Ix="Elu",rT="EluGrad",Nx="Erf",lA="Equal",Cx="Exp",uA="ExpandDims",Tx="Expm1",sT="FFT",iT="Fill",oT="FlipLeftRight",Ex="Floor",$x="FloorDiv",cA="FusedBatchNorm",hA="GatherV2",lT="GatherNd",dA="Greater",_x="GreaterEqual",Rx="Identity",uT="IFFT",cT="Imag",Dx="IsFinite",Ox="IsInf",Fx="IsNan",pA="LeakyRelu",fA="Less",mA="LessEqual",hT="LinSpace",Mx="Log",Lx="Log1p",gA="LogicalAnd",yA="LogicalNot",bA="LogicalOr",X8e="LogicalXor",ree="LogSoftmax",Y8e="LowerBound",xA="LRN",dT="LRNGrad",Q8e="MatrixBandPart",vA="Max",zx="Maximum",wA="MaxPool",pT="MaxPoolGrad",AA="MaxPool3D",fT="MaxPool3DGrad",mT="MaxPoolWithArgmax",SA="Mean",kA="Min",Bx="Minimum",IA="MirrorPad",Px="Mod",gT="Multinomial",Vx="Multiply",NA="Neg",CA="NotEqual",yT="NonMaxSuppressionV3",bT="NonMaxSuppressionV4",xT="NonMaxSuppressionV5",TA="OnesLike",EA="OneHot",$A="Pack",_A="PadV2",Z8e="Pool",Ux="Pow",RA="Prelu",DA="Prod",vT="RaggedGather",wT="RaggedRange",AT="RaggedTensorToTensor",ST="Range",kT="Real",Wx="Reciprocal",Gx="Relu",OA="Reshape",FA="ResizeNearestNeighbor",IT="ResizeNearestNeighborGrad",MA="ResizeBilinear",NT="ResizeBilinearGrad",Hx="Relu6",LA="Reverse",jx="Round",qx="Rsqrt",CT="ScatterNd",TT="TensorScatterUpdate",ET="SearchSorted",zA="Select",Kx="Selu",BA="Slice",Xx="Sin",Yx="Sinh",Qx="Sign",Zx="Sigmoid",Jx="Softplus",e0="Sqrt",PA="Sum",VA="SpaceToBatchND",UA="SplitV",WA="Softmax",$T="SparseFillEmptyRows",_T="SparseReshape",RT="SparseSegmentMean",DT="SparseSegmentSum",OT="SparseToDense",t0="SquaredDifference",FT="Square",GA="StaticRegexReplace",MT="StridedSlice",LT="StringNGrams",zT="StringSplit",BT="StringToHashBucketFast",n0="Sub",a0="Tan",r0="Tanh",s0="Tile",PT="TopK",VT="Transform",bp="Transpose",UT="Unique",HA="Unpack",jA="UnsortedSegmentSum",J8e="UpperBound",qA="ZerosLike",i0="Step",_N="FromPixels",WT="RotateWithOffset",bw="_FusedMatMul",xw="FusedConv2D",vw="FusedDepthwiseConv2D";function qi(...e){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(...e)}function eKe(...e){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.log(...e)}const Ny=Uz("kernelRegistry",()=>new Map),ww=Uz("gradRegistry",()=>new Map);function Aw(e,t){const n=Wz(e,t);return Ny.get(n)}function cO(e){return ww.get(e)}function RN(e){const t=Ny.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[s,i]=r,[o]=s.split("_");o===e&&n.push(i)}return n}function GT(e){const{kernelName:t,backendName:n}=e,a=Wz(t,n);Ny.has(a)&&qi(`The kernel '${t}' for backend '${n}' is already registered`),Ny.set(a,e)}function see(e){const{kernelName:t}=e;ww.has(t)&&Ie().getBool("DEBUG")&&qi(`Overriding the gradient for '${t}'`),ww.set(t,e)}function tKe(e,t){const n=Wz(e,t);if(!Ny.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Ny.delete(n)}function nKe(e){if(!ww.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ww.delete(e)}function aKe(e,t){RN(e).forEach(a=>{const r=Object.assign({},a,{backendName:t});GT(r)})}function Wz(e,t){return`${t}_${e}`}function iee(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var _R,h6;function rKe(){if(h6)return _R;h6=1,_R=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(O,$,_){this.low=O|0,this.high=$|0,this.unsigned=!!_}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function n(O){return(O&&O.__isLong__)===!0}t.isLong=n;var a={},r={};function s(O,$){var _,P,U;return $?(O>>>=0,(U=0<=O&&O<256)&&(P=r[O],P)?P:(_=o(O,(O|0)<0?-1:0,!0),U&&(r[O]=_),_)):(O|=0,(U=-128<=O&&O<128)&&(P=a[O],P)?P:(_=o(O,O<0?-1:0,!1),U&&(a[O]=_),_))}t.fromInt=s;function i(O,$){if(isNaN(O))return $?w:v;if($){if(O<0)return w;if(O>=g)return E}else{if(O<=-y)return R;if(O+1>=y)return T}return O<0?i(-O,$).neg():o(O%m|0,O/m|0,$)}t.fromNumber=i;function o(O,$,_){return new t(O,$,_)}t.fromBits=o;var l=Math.pow;function u(O,$,_){if(O.length===0)throw Error("empty string");if(O==="NaN"||O==="Infinity"||O==="+Infinity"||O==="-Infinity")return v;if(typeof $=="number"?(_=$,$=!1):$=!!$,_=_||10,_<2||36<_)throw RangeError("radix");var P;if((P=O.indexOf("-"))>0)throw Error("interior hyphen");if(P===0)return u(O.substring(1),$,_).neg();for(var U=i(l(_,8)),W=v,B=0;B<O.length;B+=8){var H=Math.min(8,O.length-B),j=parseInt(O.substring(B,B+H),_);if(H<8){var Z=i(l(_,H));W=W.mul(Z).add(i(j))}else W=W.mul(U),W=W.add(i(j))}return W.unsigned=$,W}t.fromString=u;function c(O,$){return typeof O=="number"?i(O,$):typeof O=="string"?u(O,$):o(O.low,O.high,typeof $=="boolean"?$:O.unsigned)}t.fromValue=c;var h=65536,p=1<<24,m=h*h,g=m*m,y=g/2,b=s(p),v=s(0);t.ZERO=v;var w=s(0,!0);t.UZERO=w;var S=s(1);t.ONE=S;var k=s(1,!0);t.UONE=k;var I=s(-1);t.NEG_ONE=I;var T=o(-1,2147483647,!1);t.MAX_VALUE=T;var E=o(-1,-1,!0);t.MAX_UNSIGNED_VALUE=E;var R=o(0,-2147483648,!1);t.MIN_VALUE=R;var D=t.prototype;return D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},D.toString=function($){if($=$||10,$<2||36<$)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var _=i($),P=this.div(_),U=P.mul(_).sub(this);return P.toString($)+U.toInt().toString($)}else return"-"+this.neg().toString($);for(var W=i(l($,6),this.unsigned),B=this,H="";;){var j=B.div(W),Z=B.sub(j.mul(W)).toInt()>>>0,te=Z.toString($);if(B=j,B.isZero())return te+H;for(;te.length<6;)te="0"+te;H=""+te+H}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var $=this.high!=0?this.high:this.low,_=31;_>0&&($&1<<_)==0;_--);return this.high!=0?_+33:_+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function($){return n($)||($=c($)),this.unsigned!==$.unsigned&&this.high>>>31===1&&$.high>>>31===1?!1:this.high===$.high&&this.low===$.low},D.eq=D.equals,D.notEquals=function($){return!this.eq($)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function($){return this.comp($)<0},D.lt=D.lessThan,D.lessThanOrEqual=function($){return this.comp($)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function($){return this.comp($)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function($){return this.comp($)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function($){if(n($)||($=c($)),this.eq($))return 0;var _=this.isNegative(),P=$.isNegative();return _&&!P?-1:!_&&P?1:this.unsigned?$.high>>>0>this.high>>>0||$.high===this.high&&$.low>>>0>this.low>>>0?-1:1:this.sub($).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(S)},D.neg=D.negate,D.add=function($){n($)||($=c($));var _=this.high>>>16,P=this.high&65535,U=this.low>>>16,W=this.low&65535,B=$.high>>>16,H=$.high&65535,j=$.low>>>16,Z=$.low&65535,te=0,V=0,Q=0,ee=0;return ee+=W+Z,Q+=ee>>>16,ee&=65535,Q+=U+j,V+=Q>>>16,Q&=65535,V+=P+H,te+=V>>>16,V&=65535,te+=_+B,te&=65535,o(Q<<16|ee,te<<16|V,this.unsigned)},D.subtract=function($){return n($)||($=c($)),this.add($.neg())},D.sub=D.subtract,D.multiply=function($){if(this.isZero())return v;if(n($)||($=c($)),e){var _=e.mul(this.low,this.high,$.low,$.high);return o(_,e.get_high(),this.unsigned)}if($.isZero())return v;if(this.eq(R))return $.isOdd()?R:v;if($.eq(R))return this.isOdd()?R:v;if(this.isNegative())return $.isNegative()?this.neg().mul($.neg()):this.neg().mul($).neg();if($.isNegative())return this.mul($.neg()).neg();if(this.lt(b)&&$.lt(b))return i(this.toNumber()*$.toNumber(),this.unsigned);var P=this.high>>>16,U=this.high&65535,W=this.low>>>16,B=this.low&65535,H=$.high>>>16,j=$.high&65535,Z=$.low>>>16,te=$.low&65535,V=0,Q=0,ee=0,ae=0;return ae+=B*te,ee+=ae>>>16,ae&=65535,ee+=W*te,Q+=ee>>>16,ee&=65535,ee+=B*Z,Q+=ee>>>16,ee&=65535,Q+=U*te,V+=Q>>>16,Q&=65535,Q+=W*Z,V+=Q>>>16,Q&=65535,Q+=B*j,V+=Q>>>16,Q&=65535,V+=P*te+U*Z+W*j+B*H,V&=65535,o(ee<<16|ae,V<<16|Q,this.unsigned)},D.mul=D.multiply,D.divide=function($){if(n($)||($=c($)),$.isZero())throw Error("division by zero");if(e){if(!this.unsigned&&this.high===-2147483648&&$.low===-1&&$.high===-1)return this;var _=(this.unsigned?e.div_u:e.div_s)(this.low,this.high,$.low,$.high);return o(_,e.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?w:v;var P,U,W;if(this.unsigned){if($.unsigned||($=$.toUnsigned()),$.gt(this))return w;if($.gt(this.shru(1)))return k;W=w}else{if(this.eq(R)){if($.eq(S)||$.eq(I))return R;if($.eq(R))return S;var B=this.shr(1);return P=B.div($).shl(1),P.eq(v)?$.isNegative()?S:I:(U=this.sub($.mul(P)),W=P.add(U.div($)),W)}else if($.eq(R))return this.unsigned?w:v;if(this.isNegative())return $.isNegative()?this.neg().div($.neg()):this.neg().div($).neg();if($.isNegative())return this.div($.neg()).neg();W=v}for(U=this;U.gte($);){P=Math.max(1,Math.floor(U.toNumber()/$.toNumber()));for(var H=Math.ceil(Math.log(P)/Math.LN2),j=H<=48?1:l(2,H-48),Z=i(P),te=Z.mul($);te.isNegative()||te.gt(U);)P-=j,Z=i(P,this.unsigned),te=Z.mul($);Z.isZero()&&(Z=S),W=W.add(Z),U=U.sub(te)}return W},D.div=D.divide,D.modulo=function($){if(n($)||($=c($)),e){var _=(this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,$.low,$.high);return o(_,e.get_high(),this.unsigned)}return this.sub(this.div($).mul($))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return o(~this.low,~this.high,this.unsigned)},D.and=function($){return n($)||($=c($)),o(this.low&$.low,this.high&$.high,this.unsigned)},D.or=function($){return n($)||($=c($)),o(this.low|$.low,this.high|$.high,this.unsigned)},D.xor=function($){return n($)||($=c($)),o(this.low^$.low,this.high^$.high,this.unsigned)},D.shiftLeft=function($){return n($)&&($=$.toInt()),($&=63)===0?this:$<32?o(this.low<<$,this.high<<$|this.low>>>32-$,this.unsigned):o(0,this.low<<$-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function($){return n($)&&($=$.toInt()),($&=63)===0?this:$<32?o(this.low>>>$|this.high<<32-$,this.high>>$,this.unsigned):o(this.high>>$-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function($){if(n($)&&($=$.toInt()),$&=63,$===0)return this;var _=this.high;if($<32){var P=this.low;return o(P>>>$|_<<32-$,_>>>$,this.unsigned)}else return $===32?o(_,0,this.unsigned):o(_>>>$-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},D.toBytes=function($){return $?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var $=this.high,_=this.low;return[_&255,_>>>8&255,_>>>16&255,_>>>24,$&255,$>>>8&255,$>>>16&255,$>>>24]},D.toBytesBE=function(){var $=this.high,_=this.low;return[$>>>24,$>>>16&255,$>>>8&255,$&255,_>>>24,_>>>16&255,_>>>8&255,_&255]},t.fromBytes=function($,_,P){return P?t.fromBytesLE($,_):t.fromBytesBE($,_)},t.fromBytesLE=function($,_){return new t($[0]|$[1]<<8|$[2]<<16|$[3]<<24,$[4]|$[5]<<8|$[6]<<16|$[7]<<24,_)},t.fromBytesBE=function($,_){return new t($[4]<<24|$[5]<<16|$[6]<<8|$[7],$[0]<<24|$[1]<<16|$[2]<<8|$[3],_)},_R}var oee=rKe();const lee=n2(oee),sKe=Yle({__proto__:null,default:lee},[oee]);const rp=lee||sKe;function KA(e){return rp.fromString(e,!0,16)}const uee=KA("c3a5c85c97cb3127"),Qd=KA("b492b66fbe98f273"),As=KA("9ae16a3b2f90404f");function hO(e){return e.xor(e.shru(47))}function cee(e,t,n){const a=e.slice(t,t+n);return rp.fromBytes(Array.from(a),!0,!0)}function ra(e,t){return cee(e,t,8)}function d6(e,t){return cee(e,t,4)}function Er(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function bh(e,t,n=KA("9ddfea08eb382d69")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function iKe(e,t,n,a,r,s){r=r.add(e),s=Er(s.add(r).add(a),21);const i=r;return r=r.add(t),r=r.add(n),s=s.add(Er(r,44)),[r.add(a),s.add(i)]}function oI(e,t,n,a){return iKe(ra(e,t),ra(e,t+8),ra(e,t+16),ra(e,t+24),n,a)}function oKe(e,t=e.length){if(t>=8){const n=As.add(t*2),a=ra(e,0).add(As),r=ra(e,t-8),s=Er(r,37).mul(n).add(a),i=Er(a,25).add(r).mul(n);return bh(s,i,n)}if(t>=4){const n=As.add(t*2),a=d6(e,0);return bh(a.shl(3).add(t),d6(e,t-4),n)}if(t>0){const n=e[0],a=e[t>>1],r=e[t-1],s=n+(a<<8),i=t+(r<<2);return hO(As.mul(s).xor(uee.mul(i))).mul(As)}return As}function lKe(e,t=e.length){const n=As.add(t*2),a=ra(e,0).mul(Qd),r=ra(e,8),s=ra(e,t-8).mul(n),i=ra(e,t-16).mul(As);return bh(Er(a.add(r),43).add(Er(s,30)).add(i),a.add(Er(r.add(As),18)).add(s),n)}function uKe(e,t=e.length){const n=As.add(t*2),a=ra(e,0).mul(As),r=ra(e,8),s=ra(e,t-8).mul(n),i=ra(e,t-16).mul(As),o=Er(a.add(r),43).add(Er(s,30)).add(i),l=bh(o,a.add(Er(r.add(As),18)).add(s),n),u=ra(e,16).mul(n),c=ra(e,24),h=o.add(ra(e,t-32)).mul(n),p=l.add(ra(e,t-24)).mul(n);return bh(Er(u.add(c),43).add(Er(h,30)).add(p),u.add(Er(c.add(a),18)).add(h),n)}function hee(e,t=e.length){const n=rp.fromNumber(81,!0);if(t<=32)return t<=16?oKe(e,t):lKe(e,t);if(t<=64)return uKe(e,t);let a=n,r=n.mul(Qd).add(113),s=hO(r.mul(As).add(113)).mul(As),i=[rp.UZERO,rp.UZERO],o=[rp.UZERO,rp.UZERO];a=a.mul(As).add(ra(e,0));let l=0;const u=(t-1>>6)*64,c=u+(t-1&63)-63;do a=Er(a.add(r).add(i[0]).add(ra(e,l+8)),37).mul(Qd),r=Er(r.add(i[1]).add(ra(e,l+48)),42).mul(Qd),a=a.xor(o[1]),r=r.add(i[0]).add(ra(e,l+40)),s=Er(s.add(o[0]),33).mul(Qd),i=oI(e,l,i[1].mul(Qd),a.add(o[0])),o=oI(e,l+32,s.add(o[1]),r.add(ra(e,l+16))),[s,a]=[a,s],l+=64;while(l!==u);const h=Qd.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=Er(a.add(r).add(i[0]).add(ra(e,l+8)),37).mul(h),r=Er(r.add(i[1]).add(ra(e,l+48)),42).mul(h),a=a.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(ra(e,l+40))),s=Er(s.add(o[0]),33).mul(h),i=oI(e,l,i[1].mul(h),a.add(o[0])),o=oI(e,l+32,s.add(o[1]),r.add(ra(e,l+16))),[s,a]=[a,s],bh(bh(i[0],o[0],h).add(hO(r).mul(uee)).add(s),bh(i[1],o[1],h).add(a),h)}function gc(e,t){return t==="string"?Xl(e):hd([e],t)}function cKe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function hd(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ru(e)),Ie().getBool("DEBUG")&&XJ(e,t),cKe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let a=0;a<n.length;++a)Math.round(e[a])!==0&&(n[a]=1);return n}else throw new Error(`Unknown data type ${t}`)}function xs(){return Ie().platform.now()}function hKe(e,t){return Ie().platform.fetch(e,t)}function Xl(e,t="utf-8"){return t=t||"utf-8",Ie().platform.encode(e,t)}function tc(e,t="utf-8"){return t=t||"utf-8",Ie().platform.decode(e,t)}function $r(e){return Ie().platform.isTypedArray!=null?Ie().platform.isTypedArray(e):iee(e)}function ru(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||zh(e)||e==null||$r(e)&&n)t.push(e);else if(Array.isArray(e)||$r(e))for(let a=0;a<e.length;++a)ru(e[a],t,n);else{let a=-1;for(const r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(a=Math.max(a,Number(r)));for(let r=0;r<=a;r++)ru(e[r],t,n)}return t}const dKe=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:tn,arraysEqualWithNull:KJ,assert:q,assertNonNegativeIntegerDimensions:zi,assertNonNull:Lm,assertShapesMatch:Zr,bytesFromStringArray:QJ,bytesPerElement:yw,checkConversionForErrors:XJ,clamp:Mh,computeStrides:St,convertBackendValuesAndArrayBuffer:eee,createScalarValue:gc,createShuffledIndices:W8e,decodeString:tc,distSquared:P8e,encodeString:Xl,fetch:hKe,fingerPrint64:hee,flatten:ru,getArrayFromDType:_a,getTypedArrayFromDType:Mr,hasEncodingLoss:Bz,hexToLong:KA,indexToLoc:Bm,inferDtype:zm,inferFromImplicitShape:zz,isBoolean:ZJ,isFunction:Lh,isInt:Wp,isNumber:CN,isPromise:zh,isScalarShape:V8e,isString:Gl,isTypedArray:$r,isValidDtype:YJ,locToIndex:ul,makeOnesTypedArray:zC,makeZerosNestedTypedArray:Pz,makeZerosTypedArray:Yr,nearestDivisor:TN,nearestLargerEven:LC,now:xs,parseAxisParam:Zt,randUniform:B8e,repeatedTry:uO,rightPad:yp,shuffle:Lz,shuffleCombo:z8e,sizeFromShape:_e,sizeToSquarishShape:NN,squeezeShape:mc,sum:qJ,swap:Hu,tanh:U8e,toNestedArray:no,toTypedArray:hd},Symbol.toStringTag,{value:"Module"}));class pKe{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new mKe)}profileKernel(t,n,a){let r;const s=()=>{r=a()};let i;const o=xs();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(const u of r)u.dataSync();i=Promise.resolve({kernelMs:xs()-o})}if(Ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(h=>{fKe(h,c.dtype,t)})}return{kernelName:t,outputs:r,inputs:n,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:a,timeMs:r,inputs:s,extraInfo:i}=t;a.forEach(o=>{Promise.all([o.data(),r,i]).then(l=>{this.logger.logKernelProfile(n,o,l[0],l[1],s,l[2])})})}}function fKe(e,t,n){if(t!=="float32")return!1;for(let a=0;a<e.length;a++){const r=e[a];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class mKe{logKernelProfile(t,n,a,r,s,i){const o=typeof r=="number"?yp(`${r}ms`,9):r.error,l=yp(t,25),u=n.rank,c=n.size,h=yp(n.shape.toString(),14);let p="";for(const m in s){const g=s[m];if(g!=null){const y=g.shape||n.shape,b=y.length;p+=`${m}: ${b}D ${b>0?y:""} `}}console.log(`%c${l}	%c${o}	%c${u}D ${h}	%c${c}	%c${p}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function gKe(e,t,n){const a={},r={};for(let l=0;l<t.length;l++)a[t[l].id]=!0;for(let l=0;l<e.length;l++){const u=e[l],c=u.inputs;for(const h in c){const p=c[h];let m=!1;for(let g=0;g<t.length;g++)if(a[p.id]){u.outputs.forEach(y=>a[y.id]=!0),m=!0,r[u.id]=!0;break}if(m)break}}const s={};s[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const u=e[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(s[u.outputs[h].id]){for(const p in c)s[c[p].id]=!0,i[u.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const u=e[l];if(r[u.id]&&i[u.id]){const c={};for(const p in u.inputs){const m=u.inputs[p];a[m.id]&&(c[p]=m)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,o.push(h)}}return o}function yKe(e,t,n,a){for(let r=t.length-1;r>=0;r--){const s=t[r],i=[];if(s.outputs.forEach(l=>{const u=e[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(i);for(const l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=s.inputs[l];if(!tn(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{const h=e[c.id];e[c.id]=a(h,u),h.dispose()}}}}const p6=20,Iv=3,RR=7;function bKe(e,t,n,a){const r=St(t),s=xKe(e,t,n,r),i=t.length,o=FI(e,t,n,r,s),l=["Tensor"];return a&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function xKe(e,t,n,a){const r=_e(t),s=a[a.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?Pv(e):e;if(o>1)for(let u=0;u<r/s;u++){const c=u*s;for(let h=0;h<s;h++)i[h]=Math.max(i[h],Bv(l[c+h],0,n).length)}return i}function Bv(e,t,n){let a;return Array.isArray(e)?a=`${parseFloat(e[0].toFixed(RR))} + ${parseFloat(e[1].toFixed(RR))}j`:Gl(e)?a=`'${e}'`:n==="bool"?a=dee(e):a=parseFloat(e.toFixed(RR)).toString(),yp(a,t)}function dee(e){return e===0?"false":"true"}function FI(e,t,n,a,r,s=!0){const i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){const y=Pv(e);return[Bv(y[0],0,n)]}return n==="bool"?[dee(e[0])]:[e[0].toString()]}if(l===1){if(o>p6){const b=Iv*i;let v=Array.from(e.slice(0,b)),w=Array.from(e.slice((o-Iv)*i,o*i));return n==="complex64"&&(v=Pv(v),w=Pv(w)),["["+v.map((S,k)=>Bv(S,r[k],n)).join(", ")+", ..., "+w.map((S,k)=>Bv(S,r[o-Iv+k],n)).join(", ")+"]"]}return["["+(n==="complex64"?Pv(e):Array.from(e)).map((b,v)=>Bv(b,r[v],n)).join(", ")+"]"]}const u=t.slice(1),c=a.slice(1),h=a[0]*i,p=[];if(o>p6){for(let y=0;y<Iv;y++){const b=y*h,v=b+h;p.push(...FI(e.slice(b,v),u,n,c,r,!1))}p.push("...");for(let y=o-Iv;y<o;y++){const b=y*h,v=b+h;p.push(...FI(e.slice(b,v),u,n,c,r,y===o-1))}}else for(let y=0;y<o;y++){const b=y*h,v=b+h;p.push(...FI(e.slice(b,v),u,n,c,r,y===o-1))}const m=l===2?",":"";p[0]="["+(o>0?p[0]+m:"");for(let y=1;y<p.length-1;y++)p[y]=" "+p[y]+m;let g=`,
`;for(let y=2;y<l;y++)g+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(s?"":g),p}function Pv(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class er{constructor(t,n,a){if(this.dtype=n,this.shape=t.slice(),this.size=_e(t),a!=null){const r=a.length;q(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=a||_a(n,this.size),this.strides=St(t)}set(t,...n){n.length===0&&(n=[0]),q(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const a=this.locToIndex(n);this.values[a]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const r of t){if(r<0||r>=this.shape[n]){const s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}n++}let a=t[t.length-1];for(let r=0;r<t.length-1;++r)a+=this.strides[r]*t[r];return this.values[a]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let a=0;a<t.length-1;++a)n+=this.strides[a]*t[a];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let a=0;a<n.length-1;++a)n[a]=Math.floor(t/this.strides[a]),t-=n[a]*this.strides[a];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return al().makeTensor(this.values,this.shape,this.dtype)}}let al=null,Kg=null;function vKe(e){al=e}function wKe(e){Kg=e}class In{constructor(t,n,a,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=_e(t),this.strides=St(t),this.dataId=a,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Kg.buffer(this.shape,this.dtype,t)}bufferSync(){return Kg.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return no(this.shape,t,this.dtype==="complex64")}arraySync(){return no(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=al().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(a=>tc(a))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),al().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=al().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>tc(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await al().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),al().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Kg.print(this,t)}clone(){return this.throwIfDisposed(),Kg.clone(this)}toString(t=!1){const n=this.dataSync();return bKe(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Kg.cast(this,t)}variable(t=!0,n,a){return this.throwIfDisposed(),al().makeVariable(this,t,n,a)}}Object.defineProperty(In,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Fe(){return Uz("Tensor",()=>In)}Fe();class Sw extends In{constructor(t,n,a,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=n,this.name=a}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!tn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);al().disposeTensor(this),this.dataId=t.dataId,al().incRef(this,null)}dispose(){al().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Sw,Symbol.hasInstance,{value:e=>e instanceof In&&e.assign!=null&&e.assign instanceof Function});var dO;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(dO||(dO={}));var pO;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(pO||(pO={}));var fO;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(fO||(fO={}));var mO;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(mO||(mO={}));var gO;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(gO||(gO={}));const AKe={float32:mO,int32:pO,bool:fO,complex64:gO};function ei(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return AKe[e][t]}function HT(e){return ei(e,"int32")}function pee(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function fee(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Ta(e,t){if(e.dtype===t.dtype)return[e,t];const n=ei(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function mee(e,t){q(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function SKe(e,t){return t.some(n=>n.id===e.id)}function Gz(e){const t=[];return gee(e,t,new Set),t}function gee(e,t,n){if(e==null)return;if(e instanceof In){t.push(e);return}if(!kKe(e))return;const a=e;for(const r in a){const s=a[r];n.has(s)||(n.add(s),gee(s,t,n))}}function kKe(e){return Array.isArray(e)||typeof e=="object"}const IKe=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:mee,getTensorsInContainer:Gz,isTensorInList:SKe,makeTypesMatch:Ta},Symbol.toStringTag,{value:"Module"}));function DR(e){return e.kernelName!=null}class f6{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Cy{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new f6}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const a=t[n];if(await this.initializeBackend(a).success){await this.setBackend(a);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,a=1){return t in this.registryFactory?(qi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:a},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:a}=this.initializeBackend(t);if(!(a?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new pKe(this.backendInstance),!0}setupRegisteredKernels(){RN(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){RN(t).forEach(a=>{a.disposeFunc!=null&&a.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const a=n.factory();if(a&&!(a instanceof MC)&&typeof a.then=="function"){const r=++this.pendingBackendInitId,s=a.then(i=>r<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,qi(`Initialization of backend ${t} failed`),qi(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(a){return qi(`Initialization of backend ${t} failed`),qi(a.stack||a.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const a=t[n],{success:r,asyncInit:s}=this.initializeBackend(a);if(s||r)return{name:a,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const a=this.state.tensorInfo.get(n),r=a.backend,s=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),a.backend=t,t.move(n,s,a.shape,a.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=t}let r;return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,a){t();try{const r=a();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Cy.nextTensorId++}nextVariableId(){return Cy.nextVariableId++}clone(t){const n=se.runKernel(Rx,{x:t}),a={x:t},r=i=>({x:()=>{const o="float32",l={x:i},u={dtype:o};return se.runKernel(xx,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,a,[n],r,s,{}),n}runKernel(t,n,a){if(this.backendName==null&&this.backend,!(Aw(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:a})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,a){const r=this.backend.numDataIds();let s=0;a.forEach(l=>{s+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,a=[];const r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const u=DR(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(DR(t)){const{kernelName:g,inputs:y,attrs:b}=t;this.backendName==null&&this.backend;const v=Aw(g,this.backendName);q(v!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),o=()=>{const w=this.backend.numDataIds();l=v.kernelFunc({inputs:y,attrs:b,backend:this.backend});const S=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,w,S);const k=S.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(r){const I=this.getTensorsForGradient(g,y,k);a=this.saveTensorsForBackwardMode(I)}return k}}else{const{forwardFunc:g}=t,y=b=>{r&&(a=b.map(v=>this.keep(this.clone(v))))};o=()=>{const b=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,y));const v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,b,v),v}}const{inputs:c,attrs:h}=t,p=DR(t)?null:t.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(m=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),n=m.outputs)}),r&&this.addTapeNode(u,c,n,p,a,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(g=>c[g]!=null?c[g].shape:null),outputShapes:n.map(g=>g.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(a=>this.keep(this.clone(a)))}getTensorsForGradient(t,n,a){const r=cO(t);if(r!=null){const s=r.inputsToSave||[],i=r.outputsToSave||[];let o;r.saveAllInputs?(q(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=s.map(u=>n[u]);const l=a.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(t,n,a,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");a=a||"float32",r=r||this.backend;let s=t;a==="string"&&Gl(t[0])&&(s=t.map(l=>Xl(l)));const i=r.write(s,n,a),o=new In(n,a,i,this.nextTensorId());if(this.trackTensor(o,r),a==="string"){const l=this.state.tensorInfo.get(i),u=QJ(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,a,r){a=a||"float32";const s={dataId:t,shape:n,dtype:a};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,n){const{dataId:a,shape:r,dtype:s}=t,i=new In(r,s,a,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,a,r){a=a||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const s=new Sw(t,n,a,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let a=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(a=t.size*yw(t.dtype)),this.state.numBytes+=a,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:a})),t instanceof Sw||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const a=t.size*yw(t.dtype);this.state.numBytes-=a}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,a=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-a;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,a,r,s,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:a,saved:s},l=cO(t);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=u=>(u=u.map((c,h)=>{if(c==null){const p=a[h],m=Yr(p.size,p.dtype);return this.makeTensor(m,p.shape,p.dtype)}return c}),r(u.length>1?u:u[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=Gz(t),a=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const i=this.state.activeScope.track[s];!i.kept&&!a.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(t,n,a,r=!1){if(q(n.length>0,()=>"gradients() received an empty list of xs."),a!=null&&a.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));q(s instanceof In,()=>"The result y returned by f() must be a tensor.");const i=gKe(this.state.activeTape,n,s);if(!r&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[s.id]=a??NKe(s.shape),yKe(o,i,u=>this.tidy(u),CKe);const l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return q(Lh(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{q(n.every(o=>o instanceof In),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let a;const r={};n.forEach((o,l)=>{r[l]=o});const s=(o,l)=>(a=t(...n,l),q(a.value instanceof In,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),q(Lh(a.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),a.value),i=(o,l)=>{const u=a.gradFunc(o,l),c=Array.isArray(u)?u:[u];q(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),q(c.every(p=>p instanceof In),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((p,m)=>{h[m]=()=>p}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=xs(),a=await this.backend.time(t);return a.wallMs=xs()-n,a}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new f6;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Cy.nextTensorId=0;Cy.nextVariableId=0;function NKe(e){const t=zC(_e(e),"float32");return se.makeTensor(t,e,"float32")}function yee(){const e=nee();if(e._tfengine==null){const t=new tee(e);e._tfengine=new Cy(t)}return q8e(e._tfengine.ENV),vKe(()=>e._tfengine),e._tfengine}const se=yee();function CKe(e,t){const n={a:e,b:t};return se.runKernel(Pm,n)}function TKe(){return typeof navigator<"u"&&navigator!=null}let yO;function EKe(e){yO=e}function Hz(e){if(yO!==void 0)return yO;if(e||TKe()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function jz(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const $Ke=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:jz,isMobile:Hz,mockIsMobile:EKe},Symbol.toStringTag,{value:"Module"}));const ti=Ie();ti.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ti.registerFlag("IS_BROWSER",()=>jz());ti.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ti.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ti.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ti.registerFlag("PROD",()=>!1);ti.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ti.getBool("DEBUG"));ti.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ti.registerFlag("IS_TEST",()=>!1);ti.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ti.getBool("DEBUG"));ti.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ti.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ti.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function su(e,t){let n=e;if($r(e))return t==="string"?[]:[e.length];if(pee(e)){const r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(fee(e))return[e.buffer.size/(t==null?4:yw(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||$r(n)&&t!=="string";)a.push(n.length),n=n[0];return Array.isArray(e)&&Ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&bee(e,a,[]),a}function bee(e,t,n){if(n=n||[],!Array.isArray(e)&&!$r(e)){q(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}q(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),q(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const a=t.slice(1);for(let r=0;r<e.length;++r)bee(e[r],a,n.concat(r))}function m6(e,t,n,a){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function X(e,t,n,a="numeric"){if(e instanceof Fe())return m6(a,e.dtype,t,n),e;let r=zm(e);if(r!=="string"&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),m6(a,r,t,n),e==null||!$r(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const s=su(e,r);!$r(e)&&!Array.isArray(e)&&(e=[e]);const o=r!=="string"?hd(e,r):ru(e,[],!0);return se.makeTensor(o,s,r)}function kw(e,t,n,a="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((s,i)=>X(s,`${t}[${i}]`,n,a))}const qz="__op";function oe(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+qz;const r=(...s)=>{se.startScope(n);try{const i=a(...s);return zh(i)&&console.error("Cannot return a Promise inside of tidy."),se.endScope(i),i}catch(i){throw se.endScope(null),i}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function _Ke(e,t){const n=X(e,"real","complex"),a=X(t,"imag","complex");Zr(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);const r={real:n,imag:a};return se.runKernel(HC,r)}const nc=oe({complex_:_Ke});function dd(e,t,n,a){if(a==null)a=zm(e);else if(a==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(fee(e)||pee(e)){if(a!=="float32"&&a!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return se.backend.createTensorFromGPUData(e,t||n,a)}if(!$r(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){zi(t);const r=_e(t),s=_e(n);q(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let i=0;i<n.length;++i){const o=n[i],l=i===n.length-1?o!==_e(t.slice(i)):!0;q(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!$r(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=a!=="string"?hd(e,a):ru(e,[],!0),se.makeTensor(e,t,a)}function Lo(e,t,n){const a=su(e,n);return dd(e,t,a,n)}const Gp={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Sl{static join(t){return new Sl(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(a=>$r(a)?a.buffer:a),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let a=0;a<t.length;a++){const r=t[a];a!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=n+r.byteLength;this.shards.push({buffer:r,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const a=this.findShardForByte(t);if(a===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=n-t,s=new ArrayBuffer(r),i=new Uint8Array(s);let o=0;for(let l=a;l<this.shards.length;l++){const u=this.shards[l],h=t+o-u.start,p=o,g=Math.min(n,u.end)-u.start,y=new Uint8Array(u.buffer,h,g-h);if(i.set(y,p),o+=y.length,n<u.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const a=RKe(this.shards,n);return a===-1?-1:(this.previousShardIndex=a,this.previousShardIndex)}}function RKe(e,t){let n=0,a=e.length;for(;n<=a;){const r=Math.floor((a-n)/2)+n,s=t(e[r]);if(s===0)return r;s<0?a=r:n=r+1}return-1}function DKe(){Ie().set("PROD",!0)}function OKe(){Ie().set("DEBUG",!0)}function FKe(){Ie().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function MKe(e){Ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function xee(){se.disposeVariables()}function tl(){return se}function bO(){return se.memory()}function LKe(e){return se.profile(e)}function Se(e,t){return se.tidy(e,t)}function Yt(e){Gz(e).forEach(n=>n.dispose())}function dr(e){return se.keep(e)}function zKe(e){return se.time(e)}function BKe(e){return se.setBackend(e)}function vee(){return se.ready()}function wee(){return se.backendName}function PKe(e){se.removeBackend(e)}function VKe(e){return se.findBackend(e)}function UKe(e){return se.findBackendFactory(e)}function Kz(e,t,n=1){return se.registerBackend(e,t,n)}function Xz(){return se.backend}function WKe(e,t){Ie().setPlatform(e,t)}const Bh=4;async function xO(e,t){const n=[],a=[],r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){const o=r[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const p=await l.bytes(),m=p.reduce((b,v)=>b+v.length,0)+Bh*p.length,g=new Uint8Array(m);let y=0;for(let b=0;b<p.length;b++){const v=p[b],w=new Uint8Array(new Uint32Array([v.length]).buffer);g.set(w,y),y+=Bh,g.set(v,y),y+=v.length}h(g)});a.push(c)}else a.push(l.data());t!=null&&(u.group=t),n.push(u)}const s=await Promise.all(a);return{data:jKe(s),specs:n}}function Aee(e,t){const n=new Sl(e),a={};let r=0;for(const s of t){const i=GKe(s,(o,l)=>n.slice(r+o,r+l));a[s.name]=See(s,n.slice(r,r+i)),r+=i}return a}function GKe(e,t){const n=_e(e.shape);let a;if("quantization"in e){const r=e.quantization;a=Gp[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=Bh+new Uint32Array(t(r,r+Bh))[0];return r}else a=Gp[e.dtype];return n*a}async function HKe(e,t){const n=_e(e.shape);let a;if("quantization"in e){const r=e.quantization;a=Gp[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=Bh+new Uint32Array(await t(r,r+Bh))[0];return r}else a=Gp[e.dtype];return n*a}function See(e,t){const n=e.name,a=e.dtype,r=e.shape,s=_e(r);let i,o=0;if("quantization"in e){const l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=Gp[l.dtype],c=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(a==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let h=0;h<c.length;h++){const p=c[h];i[h]=p*l.scale+l.min}}else if(l.dtype==="float16")i=ZKe()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(a==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let h=0;h<c.length;h++){const p=c[h];i[h]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*u}else if(a==="string"){const l=_e(e.shape);i=[];for(let u=0;u<l;u++){const c=new Uint32Array(t.slice(o,o+Bh))[0];o+=Bh;const h=new Uint8Array(t.slice(o,o+c));i.push(h),o+=c}}else{const l=Gp[a];if(a==="float32")i=new Float32Array(t);else if(a==="int32")i=new Int32Array(t);else if(a==="bool")i=new Uint8Array(t);else if(a==="complex64"){i=new Float32Array(t);const u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let g=0;g<u.length;g++)u[g]=i[g*2],c[g]=i[g*2+1];const h=Lo(u,r,"float32"),p=Lo(c,r,"float32"),m=nc(h,p);return h.dispose(),p.dispose(),m}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*l}return Lo(i,r,a)}async function g6(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){const{done:r,value:s}=await e.read();if(r&&s==null){const o=n-a.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const i=new Uint8Array(a.length+s.byteLength);i.set(a,0),i.set(new Uint8Array(s),a.length),a=i}return a.buffer}async function kee(e,t){const n={},a=e.getReader();let r=new ArrayBuffer(0);for(const s of t){const i=await HKe(s,async(u,c)=>(r=await g6(a,r,c),r.slice(u,c)));r=await g6(a,r,i);const o=r.slice(0,i);r=r.slice(i);const l=See(s,o);if(n[s.name]=l,wee()==="webgpu"){const u=Xz();"uploadToGPU"in u&&_e(l.shape)>=Ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function jKe(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const a=new Uint8Array(t);let r=0;return n.forEach(s=>{a.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),a.buffer}const Yz=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function y6(e){return Yz?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function qKe(e){if(Yz)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}function KKe(e){if(Yz){const a=Buffer.from(e,"base64");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}function Iee(e){return Sl.join(e)}function b6(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const n=e.split("/");return n[n.length-1]}function Nee(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function Qz(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),a}async function Zz(e,t){let n,a;return e.weightsManifest!=null&&([n,a]=await t(e.weightsManifest)),Qz(e,n,a)}function XA(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:y6(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:y6(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Sl(e.weightData).byteLength}}function DN(e){const t=[];for(const n of e)t.push(...n.weights);return t}function XKe(){const e=n=>{let a=n<<13,r=0;for(;(a&8388608)===0;)r-=8388608,a<<=1;return a&=-8388609,r+=947912704,a|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function YKe(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function QKe(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function ZKe(){const e=XKe(),t=YKe(),n=QKe();return a=>{const r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){const o=a[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(r)}}class va{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return va.instance==null&&(va.instance=new va),va.instance}static registerSaveRouter(t){va.getInstance().saveRouters.push(t)}static registerLoadRouter(t){va.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return va.getHandlers(t,"save")}static getLoadHandlers(t,n){return va.getHandlers(t,"load",n)}static getHandlers(t,n,a){const r=[];return(n==="load"?va.getInstance().loadRouters:va.getInstance().saveRouters).forEach(i=>{const o=i(t,a);o!==null&&r.push(o)}),r}}const JKe=e=>va.registerSaveRouter(e),eXe=e=>va.registerLoadRouter(e),Cee=e=>va.getSaveHandlers(e),tXe=(e,t)=>va.getLoadHandlers(e,t);const vO="tensorflowjs",wO=1,hp="models_store",dh="model_info_store";function Tee(){if(!Ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function AO(e){const t=e.result;t.createObjectStore(hp,{keyPath:"modelPath"}),t.createObjectStore(dh,{keyPath:"modelPath"})}class Hp{constructor(t){if(this.indexedDB=Tee(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((a,r)=>{const s=this.indexedDB.open(vO,wO);s.onupgradeneeded=()=>AO(s),s.onsuccess=()=>{const i=s.result;if(n==null){const o=i.transaction(hp,"readonly"),u=o.objectStore(hp).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));a(u.result.modelArtifacts)},u.onerror=c=>(i.close(),r(u.error)),o.oncomplete=()=>i.close()}else{n.weightData=Sl.join(n.weightData);const o=XA(n),l=i.transaction(dh,"readwrite");let u=l.objectStore(dh),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(p){return r(p)}let h;c.onsuccess=()=>{h=i.transaction(hp,"readwrite");const p=h.objectStore(hp);let m;try{m=p.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(g){return r(g)}m.onsuccess=()=>a({modelArtifactsInfo:o}),m.onerror=g=>{u=l.objectStore(dh);const y=u.delete(this.modelPath);y.onsuccess=()=>(i.close(),r(m.error)),y.onerror=b=>(i.close(),r(m.error))}},c.onerror=p=>(i.close(),r(c.error)),l.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},s.onerror=i=>r(s.error)})}}Hp.URL_SCHEME="indexeddb://";const Eee=e=>Ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hp.URL_SCHEME)?nXe(e.slice(Hp.URL_SCHEME.length)):null;va.registerSaveRouter(Eee);va.registerLoadRouter(Eee);function nXe(e){return new Hp(e)}function aXe(e){return e.startsWith(Hp.URL_SCHEME)?e.slice(Hp.URL_SCHEME.length):e}class rXe{constructor(){this.indexedDB=Tee()}async listModels(){return new Promise((t,n)=>{const a=this.indexedDB.open(vO,wO);a.onupgradeneeded=()=>AO(a),a.onsuccess=()=>{const r=a.result,s=r.transaction(dh,"readonly"),o=s.objectStore(dh).getAll();o.onsuccess=()=>{const l={};for(const u of o.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},o.onerror=l=>(r.close(),n(o.error)),s.oncomplete=()=>r.close()},a.onerror=r=>n(a.error)})}async removeModel(t){return t=aXe(t),new Promise((n,a)=>{const r=this.indexedDB.open(vO,wO);r.onupgradeneeded=()=>AO(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(dh,"readwrite"),o=i.objectStore(dh),l=o.get(t);let u;l.onsuccess=()=>{if(l.result==null)return s.close(),a(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const c=o.delete(t),h=()=>{u=s.transaction(hp,"readwrite");const m=u.objectStore(hp).delete(t);m.onsuccess=()=>n(l.result.modelArtifactsInfo),m.onerror=g=>a(l.error)};c.onsuccess=h,c.onerror=p=>(h(),s.close(),a(l.error))}},l.onerror=c=>(s.close(),a(l.error)),i.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},r.onerror=s=>a(r.error)})}}const ju="/",Xg="tensorflowjs_models",$ee="info",sXe="model_topology",iXe="weight_specs",oXe="weight_data",lXe="model_metadata";function _ee(e){return{info:[Xg,e,$ee].join(ju),topology:[Xg,e,sXe].join(ju),weightSpecs:[Xg,e,iXe].join(ju),weightData:[Xg,e,oXe].join(ju),modelMetadata:[Xg,e,lXe].join(ju)}}function Ree(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function uXe(e){const t=e.split(ju);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(ju)}function cXe(e){return e.startsWith(jp.URL_SCHEME)?e.slice(jp.URL_SCHEME.length):e}class jp{constructor(t){if(!Ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=_ee(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),a=JSON.stringify(t.weightSpecs),r=XA(t),s=Sl.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,qKe(s));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw Ree(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},a=JSON.parse(this.LS.getItem(this.keys.topology));if(a==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=a;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const o=JSON.parse(s);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=KKe(i),n}}jp.URL_SCHEME="localstorage://";const Dee=e=>Ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(jp.URL_SCHEME)?hXe(e.slice(jp.URL_SCHEME.length)):null;va.registerSaveRouter(Dee);va.registerLoadRouter(Dee);function hXe(e){return new jp(e)}class dXe{constructor(){q(Ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),q(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=Xg+ju,a=ju+$ee;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(n)&&s.endsWith(a)){const i=uXe(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t}async removeModel(t){t=cXe(t);const n=_ee(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const a=JSON.parse(this.LS.getItem(n.info));return Ree(n),a}}const ay="://";class vs{constructor(){this.managers={}}static getInstance(){return vs.instance==null&&(vs.instance=new vs),vs.instance}static registerManager(t,n){q(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(ay)&&(t=t.slice(0,t.indexOf(ay))),q(t.length>0,()=>"scheme must not be an empty string.");const a=vs.getInstance();q(a.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=n}static getManager(t){const n=vs.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(vs.getInstance().managers)}}function MI(e){if(e.indexOf(ay)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${vs.getSchemes().join(",")}`);return{scheme:e.split(ay)[0],path:e.split(ay)[1]}}async function Oee(e,t,n=!1){q(e!==t,()=>`Old path and new path are the same: '${e}'`);const a=va.getLoadHandlers(e);q(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),q(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);const r=a[0],s=va.getSaveHandlers(t);q(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),q(s.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);const i=s[0],o=MI(e).scheme,l=MI(e).path,u=o===MI(e).scheme,c=await r.load();n&&u&&await vs.getManager(o).removeModel(l);const h=await i.save(c);return n&&!u&&await vs.getManager(o).removeModel(l),h.modelArtifactsInfo}async function pXe(){const e=vs.getSchemes(),t={};for(const n of e){const a=await vs.getManager(n).listModels();for(const r in a){const s=n+ay+r;t[s]=a[r]}}return t}async function fXe(e){const t=MI(e);return vs.getManager(t.scheme).removeModel(t.path)}async function mXe(e,t){return Oee(e,t,!1)}async function gXe(e,t){return Oee(e,t,!0)}class yXe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!Ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",a=>{if(a.source===window&&a.data.name===this.messageName){a.stopPropagation();const r=this.functionRefs[a.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return iee(t)}}if(Ie().get("IS_BROWSER")){Ie().setPlatform("browser",new yXe);try{vs.registerManager(jp.URL_SCHEME,new dXe)}catch{}try{vs.registerManager(Hp.URL_SCHEME,new rXe)}catch{}}const bXe={importFetch:()=>require("node-fetch")};let OR;class xXe{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return Ie().global.fetch!=null?Ie().global.fetch(t,n):(OR==null&&(OR=bXe.importFetch()),OR(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}Ie().get("IS_NODE")&&!Ie().get("IS_BROWSER")&&Ie().setPlatform("node",new xXe);function Gt(e,t="float32",n){return t=t||"float32",zi(e),new er(e,t,n)}function vXe(e,t){const n=X(e,"x","cast");if(!YJ(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return se.runKernel(xx,a,r)}const Xe=oe({cast_:vXe});function wXe(e){const n={x:X(e,"x","clone","string_or_numeric")};return se.runKernel(Rx,n)}const Yl=oe({clone_:wXe});function Jz(e,t=!1){console.log(e.toString(t))}yee();const AXe={buffer:Gt,cast:Xe,clone:Yl,print:Jz};wKe(AXe);function SXe(e,t){let n=X(e,"a","add"),a=X(t,"b","add");[n,a]=Ta(n,a);const r={a:n,b:a};return se.runKernel(Pm,r)}const Ue=oe({add_:SXe});function kXe(e,t){let n=X(e,"a","floorDiv"),a=X(t,"b","floorDiv");[n,a]=Ta(n,a);const r={a:n,b:a};return se.runKernel($x,r)}const jT=oe({floorDiv_:kXe});function IXe(e,t){let n=X(e,"a","div"),a=X(t,"b","div");if([n,a]=Ta(n,a),n.dtype==="int32"&&a.dtype==="int32")return jT(n,a);const r={a:n,b:a},s={};return se.runKernel(kx,r,s)}const gt=oe({div_:IXe});function NXe(e,t){let n=X(e,"a","mul"),a=X(t,"b","mul");[n,a]=Ta(n,a);const r={a:n,b:a};return se.runKernel(Vx,r)}const he=oe({mul_:NXe});function CXe(e){const t=X(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return se.runKernel(eA,n)}else{const n={x:t};return se.runKernel(H1,n)}}const Xa=oe({abs_:CXe});function TXe(e){const n={x:X(e,"x","acos")};return se.runKernel(dx,n)}const eB=oe({acos_:TXe});function EXe(e){const n={x:X(e,"x","acosh")};return se.runKernel(px,n)}const tB=oe({acosh_:EXe});function $Xe(e){q(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),q(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((r,s)=>X(r,`tensors${s}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!tn(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const a=t;return se.runKernel(j1,a)}const Fee=oe({addN_:$Xe});function _Xe(e,t=null,n=!1){const r={x:X(e,"x","all","bool")},s={axis:t,keepDims:n};return se.runKernel(BC,r,s)}const qT=oe({all_:_Xe});function RXe(e,t=null,n=!1){const r={x:X(e,"x","any","bool")},s={axis:t,keepDims:n};return se.runKernel(PC,r,s)}const Iw=oe({any_:RXe});function DXe(e,t=0){const a={x:X(e,"x","argMax")},r={axis:t};return se.runKernel(q1,a,r)}const qp=oe({argMax_:DXe});function OXe(e,t=0){const a={x:X(e,"x","argMin")},r={axis:t};return se.runKernel(K1,a,r)}const nB=oe({argMin_:OXe});function FXe(e){const n={x:X(e,"x","asin")};return se.runKernel(fx,n)}const aB=oe({asin_:FXe});function MXe(e){const n={x:X(e,"x","asinh")};return se.runKernel(mx,n)}const rB=oe({asinh_:MXe});function LXe(e){const n={x:X(e,"x","atan")};return se.runKernel(gx,n)}const sB=oe({atan_:LXe});function zXe(e,t){let n=X(e,"a","atan2"),a=X(t,"b","atan2");[n,a]=Ta(n,a);const r={a:n,b:a};return se.runKernel(bx,r)}const iB=oe({atan2_:zXe});function BXe(e){const n={x:X(e,"x","atanh")};return se.runKernel(yx,n)}const oB=oe({atanh_:BXe});function YA(e,t,n,a,r="NHWC",s){const i=e[3],o=[...t,i],l=bc(r);return Br(e,o,n,s,a,null,null,l)}function Wo(e,t,n,a,r,s,i="channelsLast"){const[o,l]=Nw(t);let u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Br(e,u,n,a,r,s,!1,i)}function yc(e,t,n,a,r,s,i="NDHWC"){const[o,l,u]=SO(t);let c,h;if(i==="NDHWC")h="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")h="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return pd(e,c,n,a,r,!1,h,s)}function Br(e,t,n,a,r,s,i=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,h]=e;else if(o==="channelsFirst")[l,h,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);const[p,m,,g]=t,[y,b]=Nw(n),[v,w]=Nw(a),S=ry(p,v),k=ry(m,w),{padInfo:I,outHeight:T,outWidth:E}=UXe(r,u,c,y,b,S,k,s,o),R=i?g*h:g;let D;return o==="channelsFirst"?D=[l,R,T,E]:o==="channelsLast"&&(D=[l,T,E,R]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:T,outWidth:E,outChannels:R,padInfo:I,strideHeight:y,strideWidth:b,filterHeight:p,filterWidth:m,effectiveFilterHeight:S,effectiveFilterWidth:k,dilationHeight:v,dilationWidth:w,inShape:e,outShape:D,filterShape:t}}function pd(e,t,n,a,r,s=!1,i="channelsLast",o){let[l,u,c,h,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,h,p]=e;else if(i==="channelsFirst")[l,p,u,c,h]=e;else throw new Error(`Unknown dataFormat ${i}`);const[m,g,y,,b]=t,[v,w,S]=SO(n),[k,I,T]=SO(a),E=ry(m,k),R=ry(g,I),D=ry(y,T),{padInfo:O,outDepth:$,outHeight:_,outWidth:P}=WXe(r,u,c,h,v,w,S,E,R,D,o),U=s?b*p:b;let W;return i==="channelsFirst"?W=[l,U,$,_,P]:i==="channelsLast"&&(W=[l,$,_,P,U]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:p,outDepth:$,outHeight:_,outWidth:P,outChannels:U,padInfo:O,strideDepth:v,strideHeight:w,strideWidth:S,filterDepth:m,filterHeight:g,filterWidth:y,effectiveFilterDepth:E,effectiveFilterHeight:R,effectiveFilterWidth:D,dilationDepth:k,dilationHeight:I,dilationWidth:T,inShape:e,outShape:W,filterShape:t}}function PXe(e,t,n,a,r){a==null&&(a=lB(e,t,n));const s=e[0],i=e[1],o=Cw((s-t+2*a)/n+1,r),l=Cw((i-t+2*a)/n+1,r);return[o,l]}function VXe(e,t,n,a,r,s){r==null&&(r=lB(e,t[0],a[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=Cw((e[o]-t[o]+2*r)/a[o]+1,s));return i}function lB(e,t,n,a=1){const r=ry(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function Nw(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function SO(e){return typeof e=="number"?[e,e,e]:e}function ry(e,t){return t<=1?e:e+(e-1)*(t-1)}function UXe(e,t,n,a,r,s,i,o,l){let u,c,h;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const m=PXe([t,n],s,a,e,o);c=m[0],h=m[1]}else if(e==="same"){c=Math.ceil(t/a),h=Math.ceil(n/r);const p=Math.max(0,(c-1)*a+s-t),m=Math.max(0,(h-1)*r+i-n),g=Math.floor(p/2),y=p-g,b=Math.floor(m/2),v=m-b;u={top:g,bottom:y,left:b,right:v,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/a),h=Math.ceil((n-i+1)/r);else if(typeof e=="object"){const p=l==="channelsLast"?e[1][0]:e[2][0],m=l==="channelsLast"?e[1][1]:e[2][1],g=l==="channelsLast"?e[2][0]:e[3][0],y=l==="channelsLast"?e[2][1]:e[3][1];u={top:p,bottom:m,left:g,right:y,type:p===0&&m===0&&g===0&&y===0?"VALID":"EXPLICIT"},c=Cw((t-s+p+m)/a+1,o),h=Cw((n-i+g+y)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:h}}function WXe(e,t,n,a,r,s,i,o,l,u,c){let h,p,m,g;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const b=VXe([t,n,a,1],[o,l,u],1,[r,s,i],e,c);p=b[0],m=b[1],g=b[2]}else if(e==="same"){p=Math.ceil(t/r),m=Math.ceil(n/s),g=Math.ceil(a/i);const y=(p-1)*r+o-t,b=(m-1)*s+l-n,v=(g-1)*i+u-a,w=Math.floor(y/2),S=y-w,k=Math.floor(b/2),I=b-k,T=Math.floor(v/2),E=v-T;h={top:k,bottom:I,left:T,right:E,front:w,back:S,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:p,outHeight:m,outWidth:g}}function Cw(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ph(e){const[t,n,a]=Nw(e);return t===1&&n===1&&a===1}function Jr(e,t){return Ph(e)||Ph(t)}function Kp(e){return Nw(e).every(t=>t>0)}function bc(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Ls(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")q(Wp(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(a=>{a.forEach(r=>{q(Wp(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function GXe(e,t){const a={x:X(e,"x","reshape","string_or_numeric")},r={shape:t};return se.runKernel(OA,a,r)}const me=oe({reshape_:GXe});function HXe(e,t,n,a,r){const s=X(e,"x","avgPool","float32"),i=1;q(Jr(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=me(s,[1,s.shape[0],s.shape[1],s.shape[2]])),q(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Ls("avgPool",a,r);const u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let h=se.runKernel(X1,u,c);return h=Xe(h,s.dtype),l?me(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const QA=oe({avgPool_:HXe});function jXe(e,t,n,a,r,s="NDHWC"){const i=X(e,"x","avgPool3d","float32");let o=i,l=!1;i.rank===4&&(l=!0,o=me(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),q(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),q(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),q(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Ls("avgPool3d",a,r);const u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s};let h=se.runKernel(Y1,u,c);return h=Xe(h,o.dtype),l?me(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const uB=oe({avgPool3d_:jXe});function qXe(e,t=0){q(e.length>=1,()=>"Pass at least one tensor to concat");const n=kw(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return Yl(n[0]);const a=n,r={axis:t};return se.runKernel(tA,a,r)}const za=oe({concat_:qXe});function KXe(e,t,n=!1,a=!1){let r=X(e,"a","matMul"),s=X(t,"b","matMul");[r,s]=Ta(r,s);const i={a:r,b:s},o={transposeA:n,transposeB:a};return se.runKernel(Q1,i,o)}const Kt=oe({matMul_:KXe});function XXe(e){const n={x:X(e,"x","sigmoid","float32")};return se.runKernel(Zx,n)}const cl=oe({sigmoid_:XXe});function YXe(e,t,n){const a=X(e,"x","slice","string_or_numeric");if(a.rank===0)throw new Error("Slicing scalar is not possible");const r={x:a},s={begin:t,size:n};return se.runKernel(BA,r,s)}const ln=oe({slice_:YXe});function QXe(e){const n={x:X(e,"x","tanh","float32")};return se.runKernel(r0,n)}const Vh=oe({tanh_:QXe});function ZXe(e,t,n,a,r,s){const i=X(e,"forgetBias","basicLSTMCell"),o=X(t,"lstmKernel","basicLSTMCell"),l=X(n,"lstmBias","basicLSTMCell"),u=X(a,"data","basicLSTMCell"),c=X(r,"c","basicLSTMCell"),h=X(s,"h","basicLSTMCell"),p=za([u,h],1),m=Kt(p,o),g=Ue(m,l),y=g.shape[0],b=g.shape[1]/4,v=[y,b],w=ln(g,[0,0],v),S=ln(g,[0,b],v),k=ln(g,[0,b*2],v),I=ln(g,[0,b*3],v),T=Ue(he(cl(w),Vh(S)),he(c,cl(Ue(i,k)))),E=he(Vh(T),cl(I));return[T,E]}const Mee=oe({basicLSTMCell_:ZXe});function JXe(e,t,n){const a=X(e,"x","batchToSpaceND"),r=t.reduce((o,l)=>o*l);q(a.rank>=1+t.length,()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`),q(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),q(a.shape[0]%r===0,()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const s={x:a},i={blockShape:t,crops:n};return se.runKernel(Z1,s,i)}const ZA=oe({batchToSpaceND_:JXe});function e7e(e){let t;return e.rank===0||e.rank===1?t=me(e,[1,1,1,e.size]):e.rank===2?t=me(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=me(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function t7e(e,t,n,a,r,s){s==null&&(s=.001);const i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm");let u;r!=null&&(u=X(r,"scale","batchNorm"));let c;a!=null&&(c=X(a,"offset","batchNorm")),q(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:e7e(i),scale:u,offset:c,mean:o,variance:l},m={varianceEpsilon:s},g=se.runKernel(cA,p,m);return me(g,i.shape)}const o0=oe({batchNorm_:t7e});function n7e(e,t,n,a,r,s){const i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm");let u;r!=null&&(u=X(r,"scale","batchNorm"));let c;return a!=null&&(c=X(a,"offset","batchNorm")),q(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),q(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),q(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),o0(i,o,l,c,u,s)}const cB=oe({batchNorm2d_:n7e});function a7e(e,t,n,a,r,s){const i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm");let u;r!=null&&(u=X(r,"scale","batchNorm"));let c;return a!=null&&(c=X(a,"offset","batchNorm")),q(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),q(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),q(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),o0(i,o,l,c,u,s)}const hB=oe({batchNorm3d_:a7e});function r7e(e,t,n,a,r,s){const i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm");let u;r!=null&&(u=X(r,"scale","batchNorm"));let c;return a!=null&&(c=X(a,"offset","batchNorm")),q(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),q(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),q(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),o0(i,o,l,c,u,s)}const dB=oe({batchNorm4d_:r7e});function s7e(e,t,n){const a=X(e,"x","bincount"),r=X(t,"weights","bincount");q(a.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`),q(n>=0,()=>`size must be non-negative, but got ${n}.`),q(r.size===a.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);const s={x:a,weights:r},i={size:n};return se.runKernel(WC,s,i)}const pB=oe({bincount_:s7e});function i7e(e,t){const n=X(e,"x","bitwiseAnd"),a=X(t,"y","bitwiseAnd");if(!tn(n.shape,a.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);if(n.dtype!=="int32"||a.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);const r={a:n,b:a};return se.runKernel(J1,r)}const Lee=oe({bitwiseAnd_:i7e});function o7e(e,t){const n=X(e,"s0","broadcastArgs","int32"),a=X(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(a.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);const r={s0:n,s1:a};return se.runKernel(GC,r)}const zee=oe({broadcastArgs_:o7e});function l7e(e,t){let n=X(e,"broadcastTo","x");const a=n.shape;if(zi(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=me(n,u)}const r=n.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(r[u]===t[u])s[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Yl(n);const o={x:n},l={reps:s};return se.runKernel(s0,o,l)}const xp=oe({broadcastTo_:l7e});function u7e(e){const n={x:X(e,"x","ceil","float32")};return se.runKernel(vx,n)}const fB=oe({ceil_:u7e});function Vm(e,t,n){zi(e),n=n||zm(t);const a={shape:e,value:t,dtype:n};return se.runKernel(iT,{},a)}function c7e(e,t,n){const a=X(e,"x","clipByValue");if(q(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Vm(a.shape,t,a.dtype);const r={x:a},s={clipValueMin:t,clipValueMax:n};return se.runKernel(wx,r,s)}const ni=oe({clipByValue_:c7e});function h7e(e){return za(e,0)}const mB=oe({concat1d_:h7e});function d7e(e,t){return za(e,t)}const gB=oe({concat2d_:d7e});function p7e(e,t){return za(e,t)}const yB=oe({concat3d_:p7e});function f7e(e,t){return za(e,t)}const bB=oe({concat4d_:f7e});function m7e(e,t,n,a,r="NHWC",s=[1,1],i){const o=X(e,"x","conv2d","float32"),l=X(t,"filter","conv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=me(o,[1,o.shape[0],o.shape[1],o.shape[2]])),q(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),q(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Ls("conv2d",a,i);const h=r==="NHWC"?u.shape[3]:u.shape[1];q(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),q(Jr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),q(Kp(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),q(Kp(n),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:u,filter:l},m={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},g=se.runKernel(nA,p,m);return c?me(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const ac=oe({conv2d_:m7e});function g7e(e,t,n,a,r="NWC",s=1,i){const o=X(e,"x","conv1d"),l=X(t,"filter","conv1d");let u=o,c=!1;o.rank===2&&(c=!0,u=me(o,[1,o.shape[0],o.shape[1]])),q(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),q(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Ls("conv1d",a,i),q(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),q(Jr(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),q(Kp(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),q(Kp(n),()=>"Error in conv1D: Stride should be larger than 0."),q(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=me(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=me(u,[u.shape[0],1,u.shape[1],u.shape[2]]),b=ac(p,h,[1,n],a,"NHWC",[1,s],i);return c?me(b,[b.shape[2],b.shape[3]]):me(b,[b.shape[0],b.shape[2],b.shape[3]])}const KT=oe({conv1d_:g7e});function y7e(e,t,n,a,r,s="NHWC",i){q(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=me(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),q(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),q(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),q(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=s==="NHWC"?o[3]:o[1],h=s==="NHWC"?l.shape[3]:l.shape[1];q(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),q(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),Ls("conv2dDerInput",r,i);const p={dy:l,filter:n},m={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},g=se.runKernel(aA,p,m);return u?me(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const xB=oe({conv2DBackpropInput_:y7e});function b7e(e,t,n,a,r,s){const i=X(e,"x","conv2dTranspose"),o=X(t,"filter","conv2dTranspose");return xB(n,i,o,a,r,"NHWC",s)}const XT=oe({conv2dTranspose_:b7e});function x7e(e,t,n,a,r="NDHWC",s=[1,1,1]){const i=X(e,"x","conv3d"),o=X(t,"filter","conv3d");let l=i,u=!1;i.rank===4&&(u=!0,l=me(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),q(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),q(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),q(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),q(Jr(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),q(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),q(Kp(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),q(Kp(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:o},h={strides:n,pad:a,dataFormat:r,dilations:s},p=se.runKernel(rA,c,h);return u?me(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const vB=oe({conv3d_:x7e});function v7e(e,t,n,a,r){q(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=me(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const l=s[4],u=i.shape[4];q(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),q(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),q(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),q(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),q(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},h={pad:r,strides:a,inputShape:s},p=se.runKernel(KC,c,h);return o?me(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Bee=oe({conv3DBackpropInput_:v7e});function w7e(e,t,n,a,r){const s=X(e,"x","conv3dTranspose"),i=X(t,"filter","conv3dTranspose");return Bee(n,s,i,a,r)}const wB=oe({conv3dTranspose_:w7e});function A7e(e){const n={x:X(e,"x","cos","float32")};return se.runKernel(Ax,n)}const JA=oe({cos_:A7e});function S7e(e){const n={x:X(e,"x","cosh","float32")};return se.runKernel(Sx,n)}const YT=oe({cosh_:S7e});function k7e(e,t=0,n=!1,a=!1){const s={x:X(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:a};return se.runKernel(XC,s,i)}const Tw=oe({cumprod_:k7e});function I7e(e,t=0,n=!1,a=!1){const s={x:X(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:a};return se.runKernel(sA,s,i)}const QT=oe({cumsum_:I7e});function N7e(e,t,n,a=!1){const r=X(e,"x","denseBincount"),s=X(t,"weights","denseBincount");q(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),q(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),q(n>=0,()=>`size must be non-negative, but got ${n}.`),q(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);const i={x:r,weights:s},o={size:n,binaryOutput:a};return se.runKernel(QC,i,o)}const ON=oe({denseBincount_:N7e});function C7e(e,t,n="NHWC"){const a=X(e,"x","depthToSpace","float32"),r=n==="NHWC"?a.shape[1]:a.shape[2],s=n==="NHWC"?a.shape[2]:a.shape[3],i=n==="NHWC"?a.shape[3]:a.shape[1];q(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),q(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${a.shape}`),q(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${a.shape}`),q(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${a.shape}`);const o={x:a},l={blockSize:t,dataFormat:n};return se.runKernel(ZC,o,l)}const AB=oe({depthToSpace_:C7e});function T7e(e,t,n,a,r="NHWC",s=[1,1],i){const o=X(e,"x","depthwiseConv2d","float32"),l=X(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=me(o,[1,o.shape[0],o.shape[1],o.shape[2]])),q(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),q(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?u.shape[3]:u.shape[1];q(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Ls("depthwiseConv2d",a,i);const p={x:u,filter:l},m={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},g=se.runKernel(iA,p,m);return c?me(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const l0=oe({depthwiseConv2d_:T7e});function E7e(e){const n={x:X(e,"x","diag")};return se.runKernel(tT,n)}const Pee=oe({diag_:E7e});function $7e(e,t,n,a,r=[1,1],s="NHWC"){const i=X(e,"x","dilation2d"),o=X(t,"filter","dilation2d");q(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),q(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),q(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=me(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),q(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const c={x:l,filter:o},h={strides:n,pad:a,dilations:r},p=se.runKernel(oA,c,h);return u?me(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const SB=oe({dilation2d_:$7e});function Xp(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&i===1&&a.unshift(s)}return a}function nr(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],s=t.length-a-1,i=t[s];(r==null||r===1&&i>1)&&n.unshift(s)}return n}function Mt(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];s==null&&(s=1);let i=t[t.length-r-1];if(i==null&&(i=1),s===1)a[n-r-1]=i;else if(i===1)a[n-r-1]=s;else if(s!==i){const o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else a[n-r-1]=s}return a}const _7e=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Mt,getBroadcastDims:Xp,getReductionAxes:nr},Symbol.toStringTag,{value:"Module"}));function R7e(e,t){let n=X(e,"a","equal","string_or_numeric"),a=X(t,"b","equal","string_or_numeric");[n,a]=Ta(n,a),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(lA,r)}const Bo=oe({equal_:R7e});function D7e(e,t,n){const a=X(t,"a","where"),r=X(n,"b","where"),s=X(e,"condition","where","bool"),i=Mt(Mt(s.shape,a.shape),r.shape),o=xp(s,i),l=xp(a,i),u=xp(r,i),c={condition:o,t:l,e:u};return se.runKernel(zA,c)}const Xr=oe({where_:D7e});function O7e(e){const n={x:X(e,"x","zerosLike")};return se.runKernel(qA,n)}const cn=oe({zerosLike_:O7e});function F7e(e,t){let n=X(e,"a","div"),a=X(t,"b","div");[n,a]=Ta(n,a);const r=gt(n,a),s=cn(r),i=Bo(a,s);return Xr(i,s,r)}const kB=oe({divNoNan_:F7e});function M7e(e,t){const n=X(e,"t1","dot"),a=X(t,"t2","dot");q((n.rank===1||n.rank===2)&&(a.rank===1||a.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);const r=n.rank===1?n.size:n.shape[1],s=a.rank===1?a.size:a.shape[0];if(q(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),n.rank===1&&a.rank===1){const i=me(n,[1,-1]),o=me(a,[-1,1]),l=Kt(i,o);return me(l,[])}else if(n.rank===1&&a.rank===2){const i=me(n,[1,-1]),o=me(a,[a.shape[0],a.shape[1]]),l=Kt(i,o);return me(l,[l.size])}else if(n.rank===2&&a.rank===1){const i=me(a,[-1,1]),o=Kt(n,i);return me(o,[o.size])}else{const i=me(a,[a.shape[0],a.shape[1]]);return Kt(n,i)}}const IB=oe({dot_:M7e});function L7e(e,...t){const n=t.map((r,s)=>X(r,`tensors${s}`,"einsum")),a={equation:e};return se.runKernel(aT,n,a)}const sp=oe({einsum_:L7e});function z7e(e){const n={x:X(e,"x","elu","float32")};return se.runKernel(Ix,n)}const u0=oe({elu_:z7e});function B7e(e,t){const n=X(e,"x","ensureShape","string_or_numeric");if(!KJ(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}const Vee=oe({ensureShape_:B7e});function P7e(e){let t=X(e,"x","erf");q(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Xe(t,"float32"));const n={x:t};return se.runKernel(Nx,n)}const ZT=oe({erf_:P7e});function NB(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Uee(e,t,n){const a=e.length+t.length,r=[];let s=0,i=0;for(let o=0;o<a;o++)n.indexOf(o)===-1?r.push(e[s++]):r.push(t[i++]);return r}function Pr(e,t){const n=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&n.push(e[s]);const r=t.map(s=>e[s]);return[n,r]}function Ba(e,t){const n=t.map(a=>1);return Uee(e,n,t)}function es(e,t,n){q(NB(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function $a(e,t){if(NB(e,t))return null;const n=[];for(let a=0;a<t;++a)e.indexOf(a)===-1&&n.push(a);return e.forEach(a=>n.push(a)),n}function fd(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function Ua(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function V7e(e,t=null,n=!1){const r={x:X(e,"x","max")},s={reductionIndices:t,keepDims:n};return se.runKernel(vA,r,s)}const ao=oe({max_:V7e});function U7e(e,t=null,n=!1){const r={x:X(e,"x","min")},s={axis:t,keepDims:n};return se.runKernel(kA,r,s)}const Ty=oe({min_:U7e});function W7e(e,t){let n=X(e,"base","pow"),a=X(t,"exp","pow");[n,a]=Ta(n,a);const r={a:n,b:a};return se.runKernel(Ux,r)}const iu=oe({pow_:W7e});function kt(e,t){if(($r(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&$r(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return dd(e,[],[],t)}function G7e(e){const n={x:X(e,"x","sqrt","float32")};return se.runKernel(e0,n)}const Lr=oe({sqrt_:G7e});function H7e(e){const t=X(e,"x","square"),n={};return se.runKernel("Square",{x:t},n)}const Vn=oe({square_:H7e});function j7e(e,t=null,n=!1){let a=X(e,"x","sum");a.dtype==="bool"&&(a=Xe(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return se.runKernel(PA,r,s)}const ct=oe({sum_:j7e});function q7e(e,t="euclidean",n=null,a=!1){e=X(e,"x","norm");const r=Wee(e,t,n);let s=r.shape;if(a){const i=Zt(n,e.shape);s=Ba(r.shape,i)}return me(r,s)}function Wee(e,t,n=null){if(e.rank===0)return Xa(e);if(e.rank!==1&&n===null)return Wee(me(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ct(Xa(e),n);if(t===1/0)return ao(Xa(e),n);if(t===-1/0)return Ty(Xa(e),n);if(t==="euclidean"||t===2)return Lr(ct(iu(Xa(e),kt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ao(ct(Xa(e),n[0]),n[1]-1);if(t===1/0)return ao(ct(Xa(e),n[1]),n[0]);if(t===-1/0)return Ty(ct(Xa(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Lr(ct(Vn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const c0=oe({norm_:q7e});function K7e(e,t=null,n=!1){return c0(e,"euclidean",t,n)}const CB=oe({euclideanNorm_:K7e});function X7e(e){const n={x:X(e,"x","exp")};return se.runKernel(Cx,n)}const ai=oe({exp_:X7e});function Y7e(e,t=0){const n=X(e,"x","expandDims","string_or_numeric");q(t<=n.rank,()=>"Axis must be <= rank of the tensor");const a={input:n},r={dim:t};return se.runKernel(uA,a,r)}const us=oe({expandDims_:Y7e});function Q7e(e){const n={x:X(e,"x","expm1")};return se.runKernel(Tx,n)}const TB=oe({expm1_:Q7e});function Z7e(e,t){const n=X(e,"x","tile","string_or_numeric");q(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const a={x:n},r={reps:t};return se.runKernel(s0,a,r)}const Ji=oe({tile_:Z7e});function J7e(e,t,n,a="float32"){t==null&&(t=e);const r=Gt([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);const i=me(r.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Ji(us(i,0),[n[0],1,1]);if(n.length===2)return Ji(us(us(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ji(us(us(us(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const JT=oe({eye_:J7e});function e9e(e){const n={x:X(e,"x","floor","float32")};return se.runKernel(Ex,n)}const h0=oe({floor_:e9e});function t9e(e,t,n=0,a=0){const r=X(e,"x","gather"),s=X(t,"indices","gather","int32"),i={x:r,indices:s},o={axis:n,batchDims:a};return se.runKernel(hA,i,o)}const d0=oe({gather_:t9e});function n9e(e,t){let n=X(e,"a","greater","string_or_numeric"),a=X(t,"b","greater","string_or_numeric");[n,a]=Ta(n,a),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(dA,r)}const ii=oe({greater_:n9e});function a9e(e,t){let n=X(e,"a","greaterEqual","string_or_numeric"),a=X(t,"b","greaterEqual","string_or_numeric");[n,a]=Ta(n,a),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(_x,r)}const xc=oe({greaterEqual_:a9e});function r9e(e){const n={input:X(e,"input","imag")};return se.runKernel(cT,n)}const eS=oe({imag_:r9e});function s9e(e){const n={x:X(e,"x","isFinite")};return se.runKernel(Dx,n)}const EB=oe({isFinite_:s9e});function i9e(e){const n={x:X(e,"x","isInf")};return se.runKernel(Ox,n)}const $B=oe({isInf_:i9e});function o9e(e){const n={x:X(e,"x","isNaN")};return se.runKernel(Fx,n)}const _B=oe({isNaN_:o9e});function l9e(e,t=.2){const a={x:X(e,"x","leakyRelu")},r={alpha:t};return se.runKernel(pA,a,r)}const tS=oe({leakyRelu_:l9e});function u9e(e,t){let n=X(e,"a","less","string_or_numeric"),a=X(t,"b","less","string_or_numeric");[n,a]=Ta(n,a),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(fA,r)}const Ey=oe({less_:u9e});function c9e(e,t){let n=X(e,"a","lessEqual","string_or_numeric"),a=X(t,"b","lessEqual","string_or_numeric");[n,a]=Ta(n,a),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(mA,r)}const md=oe({lessEqual_:c9e});function Gee(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return se.runKernel(hT,{},a)}function h9e(e,t=5,n=1,a=1,r=.5){const s=X(e,"x","localResponseNormalization");q(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),q(Wp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=me(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:a,beta:r},c=se.runKernel(xA,l,u);return o?me(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const RB=oe({localResponseNormalization_:h9e});function d9e(e){const n={x:X(e,"x","log","float32")};return se.runKernel(Mx,n)}const Di=oe({log_:d9e});function p9e(e){const n={x:X(e,"x","log1p")};return se.runKernel(Lx,n)}const nS=oe({log1p_:p9e});function f9e(e){return q(Lh(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{const a=X(t,"x","tf.grad","string_or_numeric"),r=n!=null?X(n,"dy","tf.grad"):null;return se.tidy(()=>{const{value:s,grads:i}=se.gradients(()=>e(a),[a],r);return r!=null&&Zr(s.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),eE(i),i[0]})}}function m9e(e){return q(Lh(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{q(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const a=kw(t,"args","tf.grads","string_or_numeric"),r=n!=null?X(n,"dy","tf.grads"):null;return se.tidy(()=>{const{value:s,grads:i}=se.gradients(()=>e(...a),a,r);return r!=null&&Zr(s.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),eE(i),i})}}function g9e(e){return q(Lh(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{q(t instanceof In,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),q(n==null||n instanceof In,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:a,value:r}=se.gradients(()=>e(t),[t],n);return eE(a),{grad:a[0],value:r}}}function y9e(e){return q(Lh(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{q(Array.isArray(t)&&t.every(r=>r instanceof In),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),q(n==null||n instanceof In,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const a=se.gradients(()=>e(...t),t,n);return n!=null&&Zr(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),eE(a.grads),a}}function Hee(e,t){q(Lh(e),()=>"The f passed in variableGrads(f) must be a function"),q(t==null||Array.isArray(t)&&t.every(u=>u instanceof Sw),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const u in se.registeredVariables)t.push(se.registeredVariables[u])}const a=n?t.filter(u=>!u.trainable):null,r=t.length;t=t.filter(u=>u.trainable),q(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const s=!0,{value:i,grads:o}=se.gradients(e,t,null,s);q(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),q(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),a?.forEach(u=>l[u.name]=null),{value:i,grads:l}}function ou(e){return se.customGrad(e)}function eE(e){if(e.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function b9e(e){const n={x:X(e,"x","neg")};return se.runKernel(NA,n)}const ia=oe({neg_:b9e});function x9e(e){const n={x:X(e,"x","softplus")};return se.runKernel(Jx,n)}const Um=oe({softplus_:x9e});function v9e(e){const t=X(e,"x","logSigmoid");return ou(a=>({value:ia(Um(ia(a))),gradFunc:i=>he(i,cl(ia(a)))}))(t)}const DB=oe({logSigmoid_:v9e});function w9e(e,t){let n=X(e,"a","sub"),a=X(t,"b","sub");[n,a]=Ta(n,a);const r={a:n,b:a};return se.runKernel(n0,r)}const it=oe({sub_:w9e});function A9e(e,t=-1){const n=X(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return ou((r,s)=>{const o=ao(r,t,!0),l=it(r,o),u=it(Xe(l,"float32"),Di(ct(ai(l),t,!0)));return s([u]),{value:u,gradFunc:(h,p)=>{const[m]=p,g=!0,y=ai(m);return it(h,he(ct(h,t,g),y))}}})(n)}const tE=oe({logSoftmax_:A9e});function S9e(e,t=null,n=!1){const a=X(e,"x","logSumExp"),r=Zt(t,a.shape),s=ao(a,r,!0),i=it(a,s),o=ai(i),l=ct(o,r),u=Di(l),c=Ue(me(s,u.shape),u);if(n){const h=Ba(c.shape,r);return me(c,h)}return c}const aS=oe({logSumExp_:S9e});function k9e(e,t){const n=X(e,"a","logicalAnd","bool"),a=X(t,"b","logicalAnd","bool");Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(gA,r)}const yl=oe({logicalAnd_:k9e});function I9e(e){const n={x:X(e,"x","logicalNot","bool")};return se.runKernel(yA,n)}const rS=oe({logicalNot_:I9e});function N9e(e,t){const n=X(e,"a","logicalOr","bool"),a=X(t,"b","logicalOr","bool");Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(bA,r)}const nE=oe({logicalOr_:N9e});function C9e(e,t){const n=X(e,"a","logicalXor","bool"),a=X(t,"b","logicalXor","bool");return Mt(n.shape,a.shape),yl(nE(e,t),rS(yl(e,t)))}const OB=oe({logicalXor_:C9e});const lI=2147483648;function T9e(e,t,n="left"){const a=X(e,"sortedSequence","searchSorted"),r=X(t,"values","searchSorted"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=me(a,[-1,s]),l=me(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(_e(l.shape)>=lI)throw new Error(`values tensor size must less than ${lI}`);if(o.shape[1]>=lI)throw new Error(`trailing dim_size must less than ${lI} for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return se.runKernel(ET,u,c)}const aE=oe({searchSorted_:T9e});function jee(e,t){return aE(e,t,"left")}function E9e(e,t,n,a,r){const s=X(e,"x","maxPool"),i=1;let o=s,l=!1;s.rank===3&&(l=!0,o=me(s,[1,s.shape[0],s.shape[1],s.shape[2]])),q(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),q(Jr(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Ls("maxPool",a,r);const u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r},h=se.runKernel(wA,u,c);return l?me(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const sS=oe({maxPool_:E9e});function $9e(e,t=[1,1,1],n,a,r,s="NDHWC"){const i=X(e,"x","maxPool3d");let o=i,l=!1;i.rank===4&&(l=!0,o=me(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),q(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),q(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Ls("maxPool3d",a,r);const u={x:o},c={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=se.runKernel(AA,u,c);return l?me(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const FB=oe({maxPool3d_:$9e});function _9e(e,t,n,a,r=!1){const i={x:X(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},l=se.runKernel(mT,i,o);return{result:l[0],indexes:l[1]}}const qee=oe({maxPoolWithArgmax_:_9e});function R9e(e,t){let n=X(e,"a","maximum"),a=X(t,"b","maximum");[n,a]=Ta(n,a),n.dtype==="bool"&&(n=Xe(n,"int32"),a=Xe(a,"int32")),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(zx,r)}const mu=oe({maximum_:R9e});function D9e(e,t=null,n=!1){const r={x:X(e,"x","mean")},s={axis:t,keepDims:n};return se.runKernel(SA,r,s)}const Sa=oe({mean_:D9e});function Ya(e,t="float32"){if(zi(e),t==="complex64"){const a=Ya(e,"float32"),r=Ya(e,"float32");return nc(a,r)}const n=Yr(_e(e),t);return se.makeTensor(n,e,t)}function qs(e,t="float32"){if(zi(e),t==="complex64"){const a=qs(e,"float32"),r=Ya(e,"float32");return nc(a,r)}const n=zC(_e(e),t);return se.makeTensor(n,e,t)}function Kee(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let a=X(e,"x","meshgrid",e instanceof In?e.dtype:"float32");if(t===void 0)return[a];let r=X(t,"y","meshgrid",t instanceof In?t.dtype:"float32");const s=_e(a.shape),i=_e(r.shape);return n==="xy"?(a=me(a,[1,-1]),r=me(r,[-1,1]),[Kt(qs([i,1],a.dtype),a),Kt(r,qs([1,s],r.dtype))]):(a=me(a,[-1,1]),r=me(r,[1,-1]),[Kt(a,qs([1,i],a.dtype)),Kt(qs([s,1],r.dtype),r)])}function O9e(e,t){let n=X(e,"a","minimum"),a=X(t,"b","minimum");[n,a]=Ta(n,a),n.dtype==="bool"&&(n=Xe(n,"int32"),a=Xe(a,"int32")),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(Bx,r)}const Uh=oe({minimum_:O9e});function F9e(e,t,n){q(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const a=X(e,"x","mirrorPad");if(a.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");q(t.length===a.rank,()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);const r=n==="reflect"?1:0;for(let o=0;o<a.rank;o++)q(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),q(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${a.shape[o]-r} or less than 0 for input of shape ${a.shape}`);const s={paddings:t,mode:n},i={x:a};return se.runKernel(IA,i,s)}const MB=oe({mirrorPad_:F9e});function M9e(e,t){let n=X(e,"a","mod"),a=X(t,"b","mod");[n,a]=Ta(n,a);const r={a:n,b:a};return se.runKernel(Px,r)}const LB=oe({mod_:M9e});function L9e(e,t=null,n=!1){e=X(e,"x","moments");const a=Zt(t,e.shape),r=Sa(e,a,n);let s=r.shape;n||(s=Ba(r.shape,a));const i=Vn(it(Xe(e,"float32"),me(r,s))),o=Sa(i,a,n);return{mean:r,variance:o}}const iS=oe({moments_:L9e});function z9e(e,t,n,a){const r=X(t,"data","multiRNNCell"),s=kw(n,"c","multiRNNCell"),i=kw(a,"h","multiRNNCell");let o=r;const l=[];for(let h=0;h<e.length;h++){const p=e[h](o,s[h],i[h]);l.push(p[0]),l.push(p[1]),o=p[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const Xee=oe({multiRNNCell_:z9e});function B9e(e,t,n,a=!1){const r=X(e,"logits","multinomial"),s=r.size,i=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const l={logits:i===1?me(r,[1,-1]):r},u={numSamples:t,seed:n,normalized:a},c=se.runKernel(gT,l,u);return i===1?me(c,[c.size]):c}const Yee=oe({multinomial_:B9e});function P9e(e,t){let n=X(e,"a","notEqual","string_or_numeric"),a=X(t,"b","notEqual","string_or_numeric");[n,a]=Ta(n,a),Mt(n.shape,a.shape);const r={a:n,b:a};return se.runKernel(CA,r)}const Yp=oe({notEqual_:P9e});function V9e(e,t,n=1,a=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:X(e,"indices","oneHot","int32")},o={dtype:r,depth:t,onValue:n,offValue:a};return se.runKernel(EA,i,o)}const $y=oe({oneHot_:V9e});function U9e(e){const n={x:X(e,"x","onesLike")};return se.runKernel(TA,n)}const Oi=oe({onesLike_:U9e});function W9e(e,t){const n=X(e,"v1","outerProduct"),a=X(t,"v2","outerProduct");q(n.rank===1&&a.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);const r=me(n,[-1,1]),s=me(a,[1,-1]);return Kt(r,s)}const Qee=oe({outerProduct_:W9e});function G9e(e,t,n=0){const a=X(e,"x","pad");if(a.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},s={x:a};return se.runKernel(_A,s,r)}const vc=oe({pad_:G9e});function H9e(e,t,n=0){return q(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),vc(e,[t],n)}const Zee=oe({pad1d_:H9e});function j9e(e,t,n=0){return q(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vc(e,t,n)}const Jee=oe({pad2d_:j9e});function q9e(e,t,n=0){return q(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vc(e,t,n)}const ete=oe({pad3d_:q9e});function K9e(e,t,n=0){return q(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vc(e,t,n)}const tte=oe({pad4d_:K9e});function X9e(e,t,n){const a=X(e,"x","spaceToBatchND");q(a.rank>=1+t.length,()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`),q(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),q(a.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:a},s={blockShape:t,paddings:n};return se.runKernel(VA,r,s)}const oS=oe({spaceToBatchND_:X9e});function Y9e(e,t,n,a,r,s,i){r==null&&(r=[1,1]),s==null&&(s=1),a===0&&(a="valid");const o=X(e,"x","maxPool");let l=o,u=!1;o.rank===3&&(u=!0,l=me(o,[1,o.shape[0],o.shape[1],o.shape[2]])),q(Jr(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);const c=Wo(l.shape,t,s,r,a),h=[c.dilationHeight,c.dilationWidth];let p;a==="same"?p=Z9e([c.filterHeight,c.filterWidth],h):p=[[0,0],[0,0]];const m=h[0]===1&&h[1]===1,[g,y]=Q9e([c.inHeight,c.inWidth],h,p),b=m?a:"valid",v=m?l:oS(l,h,g),S=(n==="avg"?()=>QA(v,t,s,b,i):()=>sS(v,t,s,b,i))(),k=m?S:ZA(S,h,y);return u?me(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function Q9e(e,t,n){const a=n.map(c=>c[0]),r=n.map(c=>c[1]),s=e.concat(a,r),i=t.map((c,h)=>(c-s[h]%c)%c),o=r.map((c,h)=>c+i[h]),l=t.map((c,h)=>[a[h],o[h]]),u=t.map((c,h)=>[0,i[h]]);return[l,u]}function Z9e(e,t){const a=e.map((i,o)=>i+(i-1)*(t[o]-1)).map(i=>i-1),r=a.map(i=>Math.floor(i/2)),s=a.map((i,o)=>i-r[o]);return a.map((i,o)=>[r[o],s[o]])}const zB=oe({pool_:Y9e});function J9e(e,t){const n=X(e,"x","prelu"),a=X(t,"alpha","prelu"),r={x:n,alpha:a};return se.runKernel(RA,r)}const lS=oe({prelu_:J9e});function eYe(e,t=null,n=!1){let a=X(e,"x","prod");a.dtype==="bool"&&(a=Xe(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return se.runKernel(DA,r,s)}const BB=oe({prod_:eYe});function tYe(e,t,n,a){const r=e.map((c,h)=>X(c,`tensors${h}`,"raggedGather","int32")),s=X(t,"paramsDenseValues","raggedGather"),i=X(n,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:s,indices:i},l={outputRaggedRank:a},u=se.runKernel(vT,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const nte=oe({raggedGather_:tYe});function nYe(e,t,n){const a=X(e,"starts","raggedRange"),r=X(t,"limits","raggedRange",a.dtype),s=X(n,"deltas","raggedRange",a.dtype),i={starts:a,limits:r,deltas:s},o=se.runKernel(wT,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const ate=oe({raggedRange_:nYe});function aYe(e,t,n,a,r){const s=X(e,"shape","raggedTensorToTensor","int32"),i=X(t,"values","raggedTensorToTensor"),o=X(n,"defaultValue","raggedTensorToTensor",i.dtype),l=a.map((h,p)=>X(h,`tensors${p}`,"raggedTensorToTensor","int32")),u={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:r};return se.runKernel(AT,u,c)}const rte=oe({raggedTensorToTensor_:aYe});function rYe(e,t,n){zi(e);const a=_e(e);let r=null;if(n==null||n==="float32")r=new Float32Array(a);else if(n==="int32")r=new Int32Array(a);else if(n==="bool")r=new Uint8Array(a);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<a;s++)r[s]=t();return se.makeTensor(r,e,n)}const ste=oe({rand_:rYe});var LI={exports:{}},sYe=LI.exports,x6;function iYe(){return x6||(x6=1,(function(e){(function(t,n,a){function r(l){var u=this,c=o();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function s(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function i(l,u){var c=new r(l),h=u&&u.state,p=c.next;return p.int32=function(){return c.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&s(h,c),p.state=function(){return s(c,{})}),p}function o(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=i:this.alea=i})(sYe,e)})(LI)),LI.exports}var zI={exports:{}},oYe=zI.exports,v6;function lYe(){return v6||(v6=1,(function(e){(function(t,n,a){function r(o){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function s(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function i(o,l){var u=new r(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}n&&n.exports?n.exports=i:this.xor128=i})(oYe,e)})(zI)),zI.exports}var BI={exports:{}},uYe=BI.exports,w6;function cYe(){return w6||(w6=1,(function(e){(function(t,n,a){function r(o){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function s(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function i(o,l){var u=new r(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}n&&n.exports?n.exports=i:this.xorwow=i})(uYe,e)})(BI)),BI.exports}var PI={exports:{}},hYe=PI.exports,A6;function dYe(){return A6||(A6=1,(function(e){(function(t,n,a){function r(o){var l=this;l.next=function(){var c=l.x,h=l.i,p,m;return p=c[h],p^=p>>>7,m=p^p<<24,p=c[h+1&7],m^=p^p>>>10,p=c[h+3&7],m^=p^p>>>3,p=c[h+4&7],m^=p^p<<7,p=c[h+7&7],p=p^p<<13,m^=p^p<<9,c[h]=m,l.i=h+1&7,m};function u(c,h){var p,m=[];if(h===(h|0))m[0]=h;else for(h=""+h,p=0;p<h.length;++p)m[p&7]=m[p&7]<<15^h.charCodeAt(p)+m[p+1&7]<<13;for(;m.length<8;)m.push(0);for(p=0;p<8&&m[p]===0;++p);for(p==8?m[7]=-1:m[p],c.x=m,c.i=0,p=256;p>0;--p)c.next()}u(l,o)}function s(o,l){return l.x=o.x.slice(),l.i=o.i,l}function i(o,l){o==null&&(o=+new Date);var u=new r(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.x&&s(c,u),h.state=function(){return s(u,{})}),h}n&&n.exports?n.exports=i:this.xorshift7=i})(hYe,e)})(PI)),PI.exports}var VI={exports:{}},pYe=VI.exports,S6;function fYe(){return S6||(S6=1,(function(e){(function(t,n,a){function r(o){var l=this;l.next=function(){var c=l.w,h=l.X,p=l.i,m,g;return l.w=c=c+1640531527|0,g=h[p+34&127],m=h[p=p+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,g=h[p]=g^m,l.i=p,g+(c^c>>>16)|0};function u(c,h){var p,m,g,y,b,v=[],w=128;for(h===(h|0)?(m=h,h=null):(h=h+"\0",m=0,w=Math.max(w,h.length)),g=0,y=-32;y<w;++y)h&&(m^=h.charCodeAt((y+32)%h.length)),y===0&&(b=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,y>=0&&(b=b+1640531527|0,p=v[y&127]^=m+b,g=p==0?g+1:0);for(g>=128&&(v[(h&&h.length||0)&127]=-1),g=127,y=512;y>0;--y)m=v[g+34&127],p=v[g=g+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,v[g]=m^p;c.w=b,c.X=v,c.i=g}u(l,o)}function s(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function i(o,l){o==null&&(o=+new Date);var u=new r(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.X&&s(c,u),h.state=function(){return s(u,{})}),h}n&&n.exports?n.exports=i:this.xor4096=i})(pYe,e)})(VI)),VI.exports}var UI={exports:{}},mYe=UI.exports,k6;function gYe(){return k6||(k6=1,(function(e){(function(t,n,a){function r(o){var l=this,u="";l.next=function(){var h=l.b,p=l.c,m=l.d,g=l.a;return h=h<<25^h>>>7^p,p=p-m|0,m=m<<24^m>>>8^g,g=g-h|0,l.b=h=h<<20^h>>>12^p,l.c=p=p-m|0,l.d=m<<16^p>>>16^g,l.a=g-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):u+=o;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function s(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function i(o,l){var u=new r(o),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&s(c,u),h.state=function(){return s(u,{})}),h}n&&n.exports?n.exports=i:this.tychei=i})(mYe,e)})(UI)),UI.exports}var WI={exports:{}};const yYe={},bYe=Object.freeze(Object.defineProperty({__proto__:null,default:yYe},Symbol.toStringTag,{value:"Module"})),xYe=aF(bYe);var vYe=WI.exports,I6;function wYe(){return I6||(I6=1,(function(e){(function(t,n,a){var r=256,s=6,i=52,o="random",l=a.pow(r,s),u=a.pow(2,i),c=u*2,h=r-1,p;function m(k,I,T){var E=[];I=I==!0?{entropy:!0}:I||{};var R=v(b(I.entropy?[k,S(n)]:k??w(),3),E),D=new g(E),O=function(){for(var $=D.g(s),_=l,P=0;$<u;)$=($+P)*r,_*=r,P=D.g(1);for(;$>=c;)$/=2,_/=2,P>>>=1;return($+P)/_};return O.int32=function(){return D.g(4)|0},O.quick=function(){return D.g(4)/4294967296},O.double=O,v(S(D.S),n),(I.pass||T||function($,_,P,U){return U&&(U.S&&y(U,D),$.state=function(){return y(D,{})}),P?(a[o]=$,_):$})(O,R,"global"in I?I.global:this==a,I.state)}function g(k){var I,T=k.length,E=this,R=0,D=E.i=E.j=0,O=E.S=[];for(T||(k=[T++]);R<r;)O[R]=R++;for(R=0;R<r;R++)O[R]=O[D=h&D+k[R%T]+(I=O[R])],O[D]=I;(E.g=function($){for(var _,P=0,U=E.i,W=E.j,B=E.S;$--;)_=B[U=h&U+1],P=P*r+B[h&(B[U]=B[W=h&W+_])+(B[W]=_)];return E.i=U,E.j=W,P})(r)}function y(k,I){return I.i=k.i,I.j=k.j,I.S=k.S.slice(),I}function b(k,I){var T=[],E=typeof k,R;if(I&&E=="object")for(R in k)try{T.push(b(k[R],I-1))}catch{}return T.length?T:E=="string"?k:k+"\0"}function v(k,I){for(var T=k+"",E,R=0;R<T.length;)I[h&R]=h&(E^=I[h&R]*19)+T.charCodeAt(R++);return S(I)}function w(){try{var k;return p&&(k=p.randomBytes)?k=k(r):(k=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(k)),S(k)}catch{var I=t.navigator,T=I&&I.plugins;return[+new Date,t,T,t.screen,S(n)]}}function S(k){return String.fromCharCode.apply(0,k)}if(v(a.random(),n),e.exports){e.exports=m;try{p=xYe}catch{}}else a["seed"+o]=m})(typeof self<"u"?self:vYe,[],Math)})(WI)),WI.exports}var FR,N6;function AYe(){if(N6)return FR;N6=1;var e=iYe(),t=lYe(),n=cYe(),a=dYe(),r=fYe(),s=gYe(),i=wYe();return i.alea=e,i.xor128=t,i.xorwow=n,i.xorshift7=a,i.xor4096=r,i.tychei=s,FR=i,FR}var rE=AYe();const SYe=.001,ite=.1;function kYe(e,t,n){return n==null&&(n=PB()),kO(e,t,(a,r)=>VB(a,r,n))}function PB(){return se.backend.floatPrecision()===32?SYe:ite}function kO(e,t,n){let a=!0;if(($r(e)||$r(t))&&(a=!1),$r(e)&&$r(t)&&(a=!0),a){const i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){const i=su(e),o=su(t);if(!tn(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}const r=$r(e)?e:ru(e),s=$r(t)?t:ru(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.
Actual:   ${r}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){const o=r[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${r}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function IYe(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function NYe(e,t){const n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Gl(e)||Gl(e[0])||Gl(t)||Gl(t[0])?kO(e,n,(a,r)=>a==r):kO(e,t,(a,r)=>VB(a,r,0))}function CYe(e,t,n){if(n==null&&(n=PB()),!VB(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function VB(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function TYe(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function EYe(e,t){const n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`)}function ote(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?ote(n):e[t]=Xl(n)}return e}function $Ye(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",a=>n(t)),t.load()})}async function _Ye(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}const RYe=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:ite,createVideoElement:$Ye,encodeStrings:ote,expectArrayBuffersEqual:EYe,expectArraysClose:kYe,expectArraysEqual:NYe,expectNumbersClose:CYe,expectPromiseToFail:IYe,expectValuesInRange:TYe,play:_Ye,testEpsilon:PB},Symbol.toStringTag,{value:"Module"}));class UB{constructor(t,n,a,r,s){this.mean=t,this.stdDev=n,this.dtype=a,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=s||Math.random();this.random=rE.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,n,a=!1;for(;!a;){let r,s,i;do r=2*this.random()-1,s=2*this.random()-1,i=r*r+s*s;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*r*o,n=this.mean+this.stdDev*s*o,(!this.truncated||this.isValidTruncated(t))&&(a=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class DYe{constructor(t,n,a,r){this.alpha=t,this.beta=1/n,this.dtype=a;const s=r||Math.random();this.randu=rE.alea(s.toString()),this.randn=new UB(0,1,a,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,a,r,s,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,t=r*r,n=1-.331*t*t,a=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<n||Math.log(s)<a)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class OYe{constructor(t=0,n=1,a,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=a,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=rE.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function FYe(e,t,n=1,a="float32",r){if(zi(e),n==null&&(n=1),a==null&&(a="float32"),a!=="float32"&&a!=="int32")throw new Error(`Unsupported data type ${a}`);const s=new DYe(t,n,a,r),i=Gt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}const lte=oe({randomGamma_:FYe});function MYe(e,t=0,n=1,a,r){if(zi(e),a!=null&&a==="bool")throw new Error(`Unsupported data type ${a}`);const s=new UB(t,n,a,!1,r),i=Gt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}const sE=oe({randomNormal_:MYe});function LYe(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return sE(e,0,1,t,n)}const ute=oe({randomStandardNormal_:LYe});function zYe(e,t=0,n=1,a="float32",r){zi(e);const s=Gt(e,a),i=new OYe(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}const gd=oe({randomUniform_:zYe});function BYe(e,t,n,a){return gd(e,t,n,"int32",a)}const cte=oe({randomUniformInt_:BYe});function Qp(e,t,n=1,a="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return se.runKernel(ST,{},r)}function PYe(e){const n={input:X(e,"input","real")};return se.runKernel(kT,n)}const _y=oe({real_:PYe});function VYe(e){const n={x:X(e,"x","reciprocal")};return se.runKernel(Wx,n)}const WB=oe({reciprocal_:VYe});function UYe(e){const n={x:X(e,"x","relu")};return se.runKernel(Gx,n)}const kl=oe({relu_:UYe});function WYe(e){const n={x:X(e,"x","relu6")};return se.runKernel(Hx,n)}const iE=oe({relu6_:WYe});function GYe(e,t){const a={x:X(e,"x","reverse")},r={dims:t};return se.runKernel(LA,a,r)}const oo=oe({reverse_:GYe});function HYe(e){const t=X(e,"x","reverse");return q(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),oo(t,0)}const hte=oe({reverse1d_:HYe});function jYe(e,t){const n=X(e,"x","reverse");return q(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),oo(n,t)}const dte=oe({reverse2d_:jYe});function qYe(e,t){const n=X(e,"x","reverse");return q(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),oo(n,t)}const pte=oe({reverse3d_:qYe});function KYe(e,t){const n=X(e,"x","reverse");return q(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),oo(n,t)}const fte=oe({reverse4d_:KYe});function XYe(e){const n={x:X(e,"x","round")};return se.runKernel(jx,n)}const oE=oe({round_:XYe});function YYe(e){const n={x:X(e,"x","rsqrt","float32")};return se.runKernel(qx,n)}const lE=oe({rsqrt_:YYe});function QYe(e){const n={x:X(e,"x","selu")};return se.runKernel(Kx,n)}const uE=oe({selu_:QYe});function ZYe(e,t,n,a,r,s=[1,1],i="NHWC"){const o=X(e,"x","separableConv2d"),l=X(t,"depthwiseFilter","separableConv2d"),u=X(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(o.rank===3&&(h=!0,c=me(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");q(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),q(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),q(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),q(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),q(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const p=l.shape[2],m=l.shape[3];q(u.shape[2]===p*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*m}, but got ${u.shape[2]}.`);const g=l0(c,l,a,r,i,s),b=ac(g,u,1,"valid",i);return h?me(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const cE=oe({separableConv2d_:ZYe});async function JYe(e,t){const n=X(e,"x","setdiff1d"),a=X(t,"y","setdiff1d");q(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),q(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),q(a.rank===1,()=>`y should be 1D tensor, but got y (${a.shape}).`);const r=await n.data(),s=await a.data(),i=new Set(s);let o=0;for(let c=0;c<r.length;c++)i.has(r[c])||o++;const l=new er([o],n.dtype),u=new er([o],"int32");for(let c=0,h=0;c<r.length;c++)i.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const mte=JYe;function eQe(e){const n={x:X(e,"x","sign")};return se.runKernel(Qx,n)}const GB=oe({sign_:eQe});function tQe(e){const n={x:X(e,"x","sin","float32")};return se.runKernel(Xx,n)}const hE=oe({sin_:tQe});function nQe(e){const n={x:X(e,"x","sinh")};return se.runKernel(Yx,n)}const dE=oe({sinh_:nQe});function aQe(e,t,n){const a=X(e,"x","slice1d");return q(a.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`),ln(a,[t],[n])}const uS=oe({slice1d_:aQe});function rQe(e,t,n){const a=X(e,"x","slice2d");return q(a.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`),ln(a,t,n)}const pE=oe({slice2d_:rQe});function sQe(e,t,n){const a=X(e,"x","slice3d");return q(a.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`),ln(a,t,n)}const cS=oe({slice3d_:sQe});function iQe(e,t,n){const a=X(e,"x","slice4d");return q(a.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`),ln(a,t,n)}const Ry=oe({slice4d_:iQe});function oQe(e,t=-1){const n=X(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const a={logits:n},r={dim:t};return se.runKernel(WA,a,r)}const hS=oe({softmax_:oQe});function lQe(e){q(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return se.runKernel(sT,t)}const dS=oe({fft_:lQe});function uQe(e){q(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return se.runKernel(uT,t)}const Dy=oe({ifft_:uQe});function cQe(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=me(e,[n,t]);a=Dy(r)}else{const r=[n,2*(t-1)],s=me(_y(e),[n,t]),i=me(eS(e),[n,t]),o=oo(ln(s,[0,1],[n,t-2]),1),l=he(oo(ln(i,[0,1],[n,t-2]),1),kt(-1)),u=za([s,o],1),c=za([i,l],1),h=me(nc(u,c),[r[0],r[1]]);a=Dy(h)}if(a=_y(a),e.rank===3&&e.shape[0]!==0){const r=a,s=e.shape[0];a=me(a,[s,a.shape[0]/s,a.shape[1]]),r.dispose()}return a}const fE=oe({irfft_:cQe});function hQe(e,t,n=0){const r={x:X(e,"x","split")},s={numOrSizeSplits:t,axis:n};return se.runKernel(UA,r,s)}const Ys=oe({split_:hQe});function dQe(e,t){q(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(t!=null&&t<n){const g=e.shape.map(b=>0),y=e.shape.map(b=>b);y[e.shape.length-1]=t,r=ln(e,g,y),n=t}else if(t!=null&&t>n){const g=e.shape.map(y=>y);g[e.shape.length-1]=t-n,r=za([e,Ya(g)],e.shape.length-1),n=t}else r=e;const s=cn(r),i=me(nc(r,s),[a,n]),o=dS(i),l=Math.floor(n/2)+1,u=_y(o),c=eS(o),h=Ys(u,[l,n-l],u.shape.length-1),p=Ys(c,[l,n-l],c.shape.length-1),m=r.shape.slice();return m[r.shape.length-1]=l,me(nc(h[0],p[0]),m)}const pS=oe({rfft_:dQe});function pQe(e,t){let n=X(e,"a","squaredDifference"),a=X(t,"b","squaredDifference");[n,a]=Ta(n,a),Mt(n.shape,a.shape);const r={a:n,b:a},s={};return se.runKernel(t0,r,s)}const mE=oe({squaredDifference_:pQe});function fQe(e,t){const n=X(e,"x","squeeze","string_or_numeric");return me(n,mc(n.shape,t).newShape)}const yd=oe({squeeze_:fQe});function mQe(e,t=0){const n=kw(e,"tensors","stack","string_or_numeric");q(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&q(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const a=n,r={axis:t};return se.runKernel($A,a,r)}const ri=oe({stack_:mQe});function gQe(e,t=0){const a={x:X(e,"x","step")},r={alpha:t};return se.runKernel(i0,a,r)}const Wm=oe({step_:gQe});function yQe(e,t,n,a,r=0,s=0,i=0,o=0,l=0){const c={x:X(e,"x","stridedSlice","string_or_numeric")},h={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return se.runKernel(MT,c,h)}const HB=oe({stridedSlice_:yQe});function bQe(e){const n={x:X(e,"x","tan","float32")};return se.runKernel(a0,n)}const jB=oe({tan_:bQe});function cs(e,t){Lm(e);const n=su(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return dd(e,null,n,t)}function sy(e,t,n){if(Lm(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const a=su(e,n);if(a.length!==2&&a.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return dd(e,t,a,n)}function qB(e,t,n){if(Lm(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const a=su(e,n);if(a.length!==3&&a.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return dd(e,t,a,n)}function gte(e,t,n){if(Lm(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const a=su(e,n);if(a.length!==4&&a.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return dd(e,t,a,n)}function yte(e,t,n){if(Lm(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const a=su(e,n);if(a.length!==5&&a.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return dd(e,t,a,n)}function bte(e,t,n){if(Lm(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const a=su(e,n);if(a.length!==6&&a.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||a,dd(e,t,a,n)}function KB(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+` update.rank != ${r+e.length-a}`);for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function gE(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}KB(n,t,e)}function bd(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length;let i=1;for(let h=r;h<s;++h)i*=n[h];const o=r<1?1:r,l=_e(t.shape)/o,u=[...St(n.slice(0,r)),1],c=_e(n);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}const xQe=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:bd,validateInput:gE,validateUpdateShape:KB},Symbol.toStringTag,{value:"Module"}));function vQe(e,t,n){const a=X(e,"tensor","tensorScatterupdate"),r=X(t,"indices","tensorScatterupdate","int32"),s=X(n,"updates","tensorScatterupdate");if(gE(s,r,a.shape),a.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${s.dtype}.`);const i={tensor:a,indices:r,updates:s},o={};return se.runKernel(TT,i,o)}const xte=oe({tensorScatterUpdate_:vQe});function wQe(e,t=1,n=!0){const a=X(e,"x","topk");if(a.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const s={x:a},i={k:t,sorted:n},[o,l]=se.runKernel(PT,s,i);return{values:o,indices:l}}const XB=oe({topk_:wQe});function AQe(e,t=0,n=1,a,r){if(zi(e),a!=null&&a==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new UB(t,n,a,!0,r),i=Gt(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}const yE=oe({truncatedNormal_:AQe});function SQe(e,t=0){const n=X(e,"x","unique","string_or_numeric");q(n.rank>0,()=>"The input tensor must be at least 1D");const a={x:n},r={axis:t},[s,i]=se.runKernel(UT,a,r);return{values:s,indices:i}}const YB=oe({unique_:SQe});function kQe(e,t,n){const a=X(e,"x","unsortedSegmentSum"),r=X(t,"segmentIds","unsortedSegmentSum","int32");q(Wp(n),()=>"numSegments must be of dtype int");const s={x:a,segmentIds:r},i={numSegments:n};return se.runKernel(jA,s,i)}const bE=oe({unsortedSegmentSum_:kQe});function IQe(e,t=0){const n=X(e,"x","unstack","string_or_numeric");q(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const a={value:n},r={axis:t};return se.runKernel(HA,a,r)}const lo=oe({unstack_:IQe});function vte(e,t){return aE(e,t,"right")}function QB(e,t=!0,n,a){return se.makeVariable(e,t,n,a)}function xE(e,t){const n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);const a=Gt(e,"int32"),r=Gt([n.length,e.length],"int32");for(let s=0;s<n.length;s++){const i=a.indexToLoc(n[s]),o=s*e.length;r.values.set(i,o)}return r.toTensor()}async function NQe(e){const t=X(e,"condition","whereAsync","bool"),n=await t.data(),a=xE(t.shape,n);return e!==t&&t.dispose(),a}const ZB=NQe;async function CQe(e,t,n){const a=X(e,"tensor","boolMask"),r=X(t,"mask","boolMask","bool"),s=n??0,i=r.rank,o=a.shape;q(i>0,()=>"mask cannot be scalar"),Zr(o.slice(s,s+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let y=s;y<s+i;y++)l*=o[y];const u=o.slice(0,s).concat([l],o.slice(s+i)),c=me(a,u),h=me(r,[-1]),p=await ZB(h),m=yd(p,[1]),g=d0(c,m,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),m.dispose(),c.dispose(),h.dispose(),p.dispose(),g}const wte=CQe;function TQe(e,t,n){const a=X(e,"x","transpose");if(t==null&&(t=a.shape.map((i,o)=>o).reverse()),q(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`),t.forEach(i=>{q(i>=0&&i<a.rank,()=>`All entries in 'perm' must be between 0 and ${a.rank-1} but got ${t}`)}),a.rank<=1)return a.clone();const r={x:a},s={perm:t};return a.dtype==="complex64"?Se(()=>{let i=_y(a),o=eS(a);return i=se.runKernel(bp,{x:i},s),o=se.runKernel(bp,{x:o},s),n&&(o=ia(o)),nc(i,o)}):se.runKernel(bp,r,s)}const an=oe({transpose_:TQe});function EQe(e,t,n,a,r=!0){const s=X(e,"v","movingAverage"),i=X(t,"x","movingAverage"),o=X(n,"decay","movingAverage");mee(s,i),q(tn(s.shape,i.shape),()=>"Shape mismatch in v and x");const l=kt(1),u=it(l,o);let c=he(it(i,s),u);if(r){q(a!=null,()=>"When using zeroDebias: true, step is required.");const h=X(a,"step","movingAverage");c=gt(c,it(l,iu(o,h)))}return Ue(s,c)}const Ate=oe({movingAverage_:EQe});function $Qe(e,t,n){zi(n);const a=X(e,"indices","scatterND","int32"),r=X(t,"updates","scatterND");gE(r,a,n);const s={indices:a,updates:r},i={shape:n};return se.runKernel(CT,s,i)}const Ste=oe({scatterND_:$Qe});function _Qe(e,t,n,a){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const i=t.size;if(!(t.rank===0||t.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function RQe(e,t,n,a=0){zi(n);const r=X(e,"sparseIndices","sparseToDense","int32"),s=X(t,"sparseValues","sparseToDense","string_or_numeric"),i=X(a,"defaultValue","sparseToDense",s.dtype);_Qe(r,s,n,i);const o={sparseIndices:r,sparseValues:s,defaultValue:i},l={outputShape:n};return se.runKernel(OT,o,l)}const kte=oe({sparseToDense_:RQe});function DQe(e,t){const n=X(t,"indices","gatherND","int32"),r={params:X(e,"x","gatherND","string_or_numeric"),indices:n};return se.runKernel(lT,r)}const Ite=oe({gatherND_:DQe});function OQe(e,t){if(t==null)return e.shape.slice();if(tn(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)t[a]==null&&e.shape[a]!=null?n.push(e.shape[a]):n.push(t[a]);return n}return t}function FQe(e,t,n,a){const r=X(e,"x","dropout");if(q(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),q(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof In?r.clone():r;const s=OQe(r,n),i=1-t,o=gt(h0(Ue(gd(s,0,1,"float32",a),i)),i);return he(r,o)}const JB=oe({dropout_:FQe});function eP(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function vE(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){const i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return cs(r,"float32")}async function MQe(e,t,n=1){const a=X(e,"predictions","inTopK"),r=X(t,"targets","inTopK");q(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),q(a.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`),Zr(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=a.shape[a.shape.length-1];q(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);const i=await a.data(),o=await r.data(),[l,u]=[i.length/s,s],c=Mr("bool",l);for(let h=0;h<l;h++){const p=h*u,m=i.subarray(p,p+u),g=[];for(let y=0;y<m.length;y++)g.push({value:m[y],index:y});g.sort((y,b)=>b.value-y.value),c[h]=0;for(let y=0;y<n;y++)if(g[y].index===o[h]){c[h]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),Lo(c,r.shape,"bool")}const Nte=MQe;function LQe(e,t,n,a,r,s="NHWC",i){let o=e;e.rank===3&&(o=me(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=me(t,[1,t.shape[0],t.shape[1],t.shape[2]])),q(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),q(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),q(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=s==="NHWC"?o.shape[3]:o.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];q(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),q(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Ls("conv2dDerFilter",r,i);const h={x:o,dy:l},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:n};return se.runKernel(jC,h,p)}const tP=oe({conv2DBackpropFilter_:LQe});function wE(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return he(e,Wm(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function AE(e,t){let n=t;const a=nr(e.shape,t.shape);return a.length>0&&(n=ct(n,a)),me(n,e.shape)}function SE(e,t,n,a){if(t==="linear")return e;if(t==="relu")return kl(e);if(t==="elu")return u0(e);if(t==="relu6")return iE(e);if(t==="prelu")return lS(e,n);if(t==="leakyrelu")return tS(e,a);if(t==="sigmoid")return cl(e);throw new Error(`Unknown fused activation ${t}.`)}const kE=(e,t)=>!(e>0)||t==="linear";function zQe({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",kE(se.state.gradientDepth,l)===!1){q(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let T=ac(e,t,n,a,r,s,i);return o!=null&&(T=Ue(T,o)),SE(T,l,u,c)}const h=X(e,"x","conv2d","float32"),p=X(t,"filter","conv2d","float32");let m=h,g=!1;h.rank===3&&(g=!0,m=me(h,[1,h.shape[0],h.shape[1],h.shape[2]])),q(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),q(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Ls("fused conv2d",a,i);const y=r==="NHWC"?m.shape[3]:m.shape[1];q(p.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${p.shape[2]}.`),q(Jr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);const b=Br(m.shape,p.shape,n,s,a,i);let v;o!=null&&(v=X(o,"bias","fused conv2d"),[v]=Ta(v,h),r==="NHWC"?Mt(b.outShape,v.shape):(q(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),q(v.shape.length===0||v.shape[0]===b.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${b.outChannels})`)));let w;if(u!=null){const T=u.shape;if(q(T.length<=1||T.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${T.length}.`),T.length===1)q(T[0]===1||T[0]===b.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the number of output channels (${b.outChannels}).`);else if(T.length===3)try{Mt(T,b.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(R)}w=X(u,"prelu weights","fused conv2d")}const S=(T,E)=>{q(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,D,O,$]=E,_=wE(T,O,l);q(Ph(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const P=xB(D.shape,_,R,n,a),U=tP(D,_,R.shape,n,a),W=[P,U];if($!=null){const B=AE($,_);W.push(B)}return W},k={x:m,filter:p,bias:v,preluActivationWeights:w},I={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?ou((E,R,D)=>{let O=se.runKernel(xw,k,I);return D([R,E,O]),g&&(O=me(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:S}})(m,p):ou((E,R,D,O)=>{let $=se.runKernel(xw,k,I);return O([R,E,$,D]),g&&($=me($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:S}})(m,p,v)}const Cte=oe({fusedConv2d_:zQe});function BQe(e,t,n,a,r,s=[1,1],i){let o=e;e.rank===3&&(o=me(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=me(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:a,pad:r,dimRoundingMode:i,dilations:s,filterShape:n};return se.runKernel(JC,u,c)}const Tte=oe({depthwiseConv2dNativeBackpropFilter_:BQe});function PQe(e,t,n,a,r,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=me(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:a,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},h=se.runKernel(eT,u,c);return l?me(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Ete=oe({depthwiseConv2dNativeBackpropInput_:PQe});function VQe({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(kE(se.state.gradientDepth,l)===!1){let I=l0(e,t,n,a,r,s,i);return o!=null&&(I=Ue(I,o)),SE(I,l,u,c)}const h=X(e,"x","depthwiseConv2d","float32"),p=X(t,"filter","depthwiseConv2d","float32");let m=h,g=!1;h.rank===3&&(g=!0,m=me(h,[1,h.shape[0],h.shape[1],h.shape[2]])),q(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),q(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),q(m.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),s==null&&(s=[1,1]),q(Jr(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),Ls("fused depthwiseConv2d",a,i);const y=Br(m.shape,p.shape,n,s,a,i,!0);let b;o!=null&&(b=X(o,"bias","fused conv2d"),[b]=Ta(b,h),Mt(y.outShape,b.shape));let v;u!=null&&(v=X(u,"prelu weights","fused depthwiseConv2d"));const w=(I,T)=>{q(Ph(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[E,R,D,O]=T,$=wE(I,D,l),_=Ete(R.shape,$,E,n,a,s,i),P=Tte(R,$,E.shape,n,a,s,i);if(O!=null){const U=AE(b,$);return[_,P,U]}return[_,P]},S={x:m,filter:p,bias:b,preluActivationWeights:v},k={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?ou((T,E,R)=>{let D=se.runKernel(vw,S,k);return R([E,T,D]),g&&(D=me(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:w}})(m,p):ou((T,E,R,D)=>{let O=se.runKernel(vw,S,k);return D([E,T,O,R]),g&&(O=me(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:w}})(m,p,b)}const UQe=oe({fusedDepthwiseConv2d_:VQe});function WQe({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(kE(se.state.gradientDepth,s)===!1){let $=Kt(e,t,n,a);return r!=null&&($=Ue($,r)),SE($,s,i,o)}let l=X(e,"a","fused matMul"),u=X(t,"b","fused matMul");[l,u]=Ta(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),y=u.shape.slice(0,-2),b=_e(g),v=_e(y);q(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${a} must match.`);const S=Mt(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,m]),k=n?me(l,[b,c,p]):me(l,[b,p,c]),I=a?me(u,[v,m,h]):me(u,[v,h,m]);let T;r!=null&&(T=X(r,"bias","fused matMul"),[T]=Ta(T,l),Mt(S,T.shape));let E;i!=null&&(E=X(i,"prelu weights","fused matMul"));const R=($,_)=>{const[P,U,W,B]=_,H=wE(me($,W.shape),W,s);let j,Z;if(!n&&!a?(j=Kt(H,U,!1,!0),Z=Kt(P,H,!0,!1)):!n&&a?(j=Kt(H,U,!1,!1),Z=Kt(H,P,!0,!1)):n&&!a?(j=Kt(U,H,!1,!0),Z=Kt(P,H,!1,!1)):(j=Kt(U,H,!0,!0),Z=Kt(H,P,!0,!0)),r!=null){const te=AE(B,H);return[j,Z,te]}else return[j,Z]},D={a:k,b:I,bias:T,preluActivationWeights:E},O={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:o};return r==null?ou((_,P,U)=>{const W=se.runKernel(bw,D,O);return U([_,P,W]),{value:me(W,S),gradFunc:R}})(k,I):ou((_,P,U,W)=>{const B=se.runKernel(bw,D,O);return W([_,P,B,U]),{value:me(B,S),gradFunc:R}})(k,I,T)}const IO=oe({fusedMatMul_:WQe});const $te=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Cte,depthwiseConv2d:UQe,matMul:IO},Symbol.toStringTag,{value:"Module"}));function GQe(e){return vE(e,.54,.46)}const HQe=oe({hammingWindow_:GQe});function jQe(e){return vE(e,.5,.5)}const _te=oe({hannWindow_:jQe});function qQe(e,t,n,a=!1,r=0){let s=0;const i=[];for(;s+t<=e.size;)i.push(ln(e,s,t)),s+=n;if(a)for(;s<e.size;){const o=s+t-e.size,l=za([ln(e,s,t-o),Vm([o],r)]);i.push(l),s+=n}return i.length===0?sy([],[0,t]):me(za(i),[i.length,t])}const Rte=oe({frame_:qQe});function KQe(e,t,n,a,r=_te){a==null&&(a=eP(t));const s=Rte(e,t,n),i=he(s,r(t));return pS(i,a)}const XQe=oe({stft_:KQe});function YQe(e,t,n,a,r="bilinear",s=0){const i=X(e,"image","cropAndResize"),o=X(t,"boxes","cropAndResize","float32"),l=X(n,"boxInd","cropAndResize","int32"),u=o.shape[0];q(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),q(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),q(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),q(a.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`),q(a[0]>=1&&a[1]>=1,()=>`cropSize must be atleast [1,1], but was ${a}`),q(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:i,boxes:o,boxInd:l},h={method:r,extrapolationValue:s,cropSize:a};return se.runKernel(YC,c,h)}const QQe=oe({cropAndResize_:YQe});function ZQe(e){const t=X(e,"image","flipLeftRight","float32");q(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return se.runKernel(oT,n,{})}const JQe=oe({flipLeftRight_:ZQe});function eZe(e){const t=X(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];q(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),q(a===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Ji(t,r)}const tZe=oe({grayscaleToRGB_:eZe});function nZe(e){const t=X(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];q(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),q(a===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);const r=t.dtype,s=Xe(t,"float32"),i=cs([.2989,.587,.114]);let o;switch(t.rank){case 2:o=sp("ij,j->i",s,i);break;case 3:o=sp("ijk,k->ij",s,i);break;case 4:o=sp("ijkl,l->ijk",s,i);break;case 5:o=sp("ijklm,m->ijkl",s,i);break;case 6:o=sp("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=us(o,-1),Xe(o,r)}const aZe=oe({rgbToGrayscale_:nZe});function rZe(e,t,n=0,a=.5){const r=X(e,"image","rotateWithOffset","float32");q(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const s={image:r},i={radians:t,fillValue:n,center:a};return se.runKernel(WT,s,i)}const sZe=oe({rotateWithOffset_:rZe});function p0(e,t,n,a,r,s){a==null&&(a=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);const i=e.shape[0];return n=Math.min(n,i),q(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),q(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),q(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),q(t.rank===1,()=>"scores must be a 1D tensor"),q(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),q(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}function iZe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){const s=X(e,"boxes","nonMaxSuppression","float32"),i=X(t,"scores","nonMaxSuppression","float32"),o=p0(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return se.runKernel(yT,{boxes:s,scores:i},l)}const oZe=oe({nonMaxSuppression_:iZe});function lZe(e,t,n){const a=uZe(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function uZe(e,t,n){return hZe(e,t,n||cZe)}function cZe(e,t){return e>t?1:e<t?-1:0}function hZe(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);const o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}function IE(e,t,n,a,r){return nP(e,t,n,a,r,0)}function NE(e,t,n,a,r,s){return nP(e,t,n,a,r,0,!1,s,!0)}function CE(e,t,n,a,r,s){return nP(e,t,n,a,r,s,!0)}function nP(e,t,n,a,r,s,i=!1,o=!1,l=!1){const u=[];for(let b=0;b<t.length;b++)t[b]>r&&u.push({score:t[b],boxIndex:b,suppressBeginIndex:0});u.sort(C6);const c=s>0?-.5/s:0,h=[],p=[];for(;h.length<n&&u.length>0;){const b=u.pop(),{score:v,boxIndex:w,suppressBeginIndex:S}=b;if(v<r)break;let k=!1;for(let I=h.length-1;I>=S;--I){const T=dZe(e,w,h[I]);if(T>=a){k=!0;break}if(b.score=b.score*pZe(a,c,T),b.score<=r)break}b.suppressBeginIndex=h.length,k||(b.score===v?(h.push(w),p.push(b.score)):b.score>r&&lZe(u,b,C6))}const m=h.length,g=n-m;o&&g>0&&(h.push(...new Array(g).fill(0)),p.push(...new Array(g).fill(0)));const y={selectedIndices:h};return i&&(y.selectedScores=p),l&&(y.validOutputs=m),y}function dZe(e,t,n){const a=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),m=(o-s)*(l-i),g=(h-u)*(p-c);if(m<=0||g<=0)return 0;const y=Math.max(s,u),b=Math.max(i,c),v=Math.min(o,h),w=Math.min(l,p),S=Math.max(v-y,0)*Math.max(w-b,0);return S/(m+g-S)}function pZe(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function C6(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function fZe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){const s=X(e,"boxes","nonMaxSuppressionAsync"),i=X(t,"scores","nonMaxSuppressionAsync"),o=p0(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;const l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=IE(u,c,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),cs(h,"int32")}const mZe=fZe;function gZe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){const i=X(e,"boxes","nonMaxSuppression"),o=X(t,"scores","nonMaxSuppression"),l=p0(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},h=se.runKernel(xT,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const yZe=oe({nonMaxSuppressionWithScore_:gZe});async function bZe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){const i=X(e,"boxes","nonMaxSuppressionAsync"),o=X(t,"scores","nonMaxSuppressionAsync"),l=p0(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:p,selectedScores:m}=CE(c,h,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:cs(p,"int32"),selectedScores:cs(m)}}const xZe=bZe;function vZe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){const i=X(e,"boxes","nonMaxSuppression"),o=X(t,"scores","nonMaxSuppression"),l=p0(i,o,n,a,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,p={boxes:i,scores:o},m={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:s},g=se.runKernel(bT,p,m);return{selectedIndices:g[0],validOutputs:g[1]}}const wZe=oe({nonMaxSuppressionPadded_:vZe});async function AZe(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){const i=X(e,"boxes","nonMaxSuppressionAsync"),o=X(t,"scores","nonMaxSuppressionAsync"),l=p0(i,o,n,a,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[p,m]=await Promise.all([i.data(),o.data()]),{selectedIndices:g,validOutputs:y}=NE(p,m,u,c,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:cs(g,"int32"),validOutputs:kt(y,"int32")}}const SZe=AZe;function kZe(e,t,n=!1,a=!1){const r=X(e,"images","resizeBilinear");q(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),q(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),q(a===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=me(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=se.runKernel(MA,o,l);return i?me(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Dte=oe({resizeBilinear_:kZe});function IZe(e,t,n=!1,a=!1){const r=X(e,"images","resizeNearestNeighbor");q(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),q(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),q(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),q(a===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=me(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=se.runKernel(FA,o,l);return i?me(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Ote=oe({resizeNearestNeighbor_:IZe});function NZe(e,t="binary",n=!1,a=.5){const r=X(e,"image","threshold"),s=.2989,i=.587,o=.114,l=r.shape[0]*r.shape[1];let u=he(cs([a]),255),c,h,p,m;if(q(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),q(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),q(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),q(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[c,h,p]=Ys(r,[1,1,1],-1);const b=he(c,s),v=he(h,i),w=he(p,o);m=Ue(Ue(b,v),w)}else m=e;if(t==="otsu"){const b=pB(Xe(oE(m),"int32"),Lo([]),256);u=CZe(b,l)}const g=n?md(m,u):ii(m,u);return Xe(he(g,255),"int32")}function CZe(e,t){let n=cs([-1]),a=cs([0]),r=cs([0]),s,i,o,l,u,c;for(let h=0;h<e.size-1;h++){s=ln(e,0,h+1),i=ln(e,h+1),u=gt(ct(s),t),c=gt(ct(i),t);const p=ct(he(s,Qp(0,s.size)));o=gt(p,ct(s));const m=Vm(i.shape,s.size),g=Ue(Qp(0,i.size),m),y=he(i,g);l=gt(ct(y),ct(i));const b=it(o,l),v=it(o,l),w=he(u,c);r=he(he(w,b),v);const S=ii(r,a);a=Xr(S,r,a),n=Xr(S,cs([h]),n)}return n}const TZe=oe({threshold_:NZe});function EZe(e,t,n="nearest",a="constant",r=0,s){const i=X(e,"image","transform","float32"),o=X(t,"transforms","transform","float32");q(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),q(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),q(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const l={image:i,transforms:o},u={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return se.runKernel(VT,l,u)}const $Ze=oe({transform_:EZe});function _Ze(e,t,n){const a=X(e,"a","bandPart");q(a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`);const r=a.shape,[s,i]=a.shape.slice(-2);let o,l;typeof t=="number"?(q(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),q(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=X(t<0?s:t,"numLower","bandPart")):(q(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Xr(Ey(t,0),s,Uh(t,s))),typeof n=="number"?(q(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),q(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=X(n<0?i:n,"numUpper","bandPart")):(q(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Xr(Ey(n,0),i,Uh(n,i)));const u=me(Qp(0,s,1,"int32"),[-1,1]),c=Qp(0,i,1,"int32"),h=it(u,c),p=yl(md(h,o),xc(h,ia(l))),m=Ya([s,i],a.dtype);return me(ri(lo(me(a,[-1,s,i])).map(g=>Xr(p,g,m))),r)}const RZe=oe({bandPart_:_Ze});function DZe(e){let t;if(Array.isArray(e)){t=!1,q(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=e[0].shape[0];for(let s=1;s<e.length;++s)q(e[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`)}else t=!0,e=Ys(e,e.shape[0],0).map(r=>yd(r,[0]));q(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],a=e;for(let r=0;r<e.length;++r)n.push(se.tidy(()=>{let s=a[r];if(r>0)for(let i=0;i<r;++i){const o=he(ct(he(n[i],s)),n[i]);s=it(s,o)}return gt(s,c0(s,"euclidean"))}));return t?ri(n,0):n}const OZe=oe({gramSchmidt_:DZe});function FZe(e,t=!1){if(q(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return T6(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),a=lo(me(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach(l=>{const[u,c]=T6(l,t);r.push(u),s.push(c)});const i=me(ri(r,0),e.shape),o=me(ri(s,0),e.shape);return[i,o]}}function T6(e,t=!1){return se.tidy(()=>{q(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],a=e.shape[1];let r=JT(n),s=Yl(e);const i=sy([[1]],[1,1]);let o=Yl(i);const l=n>=a?a:n;for(let u=0;u<l;++u){const c=s,h=o,p=r;[o,s,r]=se.tidy(()=>{const m=ln(s,[u,u],[n-u,1]),g=c0(m),y=ln(s,[u,u],[1,1]),b=Xr(ii(y,0),sy([[-1]]),sy([[1]])),v=it(y,he(b,g)),w=gt(m,v);w.shape[0]===1?o=Yl(i):o=za([i,ln(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const S=ia(gt(Kt(b,v),g)),k=ln(s,[u,0],[n-u,a]),I=he(S,o),T=an(o);if(u===0)s=it(k,Kt(I,Kt(T,k)));else{const D=it(k,Kt(I,Kt(T,k)));s=za([ln(s,[0,0],[u,a]),D],0)}const E=an(I),R=ln(r,[0,u],[n,r.shape[1]-u]);if(u===0)r=it(R,Kt(Kt(R,o),E));else{const D=it(R,Kt(Kt(R,o),E));r=za([ln(r,[0,0],[n,u]),D],1)}return[o,s,r]}),Yt([c,h,p])}return!t&&n>a&&(r=ln(r,[0,0],[n,a]),s=ln(s,[0,0],[a,a])),[r,s]})}const MZe=oe({qr_:FZe});var Is;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Is||(Is={}));function LZe(e,t,n=Is.SUM_BY_NONZERO_WEIGHTS){const a=X(e,"losses","computeWeightedLoss");let r=null;t!=null&&(r=X(t,"weights","computeWeightedLoss"));const s=r==null?a:he(a,r);if(n===Is.NONE)return s;if(n===Is.SUM)return ct(s);if(n===Is.MEAN){if(r==null)return Sa(s);{const i=a.size/r.size,o=gt(ct(s),ct(r));return i>1?gt(o,kt(i)):o}}if(n===Is.SUM_BY_NONZERO_WEIGHTS){if(r==null)return gt(ct(s),kt(a.size));{const i=he(r,qs(a.shape)),o=Xe(ct(Yp(i,kt(0))),"float32");return gt(ct(s),o)}}throw Error(`Unknown reduction: ${n}`)}const wc=oe({computeWeightedLoss_:LZe});function zZe(e,t,n,a=Is.SUM_BY_NONZERO_WEIGHTS){const r=X(e,"labels","absoluteDifference"),s=X(t,"predictions","absoluteDifference");let i=null;n!=null&&(i=X(n,"weights","absoluteDifference")),Zr(r.shape,s.shape,"Error in absoluteDifference: ");const o=Xa(it(r,s));return wc(o,i,a)}const BZe=oe({absoluteDifference_:zZe});function PZe(e,t,n,a,r=Is.SUM_BY_NONZERO_WEIGHTS){const s=X(e,"labels","cosineDistance"),i=X(t,"predictions","cosineDistance");let o=null;a!=null&&(o=X(a,"weights","cosineDistance")),Zr(s.shape,i.shape,"Error in cosineDistance: ");const l=kt(1),u=it(l,ct(he(s,i),n,!0));return wc(u,o,r)}const VZe=oe({cosineDistance_:PZe});function UZe(e,t,n,a=Is.SUM_BY_NONZERO_WEIGHTS){let r=X(e,"labels","hingeLoss");const s=X(t,"predictions","hingeLoss");let i=null;n!=null&&(i=X(n,"weights","hingeLoss")),Zr(r.shape,s.shape,"Error in hingeLoss: ");const o=kt(1);r=it(he(kt(2),r),o);const l=kl(it(o,he(r,s)));return wc(l,i,a)}const WZe=oe({hingeLoss_:UZe});function GZe(e,t,n,a=1,r=Is.SUM_BY_NONZERO_WEIGHTS){const s=X(e,"labels","huberLoss"),i=X(t,"predictions","huberLoss");let o=null;n!=null&&(o=X(n,"weights","huberLoss")),Zr(s.shape,i.shape,"Error in huberLoss: ");const l=kt(a),u=Xa(it(i,s)),c=Uh(u,l),h=it(u,c),p=Ue(he(kt(.5),Vn(c)),he(l,h));return wc(p,o,r)}const HZe=oe({huberLoss_:GZe});function jZe(e,t,n,a=1e-7,r=Is.SUM_BY_NONZERO_WEIGHTS){const s=X(e,"labels","logLoss"),i=X(t,"predictions","logLoss");let o=null;n!=null&&(o=X(n,"weights","logLoss")),Zr(s.shape,i.shape,"Error in logLoss: ");const l=kt(1),u=kt(a),c=ia(he(s,Di(Ue(i,u)))),h=he(it(l,s),Di(Ue(it(l,i),u))),p=it(c,h);return wc(p,o,r)}const qZe=oe({logLoss_:jZe});function KZe(e,t,n,a=Is.SUM_BY_NONZERO_WEIGHTS){const r=X(e,"labels","meanSquaredError"),s=X(t,"predictions","meanSquaredError");let i=null;n!=null&&(i=X(n,"weights","meanSquaredError")),Zr(r.shape,s.shape,"Error in meanSquaredError: ");const o=mE(r,s);return wc(o,i,a)}const XZe=oe({meanSquaredError_:KZe});function YZe(e,t){const n=X(e,"labels","sigmoidCrossEntropyWithLogits"),a=X(t,"logits","sigmoidCrossEntropyWithLogits");Zr(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=kl(a),s=he(a,n),i=nS(ai(ia(Xa(a))));return Ue(it(r,s),i)}function QZe(e,t,n,a=0,r=Is.SUM_BY_NONZERO_WEIGHTS){let s=X(e,"multiClassLabels","sigmoidCrossEntropy");const i=X(t,"logits","sigmoidCrossEntropy");let o=null;if(n!=null&&(o=X(n,"weights","sigmoidCrossEntropy")),Zr(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){const u=kt(a),c=kt(1),h=kt(.5);s=Ue(he(s,it(c,u)),he(h,u))}const l=YZe(s,i);return wc(l,o,r)}const ZZe=oe({sigmoidCrossEntropy_:QZe});function JZe(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return ou((r,s,i)=>{const l=aS(s,[n],!0),u=it(Xe(s,"float32"),l);i([r,u]);const c=ia(he(u,r));return{value:ct(c,[n]),gradFunc:(m,g)=>{const[y,b]=g,v=Ba(m.shape,[n]);return[he(me(m,v),it(Xe(y,"float32"),ai(b))),he(me(m,v),it(ai(b),Xe(y,"float32")))]}}})(e,t)}function eJe(e,t,n,a=0,r=Is.SUM_BY_NONZERO_WEIGHTS){let s=X(e,"onehotLabels","softmaxCrossEntropy");const i=X(t,"logits","softmaxCrossEntropy");let o=null;if(n!=null&&(o=X(n,"weights","softmaxCrossEntropy")),Zr(s.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){const u=kt(a),c=kt(1),h=kt(s.shape[1]);s=Ue(he(s,it(c,u)),gt(u,h))}const l=JZe(s,i);return wc(l,o,r)}const tJe=oe({softmaxCrossEntropy_:eJe});function nJe(e,t,n,a){const r=X(e,"indices","sparseFillEmptyRows","int32"),s=X(t,"values","sparseFillEmptyRows"),i=X(n,"denseShape","sparseFillEmptyRows","int32"),o=X(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:r,values:s,denseShape:i,defaultValue:o},u=se.runKernel($T,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const aJe=oe({sparseFillEmptyRows_:nJe});function rJe(e,t,n){const a=X(e,"inputIndices","sparseReshape","int32"),r=X(t,"inputShape","sparseReshape","int32"),s=X(n,"newShape","sparseReshape","int32");if(a.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${a.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const i={inputIndices:a,inputShape:r,newShape:s},o=se.runKernel(_T,i);return{outputIndices:o[0],outputShape:o[1]}}const sJe=oe({sparseReshape_:rJe});function iJe(e,t,n){const a=X(e,"data","sparseSegmentMean"),r=X(t,"indices","sparseSegmentMean","int32"),s=X(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const i={data:a,indices:r,segmentIds:s};return se.runKernel(RT,i)}const oJe=oe({sparseSegmentMean_:iJe});function lJe(e,t,n){const a=X(e,"data","sparseSegmentSum"),r=X(t,"indices","sparseSegmentSum","int32"),s=X(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const i={data:a,indices:r,segmentIds:s};return se.runKernel(DT,i)}const uJe=oe({sparseSegmentSum_:lJe});function cJe(e,t,n,a,r,s,i,o){const l=X(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=X(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:u},p=se.runKernel(LT,h,c);return{nGrams:p[0],nGramsSplits:p[1]}}const hJe=oe({stringNGrams_:cJe});function dJe(e,t,n=!0){const a=X(e,"input","stringSplit","string"),r=X(t,"delimiter","stringSplit","string");if(a.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const s={skipEmpty:n},i={input:a,delimiter:r},o=se.runKernel(zT,i,s);return{indices:o[0],values:o[1],shape:o[2]}}const pJe=oe({stringSplit_:dJe});function fJe(e,t){const n=X(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return se.runKernel(BT,r,a)}const mJe=oe({stringToHashBucketFast_:fJe});function gJe(e,t,n,a=!0){const r=X(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:a};return se.runKernel(GA,{x:r},s)}const yJe=oe({staticRegexReplace_:gJe});const Fte={fft:dS,ifft:Dy,rfft:pS,irfft:fE},Mte={hammingWindow:HQe,hannWindow:_te,frame:Rte,stft:XQe},sl={flipLeftRight:JQe,grayscaleToRGB:tZe,resizeNearestNeighbor:Ote,resizeBilinear:Dte,rgbToGrayscale:aZe,rotateWithOffset:sZe,cropAndResize:QQe,nonMaxSuppression:oZe,nonMaxSuppressionAsync:mZe,nonMaxSuppressionWithScore:yZe,nonMaxSuppressionWithScoreAsync:xZe,nonMaxSuppressionPadded:wZe,nonMaxSuppressionPaddedAsync:SZe,threshold:TZe,transform:$Ze},aP={bandPart:RZe,gramSchmidt:OZe,qr:MZe},Lte={absoluteDifference:BZe,computeWeightedLoss:wc,cosineDistance:VZe,hingeLoss:WZe,huberLoss:HZe,logLoss:qZe,meanSquaredError:XZe,sigmoidCrossEntropy:ZZe,softmaxCrossEntropy:tJe},zte={sparseFillEmptyRows:aJe,sparseReshape:sJe,sparseSegmentMean:oJe,sparseSegmentSum:uJe},Bte={stringNGrams:hJe,stringSplit:pJe,stringToHashBucketFast:mJe,staticRegexReplace:yJe};const bJe=new Map,NO=new Map;class Gm{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class Ki{constructor(){this.classNameMap={}}static getMap(){return Ki.instance==null&&(Ki.instance=new Ki),Ki.instance}static register(t){Ki.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function We(e,t,n){q(e.className!=null,()=>"Class being registered does not have the static className property defined."),q(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),q(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);const a=n,r=t+">"+a;return Ki.register(e),bJe.set(r,e),NO.set(e,r),e}function xJe(e){return NO.has(e)?NO.get(e):e.className}const vJe=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Gm,SerializationMap:Ki,getRegisteredName:xJe,registerClass:We},Symbol.toStringTag,{value:"Module"}));class Ac extends Gm{minimize(t,n=!1,a){const{value:r,grads:s}=this.computeGradients(t,a);if(a!=null){const i=a.map(o=>({name:o.name,tensor:s[o.name]}));this.applyGradients(i)}else this.applyGradients(s);return Yt(s),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return Hee(t,n)}dispose(){this.iterations_!=null&&Yt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:kt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Ac,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});class rP extends Ac{static get className(){return"Adadelta"}constructor(t,n,a=null){super(),this.learningRate=t,this.rho=n,this.epsilon=a,this.accumulatedGrads=[],this.accumulatedUpdates=[],a==null&&(this.epsilon=se.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,r)=>{const s=se.registeredVariables[a],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${a}/accum_grad`,variable:Se(()=>cn(s).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${a}/accum_var`,variable:Se(()=>cn(s).variable(i))});const o=Array.isArray(t)?t[r].tensor:t[a];if(o==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;Se(()=>{const c=Ue(he(l,this.rho),he(Vn(o),1-this.rho)),h=he(gt(Lr(Ue(u,this.epsilon)),Lr(Ue(l,this.epsilon))),o),p=Ue(he(u,this.rho),he(Vn(h),1-this.rho));l.assign(c),u.assign(p);const m=Ue(he(h,-this.learningRate),s);s.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Yt(this.accumulatedGrads.map(t=>t.variable)),Yt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,a=!1;this.accumulatedGrads=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(a)})),this.accumulatedUpdates=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(a)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}class sP extends Ac{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,r)=>{const s=se.registeredVariables[a];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${a}/accumulator`,variable:Se(()=>Vm(s.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(t)?t[r].tensor:t[a];if(i==null)return;const o=this.accumulatedGrads[r].variable;Se(()=>{const l=Ue(o,Vn(i));o.assign(l);const u=Ue(he(gt(i,Lr(Ue(l,se.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Yt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}class iP extends Ac{static get className(){return"Adam"}constructor(t,n,a,r=null){super(),this.learningRate=t,this.beta1=n,this.beta2=a,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Se(()=>{this.accBeta1=kt(n).variable(),this.accBeta2=kt(a).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);Se(()=>{const a=it(1,this.accBeta1),r=it(1,this.accBeta2);n.forEach((s,i)=>{const o=se.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Se(()=>cn(o).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:Se(()=>cn(o).variable(l))});const u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedSecondMoment[i].variable,p=Ue(he(c,this.beta1),he(u,1-this.beta1)),m=Ue(he(h,this.beta2),he(Vn(u),1-this.beta2)),g=gt(p,a),y=gt(m,r);c.assign(p),h.assign(m);const b=Ue(he(gt(g,Ue(Lr(y),this.epsilon)),-this.learningRate),o);o.assign(b)}),this.accBeta1.assign(he(this.accBeta1,this.beta1)),this.accBeta2.assign(he(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Yt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Yt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),Se(()=>{this.accBeta1.assign(iu(this.beta1,this.iterations_+1)),this.accBeta2.assign(iu(this.beta2,this.iterations_+1))});const n=t.length/2,a=!1;this.accumulatedFirstMoment=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(a)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(a)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}class oP extends Ac{static get className(){return"Adamax"}constructor(t,n,a,r=null,s=0){super(),this.learningRate=t,this.beta1=n,this.beta2=a,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Se(()=>{this.iteration=kt(0).variable(),this.accBeta1=kt(n).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(a=>a.name):Object.keys(t);Se(()=>{const a=it(1,this.accBeta1),r=gt(-this.learningRate,Ue(he(this.iteration,this.decay),1));n.forEach((s,i)=>{const o=se.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:cn(o).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:cn(o).variable(l)});const u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedWeightedInfNorm[i].variable,p=Ue(he(c,this.beta1),he(u,1-this.beta1)),m=he(h,this.beta2),g=Xa(u),y=mu(m,g);c.assign(p),h.assign(y);const b=Ue(he(gt(r,a),gt(p,Ue(y,this.epsilon))),o);o.assign(b)}),this.iteration.assign(Ue(this.iteration,1)),this.accBeta1.assign(he(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Yt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Yt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}class TE extends Ac{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,r)=>{const s=Array.isArray(t)?t[r].tensor:t[a];if(s==null)return;const i=se.registeredVariables[a];Se(()=>{const o=Ue(he(this.c,s),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=dr(kt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}class lP extends TE{static get className(){return"Momentum"}constructor(t,n,a=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=a,this.accumulations=[],this.m=kt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,r)=>{const s=se.registeredVariables[a];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${a}/momentum`,variable:Se(()=>cn(s).variable(!1))});const i=this.accumulations[r].variable,o=Array.isArray(t)?t[r].tensor:t[a];o!=null&&Se(()=>{let l;const u=Ue(he(this.m,i),o);this.useNesterov?l=Ue(he(this.c,Ue(o,he(u,this.m))),s):l=Ue(he(this.c,u),s),i.assign(u),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Yt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}class uP extends Ac{static get className(){return"RMSProp"}constructor(t,n=.9,a=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=a,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=se.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(a=>a.name):Object.keys(t)).forEach((a,r)=>{const s=se.registeredVariables[a],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${a}/rms`,variable:Se(()=>cn(s).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${a}/momentum`,variable:Se(()=>cn(s).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${a}/mg`,variable:Se(()=>cn(s).variable(i))});const o=Array.isArray(t)?t[r].tensor:t[a];if(o==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;Se(()=>{const c=Ue(he(l,this.decay),he(Vn(o),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,p=Ue(he(h,this.decay),he(o,1-this.decay)),m=gt(he(o,this.learningRate),Lr(it(c,Ue(Vn(p),this.epsilon)))),g=Ue(he(u,this.momentum),m);l.assign(c),h.assign(p),u.assign(g);const y=it(s,g);s.assign(y)}else{const h=Ue(he(l,this.decay),he(Vn(o),1-this.decay)),p=Ue(he(u,this.momentum),gt(he(o,this.learningRate),Lr(Ue(h,this.epsilon))));l.assign(h),u.assign(p);const m=it(s,p);s.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Yt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Yt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Yt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,a=!1;this.accumulatedMeanSquares=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(a)})),this.accumulatedMoments=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(a)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(a)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}const wJe=[rP,sP,iP,oP,lP,uP,TE];function AJe(){for(const e of wJe)We(e)}const SJe="model",kJe=".json",IJe=".weights.bin";function E6(e){return new Promise(t=>setTimeout(t)).then(e)}class Zp{constructor(t){if(!Ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Zp.URL_SCHEME)&&(t=t.slice(Zp.URL_SCHEME.length)),(t==null||t.length===0)&&(t=SJe),this.modelJsonFileName=t+kJe,this.weightDataFileName=t+IJe}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Sl.join(t.weightData),a=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=Nee(t,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await E6(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=a,await E6(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:XA(t)}}}}Zp.URL_SCHEME="downloads://";class NJe{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const a=new FileReader;a.onload=r=>{const s=JSON.parse(r.target.result),i=s.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}const l=Zz(s,u=>this.loadWeights(u));t(l)},a.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),a.readAsText(this.jsonFile)})}loadWeights(t){const n=[],a=[];for(const i of t)n.push(...i.weights),a.push(...i.paths);const r=this.checkManifestAndWeightFiles(t),s=a.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(s).then(i=>[n,i])}loadWeightsFile(t,n){return new Promise((a,r)=>{const s=new FileReader;s.onload=i=>{const o=i.target.result;a(o)},s.onerror=i=>r(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[],a=this.weightsFiles.map(s=>b6(s.name)),r={};for(const s of t)s.paths.forEach(i=>{const o=b6(i);if(n.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(n.push(o),a.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[i]=this.weightsFiles[a.indexOf(o)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const CJe=e=>Ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Zp.URL_SCHEME)?TJe(e.slice(Zp.URL_SCHEME.length)):null;va.registerSaveRouter(CJe);function TJe(e="model"){return new Zp(e)}function EJe(e){return new NJe(e)}function $6(e,t,n,a){i(e),n=n??0,a=a??1,o(n,a);let r=0;const s=l=>(l.then(u=>{const c=n+ ++r/e.length*(a-n);return t(c),u}),l);function i(l){q(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){q(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),q(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),q(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(s))}async function Pte(e,t){t==null&&(t={});const n=t.fetchFunc==null?Ie().platform.fetch:t.fetchFunc,a=e.map(h=>n(h,t.requestInit,{isBinary:!0})),o=(t.onProgress==null?await Promise.all(a):await $6(a,t.onProgress,0,.5)).map(h=>h.arrayBuffer());return t.onProgress==null?await Promise.all(o):await $6(o,t.onProgress,.5,1)}function $Je(e,t){var n;const a=t.fetchFunc==null?Ie().platform.fetch:t.fetchFunc;let r=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;r<e.length;){s||(s=(await a(e[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await s.read();if(l){r++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}i.enqueue(u);return}i.close()}})}async function _Je(e,t="",n,a){return Vte(i=>Pte(i,{requestInit:a}))(e,t,n)}function Vte(e){return async(t,n="",a)=>{const r=t.map(()=>!1),s={},i=a!=null?a.map(()=>!1):[],o=[];if(t.forEach((m,g)=>{let y=0;m.weights.forEach(b=>{const v="quantization"in b?b.quantization.dtype:b.dtype,w=Gp[v]*_e(b.shape),S=()=>{r[g]=!0,s[g]==null&&(s[g]=[]),s[g].push({manifestEntry:b,groupOffset:y,sizeBytes:w})};a!=null?a.forEach((k,I)=>{k===b.name&&(S(),i[I]=!0)}):S(),o.push(b.name),y+=w})}),!i.every(m=>m)){const m=a.filter((g,y)=>!i[y]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=r.reduce((m,g,y)=>(g&&m.push(y),m),[]),u=[];l.forEach(m=>{t[m].paths.forEach(g=>{const y=n+(n.endsWith("/")?"":"/")+g;u.push(y)})});const c=await e(u),h={};let p=0;return l.forEach(m=>{const g=t[m].paths.length,y=new Sl(c.slice(p,p+g));s[m].forEach(v=>{const w=y.slice(v.groupOffset,v.groupOffset+v.sizeBytes),S=Aee(w,[v.manifestEntry]);for(const k in S)h[k]=S[k]}),p+=g}),h}}const RJe="application/octet-stream",DJe="application/json";class cP{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(q(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=Ie().platform.fetch,q(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&q(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const a=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=Nee(t,a);if(n.body.append("model.json",new Blob([JSON.stringify(r)],{type:DJe}),"model.json"),t.weightData!=null){const i=Sl.join(t.weightData);n.body.append("model.weights.bin",new Blob([i],{type:RJe}),"model.weights.bin")}const s=await this.fetch(this.path,n);if(s.ok)return{modelArtifactsInfo:XA(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const a=n.modelTopology,r=n.weightsManifest;if(a==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return Zz(t,n=>this.loadWeights(n))}async loadStream(){const t=await this.loadModelJSON(),n=await this.getWeightUrls(t.weightsManifest),a=DN(t.weightsManifest),r=()=>$Je(n,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:a,getWeightStream:r})}async getWeightUrls(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[a,r]=OJe(n),s=this.weightPathPrefix||a,i=[],o=[];for(const l of t)for(const u of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(u)):i.push(s+u+r);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(t){const n=await this.getWeightUrls(t),a=DN(t),r=await Pte(n,this.loadOptions);return[a,r]}}cP.URL_SCHEME_REGEX=/^https?:\/\//;function OJe(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}function CO(e){return e.match(cP.URL_SCHEME_REGEX)!=null}const Ute=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(a=>CO(a)):n=CO(e),n)return hP(e,t)}return null};va.registerSaveRouter(Ute);va.registerLoadRouter(Ute);function hP(e,t){return new cP(e,t)}function FJe(e,t){return hP(e,t)}class MR{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class Wte{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class MJe{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=n=>Promise.resolve(t.save(n)))}}function LJe(e,t,n,a){const r=arguments;return new MJe(FN(...r))}function FN(e,t,n,a){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new MR(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new MR({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new MR({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function zJe(e){return new Wte(e)}function BJe(e){return new Wte(e)}const dP=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Sl,browserFiles:EJe,browserHTTPRequest:FJe,concatenateArrayBuffers:Iee,copyModel:mXe,decodeWeights:Aee,decodeWeightsStream:kee,encodeWeights:xO,fromMemory:LJe,fromMemorySync:FN,getLoadHandlers:tXe,getModelArtifactsForJSON:Zz,getModelArtifactsForJSONSync:Qz,getModelArtifactsInfoForJSON:XA,getSaveHandlers:Cee,getWeightSpecs:DN,http:hP,isHTTPScheme:CO,listModels:pXe,loadWeights:_Je,moveModel:gXe,registerLoadRouter:eXe,registerSaveRouter:JKe,removeModel:fXe,weightsLoaderFactory:Vte,withSaveHandler:zJe,withSaveHandlerSync:BJe},Symbol.toStringTag,{value:"Module"}));function PJe(e,t,n){const a=X(e,"labels","confusionMatrix"),r=X(t,"predictions","confusionMatrix");q(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),q(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),q(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),q(a.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),q(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const s=$y(Xe(a,"int32"),n),i=$y(Xe(r,"int32"),n),o=an(s),l=Kt(o,i);return Xe(l,"int32")}const VJe=oe({confusionMatrix_:PJe});const UJe=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:VJe},Symbol.toStringTag,{value:"Module"}));let Hd,_6=!1;function Gte(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)a=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Aw(_N,se.backendName)!=null){const g={pixels:e},y={numChannels:t};return se.runKernel(_N,g,y)}const[u,c]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let h;if(i)h=e.getContext("2d").getImageData(0,0,u,c).data;else if(a||n)h=e.data;else if(s||r||o){if(Hd==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Hd=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Hd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Hd.canvas.width=u,Hd.canvas.height=c,Hd.drawImage(e,0,0,u,c),h=Hd.getImageData(0,0,u,c).data}let p;if(t===4)p=new Int32Array(h);else{const g=u*c;p=new Int32Array(g*t);for(let y=0;y<g;y++)for(let b=0;b<t;++b)p[y*t+b]=h[y*4+b]}return qB(p,[c,u,t],"int32")}function WJe(e){return e!=null&&e.data instanceof Uint8Array}function GJe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function HJe(e){return e!=null&&e.width!==0&&e.height!==0}function jJe(e){return GJe()&&!(e instanceof ImageBitmap)&&HJe(e)&&!WJe(e)}async function qJe(e,t=3){let n=null;if(Ie().getBool("WRAP_TO_IMAGEBITMAP")&&jJe(e)){let a;try{a=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{a=null}a!=null&&a.width===e.width&&a.height===e.height?n=a:n=e}else n=e;return Gte(n,t)}function Hte(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function KJe(e){const t=e?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function XJe(e,t){let n=X(e,"img","toPixels");if(!(e instanceof In)){const u=n;n=Xe(u,"int32"),u.dispose()}Hte(n);const[a,r]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*a*4);for(let u=0;u<a*r;++u){const c=[0,0,0,255];for(let p=0;p<s;p++){const m=i[u*s+p];if(n.dtype==="float32"){if(m<0||m>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${m}.`)}else if(n.dtype==="int32"&&(m<0||m>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${m}.`);s===1?(c[0]=m*o,c[1]=m*o,c[2]=m*o):c[p]=m*o}const h=u*4;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(t!=null){_6||Aw(nT,se.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),_6=!0),t.width=r,t.height=a;const u=t.getContext("2d"),c=new ImageData(l,r,a);u.putImageData(c,0,0)}return n!==e&&n.dispose(),l}function YJe(e,t,n){let a=X(e,"img","draw");if(!(e instanceof In)){const i=a;a=Xe(i,"int32"),i.dispose()}Hte(a),KJe(n?.imageOptions);const r={image:a},s={canvas:t,options:n};se.runKernel(nT,r,s)}const QJe=oe({fromPixels_:Gte}),ZJe=Object.freeze(Object.defineProperty({__proto__:null,draw:YJe,fromPixels:QJe,fromPixelsAsync:qJe,toPixels:XJe},Symbol.toStringTag,{value:"Module"}));function EE(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(_e(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,s=r[r.length-1];let i=1;for(let h=0;h<r.length-1;++h)i*=r[h];const o=e.shape,l=r.slice();l.pop();let u=1;for(let h=s;h<n;++h)u*=o[h],l.push(o[h]);const c=[...St(e.shape).map(h=>h/u),1].slice(0,s);return[l,i,u,c]}const JJe=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:EE},Symbol.toStringTag,{value:"Module"}));const TO=-2,eet=-1;function pP(e,t,n){const a=e.shape.length;q(a===t.length,()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`),q(a===n.length,()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);for(let r=0;r<a;++r)q(t[r]+n[r]<=e.shape[r],()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function tet(e){const t=[];let n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function fP(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function jte(e,t,n,a){const r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)s===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function qte(e,t,n){return n<=e?n:n-(t-1)}function Kte(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function net(e,t,n,a,r,s,i,o,l){const u=e.length;let c=new Array(u),h=new Array(u),p=new Array(u);if(t.length&&n>0){const m=t[0],g=n+1;c=Xte(i,m,g,a,e),h=Yte(o,m,g,r,e),p=jte(s,m,g,e)}else for(let m=0;m<u;m++)c[m]=Zte(i,a,s,e,m,l),h[m]=Jte(o,r,s,e,m,l),p[m]=Qte(s,m,l);return{begin:c,end:h,strides:p}}function Xte(e,t,n,a,r){const s=[...r],i=Kte(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const l=qte(t,n,o);let u=a[l];e&1<<l&&(u=0),s[o]=u}return s}function Yte(e,t,n,a,r){const s=[...r],i=Kte(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const l=qte(t,n,o);let u=a[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[o]=u}for(let o=0;o<s.length;o++){const l=r[o];s[o]<0&&(s[o]+=l),s[o]=Mh(0,s[o],r[o])}return s}function Qte(e,t,n){let a=e[t];return(n&1<<t||a==null)&&(a=1),a}function Zte(e,t,n,a,r,s){let i=t[r];const o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=a[r];return i<0&&(i+=l),i=Mh(0,i,l-1),i}function Jte(e,t,n,a,r,s){let i=t[r];const o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=a[r];return i<0&&(i+=l),o>0?i=Mh(0,i,l):i=Mh(-1,i,l-1),i}function mP(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function gP(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function $E(e,t,n){let a;const r=e.shape.length;typeof t=="number"?a=[t,...new Array(r-1).fill(0)]:t.length<r?a=t.concat(new Array(r-t.length).fill(0)):a=t.slice(),a.forEach(i=>{q(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(r).fill(-1):typeof n=="number"?s=[n,...new Array(r-1).fill(-1)]:n.length<r?s=n.concat(new Array(r-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(q(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-a[o])),[a,s]}function yP(e,t,n,a,r,s,i,o,l){let u;if(a==null?(u=new Array(t.length),u.fill(1)):u=a,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let S=0;S<h.dims;S++)c&&(1<<S&o)!==0&&h.numAddAxisAfterEllipsis++,1<<S&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};aet(h,p);let m=!0,g=!0,y=!0;const b=[],v=[];for(let S=0;S<e.length;++S){if(p.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);const k=!!(p.shrinkAxisMask&1<<S),I=e[S];if(I===-1){b.push(k?1:-1);continue}const T=[p.beginMask&1<<S,p.endMask&1<<S],E=[p.strides[S]>0?0:-1,p.strides[S]>0?I:I-1];if(k&&p.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&p.strides[S]===1;const R=!!(p.beginMask&1<<S&&p.endMask&1<<S);if(p.beginValid&&p.endValid){if(k){const _=p.begin[S]<0?I+p.begin[S]:p.begin[S];if(p.begin[S]=_,p.end[S]=p.begin[S]+1,_<0||_>=I)throw Error(`slice index ${p.begin[S]} of dimension ${S} out of bounds.`)}else p.begin[S]=R6(p.begin[S],0,p.strides[S],I,T,E),p.end[S]=R6(p.end[S],1,p.strides[S],I,T,E);const $=p.strides[S]===1&&p.begin[S]===0&&p.end[S]===I;m=m&&$,g=g&&(S===0&&p.strides[S]===1||$)}else m=m&&p.strides[S]===1&&R,g=g&&(S===0&&p.strides[S]===1||R);let D,O=!1;if(p.beginValid&&p.endValid?(D=p.end[S]-p.begin[S],O=!0):k?(D=1,O=!0):R&&I>=0&&(p.strides[S]<0?D=-I:D=I,O=!0),O){let $;D===0||D<0!=p.strides[S]<0?$=0:$=Math.trunc(D/p.strides[S])+(D%p.strides[S]!==0?1:0),b.push($)}else b.push(-1)}for(let S=0;S<p.finalShapeGatherIndices.length;++S){const k=p.finalShapeGatherIndices[S];k>=0?v.push(b[k]):k===TO&&v.push(1)}return{finalShapeSparse:v.filter((S,k)=>p.finalShapeGatherIndices[k]!==TO),finalShape:v,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:p.begin,end:p.end,strides:p.strides}}function aet(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(TO),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[a]),e.end!=null&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(eet),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function R6(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{const i=e<0?a+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}const ene=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:pP,computeFlatOffset:gP,computeOutShape:fP,getNormalizedAxes:net,isSliceContinous:mP,maskToAxes:tet,parseSliceParams:$E,sliceInfo:yP,startForAxis:Zte,startIndicesWithElidedDims:Xte,stopForAxis:Jte,stopIndicesWithElidedDims:Yte,stridesForAxis:Qte,stridesWithElidedDims:jte},Symbol.toStringTag,{value:"Module"}));const ret="4.22.0";class tne{static sgd(t){return new TE(t)}static momentum(t,n,a=!1){return new lP(t,n,a)}static rmsprop(t,n=.9,a=0,r=null,s=!1){return new uP(t,n,a,r,s)}static adam(t=.001,n=.9,a=.999,r=null){return new iP(t,n,a,r)}static adadelta(t=.001,n=.95,a=null){return new rP(t,n,a)}static adamax(t=.002,n=.9,a=.999,r=null,s=0){return new oP(t,n,a,r,s)}static adagrad(t,n=.1){return new sP(t,n)}}const Zd=tne;const set=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function bP(){return new Promise(e=>set(()=>e()))}function xP(e,t){const n=e[0].length;e.forEach((r,s)=>{q(r.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),q(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const a=e[0];e.forEach((r,s)=>{for(let i=0;i<n;i++)q(i===t||r[i]===a[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`)})}function Ql(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var rl;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(rl||(rl={}));function nne(e,t,n){let a=new Array;if(n==null&&t==null)return a;if(t==null)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(n==null)return a;if(e+n.length!==a.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${a.length}`);for(let r=1;r<n.length;++r){const s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${s} but shape[${r+e}] = ${o}`)}else a[i]=s}return a}function ane(e){const t={FIRST_DIM_SIZE:rl.FIRST_DIM_SIZE,VALUE_ROWIDS:rl.VALUE_ROWIDS,ROW_LENGTHS:rl.ROW_LENGTHS,ROW_SPLITS:rl.ROW_SPLITS,ROW_LIMITS:rl.ROW_LIMITS,ROW_STARTS:rl.ROW_STARTS},n=[];for(const a of e)if(a in t)n.push(t[a]);else break;return n}function rne(e){return e.length===0?0:e[0]===rl.FIRST_DIM_SIZE?e.length-1:e.length}function sne(e,t){if(e==null||t==null)return;const n=e.length,a=t.length;if(n>=a)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);for(let r=0;r<Math.min(n,a-1);++r){const s=e[r],i=t[r+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${s} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}const vP=30;function _E(e){return e<=vP?e:TN(e,Math.floor(Math.sqrt(e)))}function wP(e,t,n){const a=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[a,r]}function fS(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const s=t.length;for(let i=0;i<s;++i)r=r.concat([e[i+1]/t[i],t[i]]);r=r.concat(e.slice(s+1))}return r}function mS(e,t,n=!0){const a=[];if(n){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{const r=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):r.push(i);a.push(...r),a.push(0),a.push(...s)}return a}function gS(e,t,n,a=!0){const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function AP(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function SP(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}const RE=1.7580993408473768,DE=1.0507009873554805;const kP=.3275911,IP=.254829592,NP=-.284496736,CP=1.421413741,TP=-1.453152027,EP=1.061405429;function rc(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function ine(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function one(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function lne(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function $P(e,t){const n=e[t*2],a=e[t*2+1];return{real:n,imag:a}}function une(e,t,n,a){e[a*2]=t,e[a*2+1]=n}function cne(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function hne(e,t,n){const a=(n?2:-2)*Math.PI*(e/t),r=Math.cos(a),s=Math.sin(a);return{real:r,imag:s}}const LR="->",iet=/->/g,D6=",",O6="...";function _P(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(iet,"").length)/LR.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${LR}").`);const[a,r]=e.split(LR);q(a.indexOf(O6)===-1,()=>`The ellipsis notation ("${O6}") is not supported yet.`);const s=a.split(D6),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let p=0;p<r.length;++p){const m=r[p];if(!s.some(g=>g.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);o.indexOf(m)===-1&&o.push(m)}for(let p=0;p<a.length;++p){const m=a[p];o.indexOf(m)===-1&&m!==D6&&o.push(m)}const l=new Array(s.length);for(let p=0;p<i;++p){if(new Set(s[p].split("")).size!==s[p].length)throw new Error(`Found duplicate axes in input component ${s[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let m=0;m<s[p].length;++m)l[p].push(o.indexOf(s[p][m]))}const u=o.length,c=r.length,h=[];for(let p=c;p<u;++p)h.push(p);return{allDims:o,summedDims:h,idDims:l}}function RP(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)n[r]===-1&&a.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:a}}function DP(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const s=n[r].shape;for(let i=0;i<t[r].length;++i)a[t[r][i]]===void 0?a[t[r][i]]=s[i]:q(a[t[r][i]]===s[i],()=>`Expected dimension ${a[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function OP(e,t){const n=e,a=[];let r=0;e.length===0&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);const s=[];for(let i=0;i<n.length;++i){const o=n[i],l=oet(t,o);for(const u of l)s.indexOf(u)===-1&&(a[i].push(u),s.push(u))}return{path:n,steps:a}}function FP(e){return e.every((t,n)=>t===n)}function oet(e,t){const n=[];for(let a=0;a<e.length;++a)(e[a].length===0||e[a].indexOf(t)!==-1||t===-1)&&n.push(a);return n}function MP(e,t,n=0){let a=[];if(typeof t=="number")q(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);q(r<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(s!==-1){const i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}q(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function dne(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function pne(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function fne(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function mne(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function gne(e,t){return`size ${e} must be non-negative, not ${t}`}function yne(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function bne(e,t){const n=_e(e),a=_e(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function xne(e,t){const n=_e(e),a=_e(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function EO(){return"segment ids must be >= 0"}function vne(){return"segment ids are not increasing"}function wne(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Ane(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function Sne(e,t){let n=!1,a;for(e<=vP?(a=e,n=!0):a=TN(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=TN(e,a+1);return a}function kne(e,t,n){const a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function LP(e,t,n,a){const r=t.shape.length,s=e.shape.length;if(a!==0&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (
    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<a;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=a;h<r;h++)o.push(t.shape[h]);for(let h=n+1;h<s;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}const uet=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:LP,computeOutShape:kne,segOpComputeOptimalWindowSize:Sne},Symbol.toStringTag,{value:"Module"}));function sc(e){try{return e.map(t=>tc(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Ine(e){return e.map(t=>Xl(t))}const Nne=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:IP,ERF_A2:NP,ERF_A3:CP,ERF_A4:TP,ERF_A5:EP,ERF_P:kP,PARALLELIZE_THRESHOLD:vP,get RowPartitionType(){return rl},SELU_SCALE:DE,SELU_SCALEALPHA:RE,applyActivation:SE,assertAndGetBroadcastShape:Mt,assertAxesAreInnerMostDims:es,assertParamsConsistent:xP,assignToTypedArray:une,axesAreInnerMostDims:NB,calculateShapes:bd,checkEinsumDimSizes:DP,checkPadOnDimRoundingMode:Ls,combineLocations:Uee,combineRaggedTensorToTensorShapes:nne,complexWithEvenIndex:one,complexWithOddIndex:lne,computeConv2DInfo:Br,computeConv3DInfo:pd,computeDefaultPad:lB,computeDilation2DInfo:YA,computeOptimalWindowSize:_E,computeOutAndReduceShapes:Pr,computeOutShape:Ql,computePool2DInfo:Wo,computePool3DInfo:yc,convertConv2DDataFormat:bc,decodeEinsumEquation:_P,eitherStridesOrDilationsAreOne:Jr,expandShapeToKeepDim:Ba,exponent:hne,exponents:cne,fromStringArrayToUint8:Ine,fromUint8ToStringArray:sc,getAxesPermutation:$a,getBroadcastDims:Xp,getComplexWithIndex:$P,getEinsumComputePath:OP,getEinsumPermutation:RP,getFusedBiasGradient:AE,getFusedDyActivation:wE,getImageCenter:wP,getInnerMostAxes:Ua,getPermuted:mS,getRaggedRank:rne,getReductionAxes:nr,getReshaped:fS,getReshapedPermuted:gS,getRowPartitionTypesHelper:ane,getSliceBeginCoords:AP,getSliceSize:SP,getSparseFillEmptyRowsIndicesDenseShapeMismatch:dne,getSparseFillEmptyRowsNegativeIndexErrorMessage:pne,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:fne,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:yne,getSparseReshapeInputOutputMismatchErrorMessage:xne,getSparseReshapeInputOutputMultipleErrorMessage:bne,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:mne,getSparseReshapeNegativeOutputDimErrorMessage:gne,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Ane,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:EO,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:vne,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:wne,getUndoAxesPermutation:fd,isIdentityPermutation:FP,log:eKe,mergeRealAndImagArrays:rc,prepareAndValidate:EE,prepareSplitSize:MP,segment_util:uet,shouldFuse:kE,slice_util:ene,splitRealAndImagArrays:ine,stridesOrDilationsArePositive:Kp,tupleValuesAreOne:Ph,upcastType:ei,validateDefaultValueShape:sne,validateInput:gE,validateUpdateShape:KB,warn:qi},Symbol.toStringTag,{value:"Module"}));const cet=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:IE,nonMaxSuppressionV4Impl:NE,nonMaxSuppressionV5Impl:CE,whereImpl:xE},Symbol.toStringTag,{value:"Module"}));AJe();const het=Object.freeze(Object.defineProperty({__proto__:null,Abs:H1,Acos:dx,Acosh:px,AdadeltaOptimizer:rP,AdagradOptimizer:sP,AdamOptimizer:iP,AdamaxOptimizer:oP,Add:Pm,AddN:j1,All:BC,Any:PC,ArgMax:q1,ArgMin:K1,Asin:fx,Asinh:mx,Atan:gx,Atan2:bx,Atanh:yx,AvgPool:X1,AvgPool3D:Y1,AvgPool3DGrad:UC,AvgPoolGrad:VC,BatchMatMul:Q1,BatchToSpaceND:Z1,Bincount:WC,BitwiseAnd:J1,BroadcastArgs:GC,BroadcastTo:aee,Cast:xx,Ceil:vx,ClipByValue:wx,Complex:HC,ComplexAbs:eA,Concat:tA,Conv2D:nA,Conv2DBackpropFilter:jC,Conv2DBackpropInput:aA,Conv3D:rA,Conv3DBackpropFilterV2:qC,Conv3DBackpropInputV2:KC,Cos:Ax,Cosh:Sx,CropAndResize:YC,Cumprod:XC,Cumsum:sA,DataStorage:Mz,DenseBincount:QC,DepthToSpace:ZC,DepthwiseConv2dNative:iA,DepthwiseConv2dNativeBackpropFilter:JC,DepthwiseConv2dNativeBackpropInput:eT,Diag:tT,Dilation2D:oA,Dilation2DBackpropFilter:$N,Dilation2DBackpropInput:EN,Draw:nT,get ENV(){return Vz},Einsum:aT,Elu:Ix,EluGrad:rT,Environment:tee,Equal:lA,Erf:Nx,Exp:Cx,ExpandDims:uA,Expm1:Tx,FFT:sT,Fill:iT,FlipLeftRight:oT,Floor:Ex,FloorDiv:$x,FromPixels:_N,FusedBatchNorm:cA,FusedConv2D:xw,FusedDepthwiseConv2D:vw,GatherNd:lT,GatherV2:hA,Greater:dA,GreaterEqual:_x,IFFT:uT,Identity:Rx,Imag:cT,IsFinite:Dx,IsInf:Ox,IsNan:Fx,KernelBackend:MC,LRN:xA,LRNGrad:dT,LeakyRelu:pA,Less:fA,LessEqual:mA,LinSpace:hT,Log:Mx,Log1p:Lx,LogSoftmax:ree,LogicalAnd:gA,LogicalNot:yA,LogicalOr:bA,LogicalXor:X8e,LowerBound:Y8e,MatrixBandPart:Q8e,Max:vA,MaxPool:wA,MaxPool3D:AA,MaxPool3DGrad:fT,MaxPoolGrad:pT,MaxPoolWithArgmax:mT,Maximum:zx,Mean:SA,Min:kA,Minimum:Bx,MirrorPad:IA,Mod:Px,MomentumOptimizer:lP,Multinomial:gT,Multiply:Vx,Neg:NA,NonMaxSuppressionV3:yT,NonMaxSuppressionV4:bT,NonMaxSuppressionV5:xT,NotEqual:CA,OP_SCOPE_SUFFIX:qz,OneHot:EA,OnesLike:TA,Optimizer:Ac,OptimizerConstructors:tne,Pack:$A,PadV2:_A,Pool:Z8e,Pow:Ux,Prelu:RA,Prod:DA,RMSPropOptimizer:uP,RaggedGather:vT,RaggedRange:wT,RaggedTensorToTensor:AT,Range:ST,get Rank(){return dO},Real:kT,RealDiv:kx,Reciprocal:Wx,get Reduction(){return Is},Relu:Gx,Relu6:Hx,Reshape:OA,ResizeBilinear:MA,ResizeBilinearGrad:NT,ResizeNearestNeighbor:FA,ResizeNearestNeighborGrad:IT,Reverse:LA,RotateWithOffset:WT,Round:jx,Rsqrt:qx,SGDOptimizer:TE,ScatterNd:CT,SearchSorted:ET,Select:zA,Selu:Kx,Sigmoid:Zx,Sign:Qx,Sin:Xx,Sinh:Yx,Slice:BA,Softmax:WA,Softplus:Jx,SpaceToBatchND:VA,SparseFillEmptyRows:$T,SparseReshape:_T,SparseSegmentMean:RT,SparseSegmentSum:DT,SparseToDense:OT,SplitV:UA,Sqrt:e0,Square:FT,SquaredDifference:t0,StaticRegexReplace:GA,Step:i0,StridedSlice:MT,StringNGrams:LT,StringSplit:zT,StringToHashBucketFast:BT,Sub:n0,Sum:PA,Tan:a0,Tanh:r0,Tensor:In,TensorBuffer:er,TensorScatterUpdate:TT,Tile:s0,TopK:PT,Transform:VT,Transpose:bp,Unique:UT,Unpack:HA,UnsortedSegmentSum:jA,UpperBound:J8e,Variable:Sw,ZerosLike:qA,_FusedMatMul:bw,abs:Xa,acos:eB,acosh:tB,add:Ue,addN:Fee,all:qT,any:Iw,argMax:qp,argMin:nB,asin:aB,asinh:rB,atan:sB,atan2:iB,atanh:oB,avgPool:QA,avgPool3d:uB,backend:Xz,backend_util:Nne,basicLSTMCell:Mee,batchNorm:o0,batchNorm2d:cB,batchNorm3d:hB,batchNorm4d:dB,batchToSpaceND:ZA,bincount:pB,bitwiseAnd:Lee,booleanMaskAsync:wte,broadcastArgs:zee,broadcastTo:xp,broadcast_util:_7e,browser:ZJe,buffer:Gt,cast:Xe,ceil:fB,clipByValue:ni,clone:Yl,complex:nc,concat:za,concat1d:mB,concat2d:gB,concat3d:yB,concat4d:bB,conv1d:KT,conv2d:ac,conv2dTranspose:XT,conv3d:vB,conv3dTranspose:wB,copyRegisteredKernels:aKe,cos:JA,cosh:YT,cosineWindow:vE,cumprod:Tw,cumsum:QT,customGrad:ou,denseBincount:ON,deprecationWarn:MKe,depthToSpace:AB,depthwiseConv2d:l0,device_util:$Ke,diag:Pee,dilation2d:SB,disableDeprecationWarnings:FKe,dispose:Yt,disposeVariables:xee,div:gt,divNoNan:kB,dot:IB,dropout:JB,einsum:sp,elu:u0,enableDebugMode:OKe,enableProdMode:DKe,enclosingPowerOfTwo:eP,engine:tl,ensureShape:Vee,env:Ie,equal:Bo,erf:ZT,euclideanNorm:CB,exp:ai,expandDims:us,expm1:TB,eye:JT,fft:dS,fill:Vm,findBackend:VKe,findBackendFactory:UKe,floor:h0,floorDiv:jT,fused:$te,gather:d0,gatherND:Ite,gather_util:JJe,getBackend:wee,getGradient:cO,getKernel:Aw,getKernelsForBackend:RN,grad:f9e,grads:m9e,greater:ii,greaterEqual:xc,ifft:Dy,imag:eS,image:sl,inTopKAsync:Nte,io:dP,irfft:fE,isFinite:EB,isInf:$B,isNaN:_B,keep:dr,kernel_impls:cet,leakyRelu:tS,less:Ey,lessEqual:md,linalg:aP,linspace:Gee,localResponseNormalization:RB,log:Di,log1p:nS,logSigmoid:DB,logSoftmax:tE,logSumExp:aS,logicalAnd:yl,logicalNot:rS,logicalOr:nE,logicalXor:OB,losses:Lte,lowerBound:jee,matMul:Kt,math:UJe,max:ao,maxPool:sS,maxPool3d:FB,maxPoolWithArgmax:qee,maximum:mu,mean:Sa,memory:bO,meshgrid:Kee,min:Ty,minimum:Uh,mirrorPad:MB,mod:LB,moments:iS,movingAverage:Ate,mul:he,multiRNNCell:Xee,multinomial:Yee,neg:ia,nextFrame:bP,norm:c0,notEqual:Yp,oneHot:$y,ones:qs,onesLike:Oi,op:oe,outerProduct:Qee,pad:vc,pad1d:Zee,pad2d:Jee,pad3d:ete,pad4d:tte,pool:zB,pow:iu,prelu:lS,print:Jz,prod:BB,profile:LKe,raggedGather:nte,raggedRange:ate,raggedTensorToTensor:rte,rand:ste,randomGamma:lte,randomNormal:sE,randomStandardNormal:ute,randomUniform:gd,randomUniformInt:cte,range:Qp,ready:vee,real:_y,reciprocal:WB,registerBackend:Kz,registerGradient:see,registerKernel:GT,relu:kl,relu6:iE,removeBackend:PKe,reshape:me,reverse:oo,reverse1d:hte,reverse2d:dte,reverse3d:pte,reverse4d:fte,rfft:pS,round:oE,rsqrt:lE,scalar:kt,scatterND:Ste,scatter_util:xQe,searchSorted:aE,selu:uE,separableConv2d:cE,serialization:vJe,setBackend:BKe,setPlatform:WKe,setdiff1dAsync:mte,sigmoid:cl,sign:GB,signal:Mte,sin:hE,sinh:dE,slice:ln,slice1d:uS,slice2d:pE,slice3d:cS,slice4d:Ry,slice_util:ene,softmax:hS,softplus:Um,spaceToBatchND:oS,sparse:zte,sparseToDense:kte,spectral:Fte,split:Ys,sqrt:Lr,square:Vn,squaredDifference:mE,squeeze:yd,stack:ri,step:Wm,stridedSlice:HB,string:Bte,sub:it,sum:ct,sumOutType:HT,tan:jB,tanh:Vh,tensor:Lo,tensor1d:cs,tensor2d:sy,tensor3d:qB,tensor4d:gte,tensor5d:yte,tensor6d:bte,tensorScatterUpdate:xte,tensor_util:IKe,test_util:RYe,tidy:Se,tile:Ji,time:zKe,topk:XB,train:Zd,transpose:an,truncatedNormal:yE,unique:YB,unregisterGradient:nKe,unregisterKernel:tKe,unsortedSegmentSum:bE,unstack:lo,upcastType:ei,upperBound:vte,util:dKe,valueAndGrad:g9e,valueAndGrads:y9e,variable:QB,variableGrads:Hee,version_core:ret,where:Xr,whereAsync:ZB,zeros:Ya,zerosLike:cn},Symbol.toStringTag,{value:"Module"}));const Cne={kernelName:H1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(e,Wm(Xe(n,"float32"),-1))}}};const det={kernelName:dx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const a=Vn(Xe(n,"float32")),r=Lr(it(kt(1),a));return ia(gt(e,r))}}}};const pet={kernelName:px,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const a=Lr(it(Vn(Xe(n,"float32")),1));return gt(e,a)}}}};const fet={kernelName:Pm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Mt(n.shape,a.shape);return{a:()=>{let o=e;const l=nr(n.shape,r);return l.length>0&&(o=ct(o,l)),me(o,n.shape)},b:()=>{let o=e;const l=nr(a.shape,r);return l.length>0&&(o=ct(o,l)),me(o,a.shape)}}}};const met={kernelName:j1,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((a,r)=>{n[r]=()=>e.clone()}),n}};const get={kernelName:q1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cn(n)}}};const yet={kernelName:K1,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>cn(n)}}};const bet={kernelName:fx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,Lr(it(kt(1),Vn(Xe(n,"float32")))))}}};const xet={kernelName:mx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const a=Lr(Ue(kt(1),Vn(Xe(n,"float32"))));return gt(e,a)}}}};const vet={kernelName:bx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Mt(n.shape,a.shape);return{a:()=>{const o=Ue(Vn(n),Vn(a));let l=he(e,gt(a,o));const u=nr(n.shape,r);return u.length>0&&(l=ct(l,u)),me(l,n.shape)},b:()=>{const o=Ue(Vn(n),Vn(a));let l=ia(he(e,gt(n,o)));const u=nr(a.shape,r);return u.length>0&&(l=ct(l,u)),me(l,a.shape)}}}};const wet={kernelName:gx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,Ue(Vn(Xe(n,"float32")),1))}}};const Aet={kernelName:yx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,it(kt(1),Vn(Xe(n,"float32"))))}}};function ket(e,t,n,a,r,s){const i=X(e,"dy","avgPool3dGrad"),o=X(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;o.rank===4&&(c=!0,l=me(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=me(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),q(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),q(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Ls("avgPool3dGrad",r,s);const h={dy:l,input:u},p={filterSize:n,strides:a,pad:r,dimRoundingMode:s},m=se.runKernel(UC,h,p);return c?me(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const Iet=oe({avgPool3dGrad_:ket});const Net={kernelName:Y1,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>Iet(e,a,r,s,i,o)}}};function Cet(e,t,n,a,r){const s=X(e,"dy","avgPoolGrad"),i=X(t,"input","avgPoolGrad");q(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,u=!1;i.rank===3&&(u=!0,o=me(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=me(s,[1,s.shape[0],s.shape[1],s.shape[2]])),q(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),q(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:l,input:o},h={filterSize:n,strides:a,pad:r},p=se.runKernel(VC,c,h);return u?me(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Tet=oe({avgPoolGrad_:Cet});const Eet={kernelName:X1,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>Tet(e,a,r,s,i)}}};const $et={kernelName:Q1,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>Kt(e,r,!1,!0),b:()=>Kt(a,e,!0,!1)}:!s&&i?{a:()=>Kt(e,r,!1,!1),b:()=>Kt(e,a,!0,!1)}:s&&!i?{a:()=>Kt(r,e,!1,!0),b:()=>Kt(a,e,!1,!1)}:{a:()=>Kt(r,e,!0,!0),b:()=>Kt(e,a,!0,!0)}}};const _et={kernelName:Z1,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>oS(e,a,r)}}};const Ret={kernelName:aee,gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let l=r.length-1;l>=0;l--)if(r[l]===s[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ct(e,o,!0)}}};const Det={kernelName:xx,gradFunc:e=>({x:()=>e.clone()})};const Oet={kernelName:vx,gradFunc:e=>({x:()=>cn(e)})};const Fet={kernelName:wx,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>Xr(yl(xc(a,r),md(a,s)),e,cn(e))}}};const Met={kernelName:eA,inputsToSave:["x"],gradFunc:Cne.gradFunc};const Let={kernelName:tA,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map(l=>l.shape),{axis:r}=n,s=Zt(r,t[0].shape)[0],i=a.map(l=>l[s]);return Ys(e,i,s).map(l=>()=>l)}};const zet={kernelName:nA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return q(Ph(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>xB(a.shape,e,r,i,o,l),filter:()=>tP(a,e,r.shape,i,o,l)}}};const Bet={kernelName:aA,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>ac(e,r,s,i,o,1,l),filter:()=>tP(e,a,r.shape,s,i,o,l)}}};function Pet(e,t,n,a,r){let s=e;e.rank===4&&(s=me(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=me(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),q(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),q(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),q(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),q(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),q(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:s,dy:i},l={strides:a,pad:r,filterShape:n};return se.runKernel(qC,o,l)}const Vet=oe({conv3DBackpropFilter_:Pet});const Uet={kernelName:rA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s}=n;q(Ph(a),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const[i,o]=t;return{x:()=>Bee(i.shape,e,o,r,s),filter:()=>Vet(i,e,o.shape,r,s)}}};const Wet={kernelName:Ax,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(ia(hE(Xe(n,"float32"))),e)}}};const Get={kernelName:Sx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(dE(Xe(n,"float32")),e)}}};const Het={kernelName:sA,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{const o=$a([r],a.rank);let l=QT(e,r,s,!i);return o!=null&&(l=an(l,o)),l}}}};const jet={kernelName:iA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=a??[1,1];q(Ph(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=t;return q(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),q(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),q(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),q(Jr(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Ls("depthwiseConv2d",s,i),{x:()=>Ete(l.shape,e,u,r,s,o,i),filter:()=>Tte(l,e,u.shape,r,s,o,i)}}};const qet={kernelName:oA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,s={x:a,filter:r,dy:e},i={x:a,filter:r,dy:e};return{x:()=>se.runKernel(EN,s,n),filter:()=>se.runKernel($N,i,n)}}};const Ket={kernelName:Ix,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>se.runKernel(rT,a)}}};const Xet={kernelName:Nx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=he(ai(ia(Vn(n))),2/Math.sqrt(Math.PI));return{x:()=>he(e,a)}}};const Yet={kernelName:Cx,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(e,n)}}};const Qet={kernelName:uA,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>me(e,n.shape)}}};const Zet={kernelName:Tx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(e,ai(n))}}};const Jet={kernelName:Ex,gradFunc:e=>({x:()=>cn(e)})};const ett={kernelName:$x,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Mt(n.shape,a.shape);return{a:()=>{const o=gt(e,Xe(a,"float32")),l=nr(n.shape,r);return l.length>0?me(ct(o,l),n.shape):o},b:()=>{let o=he(e,Xe(n,"float32"));const l=nr(a.shape,r);l.length>0&&(o=me(ct(o,l),a.shape));const u=Vn(a);return ia(gt(o,Xe(u,"float32")))}}}};const ttt={kernelName:cA,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,s,i,o]=t,l=o??kt(1),u=nr(s.shape,r.shape),c=[];if(s.rank===1){for(let k=0;k<r.shape.length-1;++k)c.push(r.shape[k]);c.push(1)}const h=it(r,s),p=he(e,l),m=lE(Ue(i,kt(a))),g=he(he(he(m,m),m),kt(-.5));return{x:()=>s.rank===1?me(he(he(e,Ji(me(m,[1,1,1,s.shape[0]]),c)),l),r.shape):me(he(he(e,m),l),r.shape),mean:()=>{let k=he(he(m,kt(-1)),p);return s.rank===1&&(k=ct(k,u)),me(k,s.shape)},variance:()=>{let k=he(he(g,h),p);return s.rank===1&&(k=ct(k,u)),me(k,s.shape)},scale:()=>{const k=he(h,m);let I=he(e,k);return s.rank===1&&(I=ct(I,u)),me(I,s.shape)},offset:()=>{let k=e;return s.rank===1&&(k=ct(k,u)),me(k,s.shape)}}}};const ntt={kernelName:hA,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:s,batchDims:i}=n,o=Zt(s,a.shape)[0],l=(u,c,h)=>()=>{const p=u.shape,m=c.size,g=p.slice(0,o),y=g.length,b=p.slice(s,p.length).slice(1),v=b.length,w=F6(0,y),S=F6(y+1,y+1+v),k=M6([g,[m],b]),I=me(h,k),T=me(c,[m]),E=M6([[y],w,S]),R=an(I,E);let D=bE(R,T,u.shape[o]);const O=fd(E);return D=an(D,O),D};if(i===1){const u=a.shape[0],c=a.split(u,0);return{x:()=>ri(c.map((m,g)=>l(m,r.slice(g,1),e.slice(g,1))())).reshape(a.shape),indices:()=>r}}else return{x:l(a,r,e),indices:()=>r}}};function F6(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function M6(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const att={kernelName:_x,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>cn(n),b:()=>cn(a)}}};const rtt={kernelName:Rx,gradFunc:e=>({x:()=>Xe(e,"float32")})};const stt={kernelName:Dx,gradFunc:e=>({x:()=>cn(e)})};const itt={kernelName:Ox,gradFunc:e=>({x:()=>cn(e)})};const ott={kernelName:Fx,gradFunc:e=>({x:()=>cn(e)})};const ltt={kernelName:pA,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,s=ii(a,0);return{x:()=>Xr(s,e,he(e,r))}}};const utt={kernelName:Lx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,Ue(n,1))}}};const ctt={kernelName:Mx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,Xe(n,"float32"))}}};const htt={kernelName:ree,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const i=ai(a);return it(e,he(ct(e,r,!0),i))}}}};function dtt(e,t,n,a=5,r=1,s=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:a,bias:r,alpha:s,beta:i};return se.runKernel(dT,o,l)}const ptt=oe({localResponseNormalizationBackprop_:dtt});const ftt={kernelName:xA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>ptt(a,r,e,s,i,o,l)}}};function Tne(e,t,n,a){return t.rank<n.rank&&(t=me(t,Ba(t.shape,a))),e.rank<n.rank&&(e=me(e,Ba(e.shape,a))),{x:()=>he(e,Xe(Bo(n,t),e.dtype))}}const L6={kernelName:vA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,s=t[0],i=t[1],o=Zt(r,s.shape),l=Tne(e,i,s,o);return{x:()=>l.x()}}};const mtt={kernelName:zx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>he(e,Xe(xc(n,a),"float32")),b:()=>he(e,Xe(Ey(n,a),"float32"))}}};function gtt(e,t,n,a,r,s,i){const o=X(e,"dy","maxPool3dGrad"),l=X(t,"input","maxPool3dGrad"),u=X(n,"output","maxPool3dGrad");let c=o,h=l,p=u,m=!1;l.rank===4&&(m=!0,c=me(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=me(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=me(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),q(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),q(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),q(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),Ls("maxPool3dGrad",s,i);const g={dy:c,input:h,output:p},y={filterSize:a,strides:r,pad:s,dimRoundingMode:i},b=se.runKernel(fT,g,y);return m?me(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const ytt=oe({maxPool3dGrad_:gtt});const btt={kernelName:AA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>ytt(e,a,r,s,i,o,l)}}};function xtt(e,t,n,a,r,s,i){const o=X(e,"dy","maxPoolGrad"),l=X(t,"input","maxPoolGrad"),u=X(n,"output","maxPoolGrad");q(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),q(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),q(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Ls("maxPoolGrad",s,i);const c={dy:o,input:l,output:u},h={filterSize:a,strides:r,pad:s,dimRoundingMode:i};return se.runKernel(pT,c,h)}const vtt=oe({maxPoolGrad_:xtt});const wtt={kernelName:wA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>vtt(e,a,r,s,i,o)}}};const Att={kernelName:SA,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,s=Zt(r,a.shape),o=Pr(a.shape,s)[1],l=_e(o);return{x:()=>{const c=a.shape.slice();s.forEach(m=>{c[m]=1});const h=me(e,c);return gt(he(h,qs(a.shape,"float32")),l)}}}};const Stt={kernelName:kA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[s,i]=t,o=Zt(r,s.shape),l=Tne(e,i,s,o);return{x:()=>l.x()}}};const ktt={kernelName:Bx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>he(e,Xe(md(n,a),"float32")),b:()=>he(e,Xe(ii(n,a),"float32"))}}};const Itt={kernelName:IA,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>ln(e,s,a.shape)}}};const Ntt={kernelName:Px,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Mt(n.shape,a.shape);return{a:()=>{const o=nr(n.shape,r);return o.length>0?me(ct(e,o),n.shape):e},b:()=>{const o=he(e,ia(h0(gt(n,a)))),l=nr(a.shape,r);return l.length>0?me(ct(o,l),a.shape):o}}}};const Ctt={kernelName:Vx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Mt(n.shape,a.shape);return{a:()=>{const o=he(e,Xe(a,"float32")),l=nr(n.shape,r);return l.length>0?me(ct(o,l),n.shape):o},b:()=>{const o=he(e,Xe(n,"float32")),l=nr(a.shape,r);return l.length>0?me(ct(o,l),a.shape):o}}}};const Ttt={kernelName:NA,gradFunc:e=>({x:()=>ia(e)})};const Ett={kernelName:EA,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Ya(n.shape,"float32")}}};const $tt={kernelName:TA,gradFunc:e=>({x:()=>cn(e)})};const _tt={kernelName:$A,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return lo(e,a).map(s=>()=>s)}};const z6={kernelName:_A,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>ln(e,s,a.shape)}}};const Rtt={kernelName:Ux,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,s=n,i=a,o=Mt(s.shape,i.shape);return{a:()=>{const c=Xe(i,"float32");let h=he(e,he(c,iu(s,it(c,kt(1)))));const p=nr(s.shape,o);return p.length>0&&(h=ct(h,p)),me(h,s.shape)},b:()=>{const c=ii(s,0),h=Xr(c,Di(s),cn(s));let p=he(e,he(r,h));const m=nr(i.shape,o);return m.length>0&&(p=ct(p,m)),me(p,i.shape)}}}};const Dtt={kernelName:RA,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=ii(n,0);return{x:()=>Xr(r,e,he(e,a)),alpha:()=>{let s=Xr(r,cn(e),he(e,n));const i=nr(a.shape,e.shape);return i.length>0&&(s=ct(s,i)),me(s,a.shape)}}}};function Ott(e,t,n){const a=e.shape.slice();a[n]=1;const r=me(t,a),s=Tw(e,n,!0,!1),i=Tw(e,n,!0,!0),o=he(s,i);return he(r,o)}function Ftt(e,t,n){const a=e.shape.length,r=a-n.length,s=$a(n,a);let i=e;s!=null&&(i=an(e,s));const o=i.shape.slice(),u=o.splice(a-n.length,n.length).reduce((p,m)=>p*m,1);o.push(u);const c=i.reshape(o);let h=Ott(c,t,r);if(h=h.reshape(i.shape),s!=null){const p=fd(s);h=an(h,p)}return h}const Mtt={kernelName:DA,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;let s=[];return r==null?s=a.shape.map((i,o)=>o):typeof r=="number"?s=[r]:s=r,{x:()=>Ftt(a,e,s)}}};const Ltt={kernelName:kx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Mt(n.shape,a.shape);return{a:()=>{const o=gt(e,Xe(a,"float32")),l=nr(n.shape,r);return l.length>0?me(ct(o,l),n.shape):o},b:()=>{let o=he(e,Xe(n,"float32"));const l=nr(a.shape,r);l.length>0&&(o=me(ct(o,l),a.shape));const u=Vn(a);return ia(gt(o,Xe(u,"float32")))}}}};const ztt={kernelName:Wx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,ia(Vn(n)))}}};const Btt={kernelName:Hx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=he(md(n,6),Wm(n));return{x:()=>he(e,Xe(a,"float32"))}}};const Ptt={kernelName:Gx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(e,Xe(Wm(n),"float32"))}}};const Vtt={kernelName:OA,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,n.shape)}}};const Utt={kernelName:MA,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>se.runKernel(NT,r,n)}}};const Wtt={kernelName:FA,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>se.runKernel(IT,r,n)}}};const Gtt={kernelName:LA,gradFunc:(e,t,n)=>{const{dims:a}=n,r=Zt(a,e.shape);return{x:()=>oo(e,r)}}};const Htt={kernelName:jx,gradFunc:e=>({x:()=>cn(e)})};const jtt={kernelName:qx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ia(gt(e,he(iu(n,1.5),2)))}}};const qtt={kernelName:zA,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Xe(cn(n),"float32"),t:()=>he(e,Xe(n,e.dtype)),e:()=>he(e,Xe(rS(n),e.dtype))}}};const Ktt={kernelName:Kx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const a=ii(n,kt(0)),r=kt(RE),s=kt(DE),i=he(e,s),o=he(he(e,r),ai(Xe(n,"float32")));return Xr(a,i,o)}}}};const Xtt={kernelName:Zx,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(e,he(n,it(kt(1),n)))}}};const Ytt={kernelName:Qx,gradFunc:e=>({x:()=>cn(e)})};const Qtt={kernelName:Xx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(JA(Xe(n,"float32")),e)}}};const Ztt={kernelName:Yx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(YT(Xe(n,"float32")),e)}}};const Jtt={kernelName:BA,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:s}=n,i=a.shape,[o,l]=$E(a,r,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>vc(e,u)}}};const ent={kernelName:WA,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,s=!0,i=he(e,a);return{logits:()=>it(i,he(ct(i,[r],s),a))}}};const tnt={kernelName:Jx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(e,cl(n))}}};const B6={kernelName:VA,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>ZA(e,a,r)}}};const P6={kernelName:UA,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>za(e,a)}}};const nnt={kernelName:e0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,he(Lr(Xe(n,"float32")),2))}}};const ant={kernelName:FT,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(e,he(Xe(n,"float32"),2))}}};const rnt={kernelName:t0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=kt(2);return{a:()=>he(e,he(r,it(n,a))),b:()=>he(e,he(r,it(a,n)))}}};const snt={kernelName:i0,gradFunc:e=>({x:()=>cn(e)})};const int={kernelName:n0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Mt(n.shape,a.shape);return{a:()=>{let o=e;const l=nr(n.shape,r);return l.length>0&&(o=ct(o,l)),me(o,n.shape)},b:()=>{let o=e;const l=nr(a.shape,r);return l.length>0&&(o=ct(o,l)),me(ia(o),a.shape)}}}};const ont={kernelName:PA,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:s}=n;Zt(s,a.shape).forEach(u=>{r[u]=1});const o=me(e,r),l=he(o,qs(a.shape,"float32"));return{x:()=>l}}};const lnt={kernelName:a0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gt(e,Vn(JA(n)))}}};const unt={kernelName:r0,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>he(it(kt(1),Vn(n)),e)}}};const cnt={kernelName:s0,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let i=cn(a);if(a.rank===1)for(let o=0;o<r[0];++o)i=Ue(i,ln(e,[o*a.shape[0]],[a.shape[0]]));else if(a.rank===2)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)i=Ue(i,ln(e,[o*a.shape[0],l*a.shape[1]],[a.shape[0],a.shape[1]]));else if(a.rank===3)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)i=Ue(i,ln(e,[o*a.shape[0],l*a.shape[1],u*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else if(a.rank===4)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)i=Ue(i,ln(e,[o*a.shape[0],l*a.shape[1],u*a.shape[2],c*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);return i}}}};const hnt={kernelName:bp,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,s=fd(r);return{x:()=>an(e,s)}}};const dnt={kernelName:HA,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>ri(e,r)}}};const pnt={kernelName:jA,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fnt(e,n)}}};function fnt(e,t){const n=mu(t,cn(t)),a=d0(e,n);let r=xc(t,kt(0,"int32"));const s=a.rank-r.rank;for(let o=0;o<s;++o)r=us(r,o+1);r=yl(r,qs(a.shape,"bool"));const i=cn(a);return Xr(r,a,i)}const mnt={kernelName:qA,gradFunc:e=>({x:()=>cn(e)})};const gnt=[Cne,det,pet,fet,met,get,yet,bet,xet,vet,wet,Aet,Net,Eet,$et,_et,Ret,Det,Oet,Fet,Met,Let,Bet,zet,Uet,Wet,Get,Het,jet,qet,Ltt,Ket,Xet,Yet,Qet,Zet,ett,Jet,ttt,ntt,att,rtt,stt,itt,ott,ltt,utt,ctt,htt,ftt,L6,L6,mtt,btt,wtt,Att,Stt,ktt,Itt,Ntt,Ctt,Ttt,Ett,$tt,_tt,z6,z6,Rtt,Dtt,Mtt,ztt,Btt,Ptt,Vtt,Utt,Wtt,Gtt,Htt,jtt,qtt,Ktt,Xtt,Ytt,Qtt,Ztt,Jtt,ent,tnt,B6,B6,P6,P6,nnt,rnt,ant,snt,int,ont,lnt,unt,cnt,hnt,dnt,pnt,mnt];for(const e of gnt)see(e);Fe().prototype.abs=function(){return this.throwIfDisposed(),Xa(this)};Fe().prototype.acos=function(){return this.throwIfDisposed(),eB(this)};Fe().prototype.acosh=function(){return this.throwIfDisposed(),tB(this)};Fe().prototype.add=function(e){return this.throwIfDisposed(),Ue(this,e)};Fe().prototype.all=function(e,t){return this.throwIfDisposed(),qT(this,e,t)};Fe().prototype.any=function(e,t){return this.throwIfDisposed(),Iw(this,e,t)};Fe().prototype.argMax=function(e){return this.throwIfDisposed(),qp(this,e)};Fe().prototype.argMin=function(e){return this.throwIfDisposed(),nB(this,e)};Fe().prototype.asScalar=function(){return this.throwIfDisposed(),q(this.size===1,()=>"The array must have only 1 element."),me(this,[])};Fe().prototype.asType=function(e){return this.throwIfDisposed(),Xe(this,e)};Fe().prototype.as1D=function(){return this.throwIfDisposed(),me(this,[this.size])};Fe().prototype.as2D=function(e,t){return this.throwIfDisposed(),me(this,[e,t])};Fe().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),me(this,[e,t,n])};Fe().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),me(this,[e,t,n,a])};Fe().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),me(this,[e,t,n,a,r])};Fe().prototype.asin=function(){return this.throwIfDisposed(),aB(this)};Fe().prototype.asinh=function(){return this.throwIfDisposed(),rB(this)};Fe().prototype.atan=function(){return this.throwIfDisposed(),sB(this)};Fe().prototype.atan2=function(e){return this.throwIfDisposed(),iB(this,e)};Fe().prototype.atanh=function(){return this.throwIfDisposed(),oB(this)};Fe().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),QA(this,e,t,n,a)};Fe().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),ZA(this,e,t)};Fe().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),o0(this,e,t,n,a,r)};Fe().prototype.broadcastTo=function(e){return this.throwIfDisposed(),xp(this,e)};Fe().prototype.cast=function(e){return this.throwIfDisposed(),Xe(this,e)};Fe().prototype.ceil=function(){return this.throwIfDisposed(),fB(this)};Fe().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),ni(this,e,t)};Fe().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof In&&(e=[e]),za([this,...e],t)};Fe().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),KT(this,e,t,n,a,r,s)};Fe().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),XT(this,e,t,n,a,r)};Fe().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),ac(this,e,t,n,a,r,s)};Fe().prototype.cos=function(){return this.throwIfDisposed(),JA(this)};Fe().prototype.cosh=function(){return this.throwIfDisposed(),YT(this)};Fe().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Tw(this,e,t,n)};Fe().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),QT(this,e,t,n)};Fe().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),AB(this,e,t)};Fe().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),l0(this,e,t,n,a,r,s)};Fe().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),SB(this,e,t,n,a,r)};Fe().prototype.divNoNan=function(e){return this.throwIfDisposed(),kB(this,e)};Fe().prototype.div=function(e){return this.throwIfDisposed(),gt(this,e)};Fe().prototype.dot=function(e){return this.throwIfDisposed(),IB(this,e)};Fe().prototype.elu=function(){return this.throwIfDisposed(),u0(this)};Fe().prototype.equal=function(e){return this.throwIfDisposed(),Bo(this,e)};Fe().prototype.erf=function(){return this.throwIfDisposed(),ZT(this)};Fe().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),CB(this,e,t)};Fe().prototype.exp=function(){return this.throwIfDisposed(),ai(this)};Fe().prototype.expandDims=function(e){return this.throwIfDisposed(),us(this,e)};Fe().prototype.expm1=function(){return this.throwIfDisposed(),TB(this)};Fe().prototype.fft=function(){return this.throwIfDisposed(),dS(this)};Fe().prototype.flatten=function(){return this.throwIfDisposed(),me(this,[this.size])};Fe().prototype.floor=function(){return this.throwIfDisposed(),h0(this)};Fe().prototype.floorDiv=function(e){return this.throwIfDisposed(),jT(this,e)};Fe().prototype.gather=function(e,t,n){return this.throwIfDisposed(),d0(this,e,t,n)};Fe().prototype.greaterEqual=function(e){return this.throwIfDisposed(),xc(this,e)};Fe().prototype.greater=function(e){return this.throwIfDisposed(),ii(this,e)};Fe().prototype.ifft=function(){return this.throwIfDisposed(),Dy(this)};Fe().prototype.irfft=function(){return this.throwIfDisposed(),fE(this)};Fe().prototype.isFinite=function(){return this.throwIfDisposed(),EB(this)};Fe().prototype.isInf=function(){return this.throwIfDisposed(),$B(this)};Fe().prototype.isNaN=function(){return this.throwIfDisposed(),_B(this)};Fe().prototype.leakyRelu=function(e){return this.throwIfDisposed(),tS(this,e)};Fe().prototype.lessEqual=function(e){return this.throwIfDisposed(),md(this,e)};Fe().prototype.less=function(e){return this.throwIfDisposed(),Ey(this,e)};Fe().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),RB(this,e,t,n,a)};Fe().prototype.logSigmoid=function(){return this.throwIfDisposed(),DB(this)};Fe().prototype.logSoftmax=function(e){return this.throwIfDisposed(),tE(this,e)};Fe().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),aS(this,e,t)};Fe().prototype.log=function(){return this.throwIfDisposed(),Di(this)};Fe().prototype.log1p=function(){return this.throwIfDisposed(),nS(this)};Fe().prototype.logicalAnd=function(e){return this.throwIfDisposed(),yl(this,e)};Fe().prototype.logicalNot=function(){return this.throwIfDisposed(),rS(this)};Fe().prototype.logicalOr=function(e){return this.throwIfDisposed(),nE(this,e)};Fe().prototype.logicalXor=function(e){return this.throwIfDisposed(),OB(this,e)};Fe().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Kt(this,e,t,n)};Fe().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),sS(this,e,t,n,a)};Fe().prototype.max=function(e,t){return this.throwIfDisposed(),ao(this,e,t)};Fe().prototype.maximum=function(e){return this.throwIfDisposed(),mu(this,e)};Fe().prototype.mean=function(e,t){return this.throwIfDisposed(),Sa(this,e,t)};Fe().prototype.min=function(e,t){return this.throwIfDisposed(),Ty(this,e,t)};Fe().prototype.minimum=function(e){return this.throwIfDisposed(),Uh(this,e)};Fe().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),MB(this,e,t)};Fe().prototype.mod=function(e){return this.throwIfDisposed(),LB(this,e)};Fe().prototype.mul=function(e){return this.throwIfDisposed(),he(this,e)};Fe().prototype.neg=function(){return this.throwIfDisposed(),ia(this)};Fe().prototype.norm=function(e,t,n){return this.throwIfDisposed(),c0(this,e,t,n)};Fe().prototype.notEqual=function(e){return this.throwIfDisposed(),Yp(this,e)};Fe().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),$y(this,e,t,n)};Fe().prototype.onesLike=function(){return this.throwIfDisposed(),Oi(this)};Fe().prototype.pad=function(e,t){return this.throwIfDisposed(),vc(this,e,t)};Fe().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),zB(this,e,t,n,a,r,s)};Fe().prototype.pow=function(e){return this.throwIfDisposed(),iu(this,e)};Fe().prototype.prelu=function(e){return this.throwIfDisposed(),lS(this,e)};Fe().prototype.prod=function(e,t){return this.throwIfDisposed(),BB(this,e,t)};Fe().prototype.reciprocal=function(){return this.throwIfDisposed(),WB(this)};Fe().prototype.relu=function(){return this.throwIfDisposed(),kl(this)};Fe().prototype.relu6=function(){return this.throwIfDisposed(),iE(this)};Fe().prototype.reshapeAs=function(e){return this.throwIfDisposed(),me(this,e.shape)};Fe().prototype.reshape=function(e){return this.throwIfDisposed(),me(this,e)};Fe().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Dte(this,e,t,n)};Fe().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Ote(this,e,t,n)};Fe().prototype.reverse=function(e){return this.throwIfDisposed(),oo(this,e)};Fe().prototype.rfft=function(){return this.throwIfDisposed(),pS(this)};Fe().prototype.round=function(){return this.throwIfDisposed(),oE(this)};Fe().prototype.rsqrt=function(){return this.throwIfDisposed(),lE(this)};Fe().prototype.selu=function(){return this.throwIfDisposed(),uE(this)};Fe().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),cE(this,e,t,n,a,r,s)};Fe().prototype.sigmoid=function(){return this.throwIfDisposed(),cl(this)};Fe().prototype.sign=function(){return this.throwIfDisposed(),GB(this)};Fe().prototype.sin=function(){return this.throwIfDisposed(),hE(this)};Fe().prototype.sinh=function(){return this.throwIfDisposed(),dE(this)};Fe().prototype.slice=function(e,t){return this.throwIfDisposed(),ln(this,e,t)};Fe().prototype.softmax=function(e){return this.throwIfDisposed(),hS(this,e)};Fe().prototype.softplus=function(){return this.throwIfDisposed(),Um(this)};Fe().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),oS(this,e,t)};Fe().prototype.split=function(e,t){return this.throwIfDisposed(),Ys(this,e,t)};Fe().prototype.sqrt=function(){return this.throwIfDisposed(),Lr(this)};Fe().prototype.square=function(){return this.throwIfDisposed(),Vn(this)};Fe().prototype.squaredDifference=function(e){return this.throwIfDisposed(),mE(this,e)};Fe().prototype.squeeze=function(e){return this.throwIfDisposed(),yd(this,e)};Fe().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof In?[this,e]:[this,...e];return ri(n,t)};Fe().prototype.step=function(e){return this.throwIfDisposed(),Wm(this,e)};Fe().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),HB(this,e,t,n,a,r,s,i,o)};Fe().prototype.sub=function(e){return this.throwIfDisposed(),it(this,e)};Fe().prototype.sum=function(e,t){return this.throwIfDisposed(),ct(this,e,t)};Fe().prototype.tan=function(){return this.throwIfDisposed(),jB(this)};Fe().prototype.tanh=function(){return this.throwIfDisposed(),Vh(this)};Fe().prototype.tile=function(e){return this.throwIfDisposed(),Ji(this,e)};Fe().prototype.toBool=function(){return this.throwIfDisposed(),Xe(this,"bool")};Fe().prototype.toFloat=function(){return this.throwIfDisposed(),Xe(this,"float32")};Fe().prototype.toInt=function(){return this.throwIfDisposed(),Xe(this,"int32")};Fe().prototype.topk=function(e,t){return this.throwIfDisposed(),XB(this,e,t)};Fe().prototype.transpose=function(e){return this.throwIfDisposed(),an(this,e)};Fe().prototype.unique=function(e){return this.throwIfDisposed(),YB(this,e)};Fe().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),bE(this,e,t)};Fe().prototype.unstack=function(e){return this.throwIfDisposed(),lo(this,e)};Fe().prototype.where=function(e,t){return this.throwIfDisposed(),Xr(e,this,t)};Fe().prototype.zerosLike=function(){return this.throwIfDisposed(),cn(this)};class Bl extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Bl.prototype)}}class Oo extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Oo.prototype)}}class ye extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ye.prototype)}}class jt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,jt.prototype)}}class zP extends Error{constructor(t){super(t),Object.setPrototypeOf(this,zP.prototype)}}class Ene{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let n;return this.cache.has(t)&&(n=this.cache.get(t),this.cache.delete(t),this.cache.set(t,n)),n}put(t,n){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const a=this.cache.keys().next().value;this.cache.delete(a)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let n=0;n<this.maxEntries-t;n++){const a=this.cache.keys().next().value;this.cache.delete(a)}this.maxEntries=t}}function Jp(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}else{const n=new Array(t);return n.fill(e),n}}function Pl(e,t){if(!e)throw new zP(t)}function V6(e,t){let n=0;for(const a of e)a===t&&n++;return n}function Hs(e){return e.length===1?e[0]:e}function $n(e){return Array.isArray(e)?e:[e]}function Vu(e){const n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function ip(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}let To={};function BP(e){if(e==null)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function $O(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>$O(t));else{const t=Object.keys(e);for(const n of t){const a=e[n];a!=null&&typeof a=="object"&&(!Array.isArray(a)&&a.type==="ndarray"&&typeof a.value=="number"?e[n]=a.value:$O(a))}}}function yS(e,t={},n={},a="object",r=!1){if(typeof e=="string"){const s=e;let i;if(s in n)i=n[s];else if(s in To)i=To[s];else if(i=t[s],i==null)throw new ye(`Unknown ${a}: ${e}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const s=e;if(s.className==null||s.config==null)throw new ye(`${a}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);const i=s.className;let o,l;if(i in n?[o,l]=n[i]:i in To?[o,l]=To.className:i in t&&([o,l]=t[i]),o==null)throw new ye(`Unknown ${a}: ${i}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const m of Object.keys(To))u[m]=To[m];for(const m of Object.keys(n))u[m]=n[m];const c=s.config;c.customObjects=u;const h=Object.assign({},To);for(const m of Object.keys(n))To[m]=n[m];$O(s.config);const p=l(o,s.config,n,r);return To=Object.assign({},h),p}else{const u=Object.assign({},To);for(const h of Object.keys(n))To[h]=n[h];const c=new o(s.config);return To=Object.assign({},u),c}}}function ynt(e,t){return e<t?-1:e>t?1:0}function uI(e,t){return-1*ynt(e,t)}function xh(e){if(e==null)return e;const t=[];for(const n of e)t.indexOf(n)===-1&&t.push(n);return t}function bnt(e){if(e==null)throw new ye(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Hm(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new ye(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function PP(e,t,n=0,a=1/0){return Pl(n>=0),Pl(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(r=>typeof r===t)}function Rr(e,t){Array.isArray(e)?(q(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,a)=>Rr(n,`element ${a+1} of ${t}`))):q(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${$ne(e)}.`)}function $ne(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>$ne(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function xnt(e,t,n){let a=n!=null?n():xs(),r;return(...i)=>{const o=n!=null?n():xs();return o-a<t||(a=o,r=e(...i)),r}}function _ne(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}let vnt=0;function Rne(){return vnt++}const cI={};function OE(e=""){return e in cI||(cI[e]=0),cI[e]+=1,e+cI[e].toString()}const wnt=["channelsFirst","channelsLast"],Ant=["nearest","bilinear"],Snt=["valid","same","causal"],knt=["max","avg"],Int=["sum","mul","concat","ave"];const Wg=new Map;function Wa(e){Hm(wnt,"DataFormat",e)}function Nnt(e){Hm(Ant,"InterpolationFormat",e)}function ho(e){Hm(Snt,"PaddingMode",e)}function Dne(e){Hm(knt,"PoolMode",e)}const Qv=[],U6="/";function vp(e,t){Qv.push(e);try{const n=t();return Qv.pop(),n}catch(n){throw Qv.pop(),n}}function Cnt(){return Qv.length===0?"":Qv.join(U6)+U6}function One(e){if(!Mne(e))throw new Error("Not a valid tensor name: '"+e+"'");return Cnt()+e}function Fne(e){if(!Mne(e))throw new Error("Not a valid tensor name: '"+e+"'");Wg.has(e)||Wg.set(e,0);const t=Wg.get(e);if(Wg.set(e,Wg.get(e)+1),t>0){const n=`${e}_${t}`;return Wg.set(n,1),n}else return e}const Tnt=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Mne(e){return!!e.match(Tnt)}function Ent(e){return e===parseInt(e.toString(),10)}function vh(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Oy(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function Wh(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function bl(e,t){if(t<e)throw new ye(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let a=e;a<t;++a)n.push(a);return n}let zR;function pr(){return zR==null&&(zR=Xz().epsilon()),zR}function xl(){return"channelsLast"}function Zl(e,t){return Xe(e,t)}function bS(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),me(e,n)}function $nt(e,t){return Se(()=>{if(e.shape.length!==2)throw new ye(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);const n=bS(e,1);return _O(n,[1,t,1])})}function _nt(e){const t=[vh(e.shape)];return me(e,t)}function Rnt(e){if(e.rank<=1)throw new ye(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],vh(e.shape,1)];return me(e,t)}function wp(e,t,n){return Se(()=>{switch(e.rank){case 1:return uS(e,t,n);case 2:return pE(e,[t,0],[n,e.shape[1]]);case 3:return cS(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Ry(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ln(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ln(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new ye(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function BR(e,t,n){return Se(()=>{switch(e.rank){case 1:return uS(e,t,n);case 2:return pE(e,[0,t],[e.shape[0],n]);case 3:return cS(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Ry(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ye(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function hI(e,t,n,a){return Se(()=>{switch(e.rank){case 1:return uS(e,t,n);case 2:switch(a){case 1:return wp(e,t,n);case 2:return BR(e,t,n);default:throw new ye(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return wp(e,t,n);case 2:return cS(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return BR(e,t,n);default:throw new ye(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return wp(e,t,n);case 2:return Ry(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Ry(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return BR(e,t,n);default:throw new ye(`The axis is not within the rank of the tensor ${a}`)}default:throw new ye(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function VP(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),za(e,t)}function W6(e,t){switch(e.rank){case 1:return mB([e,t]);case 2:return gB([e,t],0);case 3:return yB([e,t],0);case 4:return bB([e,t],0);default:throw new ye(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function _O(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ye(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ji(e,t)}function FE(e,t=0,n=1,a,r){return sE(e,t,n,a,r)}function Jl(e,t,n,a){if(e.rank<2||t.rank<2)throw new jt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){const r=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(r!==s)throw new jt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return IO({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?RO(e.rank,a,xl()):null,activation:n});{const r=e.shape.slice(),s=r.pop();e=me(e,[-1,s]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(g,y)=>y===0?t.rank-2:y<=t.rank-2?y-1:y);t=me(an(t,c),[l,-1]);const h=[...r,...u];return me(IO({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?RO(e.rank,a,xl()):null,activation:n}),h)}}function Lne(e,t,n){return Se(()=>(Array.isArray(t)?t=cs(t,"int32"):t=Xe(t,"int32"),d0(e,t,n)))}function xS(e){return he(e,e)}function RO(e,t,n){const a=t.shape;if(t.rank!==1&&t.rank!==e)throw new ye(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return a.length===1?me(t,[1,a[0],1,1,1]):me(t,[1,a[3],a[0],a[1],a[2]]);if(n==="channelsLast")return a.length===1?me(t,[1,1,1,1,a[0]]):me(t,[1].concat(a))}else if(e===4){if(n==="channelsFirst")return a.length===1?me(t,[1,a[0],1,1]):me(t,[1,a[2],a[0],a[1]]);if(n==="channelsLast")return a.length===1?me(t,[1,1,1,a[0]]):me(t,[1].concat(a))}else if(e===3){if(n==="channelsFirst")return a.length===1?me(t,[1,a[0],1]):me(t,[1,a[1],a[0]]);if(n==="channelsLast")return a.length===1?me(t,[1,1,a[0]]):me(t,[1].concat(a))}else if(e<3)return t;throw new ye(`Unsupported input rank by biasAdd: ${t.rank}`)}function Il(e,t,n){return Se(()=>(n==null&&(n=xl()),Wa(n),Ue(e,RO(e.rank,t,n))))}function Dnt(e,t=1){if(t!==1)throw new jt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return u0(e)}function Ont(e){return Se(()=>gt(e,Ue(Xa(e),1)))}function zne(e,t,n,a){return Se(()=>JB(e,t,n,a))}function Fnt(e){return Se(()=>{const t=Ue(.5,he(.2,e));return ni(t,0,1)})}function vS(e,t,n=!1){return n?e():t()}const Mnt=["fanIn","fanOut","fanAvg"],Lnt=["normal","uniform","truncatedNormal"];function znt(e){Hm(Mnt,"FanMode",e)}function Bnt(e){Hm(Lnt,"Distribution",e)}class Go extends Gm{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Bne extends Go{apply(t,n){return Ya(t,n)}}Bne.className="Zeros";We(Bne);class UP extends Go{apply(t,n){return qs(t,n)}}UP.className="Ones";We(UP);class Pne extends Go{constructor(t){if(super(),typeof t!="object")throw new ye(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new ye(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return Se(()=>he(kt(this.value),qs(t,n)))}getConfig(){return{value:this.value}}}Pne.className="Constant";We(Pne);class Vne extends Go{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return gd(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Vne.className="RandomUniform";We(Vne);class Une extends Go{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new jt(`randomNormal does not support dType ${n}.`);return FE(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Une.className="RandomNormal";We(Une);class Wne extends Go{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new jt(`truncatedNormal does not support dType ${n}.`);return yE(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Wne.className="TruncatedNormal";We(Wne);class Gne extends Go{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,n){return Se(()=>{if(t.length!==2||t[0]!==t[1])throw new ye("Identity matrix initializer can only be used for 2D square matrices.");return he(this.gain,JT(t[0]))})}getConfig(){return{gain:this.gain}}}Gne.className="Identity";We(Gne);function Pnt(e,t="channelsLast"){let n,a;if(Wa(t),e.length===2)n=e[0],a=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){const r=vh(e,2);n=e[1]*r,a=e[0]*r}else if(t==="channelsLast"){const r=vh(e,0,e.length-2);n=e[e.length-2]*r,a=e[e.length-1]*r}}else{const r=vh(e);n=Math.sqrt(r),a=Math.sqrt(r)}return[n,a]}class Fi extends Go{constructor(t){if(super(),t.scale<0)throw new ye(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,znt(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Bnt(this.distribution),this.seed=t.seed}apply(t,n){const a=Pnt(t),r=a[0],s=a[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,r):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(r+s)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new jt(`${this.getClassName()} does not support dType ${n}.`);return yE(t,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return gd(t,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Fi.className="VarianceScaling";We(Fi);class WP extends Fi{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Fi.className}}WP.className="GlorotUniform";We(WP);class GP extends Fi{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Fi.className}}GP.className="GlorotNormal";We(GP);class HP extends Fi{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Fi.className}}HP.className="HeNormal";We(HP);class jP extends Fi{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Fi.className}}jP.className="HeUniform";We(jP);class qP extends Fi{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Fi.className}}qP.className="LeCunNormal";We(qP);class KP extends Fi{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Fi.className}}KP.className="LeCunUniform";We(KP);class Hne extends Go{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,n){return Se(()=>{if(t.length<2)throw new jt("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const a=_e(t.slice(0,-1)),r=t[t.length-1],s=a*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const i=[Math.max(r,a),Math.min(r,a)],o=FE(i,0,1,n,this.seed),l=aP.qr(o,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(r,a)*Math.min(r,a)],[Math.min(r,a)+1]);return u=he(u,h.sign()),a<r&&(u=u.transpose()),he(kt(this.gain),u.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Hne.className="Orthogonal";We(Hne);const G6={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function H6(e,t={}){return yS(e,Ki.getMap().classNameMap,t,"initializer")}function Ia(e){return BP(e)}function ma(e){if(typeof e=="string"){const t=e in G6?G6[e]:e;if(t==="GlorotNormal")return new GP;if(t==="GlorotUniform")return new WP;if(t==="HeNormal")return new HP;if(t==="HeUniform")return new jP;if(t==="LeCunNormal")return new qP;if(t==="LeCunUniform")return new KP;{const n={};return n.className=t,n.config={},H6(n)}}else return e instanceof Go?e:H6(e)}function DO(e){return Array.isArray(e)&&Array.isArray(e[0])}function MN(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function $t(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new ye(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function vn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new ye(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function LN(e){let t=0;for(const n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((a,r)=>a*r);return t}const j6="Variable";class Vnt{constructor(t,n="float32",a=j6,r=!0,s=null){this.dtype=n??"float32",this.shape=t.shape,this.id=Rne(),a=a??j6,this.originalName=One(a),this.name=Fne(this.originalName),this.trainable_=r,this.constraint=s,this.val=QB(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),Unt(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Unt(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function OO(e){return e.map(t=>t.read())}function XP(e){e.forEach(t=>{t[0].write(t[1])})}class fr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class lu{constructor(t,n,a,r,s,i,o){this.dtype=t,this.shape=n,this.sourceLayer=a,this.inputs=r,this.callArgs=s,this.outputTensorIndex=o,this.id=Rne(),i!=null&&(this.originalName=One(i),this.name=Fne(this.originalName)),this.rank=n.length}}let Wnt=0;class ME{constructor(t,n){this.callArgs=n,this.id=Wnt++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const a of t.inboundLayers)a?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers)n!=null?t.push(n.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Gnt=0;class Jt extends Gm{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Gnt++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const a=this.getClassName();n=Vu(a)+"_"+OE(a)}if(this.name=n,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let a;if(t.batchInputShape!=null)a=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),a=[s].concat(t.inputShape)}this.batchInputShape=a;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0)throw new Oo(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new ye(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Hs(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Hs(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Bl(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Bl(`Layer ${this.name} is not connected, no input to return.`);return Hs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Bl(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Bl(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Hs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const n=$n(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const a=$n(this.inputSpec);if(n.length!==a.length)throw new ye(`Layer ${this.name} expects ${a.length} inputs, but it received ${n.length} input tensors. Input received: ${t}`);for(let r=0;r<n.length;r++){const s=n[r],i=a[r];if(i==null)continue;const o=s.rank;if(i.ndim!=null&&o!==i.ndim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&s.dtype!==i.dtype)throw new ye(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){const l=s.shape;for(const u in i.axes){const c=Number(u),h=i.axes[u],p=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(p)===-1)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=s.shape[l];if(u!=null&&c!=null&&u!==c)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){this._callHook!=null&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();const a=$n(t),r=qnt(t),s=Knt(t);if(r===s)throw new ye("Arguments to apply() must be all SymbolicTensors or all Tensors");return vp(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const o of $n(t))i.push(o.shape);this.build(Hs(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,n);this.supportsMasking&&this.setMaskMetadata(t,i);const o=$n(i),l=[];for(let u of o)a.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=Hs(l),this.activityRegularizer!=null)throw new jt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=Hnt(t),o=this.computeOutputShape(i);let l;const u=jnt(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((c,h)=>new lu(u,c,this,$n(t),n,this.name,h)):l=new lu(u,o,this,$n(t),n,this.name),this.addInboundNode(t,l,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new jt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((a,r)=>{a!=null&&t[r]!=null&&t[r]!==a&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Bl(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const n of this.inboundNodes){const a=JSON.stringify(n.outputShapes);t.indexOf(a)===-1&&t.push(a)}if(t.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new Bl(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Oo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return LN(this.weights)}build(t){this.built=!0}getWeights(t=!1){return OO(t?this.trainableWeights:this.weights)}setWeights(t){Se(()=>{const n=this.weights;if(n.length!==t.length)throw new ye(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(n.length===0)return;const a=[],r=OO(n);for(let s=0;s<r.length;++s){const i=r[s],o=n[s],l=t[s];if(!tn(i.shape,l.shape))throw new ye(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);a.push([o,l])}XP(a)})}addWeight(t,n,a,r,s,i,o,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new ye(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),a==null&&(a="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():ma("zeros"));const u=r.apply(n,a),c=new Vnt(u,a,t,i,o);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=$n(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(a=>{if(a!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(t,n,a){if(!this.supportsMasking)return;const r=this.computeMask(t,a),s=$n(n),i=$n(r);if(s.length!==i.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let o=0;o<s.length;o++)s[o].kerasMask=i[o]}addInboundNode(t,n,a,r,s,i,o=null){const l=$n(t);n=$n(n),a=$n(a),r=$n(r),s=MN(s),i=MN(i);const u=[],c=[],h=[];for(const p of l)u.push(p.sourceLayer),c.push(p.nodeIndex),h.push(p.tensorIndex);new ME({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:n,inputMasks:a,outputMasks:r,inputShapes:s,outputShapes:i},o);for(let p=0;p<n.length;p++)n[p].sourceLayer=this,n[p].nodeIndex=this.inboundNodes.length-1,n[p].tensorIndex=p}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function Hnt(e){e=$n(e);const t=[];for(const n of e)t.push(n.shape);return Hs(t)}function jnt(e){return"float32"}function jne(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{const a=t.inboundNodes[n];if(a.inboundLayers.length===0)return a.inputTensors;{const r=[];for(let s=0;s<a.inboundLayers.length;s++){const i=a.inputTensors[s],o=a.inboundLayers[s],l=a.nodeIndices[s],u=jne(i,o,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}function qnt(e){let t=!0;for(const n of $n(e))if(!(n instanceof lu)){t=!1;break}return t}function Knt(e){let t=!0;for(const n of $n(e))if(n instanceof lu){t=!1;break}return t}class wS extends Jt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:OE("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new ye("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(n==null){if(t.inputShape==null)throw new ye("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new ye("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const a=t.dtype||"float32";this.batchInputShape=n,this.dtype=a,this.inputSpec=[{shape:n}];const r=new lu(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new ME({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new ye(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}wS.className="InputLayer";We(wS);function Xnt(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new ye("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new wS({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function Ynt(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Xe(t,e.dtype)}catch{throw new ye(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}class ph{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof ph)for(const n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(const n of t)this.add(n.key,n.value)}}add(t,n,a){if(this.id2Value[t.id]==null)this.id2Value[t.id]=Ynt(t,n),this.name2Id[t.name]=t.id,a!=null&&(this.id2Mask[t.id]=a);else throw new ye(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof lu){if(this.id2Value[t.id]==null)throw new ye(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const n=this.name2Id[t];if(n==null)throw new ye(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof lu){if(this.id2Value[t.id]==null)throw new ye(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const n=this.name2Id[t];if(n==null)throw new ye(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Yt(this.id2Mask)}}const zN=new Ene,BN=new Ene;function Qnt(e){zN?.setMaxEntries(e),BN?.setMaxEntries(e)}function Vv(e,t,n,a){const r=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(g=>g.name),l=[],u=t.names();for(const g of o)u.indexOf(g)!==-1?l.push(t.getValue(g)):l.push(null);const c=o.join(",")+"|"+t.names().sort().join(",");let h=zN.get(c),p;if(h==null){const g=Znt(i,t);h=g.sorted,p=g.recipientCounts,zN.put(c,h),BN.put(c,p)}p={},r||Object.assign(p,BN.get(c));const m=new ph(t);for(let g=0;g<h.length;++g){const y=h[g],b=y.sourceLayer;if(b instanceof wS)continue;const v=[],w=[],S=[];let k=!1;for(const D of y.inputs){const O=m.getValue(D),$=m.getMask(D);v.push(O),w.push($),$!=null&&(k=!0),r||(p[D.name]--,p[D.name]===0&&!t.hasKey(D)&&o.indexOf(D.name)===-1&&!O.isDisposed&&D.sourceLayer.stateful!==!0&&S.push(O))}k&&(n=n||{},n.mask=w[0]);const I=$n(b.apply(v,n));let T=null;b.supportsMasking&&(T=b.computeMask(v,w));const E=eat(y),R=Array.isArray(E)?E:[E];for(let D=0;D<R.length;++D){m.hasKey(R[D])||m.add(R[D],I[D],Array.isArray(T)?T[0]:T);const O=o.indexOf(R[D].name);O!==-1&&(l[O]=I[D])}r||Yt(S)}return m.disposeMasks(),s?l:l[0]}function Znt(e,t){q(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(e.length===1){const r=q6(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const s of e){const{sorted:i,recipientMap:o}=q6(s,t);for(const l of i)r.has(l.name)||(n.push(l),r.add(l.name));for(const l in o)a[l]==null&&(a[l]=new Set),o[l].forEach(u=>a[l].add(u))}}return{sorted:n,recipientCounts:Jnt(a)}}function Jnt(e){const t={};for(const n in e)t[n]=e[n].size;return t}function q6(e,t){const n=new Set,a=[],r={};for(const o of t.names())n.add(o);const s=[],i=[];for(s.push(e);s.length>0;){const o=s[s.length-1];if(n.has(o.name)){s.pop();continue}const l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),a.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(const u of o.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(o.name),!n.has(u.name)&&s.push(u)}}return{sorted:a,recipientMap:r}}function eat(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let a=0;a<e.sourceLayer.inboundNodes.length;++a)for(const r of e.sourceLayer.inboundNodes[a].outputTensors)if(r.id===e.id){n=a;break}t=e.sourceLayer.getOutputAt(n)}return t}const tat=Ie();tat.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Qnt);function YP(e,t){return Se(()=>Lr(ct(he(e,e),t,!0)))}class AS extends Gm{getConfig(){return{}}}class qne extends AS{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Se(()=>{const n=YP(t,this.axis),a=ni(n,0,this.maxValue);return he(t,gt(a,Ue(pr(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}qne.className="MaxNorm";We(qne);class Kne extends AS{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Se(()=>gt(t,Ue(pr(),YP(t,this.axis))))}getConfig(){return{axis:this.axis}}}Kne.className="UnitNorm";We(Kne);class Xne extends AS{apply(t){return kl(t)}}Xne.className="NonNeg";We(Xne);class Yne extends AS{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Se(()=>{const n=YP(t,this.axis),a=Ue(he(this.rate,ni(n,this.minValue,this.maxValue)),he(1-this.rate,n));return he(t,gt(a,Ue(pr(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Yne.className="MinMaxNorm";We(Yne);const K6={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function br(e){return BP(e)}function X6(e,t={}){return yS(e,Ki.getMap().classNameMap,t,"constraint")}function xr(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in K6?K6[e]:e,config:{}};return X6(n)}else return e instanceof AS?e:X6(e)}async function jd(e){if(e==null)return;const t=[],n=[],a=[];for(const r in e){const s=e[r];if(typeof s!="number"){const i=s;t.push(i.data()),n.push(r),a.push(i)}}if(t.length>0){const r=await Promise.all(t);for(let s=0;s<r.length;++s)e[n[s]]=r[s][0];Yt(a)}}function Qne(e){if(e!=null)for(const t in e){const n=e[t];typeof n!="number"&&n.dispose()}}var Y6;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(Y6||(Y6={}));const nat=125;class Ew{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class aat{constructor(t,n=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){n==null&&(n={});for(const a of this.callbacks)await a.onEpochBegin(t,n)}async onEpochEnd(t,n){n==null&&(n={});for(const a of this.callbacks)await a.onEpochEnd(t,n)}async onBatchBegin(t,n){n==null&&(n={});for(const a of this.callbacks)await a.onBatchBegin(t,n)}async onBatchEnd(t,n){n==null&&(n={});for(const a of this.callbacks)await a.onBatchEnd(t,n)}async onTrainBegin(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class rat extends Ew{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){n==null&&(n={});const a=n.size==null?0:n.size;this.seen+=a;for(const r in n){const s=n[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*a;else{let i;r in this.totals?i=this.totals[r]:this.totals[r]=0;const o=Se(()=>Ue(this.totals[r],he(s,a)));this.totals[r]=o,i?.dispose()}}}async onEpochEnd(t,n){if(n!=null)for(const a of this.params.metrics)this.totals[a]!=null&&(typeof this.totals[a]=="number"?n[a]=this.totals[a]/this.seen:Se(()=>{const r=he(gt(1,this.seen),this.totals[a]);n[a]=r,this.totals[a].dispose(),dr(n[a])}))}}class sat extends Ew{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){n==null&&(n={}),this.epoch.push(t);for(const a in n)this.history[a]==null&&(this.history[a]=[]),this.history[a].push(n[a])}async syncData(){const t=[],n=[],a=[];for(const s in this.history){const i=this.history[s];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const l=i[o];t.push(l.data()),n.push(s),a.push(o)}}const r=await Promise.all(t);for(let s=0;s<r.length;++s)this.history[n[s]][a[s]].dispose(),this.history[n[s]][a[s]]=r[s][0]}}class iat extends Ew{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||bP,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=nat),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");CN(this.yieldEvery)&&(this.maybeWait=xnt(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,a){const r=[];this.yield!=null&&(await jd(a),r.push(this.yield(t,n,a))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,n){this.currentEpoch=t,this.epochBegin!=null&&(await jd(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const a=[];this.epochEnd!=null&&(await jd(n),a.push(this.epochEnd(t,n))),this.yieldEvery==="epoch"&&a.push(this.nextFrameFunc()),await Promise.all(a)}async onBatchBegin(t,n){this.batchBegin!=null&&(await jd(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const a=[];this.batchEnd!=null&&(await jd(n),a.push(this.batchEnd(t,n))),this.yieldEvery==="batch"?a.push(this.nextFrameFunc()):CN(this.yieldEvery)&&a.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(a)}async onTrainBegin(t){this.trainBegin!=null&&(await jd(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await jd(t),await this.trainEnd(t))}}function Zne(e,t){return e==null&&(e={}),e instanceof Ew?[e]:Array.isArray(e)&&e[0]instanceof Ew?e:$n(e).map(a=>new iat(a,t))}class $o{constructor(){}static registerCallbackConstructor(t,n){q(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),$o.checkForDuplicate(n),$o.constructors[t]==null&&($o.constructors[t]=[]),$o.constructors[t].push(n)}static checkForDuplicate(t){for(const n in $o.constructors)$o.constructors[+n].forEach(r=>{if(r===t)throw new ye("Duplicate callback constructor.")})}static clear(){$o.constructors={}}static createCallbacks(t){const n=[];for(const a in $o.constructors){const r=+a;t>=r&&n.push(...$o.constructors[r])}return n.map(a=>new a)}}$o.constructors={};function Jne(e,t,n,a,r,s,i,o,l){const u=new sat,c=[new rat,...$o.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);const h=new aat(c);return h.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function Qu(e,t={},n=!1){return yS(e,Ki.getMap().classNameMap,t,"layer",n)}function PN(e,t){return Se(()=>{e.dtype!=="float32"&&(e=Xe(e,"float32"));const n=ct(xS(e),t,!0),a=Vm(n.shape,pr()),r=Lr(mu(n,a));return gt(e,r)})}function LE(e,t){return Se(()=>Sa(xS(it(t,e)),-1))}function QP(e,t){return Se(()=>Sa(Xa(it(t,e)),-1))}function ZP(e,t){return Se(()=>{const n=it(e,t),a=ni(Xa(e),pr(),Number.MAX_VALUE),r=Xa(gt(n,a));return he(100,Sa(r,-1))})}function oat(e,t){return Se(()=>{const n=ni(t,pr(),Number.MAX_VALUE),a=Di(Ue(1,n)),r=ni(e,pr(),Number.MAX_VALUE),s=Di(Ue(1,r));return Sa(xS(it(a,s)),-1)})}function lat(e,t){return Se(()=>{const n=mu(0,it(1,he(e,t)));return Sa(xS(n),-1)})}function uat(e,t){return Se(()=>{const n=mu(0,it(1,he(e,t)));return Sa(n,-1)})}function cat(e,t){return Se(()=>{const n=ct(he(e,t),-1),a=ao(he(it(1,e),t),-1);return mu(0,Ue(1,it(a,n)))})}function hat(e,t){return Se(()=>{const n=Math.log(2),a=it(t,e),r=it(Ue(a,Um(he(-2,a))),n);return Sa(r,-1)})}function $w(e,t,n=!1){return Se(()=>{if(n)t=hS(t);else{const a=ct(t,t.shape.length-1,!0);t=gt(t,a)}return t=ni(t,pr(),1-pr()),ia(ct(he(Xe(e,"float32"),Di(t)),t.shape.length-1))})}function VN(e,t,n=!1){return Se(()=>{const a=Xe(h0(_nt(e)),"int32");t=ni(t,pr(),1-pr());const r=t.shape,s=me($y(a,r[r.length-1]),r);return $w(s,t,n)})}function dat(e,t){if(!tn(e.shape,t.shape))throw new ye(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Se(()=>{const n=kl(t),a=ia(Xa(t));return Ue(it(n,he(t,e)),nS(ai(a)))})}function zE(e,t){return Se(()=>{let n;return n=ni(t,pr(),1-pr()),n=Di(gt(n,it(1,n))),Sa(dat(e,n),-1)})}function pat(e,t){return Se(()=>{const n=ni(e,pr(),1),a=ni(t,pr(),1);return ct(he(e,Di(gt(n,a))),-1)})}function fat(e,t){return Se(()=>{const n=Di(Ue(pr(),t));return Sa(it(t,he(e,n)),-1)})}function eae(e,t){return Se(()=>{const n=PN(e,-1),a=PN(t,-1),r=he(n,a);return ia(ct(r,-1))})}const UN={meanSquaredError:LE,meanAbsoluteError:QP,meanAbsolutePercentageError:ZP,meanSquaredLogarithmicError:oat,squaredHinge:lat,hinge:uat,categoricalHinge:cat,logcosh:hat,categoricalCrossentropy:$w,sparseCategoricalCrossentropy:VN,binaryCrossentropy:zE,kullbackLeiblerDivergence:pat,poisson:fat,cosineProximity:eae};function PR(e){if(typeof e=="string"){if(e in UN)return UN[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ye(t)}else return e}function tae(e,t){return Se(()=>{const n=he(.5,Oi(t)),a=Zl(ii(t,n),e.dtype);return Sa(Bo(e,a),-1)})}function nae(e,t){return Se(()=>Zl(Bo(qp(e,-1),qp(t,-1)),"float32"))}function mat(e,t){return Se(()=>Xe(ct(yl(Bo(e,1),Bo(t,1))),"float32"))}function gat(e,t){return Se(()=>Xe(ct(yl(Bo(e,0),Bo(t,1))),"float32"))}function yat(e,t){return Se(()=>{const n=mat(e,t),a=gat(e,t),r=Ue(n,a);return Xe(Xr(ii(r,0),gt(n,r),0),"float32")})}function bat(e,t){return zE(e,t)}function xat(e,t){return e.rank===t.rank&&(e=yd(e,[e.rank-1])),t=qp(t,-1),t.dtype!==e.dtype&&(t=Xe(t,e.dtype)),Xe(Bo(e,t),"float32")}const vat=LE,wat=LE,Aat=QP,Sat=QP,kat=ZP,Iat=ZP,aae=$w,Nat=eae,rae=VN,WN={binaryAccuracy:tae,categoricalAccuracy:nae,precision:yat,categoricalCrossentropy:aae,sparseCategoricalCrossentropy:rae,mse:vat,MSE:wat,mae:Aat,MAE:Sat,mape:kat,MAPE:Iat,cosine:Nat};function Cat(e){if(typeof e=="string"&&e in WN)return WN[e];if(typeof e!="string"&&e!=null)return e;throw new ye(`Unknown metric ${e}`)}function dI(e){if(Pl(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(const n of Object.keys(UN))if(UN[n]===e){t=n;break}if(t!==void 0)return t;for(const n of Object.keys(WN))if(WN[n]===e){t=n;break}return t!==void 0?t:e.name}}function Tat(e){const t={Adagrad:()=>Zd.adagrad(.01),Adadelta:()=>Zd.adadelta(1,.95,pr()),Adam:()=>Zd.adam(.001,.9,.999,pr()),Adamax:()=>Zd.adamax(.002,.9,.999,pr(),0),RMSProp:()=>Zd.rmsprop(.001,.9,0,pr()),SGD:()=>Zd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ye(`Unknown Optimizer ${e}`)}const Q6=1*1024*1024;function Z6(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!FO(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const a=JSON.stringify(e);a.length>Q6&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${a.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Q6}.`)}}function FO(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t)if(typeof n!="string"||!FO(e[n]))return!1;return!0}else if(Array.isArray(e)){for(const t of e)if(!FO(t))return!1;return!0}else return!1;else{const t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function Eat(e,t,n,a=console.log){const r=_at(e),s=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!r){s.push("Receives inputs"),i=[];for(const c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}a("_".repeat(t)),GN(s,n,a),a("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)r?Rat(o[c],n,a):Dat(o[c],n,i,a),a((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=$at(e),u=LN(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a("_".repeat(t))}function $at(e){let t;return e.collectedTrainableWeights!=null?t=LN(e.collectedTrainableWeights):t=LN(e.trainableWeights),t}function _at(e){let t=!0;const n=[],a=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(const r of e.layers){let s=!1;for(const i of r.inboundNodes)if(a.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function GN(e,t,n=console.log){let a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function Rat(e,t,n){let a,r;try{r=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}const s=e.name,i=e.getClassName(),o=[`${s} (${i})`,r,a,e.countParams().toString()];GN(o,t,n)}function Dat(e,t,n,a){let r,s;try{s=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}const i=[];for(const h of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let p=0;p<h.inboundLayers.length;++p){const m=h.inboundLayers[p].name,g=h.nodeIndices[p],y=h.tensorIndices[p];i.push(`${m}[${g}][${y}]`)}const o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,s,r,e.countParams().toString(),u];GN(c,t,a);for(let h=1;h<i.length;++h)GN(["","","","",i[h]],t,a)}function sae(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function MO(e,t){if(e===null)return null;if(typeof e=="string")return ip(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const s=e[r];sae(t,r,s)?n.push(s):n.push(MO(s,t))}return n}else{const n={};for(const a of Object.keys(e)){const r=e[a];if(a==="name"&&typeof r=="string")n[a]=r;else{const s=ip(a);n[s]=MO(r,s)}}return n}}function LO(e,t){if(e==null)return null;if(typeof e=="string")return Vu(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const s=e[r];sae(t,r,s)?n.push(s):n.push(LO(s,t))}return n}else{const n={};for(const a of Object.keys(e)){const r=e[a],s=Vu(a);(a==="name"||a==="className")&&typeof r=="string"?n[s]=r:n[s]=LO(r,a)}return n}}const iae="4.22.0";const Oat=e=>{const t=Object.keys(e);if(t.length===0)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class el extends Jt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=OE(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],xh(this.inputs).length!==this.inputs.length)throw new ye(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);xh(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const S=w.sourceLayer,k=w.nodeIndex,I=w.tensorIndex;this.outputLayers.push(S),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(I)}for(const w of this.inputs){const S=w.sourceLayer,k=w.nodeIndex,I=w.tensorIndex;Pl(k===0,"input layer has >1 nodes"),Pl(I===0,"input layer has >1 tensors"),this.inputLayers.push(S),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const S=this.inputLayers[w];if(!(S instanceof wS))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${w} (0-based) originates from layer type ${S.getClassName()}.`);this.inputNames.push(S.name),this.feedInputShapes.push(S.batchInputShape),this.feedInputNames.push(S.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const n={},a={},r={},s={},i={},o=[],l=(w,S,k,I,T,E)=>{(I==null||T==null||E==null)&&(I=w.sourceLayer,T=w.nodeIndex,E=w.tensorIndex);const R=I.inboundNodes[T];if(k.indexOf(R)!==-1)throw new Oo(`The tensor ${w.name} at layer "${I.name}" is part of a cycle.`);if(S.indexOf(R)!==-1)return;this.containerNodes.add(el.nodeKey(I,T)),I.id in i||(i[I.id]=Object.keys(i).length),k.indexOf(R)===-1&&k.push(R);const D=R.inboundLayers.length;for(let O=0;O<D;O++){const $=R.inputTensors[O],_=R.inboundLayers[O],P=R.nodeIndices[O],U=R.tensorIndices[O];l($,S,k,_,P,U)}for(S.push(R);k.indexOf(R)>=0;)k.splice(k.indexOf(R),1);o.push(R)},u=[],c=[];for(const w of this.outputs)l(w,u,c);const h=o.slice().reverse();for(const w of h){a[w.id]=w,w.id in n||(n[w.id]=0);let S=n[w.id];const k=r[w.outboundLayer.id]==null?0:r[w.outboundLayer.id];S=Math.max(S,k),r[w.outboundLayer.id]=S,s[w.outboundLayer.id]=w.outboundLayer,n[w.id]=S;for(let I=0;I<w.inboundLayers.length;I++){const T=w.inboundLayers[I],E=w.nodeIndices[I],R=T.inboundNodes[E],D=n[R.id]==null?0:n[R.id];n[R.id]=Math.max(S+1,D),a[R.id]=R}}const p={};for(const w in n){const S=n[w];S in p||(p[S]=[]),p[S].push(a[w])}const m={};for(const w in r){const S=r[w];S in m||(m[S]=[]),m[S].push(s[w])}let g=Object.keys(m).map(w=>parseInt(w,10)).sort(uI);this.layers=[];for(const w of g){const S=m[w];S.sort((k,I)=>{const T=i[k.id],E=i[I.id];return T<E?-1:T>E?1:0});for(const k of S)k instanceof el&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=m,g=Object.keys(p).map(w=>parseInt(w,10)).sort(uI);const y=this.inputs.slice(),b=[];for(const w of g)for(const S of p[w]){const k=S.outboundLayer;if(k!=null){for(const I of S.inputTensors)if(y.indexOf(I)===-1)throw new Oo(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${k.name}". The following previous layers were accessed without issue: ${b}`);for(const I of S.outputTensors)y.push(I);b.push(k.name)}}this.nodesByDepth=p;const v=this.layers.map(w=>w.name);for(const w of v){const S=v.filter(k=>k===w).length;if(S!==1)throw new Oo(`The name "${w}" is used ${S} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new ME({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(a=>a.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ye("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const a of this.layers)n.push(...a.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){const a={};let r=0;const s=Oat(t);s&&this.parseWeights(t);for(const o of this.layers)for(const[l,u]of o.weights.entries()){const c=s?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(a[c]!=null)throw new ye(`Duplicate weight name: ${c}`);a[c]=u,r++}const i=[];for(const o in t){let l=o;if(a[o]==null){const u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(a[l]!=null)i.push([a[l],t[o]]);else if(n)throw new ye(`Provided weight data has no target variable: ${o}`);delete a[l]}if(n){const o=[];for(const l in a)o.push(l);if(o.length>0)throw new ye(`${o.length} of ${r} weights are not set: ${o}`)}XP(i)}parseWeights(t){for(const n in Object.keys(t)){const a=n.split("/"),r=["vars","layer_checkpoint_dependencies"],s=a.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){const t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${iae}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){const a=LO(this.updatedConfig());return n?JSON.stringify(a):a}call(t,n){return Se(()=>{t=$n(t);const a=new ph;for(let r=0;r<this.inputs.length;++r)a.add(this.inputs[r],t[r]);return Vv(this.outputs,a,n)})}computeMask(t,n){return Se(()=>{t=$n(t);let a;return n==null?a=Jp(null,t.length):a=$n(n),this.runInternalGraph(t,a)[1]})}computeOutputShape(t){const n=MN(t);if(n.length!==this.inputLayers.length)throw new ye(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const a={};for(let o=0;o<n.length;o++){const l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";a[c]=u}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(uI);if(r.length>1)for(const o of r){const l=this.nodesByDepth[o];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(y=>y.id).indexOf(c.id)!==-1)continue;const h=[];for(let y=0;y<u.inboundLayers.length;y++){const b=u.inboundLayers[y],v=u.nodeIndices[y],w=u.tensorIndices[y],S=`${b.name}_${v}_${w}`,k=a[S];h.push(k)}const p=c.computeOutputShape(Hs(h)),m=MN(p),g=c.inboundNodes.indexOf(u);for(let y=0;y<m.length;y++){const b=`${c.name}_${g}_${y}`;a[b]=m[y]}}}const s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],h=`${l.name}_${u}_${c}`;i.push(h)}for(let o=0;o<i.length;o++){const l=i[o];Pl(l in a),s.push(a[l])}return Hs(s)}runInternalGraph(t,n){n==null&&(n=Jp(null,t.length));const a={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=t[l],h=n[l];a[u.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(uI);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,p=c.inputTensors,m=c.outputTensors,g=new Array;for(const y of p)y.id in a&&g.push(a[y.id]);if(g.length===p.length){let y={},b,v,w,S;if(c.callArgs!=null&&(y=c.callArgs),g.length===1){const[k,I]=g[0];y.mask==null&&(y.mask=I),w=$n(h.call(k,y)),S=$n(h.computeMask(k,I)),b=[k],v=[I]}else b=g.map(k=>k[0]),v=g.map(k=>k[1]),y.mask==null&&(y.mask=v),w=$n(h.call(b,y)),S=$n(h.computeMask(b,v));if(h.activityRegularizer)throw new jt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<m.length;++k){const I=m[k],T=w[k],E=S[k];a[I.id]=[T,E]}}}}const s=[],i=[],o=[];for(const l of this.outputs){Pl(l.id in a,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=a[l.id];o.push(u.shape),s.push(u),i.push(c)}return[s,i,o]}buildNodeConversionMap(t){const n={};let a;for(const r of this.layers){a=r instanceof el?1:0;for(let s=0;s<r.inboundNodes.length;s++){const i=el.nodeKey(r,s);this.containerNodes.has(i)&&(n[i]=a,a+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new ye("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const a of this.layers)if(a.name===t)return a;throw new ye(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new ye(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return Se(()=>{const t=[];for(const n of this.layers)for(let a=0;a<n.inboundNodes.length;++a){const r=el.nodeKey(n,a);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){const t={name:this.name},n=this.buildNodeConversionMap(this.layers),a=[];for(const i of this.layers){const o=i.getClassName(),l=i.getConfig(),u=[];for(let h=0;h<i.inboundNodes.length;h++){const p=i.inboundNodes[h],m=el.nodeKey(i,h);let g={};if(this.containerNodes.has(m)){if(p.callArgs)try{JSON.stringify(p.callArgs),g=p.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(p.inboundLayers.length>0){const y=[];for(let b=0;b<p.inboundLayers.length;b++){const v=p.inboundLayers[b],w=p.nodeIndices[b],S=p.tensorIndices[b],k=el.nodeKey(v,w);let I=n[k];I==null&&(I=0),y.push([v.name,I,S,g])}u.push(y)}}}const c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,a.push(c)}t.layers=a;const r=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=el.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[i];r.push([o.name,c,h])}t.inputLayers=r;const s=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=el.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[i];s.push([o.name,c,h])}return t.outputLayers=s,t}static fromConfig(t,n,a={},r=!1){const s={},i={};function o(b,v){b.name in i?i[b.name].push(v):i[b.name]=[v]}function l(b,v){const w=[];let S;for(const k of v){const I=k[0],T=k[1],E=k[2];if(S=k[3]==null?{}:k[3],!(I in s)){o(b,v);return}const R=s[I];if(R.inboundNodes.length<=T){o(b,v);return}const D=R.inboundNodes[T];w.push(D.outputTensors[E])}w.length>0&&b.apply(Hs(w),S)}function u(b){const v=b.name,w=Qu(b,n.customObjects!=null?n.customObjects:{});w.setFastWeightInitDuringBuild(r),s[v]=w,b.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new ye(`Corrupted configuration, expected array for nodeData: ${k}`);o(w,k)})}const c=n.name,h=n.layers;for(const b of h)u(b);for(;!bnt(i);)for(const b of h){const v=s[b.name];if(v.name in i){const w=i[v.name];delete i[v.name];for(const S of w)l(v,S)}}const p=[],m=[],g=n.inputLayers;for(const b of g){const v=b[0],w=b[1],S=b[2];Pl(v in s);const I=s[v].inboundNodes[w].outputTensors;p.push(I[S])}const y=n.outputLayers;for(const b of y){const v=b[0],w=b[1],S=b[2];Pl(v in s);const I=s[v].inboundNodes[w].outputTensors;m.push(I[S])}return new t({inputs:p,outputs:m,name:c})}get stateful(){if(this._stateful)throw new ye("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Se(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Fat(e,t,n){const a=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(a===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){const r=[];return t.forEach(s=>{s in e?r.push(e[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function oae(e,t){return Fat(e,t,"classWeight")}async function lae(e,t,n,a){if(n!=null){const r=Se(()=>{if(e.shape.length===1)return Yl(e);if(e.shape.length===2){if(e.shape[1]>1)return qp(e,1);if(e.shape[1]===1)return me(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());Yt(r);const i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),cs(i,"float32")}else return null}function Mat(e,t){return he(e,t)}const Lat=32;function uae(e,t){let n,a;const r=t;n=r.xs,a=r.ys,q(n!=null&&a!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const s=J6("input",e.inputNames,n),i=J6("output",e.outputNames,a),o=s[0].shape[0];q(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),q(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)q(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)q(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function J6(e,t,n){if(n instanceof In)return[n];if(Array.isArray(n))return q(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const a=[];for(const r of t){if(n[r]==null)throw new ye(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function zat(e){if(e.length===3)throw new jt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function Bat(e,t,n){const a=n.batchesPerEpoch!=null;if(q(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),q(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),q(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),q(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),q(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=n.validationData!=null;let s,i;if(r)if(ej(n.validationData))q(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const b=zat(n.validationData);s=b.xs,i=b.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(b=>"val_"+b)):u=l.slice();const c=Zne(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:p,history:m}=Jne(c,h,n.epochs,null,null,Pat(t,n),null,r,u);p.setModel(e),e.history=m,await p.onTrainBegin(),e.stopTraining_=!1;let g=n.initialEpoch==null?0:n.initialEpoch,y=await t.iterator();for(;g<n.epochs;){const b={};await p.onEpochBegin(g);let v=0,w=0;for(a||(y=await t.iterator());!a||v<n.batchesPerEpoch;){const S=await y.next();if(a&&S.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(S.value!=null){const{xs:k,ys:I}=uae(e,S.value),T={};T.batch=w,T.size=k[0].shape[0],await p.onBatchBegin(w,T);const E=[];if(n.classWeight!=null){const O=oae(n.classWeight,e.outputNames);for(let $=0;$<O.length;++$)E.push(await lae(I[$],null,O[$]))}const R=k.concat(I).concat(E),D=o(R);Yt(R);for(let O=0;O<l.length;++O){const $=l[O],_=D[O];T[$]=_,dr(_)}await p.onBatchEnd(w,T),Qne(T),w++,v++}if(a?v>=n.batchesPerEpoch:S.done){if(r){let k;ej(n.validationData)?k=$n(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):k=$n(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?Lat:n.validationBatchSize,verbose:0}));for(let I=0;I<e.metricsNames.length;++I)b[`val_${e.metricsNames[I]}`]=k[I]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(g,b),g++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Pat(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function ej(e){return typeof e.iterator=="function"}function Vat(e){return typeof e.next=="function"}async function Uat(e,t,n){n=n||{};const a=n.batches!=null,r=e.testFunction;let s=[];if(n.verbose>0)throw new jt("Verbose mode is not implemented yet.");q(!a||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=Vat(t)?t:await t.iterator();let o=0,l=0;for(;!a||l<n.batches;){const u=await i.next();if(s=Se(()=>{if(u.value){const{xs:c,ys:h}=uae(e,u.value),p=c.concat(h),m=Se(()=>r(p));if(Yt(p),l===0)for(let y=0;y<m.length;++y)s.push(kt(0));const g=p[0].shape[0];for(let y=0;y<m.length;++y){const b=m[y],v=s[y];s[y]=Se(()=>Ue(s[y],he(g,b))),l>0&&Yt(v)}Yt(m),o+=g,++l}return s}),u.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){const c=s[u];s[u]=gt(s[u],o),Yt(c)}return Hs(s)}function VR(e){q(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Nv(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(a=>wp(a,t,n-t)):wp(e,t,n-t)}function zO(e,t){return Se(()=>e==null?null:Array.isArray(e)?e.map(n=>zO(n,t)):Lne(e,t.dtype==="int32"?t:Xe(t,"int32")))}function UR(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function cae(e){const t=[];e instanceof In&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(a.rank===1)t.push(bS(a,1));else{if(a.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Qo(e,t){if(e==null)return;const n=[];if(t instanceof In)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(const r in t){const s=t[r];n.push(s.id)}const a=[];if(e instanceof In)n.indexOf(e.id)===-1&&a.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&a.push(r)});else if(e!=null)for(const r in e){const s=e[r];n.indexOf(s.id)===-1&&a.push(s)}a.forEach(r=>{r.isDisposed||r.dispose()})}function Wat(e){return e instanceof In}function BO(e){return Array.isArray(e)}function tj(e){return!Wat(e)&&!BO(e)}function nj(e,t,n,a=!0,r=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(BO(e)&&e.length>0)i=!0;else if(tj(e)){for(const o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new ye(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(tj(e)){e=e,s=[];for(const i of t){if(e[i]==null)throw new ye(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(BO(e)){if(e=e,e.length!==t.length)throw new ye(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new ye(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=cae(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=s[i];if(o.shape.length!==n[i].length)throw new ye(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new ye(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function Gat(e,t,n){const a=xh(e.map(s=>s.shape[0]));a.sort();const r=xh(t.map(s=>s.shape[0]));if(r.sort(),a.length>1)throw new ye(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>1)throw new ye(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(a.length>0&&r.length>0&&!tn(a,r))throw new ye(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function Hat(e,t,n){const a=[LE,zE,$w];for(let r=0;r<e.length;++r){const s=e[r],i=t[r],o=n[r];if(i!=null){if(i===$w&&s.shape[s.shape.length-1]===1)throw new ye(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(a.indexOf(i)!==-1){const l=s.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){const h=l[c],p=u[c];if(p!=null&&h!==p)throw new ye(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function aj(e,t,n,a=!0,r=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new ye(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new ye(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=s[i];if(o.shape.length!==n[i].length)throw new ye(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new ye(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function jat(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(a=>n);{const a=[];for(const r of t){let s=n.hasOwnProperty(r)?n[r]:[];Array.isArray(s)||(s=[s]),a.push(s)}return a}}const qat="layers-model";class iy extends el{constructor(t){super(t),this.isTraining=!1}summary(t,n,a=console.log){if(!this.built)throw new ye("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Eat(this,t,n,a)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=Tat(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Ac))throw new ye("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new ye(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(PR(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new ye(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(o=>PR(o))}else{const i=PR(t.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const a=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],vp("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(a.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const r=jat(t.metrics,this.outputNames),s=(i,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,i])};vp("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(a.indexOf(i)!==-1)continue;const o=r[i];(u=>{let h,p,m;for(const g of u){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){const b=this.internalOutputShapes[i];b[b.length-1]===1||this.lossFunctions[i]===zE?["accuracy","acc"].indexOf(g)!==-1?p=tae:["crossentropy","ce"].indexOf(g)!==-1&&(p=bat):this.lossFunctions[i]===VN?["accuracy","acc"].indexOf(g)!==-1?p=xat:["crossentropy","ce"].indexOf(g)!==-1&&(p=rae):["accuracy","acc"].indexOf(g)!==-1?p=nae:["crossentropy","ce"].indexOf(g)!==-1&&(p=aae);let v;["accuracy","acc"].indexOf(g)!==-1?v="acc":["crossentropy","ce"].indexOf(g)!==-1&&(v="ce"),m=p,h=""+v}else m=Cat(g),h=""+dI(g);let y;vp(h,()=>{y=m}),s(i,h,y)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,a={}){const r=a.batchSize==null?32:a.batchSize;VR(r);const i=this.standardizeUserDataXY(t,n,!0,r);try{const o=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,o,r,a.verbose,a.steps);return Hs(u)}finally{Qo(i[0],t),Qo(i[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),Uat(this,t,n)}checkNumSamples(t,n,a,r="steps"){let s;if(a!=null){if(s=null,n!=null)throw new ye(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new ye(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(t,n){if(Array.isArray(n)&&n.length===0)throw new ye("`outputs` is an empty Array, which is not allowed.");const a=Array.isArray(n),r=a?n:[n],s=this.retrieveSymbolicTensors(r),i=new ph;if(t instanceof In&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new ye(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],t[l])}else for(const l of this.inputs){const u=t[l.name];if(u==null)throw new ye(`No value is provided for the model's input ${l.name}`);i.add(l,u)}const o=Vv(s,i);return a?o:o[0]}retrieveSymbolicTensors(t){const n=Jp(null,t.length);let a=t.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],i=s.map(o=>o.name);for(let o=0;o<t.length;++o){const l=i.indexOf(t[o]);if(l!==-1&&(n[o]=s[l],a--),a===0)break}if(a===0)break}if(a>0){const r=[];throw n.forEach((s,i)=>{s==null&&r.push(t[i])}),new ye(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return n}predictLoop(t,n=32,a=!1){return Se(()=>{const r=this.checkNumSamples(t);if(a)throw new jt("Verbose predictLoop() is not implemented yet.");const s=UR(r,n),i=this.outputs.map(o=>[]);for(let o=0;o<s.length;++o)Se(()=>{const u=s[o][0],c=s[o][1],h=Nv(t,u,c),p=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)p.push({key:this.inputs[g],value:h[g]});else p.push({key:this.inputs[0],value:h});const m=new ph(p);return Vv(this.outputs,m)}).forEach((u,c)=>i[c].push(u));return Hs(i.map(o=>za(o,0)))})}predict(t,n={}){const a=cae(t);aj(a,this.inputNames,this.feedInputShapes,!1);try{const r=n.batchSize==null?32:n.batchSize;return VR(r),this.predictLoop(a,r)}finally{Qo(a,t)}}predictOnBatch(t){aj(t,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,a=!0,r){if(this.optimizer_==null)throw new Oo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===VN?s.push(o.slice(0,o.length-1).concat([1])):s.push(o)}if(t=nj(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=nj(n,this.feedOutputNames,s,!1,"target"),Gat(t,n),Hat(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!==0)throw new ye(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,a,r,s=!0,i){const[o,l]=this.standardizeUserDataXY(t,n,s,i);if(a!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=oae(r,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await lae(l[h],null,c[h]))}return[o,l,u]}testLoop(t,n,a,r=0,s){return Se(()=>{const i=this.checkNumSamples(n,a,s,"steps"),o=[];if(r>0)throw new jt("Verbose mode is not implemented yet.");if(s!=null)throw new jt("steps mode in testLoop() is not implemented yet");{const l=UR(i,a),u=cs(bl(0,i));for(let c=0;c<l.length;++c){const h=l[c][0],p=l[c][1],m=wp(u,h,p-h),g=zO(n,m),y=t(g);if(c===0)for(let b=0;b<y.length;++b)o.push(kt(0));for(let b=0;b<y.length;++b){const v=y[b];o[b]=Ue(o[b],he(p-h,v))}}for(let c=0;c<o.length;++c)o[c]=gt(o[c],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,n=[];for(let a=0;a<t.length;++a){const r=t[a];let s=r;if(V6(t,r)>1){const i=V6(t.slice(0,a),r);s+=`_${i}`}n.push(s)}return n}makeTrainFunction(){return t=>{const n=[],a=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const h=[];for(let y=0;y<this.inputs.length;++y)h.push({key:this.inputs[y],value:a[y]});const p=new ph(h),m=Vv(this.outputs,p,{training:!0});let g;for(let y=0;y<this.lossFunctions.length;++y){const b=this.lossFunctions[y];let v=b(r[y],m[y]);s[y]!=null&&(v=Mat(v,s[y]));const w=Sa(v);n.push(w),y===0?g=v:g=Ue(g,v)}for(let y=0;y<this.metricsTensors.length;++y){let b;if(this.outputs.length>1&&y<this.outputs.length)b=n[y];else{const v=this.metricsTensors[y][0],w=this.metricsTensors[y][1];b=Sa(v(r[w],m[w]))}dr(b),i.push(b)}return g=Sa(g),this.calculateLosses().forEach(y=>{g=Ue(g,y)}),g},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(o,!0,l)].concat(i)}}makeTestFunction(){this.testFunction=t=>Se(()=>{const n=[];let a;const r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:r[u]});const o=new ph(i),l=Vv(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=Sa(c(s[u],l[u]));u===0?a=h:a=Ue(a,h),n.push(a)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],p=Sa(c(s[h],l[h]));n.push(p)}return n})}async fit(t,n,a={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,s,i,o,l,u,c,h,p;try{const m=a.batchSize==null?32:a.batchSize;VR(m);const y=await this.standardizeUserData(t,n,a.sampleWeight,a.classWeight,!1,m);r=y[0],s=y[1],p=y[2];let b=!1,v;if(a.validationData!=null&&a.validationData.length>0){if(b=!0,a.validationData.length===2)l=a.validationData[0],u=a.validationData[1];else throw a.validationData.length===3?new jt("validationData including sample weights is not supported yet."):new ye(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${a.validationData} is invalid.`);const O=await this.standardizeUserData(l,u,null,null,!0,m);c=O[0],h=O[1],v=c.concat(h)}else if(a.validationSplit!=null&&a.validationSplit>0&&a.validationSplit<1){b=!0;const D=Math.floor(r[0].shape[0]*(1-a.validationSplit)),O=r[0].shape[0];c=Nv(r,D,O),i=r,r=Nv(r,0,D),h=Nv(s,D,O),o=s,s=Nv(s,0,D),v=c.concat(h)}else a.validationSteps!=null&&(b=!0);const w=r.concat(s).concat(p);this.checkTrainableWeightsConsistency();const S=this.makeTrainFunction(),k=this.getDedupedMetricsNames();let I,T;b?(this.makeTestFunction(),I=this.testFunction,T=k.slice().concat(k.map(D=>"val_"+D))):(I=null,v=[],T=k.slice());const E=Zne(a.callbacks,a.yieldEvery);return await this.fitLoop(S,w,k,m,a.epochs,a.verbose,E,I,v,a.shuffle,T,a.initialEpoch,null,null)}finally{this.isTraining=!1,Qo(r,t),Qo(s,n),Qo(i,t),Qo(o,n),Qo(c,l),Qo(h,u),p!=null&&Yt(p)}}async fitLoop(t,n,a,r,s,i,o,l,u,c,h,p,m,g){r==null&&(r=32),s==null&&(s=1),c==null&&(c=!0),p==null&&(p=0);let y=!1;if(l!=null&&u!=null&&(y=!0),g!=null&&(y=!0,m==null))throw new ye("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=this.checkNumSamples(n,r,m,"steps_per_epoch");let v;b!=null&&(v=bl(0,b)),i==null&&(i=1);const{callbackList:w,history:S}=Jne(o,i,s,p,b,m,r,y,h);w.setModel(this),this.history=S,await w.onTrainBegin(),this.stopTraining_=!1;for(let k=p;k<s;++k){await w.onEpochBegin(k);const I={};if(m!=null)throw new jt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new jt("batch shuffling is not implemneted yet");c&&Lz(v);const T=cs(v),E=UR(b,r);for(let R=0;R<E.length;++R){const D={};if(await w.onBatchBegin(R,D),Se(()=>{const O=E[R][0],$=E[R][1],_=wp(T,O,$-O);D.batch=R,D.size=$-O;const P=zO(n,_),U=t(P);for(let W=0;W<a.length;++W){const B=a[W],H=U[W];D[B]=H,dr(H)}if(R===E.length-1&&y){const W=this.testLoop(l,u,r);for(let B=0;B<a.length;++B){const H=a[B],j=W[B];dr(j),I["val_"+H]=j}}}),await w.onBatchEnd(R,D),Qne(D),this.stopTraining_)break}T.dispose()}if(await w.onEpochEnd(k,I),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,n){return Bat(this,t,n)}async trainOnBatch(t,n){const a=await this.standardizeUserData(t,n),r=a[0],s=a[1],o=this.makeTrainFunction()(r.concat(s)),l=[];for(const u of o){const c=await u.data();l.push(c[0])}return Yt(o),Qo(a[0],t),Qo(a[1],n),Hs(l)}getNamedWeights(t){const n=[],a=t!=null&&t.trainableOnly,r=a?this.trainableWeights:this.weights,s=this.getWeights(a);for(let i=0;i<r.length;++i)a&&!r[i].trainable||n.push({name:r[i].originalName,tensor:s[i]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=bO().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-bO().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Vu(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>Vu(n))}else{const n=Object.keys(this.loss);t={};const a=this.loss;for(const r of n)if(typeof a[r]=="string")t[r]=Vu(a[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Vu(dI(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Vu(dI(t)));{const t={};for(const n in this.metrics)t[n]=Vu(dI(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=MO(t.optimizer_config),a=Qu(n);let r;if(typeof t.loss=="string")r=ip(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(i=>ip(i));else if(t.loss!=null){r={};for(const i in t.loss)r[i]=ip(t.loss[i])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(i=>ip(i));else if(t.metrics!=null){s={};for(const i in t.metrics)s[i]=ip(t.metrics[i])}this.compile({loss:r,metrics:s,optimizer:a})}async save(t,n){if(typeof t=="string"){const u=Cee(t);if(u.length===0)throw new ye(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new ye(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new ye("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const a=await xO(this.getNamedWeights(n)),o={modelTopology:this.toJSON(null,!1),format:qat,generatedBy:`TensorFlow.js tfjs-layers v${iae}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await xO(await this.optimizer.getWeights(),u);a.specs.push(...h),a.data=Iee([a.data,c])}return this.userDefinedMetadata!=null&&(Z6(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=a.data,o.weightSpecs=a.specs,t.save(o)}setUserDefinedMetadata(t){Z6(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}iy.className="Model";We(iy);class hae extends iy{}hae.className="Functional";We(hae);class _w extends iy{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:OE("sequential_"),t.layers!=null)for(const n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(a=>a<0))throw new ye(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof _w||t instanceof iy;let a;if(n){if(a=t,a.outputs.length!==1)throw new ye("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(a.inputs.length!==1)throw new ye("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ye("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=Xnt({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(n)this.outputs=a.outputs,this.inputs=a.inputs;else{if(t.inboundNodes.length!==1)throw new ye(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ye("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=jne(this.outputs[0])}this.inboundNodes=[],new ME({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Jp(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(vn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new iy({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,a=console.log){this.built||this.build(),super.summary(t,n,a)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,a={}){if(!this.built)throw new Oo("The model needs to be compiled before being used.");return this.model.evaluate(t,n,a)}async evaluateDataset(t,n){if(!this.built)throw new Oo("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,a={}){if(!this.built)throw new Oo("The model needs to be compiled before being used.");return this.model.fit(t,n,a)}async fitDataset(t,n){if(!this.built)throw new Oo("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,a={},r=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new ye("Legacy serialization format not supported yet.");s=n}else q(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;const o=new t(i);if(!(o instanceof _w))throw new jt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of s){const c=Qu(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(t){if(this.model==null)throw new ye("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ye("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const a={};a.className=n.getClassName(),a.config=n.getConfig(),t.push(a)}return{name:this.name,layers:t}}}_w.className="Sequential";We(_w);let ms=class extends Gm{getConfig(){return{}}};class dae extends ms{apply(t,n=1){return Dnt(t,n)}}dae.className="elu";We(dae);class pae extends ms{apply(t){return uE(t)}}pae.className="selu";We(pae);class fae extends ms{apply(t){return kl(t)}}fae.className="relu";We(fae);class mae extends ms{apply(t){return Se(()=>Uh(6,kl(t)))}}mae.className="relu6";We(mae);class gae extends ms{apply(t){return t}}gae.className="linear";We(gae);class yae extends ms{apply(t){return cl(t)}}yae.className="sigmoid";We(yae);class bae extends ms{apply(t){return Fnt(t)}}bae.className="hardSigmoid";We(bae);class xae extends ms{apply(t){return Um(t)}}xae.className="softplus";We(xae);class vae extends ms{apply(t){return Ont(t)}}vae.className="softsign";We(vae);class wae extends ms{apply(t){return Vh(t)}}wae.className="tanh";We(wae);let JP=class extends ms{apply(t,n=-1){return hS(t,n)}};JP.className="softmax";We(JP);class Aae extends ms{apply(t,n=-1){return tE(t,n)}}Aae.className="logSoftmax";We(Aae);class Sae extends ms{apply(t){return Se(()=>Se(()=>{const n=Math.sqrt(2),a=he(.5,Ue(1,ZT(gt(t,n))));return he(t,a)}))}}Sae.className="gelu";We(Sae);class kae extends ms{apply(t){return Se(()=>he(.5,he(t,Ue(1,Vh(he(Lr(gt(2,Math.PI)),Ue(t,he(.044715,iu(t,3)))))))))}}kae.className="gelu_new";We(kae);class Iae extends ms{apply(t){return Se(()=>he(t,Vh(Um(t))))}}Iae.className="mish";We(Iae);class Nae extends ms{apply(t,n=1){return Se(()=>he(cl(he(t,n)),t))}}Nae.className="swish";We(Nae);function Gh(e){return e.getClassName()}function WR(e,t={}){return yS(e,Ki.getMap().classNameMap,t,"activation")}function Hh(e){if(e==null){const t={};return t.className="linear",t.config={},WR(t)}if(typeof e=="string"){const t={};return t.className=e,t.config={},WR(t)}else return e instanceof ms?e:WR(e)}function Kat(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class Cae extends Gm{}class Tae extends Cae{constructor(t){super(),Kat(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return Se(()=>{let n=Ya([1]);return this.hasL1&&(n=Ue(n,ct(he(this.l1,Xa(t))))),this.hasL2&&(n=Ue(n,ct(he(this.l2,xS(t))))),me(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}}Tae.className="L1L2";We(Tae);const rj={l1l2:"L1L2"};function Jn(e){return BP(e)}function sj(e,t={}){return yS(e,Ki.getMap().classNameMap,t,"regularizer")}function ya(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in rj?rj[e]:e,config:{}};return sj(n)}else return e instanceof Cae?e:sj(e)}class Eae extends Jt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,n){t=$t(t);let a=kl(t);return this.maxValue!=null&&(a=ni(a,0,this.maxValue)),a}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}}Eae.className="ReLU";We(Eae);class $ae extends Jt{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const a=$t(t);return tS(a,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}$ae.className="LeakyReLU";We($ae);class _ae extends Jt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=ma(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ya(t.alphaRegularizer),this.alphaConstraint=xr(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new ye(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=vn(t);const n=t.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)n[r-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const a={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)a[r]=t[r];this.inputSpec=[new fr({ndim:t.length,axes:a})],this.built=!0}call(t,n){return t=$t(t),lS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Ia(this.alphaInitializer),alphaRegularizer:Jn(this.alphaRegularizer),alphaConstraint:br(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}}_ae.className="PReLU";We(_ae);let Rae=class extends Jt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new jt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const a=$t(t);return u0(a)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};Rae.className="ELU";We(Rae);class Dae extends Jt{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const a=$t(t);return he(a,Xe(ii(a,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}}Dae.className="ThresholdedReLU";We(Dae);class Oae extends Jt{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new JP().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){return Se(()=>{let a=$t(t);const r=n.mask;if(r!=null){const s=he(it(qs(a.shape),Xe(r,a.dtype)),kt(-1e9));a=Ue(a,s)}return this.axis instanceof Array?this.axis.length>1?ai(it(a,aS(a,this.axis,!0))):this.softmax(a,this.axis[0]):this.softmax(a,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}Oae.className="Softmax";We(Oae);function oy(e,t,n){if(typeof e=="number")return Jp(e,t);if(e.length!==t)throw new ye(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){const r=e[a];if(!Ent(r))throw new ye(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function hl(e,t,n,a,r=1){if(e==null)return e;const s=t+(t-1)*(r-1);let i;return n==="same"?i=e:i=e-s+1,Math.floor((i+a-1)/a)}function Vl(e,t,n,a){if(e==null)return null;if(a==="valid")e=e*t+Wh([n-t,0]);else if(a==="same")e=e*t;else throw new ye(`Unsupport padding mode: ${a}.`);return e}function e4(e,t){return Se(()=>(Wa(t),t==="channelsFirst"?an(e,[0,2,3,1]):e))}function Fae(e,t){return Se(()=>(Wa(t),t==="channelsFirst"?an(e,[0,2,3,4,1]):e))}function Xat(e,t,n,a=1,r="valid",s,i=1){return Se(()=>{if(s==null&&(s=xl()),Wa(s),e.shape.length!==3)throw new ye(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new ye(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new ye(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=an(e,[0,2,1])),r==="causal")throw new jt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=KT(e,t,a,r==="same"?"same":"valid","NWC",i);return n!=null&&(o=Il(o,n)),o})}function ij(e,t,n,a=[1,1],r="valid",s,i,o=null){return Se(()=>{if(s==null&&(s=xl()),Wa(s),e.rank!==3&&e.rank!==4)throw new ye(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ye(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=e4(e,s);if(r==="causal")throw new jt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Cte({x:l,filter:t,strides:a,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=an(l,[0,3,1,2])),l})}function Yat(e,t,n,a=[1,1,1],r="valid",s,i){return Se(()=>{if(s==null&&(s=xl()),Wa(s),e.rank!==4&&e.rank!==5)throw new ye(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ye(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Fae(e,s);if(r==="causal")throw new jt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=vB(o,t,a,r==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Il(o,n)),s==="channelsFirst"&&(o=an(o,[0,4,1,2,3])),o})}class BE extends Jt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",BE.verifyArgs(n),this.rank=t,Rr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new jt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=oy(n.kernelSize,t,"kernelSize"),this.strides=oy(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,ho(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Wa(this.dataFormat),this.activation=Hh(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=ma(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=xr(n.biasConstraint),this.biasRegularizer=ya(n.biasRegularizer),this.activityRegularizer=ya(n.activityRegularizer),this.dilationRate=oy(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ye(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ye(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ye(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Pl("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!PP(t.kernelSize,"number",1,3))throw new ye(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Gh(this.activation),useBias:this.useBias,biasInitializer:Ia(this.biasInitializer),biasRegularizer:Jn(this.biasRegularizer),activityRegularizer:Jn(this.activityRegularizer),biasConstraint:br(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}class f0 extends BE{constructor(t,n){super(t,n),this.kernel=null,f0.verifyArgs(n),this.filters=n.filters,Rr(this.filters,"filters"),this.kernelInitializer=ma(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=xr(n.kernelConstraint),this.kernelRegularizer=ya(n.kernelRegularizer)}build(t){t=vn(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ye(`The channel dimension of the input should be defined. Found ${t[n]}`);const a=t[n],r=this.kernelSize.concat([a,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:a}}],this.built=!0}call(t,n){return Se(()=>{t=$t(t);let a;const r=this.bias==null?null:this.bias.read(),s=_ne(this.activation.getClassName());if(s!=null&&this.rank===2)a=ij(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)a=Xat(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)a=ij(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)a=Yat(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new jt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(a=this.activation.apply(a))}return a})}computeOutputShape(t){t=vn(t);const n=[],a=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<a.length;++s){const i=hl(a[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){const t={filters:this.filters,kernelInitializer:Ia(this.kernelInitializer),kernelRegularizer:Jn(this.kernelRegularizer),kernelConstraint:br(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ye(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class SS extends f0{constructor(t){super(2,t),SS.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!PP(t.kernelSize,"number",1,2))throw new ye(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}SS.className="Conv2D";We(SS);class kS extends f0{constructor(t){super(3,t),kS.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ye(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}kS.className="Conv3D";We(kS);class Mae extends SS{constructor(t){if(super(t),this.inputSpec=[new fr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ye(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=vn(t),t.length!==4)throw new ye("Input should have rank 4; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ye("The channel dimension of the inputs should be defined. Found `None`.");const a=t[n],r=this.kernelSize.concat([this.filters,a]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new fr({ndim:4,axes:{[n]:a}})],this.built=!0}call(t,n){return Se(()=>{let a=$t(t);if(a.shape.length!==4)throw new ye(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${a.shape.length}`);const r=a.shape,s=r[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const l=r[i],u=r[o],c=this.kernelSize[0],h=this.kernelSize[1],p=this.strides[0],m=this.strides[1],g=Vl(l,p,c,this.padding),y=Vl(u,m,h,this.padding),b=[s,g,y,this.filters];this.dataFormat!=="channelsLast"&&(a=an(a,[0,2,3,1]));let v=XT(a,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=an(v,[0,3,1,2])),this.bias!=null&&(v=Il(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(t){t=vn(t);const n=t.slice();let a,r,s;this.dataFormat==="channelsFirst"?(a=1,r=2,s=3):(a=3,r=1,s=2);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[a]=this.filters,n[r]=Vl(n[r],l,i,this.padding),n[s]=Vl(n[s],u,o,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Mae.className="Conv2DTranspose";We(Mae);class Lae extends kS{constructor(t){if(super(t),this.inputSpec=[new fr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ye(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=vn(t),t.length!==5)throw new ye("Input should have rank 5; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ye("The channel dimension of the inputs should be defined. Found `None`.");const a=t[n],r=this.kernelSize.concat([this.filters,a]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new fr({ndim:5,axes:{[n]:a}})],this.built=!0}call(t,n){return Se(()=>{let a=$t(t);if(a.shape.length!==5)throw new ye(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${a.shape.length}`);const r=a.shape,s=r[0];let i,o,l;this.dataFormat==="channelsFirst"?(l=2,i=3,o=4):(l=1,i=2,o=3);const u=r[l],c=r[i],h=r[o],p=this.kernelSize[0],m=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[0],b=this.strides[1],v=this.strides[2],w=Vl(u,y,p,this.padding),S=Vl(c,b,m,this.padding),k=Vl(h,v,g,this.padding),I=[s,w,S,k,this.filters];this.dataFormat!=="channelsLast"&&(a=an(a,[0,2,3,4,1]));let T=wB(a,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(T=an(T,[0,4,1,2,3])),this.bias!==null&&(T=Il(T,this.bias.read(),this.dataFormat)),this.activation!==null&&(T=this.activation.apply(T)),T})}computeOutputShape(t){t=vn(t);const n=t.slice();let a,r,s,i;this.dataFormat==="channelsFirst"?(a=1,r=2,s=3,i=4):(a=4,r=1,s=2,i=3);const o=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],p=this.strides[2];return n[a]=this.filters,n[r]=Vl(n[r],c,o,this.padding),n[s]=Vl(n[s],h,l,this.padding),n[i]=Vl(n[i],p,u,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Lae.className="Conv3DTranspose";We(Lae);class zae extends f0{constructor(t,n){if(super(t,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new ye("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new ye("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new ye(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=ma(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ya(n.depthwiseRegularizer),this.depthwiseConstraint=xr(n.depthwiseConstraint),this.pointwiseInitializer=ma(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ya(n.pointwiseRegularizer),this.pointwiseConstraint=xr(n.pointwiseConstraint)}build(t){if(t=vn(t),t.length<this.rank+2)throw new ye(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0)throw new ye(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);const a=t[n],r=this.kernelSize.concat([a,this.depthMultiplier]),s=[];for(let o=0;o<this.rank;++o)s.push(1);s.push(a*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new fr({ndim:this.rank+2,axes:{[n]:a}})],this.built=!0}call(t,n){return Se(()=>{t=$t(t);let a;if(this.rank===1)throw new jt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=an(t,[0,2,3,1])),a=cE(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(a=Il(a,this.bias.read(),this.dataFormat)),this.activation!=null&&(a=this.activation.apply(a)),this.dataFormat==="channelsFirst"&&(a=an(a,[0,3,1,2])),a})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ia(this.depthwiseInitializer),t.pointwiseInitializer=Ia(this.pointwiseInitializer),t.depthwiseRegularizer=Jn(this.depthwiseRegularizer),t.pointwiseRegularizer=Jn(this.pointwiseRegularizer),t.depthwiseConstraint=br(this.depthwiseConstraint),t.pointwiseConstraint=br(this.pointwiseConstraint),t}}zae.className="SeparableConv";class Bae extends zae{constructor(t){super(2,t)}}Bae.className="SeparableConv2D";We(Bae);class PE extends f0{constructor(t){super(1,t),PE.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!PP(t.kernelSize,"number",1,1))throw new ye(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}PE.className="Conv1D";We(PE);class Pae extends Jt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return Se(()=>{if(t=$t(t),this.dataFormat==="channelsLast"){const a=hI(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return hI(a,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const a=hI(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return hI(a,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}Pae.className="Cropping2D";We(Pae);class Vae extends Jt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wa(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,Nnt(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2],a=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,a]}else{const n=t[1]==null?null:this.size[0]*t[1],a=t[2]==null?null:this.size[1]*t[2];return[t[0],n,a,t[3]]}}call(t,n){return Se(()=>{let a=$t(t);const r=a.shape;if(this.dataFormat==="channelsFirst"){a=an(a,[0,2,3,1]);const s=this.size[0]*r[2],i=this.size[1]*r[3],o=this.interpolation==="nearest"?sl.resizeNearestNeighbor(a,[s,i]):sl.resizeBilinear(a,[s,i]);return an(o,[0,3,1,2])}else{const s=this.size[0]*r[1],i=this.size[1]*r[2];return this.interpolation==="nearest"?sl.resizeNearestNeighbor(a,[s,i]):sl.resizeBilinear(a,[s,i])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}}Vae.className="UpSampling2D";We(Vae);function Qat(e,t,n=[1,1],a="valid",r,s){return Se(()=>{r==null&&(r=xl()),Wa(r);let i=e4(e,r);if(e.rank!==4)throw new ye(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new ye(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=l0(i,t,n,a==="same"?"same":"valid","NHWC",s),r==="channelsFirst"&&(i=an(i,[0,3,1,2])),i})}class Uae extends BE{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ma(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=xr(t.depthwiseConstraint),this.depthwiseRegularizer=ya(t.depthwiseRegularizer)}build(t){if(t=vn(t),t.length<4)throw new ye(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0)throw new ye(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);const a=t[n],r=[this.kernelSize[0],this.kernelSize[1],a,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[a*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Se(()=>{t=$t(t);let a=Qat(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(a=Il(a,this.bias.read(),this.dataFormat)),this.activation!=null&&(a=this.activation.apply(a)),a})}computeOutputShape(t){t=vn(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1],a=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=hl(n,this.kernelSize[0],this.padding,this.strides[0]),i=hl(a,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,s,i]:[t[0],s,i,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ia(this.depthwiseInitializer),t.depthwiseRegularizer=Jn(this.depthwiseRegularizer),t.depthwiseConstraint=br(this.depthwiseRegularizer),t}}Uae.className="DepthwiseConv2D";We(Uae);function Wae(e,t,n,a){if(Array.isArray(e)){if(t!=null||n!=null)throw new ye("When inputs is an array, neither initialState or constants should be provided");a!=null&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function Gae(e,t,n,a=!1,r,s,i=!1,o=!1){return Se(()=>{const l=t.shape.length;if(l<3)throw new ye(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(bl(2,l));t=an(t,u),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Xe(Xe(r,"bool"),"float32"),r.rank===l-1&&(r=us(r,-1)),r=an(r,u)),a&&(t=oo(t,0),r!=null&&(r=oo(r,0)));const c=[];let h,p=n;const m=t.shape[0],g=lo(t);let y;r!=null&&(y=lo(r));for(let v=0;v<m;++v){const w=g[v],S=Se(()=>e(w,p));if(r==null)h=S[0],p=S[1];else{const k=Se(()=>{const I=y[v],T=it(Oi(I),I),E=Ue(he(S[0],I),he(p[0],T)),R=p.map((D,O)=>Ue(he(S[1][O],I),he(D,T)));return{output:E,newStates:R}});h=k.output,p=k.newStates}o&&c.push(h)}let b;return o&&(b=ri(c,1)),[h,b,p]})}class xd extends Jt{constructor(t){super(t);let n;if(t.cell==null)throw new ye("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new a4({cells:t.cell}):n=t.cell,n.stateSize==null)throw new ye("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new fr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return bl(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){DO(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const a=n[0];let r;if(this.returnSequences?r=[t[0],t[1],a]:r=[t[0],a],this.returnState){const s=[];for(const i of n)s.push([t[0],i]);return[r].concat(s)}else return r}computeMask(t,n){return Se(()=>{Array.isArray(n)&&(n=n[0]);const a=this.returnSequences?n:null;if(this.returnState){const r=this.states.map(s=>null);return[a].concat(r)}else return a})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let a=0;a<t;++a)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new jt("Constants support is not implemented in RNN yet.");DO(t)&&(t=t[0]),t=t;const n=this.stateful?t[0]:null,a=t.slice(2);this.inputSpec[0]=new fr({shape:[n,null,...a]});const r=[t[0]].concat(t.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!tn(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new ye(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new fr({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){Se(()=>{if(!this.stateful)throw new Bl("Cannot call resetStates() on an RNN Layer that is not stateful.");const a=this.inputSpec[0].shape[0];if(a==null)throw new ye("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Ya([a,r])):this.states_=[Ya([a,this.cell.stateSize])];else if(t==null)Yt(this.states_),this.keptStates!=null&&(Yt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Ya([a,r])):this.states_[0]=Ya([a,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ye(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Yt(this.states_);for(let r=0;r<this.states_.length;++r){const s=t[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[a,i];if(!tn(s.shape,o))throw new ye(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>dr(r.clone()))})}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const s=Wae(t,a,r,this.numConstants);t=s.inputs,a=s.initialState,r=s.constants;let i=[],o=[];if(a!=null){n.initialState=a,i=i.concat(a),this.stateSpec=[];for(const u of a)this.stateSpec.push(new fr({shape:u.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof lu){const u=[t].concat(i),c=this.inputSpec.concat(o),h=this.inputSpec;this.inputSpec=c;const p=super.apply(u,n);return this.inputSpec=h,p}else return super.apply(t,n)}call(t,n){return Se(()=>{const a=n==null?null:n.mask,r=n==null?null:n.training;let s=n==null?null:n.initialState;t=$t(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new ye(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},u=Gae((g,y)=>{const b=this.cell.call([g].concat(y),o);return[b[0],b.slice(1)]},t,s,this.goBackwards,a,null,this.unroll,this.returnSequences),c=u[0],h=u[1],p=u[2];this.stateful&&this.resetStates(p,r);const m=this.returnSequences?h:c;return this.returnState?[m].concat(p):m})}getInitialState(t){return Se(()=>{let n=Ya(t.shape);return n=ct(n,[1,2]),n=bS(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?_O(n,[1,a]):n):this.cell.stateSize>1?[_O(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const a=this.cell.getConfig();return this.getClassName()===xd.className&&(n.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),t),n)}static fromConfig(t,n,a={}){const r=n.cell,s=Qu(r,a);return new t(Object.assign(n,{cell:s}))}}xd.className="RNN";We(xd);class VE extends Jt{}class t4 extends VE{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Rr(this.units,"units"),this.activation=Hh(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ma(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ma(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ma(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ya(t.kernelRegularizer),this.recurrentRegularizer=ya(t.recurrentRegularizer),this.biasRegularizer=ya(t.biasRegularizer),this.kernelConstraint=xr(t.kernelConstraint),this.recurrentConstraint=xr(t.recurrentConstraint),this.biasConstraint=xr(t.biasConstraint),this.dropout=Oy([1,Wh([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Oy([1,Wh([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=vn(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Se(()=>{if(t=t,t.length!==2)throw new ye(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let a=t[1];t=t[0];const r=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jh({ones:()=>Oi(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jh({ones:()=>Oi(a),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?s=Jl(he(t,i),this.kernel.read()):s=Jl(t,this.kernel.read()),this.bias!=null&&(s=Il(s,this.bias.read())),o!=null&&(a=he(a,o));let l=Ue(s,Jl(a,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Gh(this.activation),useBias:this.useBias,kernelInitializer:Ia(this.kernelInitializer),recurrentInitializer:Ia(this.recurrentInitializer),biasInitializer:Ia(this.biasInitializer),kernelRegularizer:Jn(this.kernelRegularizer),recurrentRegularizer:Jn(this.recurrentRegularizer),biasRegularizer:Jn(this.biasRegularizer),activityRegularizer:Jn(this.activityRegularizer),kernelConstraint:br(this.kernelConstraint),recurrentConstraint:br(this.recurrentConstraint),biasConstraint:br(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}t4.className="SimpleRNNCell";We(t4);class Hae extends xd{constructor(t){t.cell=new t4(t),super(t)}call(t,n){return Se(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;return super.call(t,{mask:a,training:r,initialState:s})})}static fromConfig(t,n){return new t(n)}}Hae.className="SimpleRNN";We(Hae);class n4 extends VE{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new ye("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Rr(this.units,"units"),this.activation=Hh(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Hh(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ma(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ma(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ma(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ya(t.kernelRegularizer),this.recurrentRegularizer=ya(t.recurrentRegularizer),this.biasRegularizer=ya(t.biasRegularizer),this.kernelConstraint=xr(t.kernelConstraint),this.recurrentConstraint=xr(t.recurrentConstraint),this.biasConstraint=xr(t.biasConstraint),this.dropout=Oy([1,Wh([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Oy([1,Wh([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=vn(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Se(()=>{if(t=t,t.length!==2)throw new ye(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const a=n.training==null?!1:n.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jh({ones:()=>Oi(t),rate:this.dropout,training:a,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jh({ones:()=>Oi(r),rate:this.recurrentDropout,training:a,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u;0<this.dropout&&this.dropout<1&&(t=he(t,s[0]));let c=Jl(t,this.kernel.read());this.useBias&&(c=Il(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=he(r,i[0]));const h=this.recurrentKernel.read(),[p,m]=Ys(h,[2*this.units,this.units],h.rank-1),g=Jl(r,p),[y,b,v]=Ys(c,3,c.rank-1),[w,S]=Ys(g,2,g.rank-1);o=this.recurrentActivation.apply(Ue(y,w)),l=this.recurrentActivation.apply(Ue(b,S));const k=Jl(he(l,r),m);u=this.activation.apply(Ue(v,k));const I=Ue(he(o,r),he(Ue(1,ia(o)),u));return[I,I]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Gh(this.activation),recurrentActivation:Gh(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ia(this.kernelInitializer),recurrentInitializer:Ia(this.recurrentInitializer),biasInitializer:Ia(this.biasInitializer),kernelRegularizer:Jn(this.kernelRegularizer),recurrentRegularizer:Jn(this.recurrentRegularizer),biasRegularizer:Jn(this.biasRegularizer),activityRegularizer:Jn(this.activityRegularizer),kernelConstraint:br(this.kernelConstraint),recurrentConstraint:br(this.recurrentConstraint),biasConstraint:br(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),n)}}n4.className="GRUCell";We(n4);class jae extends xd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new n4(t),super(t)}call(t,n){return Se(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;return super.call(t,{mask:a,training:r,initialState:s})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}jae.className="GRU";We(jae);class UE extends VE{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Rr(this.units,"units"),this.activation=Hh(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Hh(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=ma(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ma(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ma(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=ya(t.kernelRegularizer),this.recurrentRegularizer=ya(t.recurrentRegularizer),this.biasRegularizer=ya(t.biasRegularizer),this.kernelConstraint=xr(t.kernelConstraint),this.recurrentConstraint=xr(t.recurrentConstraint),this.biasConstraint=xr(t.biasConstraint),this.dropout=Oy([1,Wh([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Oy([1,Wh([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;t=vn(t);const a=t[t.length-1];this.kernel=this.addWeight("kernel",[a,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const s=this.biasInitializer,i=this.units;r=new(n=class extends Go{apply(l,u){const c=s.apply([i]),h=new UP().apply([i]),p=s.apply([i*2]);return W6(W6(c,h),p)}},n.className="CustomInit",n)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return Se(()=>{const a=n.training==null?!1:n.training;if(t=t,t.length!==3)throw new ye(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jh({ones:()=>Oi(t),rate:this.dropout,training:a,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jh({ones:()=>Oi(r),rate:this.recurrentDropout,training:a,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(t=he(t,i[0]));let p=Jl(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=he(r,o[0])),p=Ue(p,Jl(r,this.recurrentKernel.read())),this.useBias&&(p=Il(p,this.bias.read()));const[m,g,y,b]=Ys(p,4,p.rank-1);l=this.recurrentActivation.apply(m),u=this.recurrentActivation.apply(g),c=Ue(he(u,s),he(l,this.activation.apply(y))),h=this.recurrentActivation.apply(b);const v=he(h,this.activation.apply(c));return[v,v,c]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Gh(this.activation),recurrentActivation:Gh(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ia(this.kernelInitializer),recurrentInitializer:Ia(this.recurrentInitializer),biasInitializer:Ia(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Jn(this.kernelRegularizer),recurrentRegularizer:Jn(this.recurrentRegularizer),biasRegularizer:Jn(this.biasRegularizer),activityRegularizer:Jn(this.activityRegularizer),kernelConstraint:br(this.kernelConstraint),recurrentConstraint:br(this.recurrentConstraint),biasConstraint:br(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}UE.className="LSTMCell";We(UE);class qae extends xd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new UE(t),super(t)}call(t,n){return Se(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;return super.call(t,{mask:a,training:r,initialState:s})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}qae.className="LSTM";We(qae);class a4 extends VE{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return Se(()=>{t=t;let a=t.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(a.splice(0,o.stateSize.length)):r.push(a.splice(0,1));r.reverse();const s=[];let i;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];a=r[o],o===0?i=[t[0]].concat(a):i=[i[0]].concat(a),i=l.call(i,n),s.push(i.slice(1))}a=[];for(const o of s.slice().reverse())a.push(...o);return[i[0]].concat(a)})}build(t){DO(t)&&(t=t[0]),t=t;let n;this.cells.forEach((a,r)=>{vp(`RNNCell_${r}`,()=>{a.build(t),Array.isArray(a.stateSize)?n=a.stateSize[0]:n=a.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){const t=super.getConfig(),n=s=>({className:s.getClassName(),config:s.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},t),r)}static fromConfig(t,n,a={}){const r=[];for(const s of n.cells)r.push(Qu(s,a));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const a of this.cells)n.push(...a.trainableWeights);return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells)t.push(...n.weights);return OO(t)}setWeights(t){const n=[];for(const a of this.cells){const r=a.weights.length,s=t.splice(r);for(let i=0;i<a.weights.length;++i)n.push([a.weights[i],s[i]])}XP(n)}}a4.className="StackedRNNCells";We(a4);function jh(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):zne(t(),n),o=()=>vS(i,t,a);return!r||r<=1?dr(o().clone()):Array(r).fill(void 0).map(o).map(u=>dr(u.clone()))}var Zat=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n};class Kae extends xd{constructor(t){if(t.unroll)throw new jt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new jt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new fr({ndim:5})]}call(t,n){return Se(()=>{if(this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new ye("ConvRNN2D cell does not support constants");const a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;return super.call(t,{mask:a,training:r,initialState:s})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return Se(()=>{const{stateSize:n}=this.cell,a=t.shape,r=this.computeSingleOutputShape(a),s=[r[0],...r.slice(2)],i=Ya(s);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(t,n=!1){Se(()=>{if(!this.stateful)throw new Bl("Cannot call resetStates() on an RNN Layer that is not stateful.");const a=this.inputSpec[0].shape,r=this.computeSingleOutputShape(a),s=[r[0],...r.slice(2)];if(a[0]==null)throw new ye("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ya(s)):this.states_=[Ya(s)];else if(t==null)Yt(this.states_),this.keptStates!=null&&(Yt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ya(s)):this.states_[0]=Ya(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ye(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):Yt(this.states_);for(let o=0;o<this.states_.length;++o){const l=t[o],u=s;if(!tn(l.shape,u))throw new ye(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>dr(o.clone()))})}computeSingleOutputShape(t){const{dataFormat:n,filters:a,kernelSize:r,padding:s,strides:i,dilationRate:o}=this.cell,l=n==="channelsFirst",u=t[l?3:2],c=t[l?4:3],h=hl(u,r[0],s,i[0],o[0]),p=hl(c,r[1],s,i[1],o[1]);return[...t.slice(0,2),...l?[a,h,p]:[h,p,a]]}}Kae.className="ConvRNN2D";class r4 extends UE{constructor(t){const{filters:n,kernelSize:a,strides:r,padding:s,dataFormat:i,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:n})),this.filters=n,Rr(this.filters,"filters"),this.kernelSize=oy(a,2,"kernelSize"),this.kernelSize.forEach(l=>Rr(l,"kernelSize")),this.strides=oy(r||1,2,"strides"),this.strides.forEach(l=>Rr(l,"strides")),this.padding=s||"valid",ho(this.padding),this.dataFormat=i||"channelsLast",Wa(this.dataFormat),this.dilationRate=oy(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>Rr(l,"dilationRate"))}build(t){var n;t=vn(t);const a=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[a]==null)throw new ye(`The channel dimension of the input should be defined. Found ${t[a]}`);const r=t[a],s=4,i=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends Go{apply(p,m){const g=u.apply([c]),y=qs([c]),b=u.apply([c*2]);return VP([g,y,b])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return Se(()=>{if(t.length!==3)throw new ye(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const a=n.training||!1,r=t[0],s=t[1],i=t[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=jh({ones:()=>Oi(r),rate:this.dropout,training:a,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(te,V,Q)=>!V||!V[Q]?te:he(V[Q],te);let c=u(r,l,0),h=u(r,l,1),p=u(r,l,2),m=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=jh({ones:()=>Oi(s),rate:this.recurrentDropout,training:a,count:o,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let y=u(s,g,0),b=u(s,g,1),v=u(s,g,2),w=u(s,g,3);const S=3,[k,I,T,E]=Ys(this.kernel.read(),o,S),[R,D,O,$]=this.useBias?Ys(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,k,R,this.padding),h=this.inputConv(h,I,D,this.padding),p=this.inputConv(p,T,O,this.padding),m=this.inputConv(m,E,$,this.padding);const[_,P,U,W]=Ys(this.recurrentKernel.read(),o,S);y=this.recurrentConv(y,_),b=this.recurrentConv(b,P),v=this.recurrentConv(v,U),w=this.recurrentConv(w,W);const B=this.recurrentActivation.apply(Ue(c,y)),H=this.recurrentActivation.apply(Ue(h,b)),j=Ue(he(H,i),he(B,this.activation.apply(Ue(p,v)))),Z=he(this.recurrentActivation.apply(Ue(m,w)),this.activation.apply(j));return[Z,Z,j]})}getConfig(){const t=super.getConfig(),{units:n}=t,a=Zat(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},a),r)}inputConv(t,n,a,r){const s=ac(t,n,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return a?Il(s,a,this.dataFormat):s}recurrentConv(t,n){return ac(t,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}r4.className="ConvLSTM2DCell";We(r4);class Xae extends Kae{constructor(t){const n=new r4(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}Xae.className="ConvLSTM2D";We(Xae);class s4 extends Jt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const n=t.shape,a=[];for(let r=0;r<this.noiseShape.length;++r)a.push(this.noiseShape[r]==null?n[r]:this.noiseShape[r]);return a}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const a=$t(t);if(0<this.rate&&this.rate<1){const r=n.training==null?!1:n.training,s=this.getNoiseShape(a);return vS(()=>zne(a,this.rate,s,this.seed),()=>a,r)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}}s4.className="Dropout";We(s4);class Yae extends s4{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}Yae.className="SpatialDropout1D";We(Yae);class Qae extends Jt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;t.batchSize!=null&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,Rr(this.units,"units"),this.activation=Hh(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=ma(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ma(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=xr(t.kernelConstraint),this.biasConstraint=xr(t.biasConstraint),this.kernelRegularizer=ya(t.kernelRegularizer),this.biasRegularizer=ya(t.biasRegularizer),this.activityRegularizer=ya(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=vn(t);const n=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){t=vn(t);const n=t.slice();return n[n.length-1]=this.units,n}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const a=$t(t),r=_ne(this.activation.getClassName());let s;return r!=null?s=Jl(a,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Jl(a,this.kernel.read()),this.bias!=null&&(s=Il(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){const t={units:this.units,activation:Gh(this.activation),useBias:this.useBias,kernelInitializer:Ia(this.kernelInitializer),biasInitializer:Ia(this.biasInitializer),kernelRegularizer:Jn(this.kernelRegularizer),biasRegularizer:Jn(this.biasRegularizer),activityRegularizer:Jn(this.activityRegularizer),kernelConstraint:br(this.kernelConstraint),biasConstraint:br(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}Qae.className="Dense";We(Qae);class Zae extends Jt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=vn(t);for(const n of t.slice(1))if(n==null)throw new ye(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],vh(t,1)]}call(t,n){return Se(()=>{this.invokeCallHook(t,n);let a=$t(t);if(this.dataFormat==="channelsFirst"&&a.rank>1){const r=[0];for(let s=2;s<a.rank;++s)r.push(s);r.push(1),a=an(a,r)}return Rnt(a)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(t,n),t}}Zae.className="Flatten";We(Zae);class Jae extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.activation=Hh(t.activation)}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const a=$t(t);return this.activation.apply(a)})}getConfig(){const t={activation:Gh(this.activation)},n=super.getConfig();return Object.assign(t,n),t}}Jae.className="Activation";We(Jae);class ere extends Jt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return Se(()=>(t=$t(t),$nt(t,this.n)))}getConfig(){const t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}}ere.className="RepeatVector";We(ere);class tre extends Jt{constructor(t){super(t),this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const a="Total size of new array must be unchanged.",r=n.slice();let s=1,i=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(i===null)i=l;else throw new ye("Can only specifiy one unknown dimension.");else s*=u}const o=vh(t);if(i!==null){if(s===0||o%s!==0)throw new ye(a);r[i]=o/s}else if(o!==s)throw new ye(a);return r}computeOutputShape(t){let n=!1;for(let a=0;a<t.length;++a)if(this.isUnknown(t[a])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const a=$t(t),r=a.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return me(a,s)})}getConfig(){const t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}}tre.className="Reshape";We(tre);class nre extends Jt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const n=bl(1,t.dims.length+1);if(!tn(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new fr({ndim:this.dims.length+1})]}computeOutputShape(t){t=vn(t);const n=t.slice();return this.dims.forEach((a,r)=>{n[r+1]=t[a]}),n}call(t,n){return an($t(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}}nre.className="Permute";We(nre);class are extends Jt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){const a=$t(t);return Iw(Yp(a,this.maskValue),-1)}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const a=$t(t),i=Iw(Yp(a,this.maskValue),-1,!0);return he(a,Xe(i,a.dtype))})}}are.className="Masking";We(are);class rre extends Jt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let n=null;t.batchSize!=null&&(n=t.batchSize),t.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat($n(t.inputLength))}this.inputDim=t.inputDim,Rr(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Rr(this.outputDim,"outputDim"),this.embeddingsInitializer=ma(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ya(t.embeddingsRegularizer),this.activityRegularizer=ya(t.activityRegularizer),this.embeddingsConstraint=xr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return Se(()=>this.maskZero?(t=$t(t),Yp(t,cn(t))):null)}computeOutputShape(t){if(t=vn(t),this.inputLength==null)return[...t,this.outputDim];const n=$n(this.inputLength);if(n.length!==t.length-1)throw new ye(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let a=0;for(let r=0;r<n.length;++r){const s=n[r],i=t[r+1];if(s!=null&&i!=null&&s!==i)throw new ye(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(n[a]=i),a++}}return[t[0],...n,this.outputDim]}call(t,n){return Se(()=>{this.invokeCallHook(t,n);let a=$t(t);a.dtype!=="int32"&&(a=Zl(a,"int32"));const r=Lne(this.embeddings.read(),me(a,[a.size]));return me(r,vn(this.computeOutputShape(a.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ia(this.embeddingsInitializer),embeddingsRegularizer:Jn(this.embeddingsRegularizer),activityRegularizer:Jn(this.activityRegularizer),embeddingsConstraint:br(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}}rre.className="Embedding";We(rre);class jm extends Jt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new jt}computeElementwiseOpOutputShape(t,n){if(t==null||n==null)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(n.length===0)return t;const a=t.slice(0,t.length-n.length);for(let r=0;r<n.length;++r){const s=t[t.length-n.length+r],i=n[r];if(s==null||i==null||s<0||i<0)a.push(null);else if(s===1)a.push(i);else if(i===1)a.push(s);else{if(s!==i)throw new ye("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));a.push(s)}}return a}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[vn(t)]),t=t,t.length<2)throw new ye(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(const s of t)s!=null&&s[0]!==null&&n.push(s[0]);if(n=xh(n),n.length>1)throw new ye(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let a=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){const i=t[s]==null?null:t[s].slice(1);a=this.computeElementwiseOpOutputShape(a,i)}const r=t.map(s=>s.length);t.indexOf(null)===-1&&xh(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,n){return Se(()=>{if(t=t,this.reshapeRequired){const a=[],r=t.map(s=>s.rank);if(r.indexOf(null)===-1){const s=Wh(r);for(let i of t){const o=i.rank;for(let l=0;l<s-o;++l)i=bS(i,1);a.push(i)}return this.mergeFunction(a)}else{let s=!1;for(const l of t){const u=l.rank;if(u==null){const c=l.shape,h=c[0],p=c.slice(1).concat([h]);let m=me(l,[h].concat(vh(c.slice(1))));m=an(m,[1,0]),m=me(m,p),a.push(m),s=!0}else if(u>1){const c=bl(1,u).concat([0]);a.push(an(l,c)),s=!0}else a.push(l)}let i=this.mergeFunction(a);const o=i.rank;if(s){if(o==null){const l=i.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));i=me(an(me(i,[-1,c]),[1,0]),h)}else if(o>1){const l=[o-1].concat(bl(0,o-1));i=an(i,l)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let n;t[0]==null?n=null:n=t[0].slice(1);for(let r=1;r<t.length;++r){const s=t[r]==null?null:t[r].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let a=[];for(const r of t)r!=null&&r[0]!==null&&a.push(r[0]);return a=xh(a),a.length===1?n=a.concat(n):n=[null].concat(n),n}computeMask(t,n){return Se(()=>{if(n==null)return null;if(!Array.isArray(n))throw new ye("`mask` should be an Array");if(!Array.isArray(t))throw new ye("`inputs` should be an Array");if(n.length!==t.length)throw new ye(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(r=>r==null))return null;n=n.map(r=>r==null?r:us(r,0));let a=n[0];for(let r=1;r<n.length-1;++r)a=yl(a,n[r]);return a})}}class sre extends jm{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0].clone();for(let a=1;a<t.length;++a)n=Ue(n,t[a]);return n})}}sre.className="Add";We(sre);class ire extends jm{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0].clone();for(let a=1;a<t.length;++a)n=he(n,t[a]);return n})}}ire.className="Multiply";We(ire);class ore extends jm{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0].clone();for(let a=1;a<t.length;++a)n=Ue(n,t[a]);return he(1/t.length,n)})}}ore.className="Average";We(ore);class lre extends jm{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0];for(let a=1;a<t.length;++a)n=mu(n,t[a]);return n})}}lre.className="Maximum";We(lre);class ure extends jm{constructor(t){super(t)}mergeFunction(t){return Se(()=>{let n=t[0];for(let a=1;a<t.length;++a)n=Uh(n,t[a]);return n})}}ure.className="Minimum";We(ure);class cre extends jm{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new ye("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let n=!0;for(const r of t)if(r!=null){n=!1;break}if(n)return;const a=[];for(let r=0;r<t.length;++r){const s=t[r].slice();s.splice(this.axis,1);let i=!1;for(const o of a)if(tn(o,s)){i=!0;break}i||a.push(s)}if(a.length>1)throw new ye("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Se(()=>VP(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new ye("A `Concatenate` layer should be called on a list of inputs.");const n=t,a=n[0].slice(),r=this.axis<0?a.length+this.axis:this.axis;for(const s of n.slice(1)){if(a[r]==null||s[r]==null){a[r]=null;break}a[r]+=s[r]}return a}computeMask(t,n){if(n==null)return null;if(!Array.isArray(n))throw new ye("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new ye("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new ye(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return Se(()=>{let a=!0;if(n.forEach(i=>{if(i!=null){a=!1;return}}),a)return null;const r=[];for(let i=0;i<t.length;++i)n[i]==null?r.push(Xe(Oi(t[i]),"bool")):n[i].rank<t[i].rank?r.push(us(n[i],-1)):r.push(n[i]);const s=za(r,this.axis);return qT(s,-1,!1)})}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}cre.className="Concatenate";We(cre);function Cv(e,t){for(;e<0;)e+=t;return e}function Jat(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new jt("batchDot is not implemented for tensors of 4D or higher rank yet");if(q(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),q(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new jt("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;n==null&&(n=[a-1,r-2]);const s=n;return Se(()=>{let i;if(a>r){i=a-r;const l=[];for(let u=0;u<i;++u)l.push(1);t=me(t,t.shape.concat(l))}else if(r>a){i=r-a;const l=[];for(let u=0;u<i;++u)l.push(1);e=me(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=ct(he(e,t),s[0]):o=ct(he(an(e,[1,0]),t),s[1]);else{const l=s[0]!==e.shape.length-1,u=s[1]===t.shape.length-1;o=Kt(e,t,l,u)}if(i>0){let l;a>r?l=a+r-3:l=a-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);o=yd(o,u)}return o.shape.length===1&&(o=us(o,1)),o})}class hre extends jm{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){q(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0],a=t[1];if(n.length>3||a.length>3)throw new jt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,a);if(n[r[0]]!==a[r[1]])throw new ye(`Dimension incompatibility: ${n[r[0]]} !== ${a[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new ye(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n=t[0],a=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,i)=>Cv(s,t[i].shape.length)):r=[Cv(this.axes,n.shape.length),Cv(this.axes,a.shape.length)],this.normalize&&(n=PN(n,r[0]),a=PN(a,r[1])),Jat(n,a,r)}interpretAxes(t,n){let a;return Array.isArray(this.axes)?a=this.axes:a=[Cv(this.axes,t.length),Cv(this.axes,n.length)],a}computeOutputShape(t){q(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0].slice(),a=t[1].slice();if(n.length>3||a.length>3)throw new jt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,a);n.splice(r[0],1),a.splice(r[1],1),a.splice(0,1);const s=n.concat(a);return s.length===1&&s.push(1),s}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}}hre.className="Dot";We(hre);class dre extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const a=$t(t);return vS(()=>Ue(FE(a.shape,0,this.stddev),a),()=>a,n.training||!1)})}}dre.className="GaussianNoise";We(dre);class pre extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return Se(()=>{this.invokeCallHook(t,n);const a=$t(t);return this.rate>0&&this.rate<1?vS(()=>{const s=Math.sqrt(this.rate/(1-this.rate));return he(a,FE(a.shape,1,s))},()=>a,n.training||!1):a})}}pre.className="GaussianDropout";We(pre);class fre extends Jt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||$t(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return Se(()=>{if(this.rate<1&&this.rate>0){const a=this._getNoiseShape(t);return vS(()=>{const s=$t(t),o=-1.6732632423543772*1.0507009873554805;let l=xc(gd(a),this.rate);l=Zl(l,"float32");const u=((1-this.rate)*(1+this.rate*o**2))**-.5,c=-u*o*this.rate,h=Ue(he(s,l),he(Ue(l,-1),o));return Ue(he(h,u),c)},()=>$t(t),n.training||!1)}return t})}}fre.className="AlphaDropout";We(fre);function Rw(e,t,n,a,r,s=.001){let i;if(e.rank===2)i=cB(e,t,n,a,r,s);else if(e.rank===3)i=hB(e,t,n,a,r,s);else if(e.rank===4)i=dB(e,t,n,a,r,s);else throw new jt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function ert(e,t,n,a,r=.001){return Se(()=>{const s=iS(e,a),i=s.mean,o=s.variance;return[Rw(e,i,o,n,t,r),i,o]})}function trt(e,t,n,a,r=.001){return Se(()=>{const s=iS(e,a),i=s.mean,o=s.variance,l=[];for(const g of bl(0,e.rank))a.indexOf(g)!==-1?l.push(1):l.push(e.shape[g]);const u=me(i,l),c=me(o,l),h=t==null?null:me(t,l),p=n==null?null:me(n,l);return[Rw(e,u,c,p,h,r),i,o]})}function nrt(e,t,n,a,r=.001){return tn(a.slice().sort(),bl(0,e.rank-1))?ert(e,t,n,a,r):trt(e,t,n,a,r)}class mre extends Jt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=ma(t.betaInitializer||"zeros"),this.gammaInitializer=ma(t.gammaInitializer||"ones"),this.movingMeanInitializer=ma(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ma(t.movingVarianceInitializer||"ones"),this.betaConstraint=xr(t.betaConstraint),this.gammaConstraint=xr(t.gammaConstraint),this.betaRegularizer=ya(t.betaRegularizer),this.gammaRegularizer=ya(t.gammaRegularizer)}build(t){t=vn(t);const n=this.axis>=0?this.axis:this.axis+t.length,a=t[n];if(a==null)throw new ye(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new fr({ndim:t.length,axes:{[n]:a}})];const r=[a];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return Se(()=>{const a=n.training==null?!1:n.training,r=$t(t),s=r.shape,i=s.length,o=bl(0,i),l=this.axis>=0?this.axis:this.axis+i;o.splice(l,1);const u=Jp(1,i);u[l]=s[l];const c=o.slice();c.sort();const h=!tn(c,bl(0,i).slice(0,i-1)),p=()=>{if(h){const w=me(this.movingMean.read(),u),S=me(this.movingVariance.read(),u),k=this.center?me(this.beta.read(),u):null,I=this.scale?me(this.gamma.read(),u):null;return Rw(r,w,S,k,I,this.epsilon)}else return Rw(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!a)return p();const[m,g,y]=nrt(r,this.gamma.read(),this.beta.read(),o,this.epsilon),b=(w,S,k)=>{Se(()=>{const I=1-k,T=w.read(),E=he(it(T,S),I);w.write(it(T,E))})};return b(this.movingMean,g,this.momentum),b(this.movingVariance,y,this.momentum),m})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ia(this.betaInitializer),gammaInitializer:Ia(this.gammaInitializer),movingMeanInitializer:Ia(this.movingMeanInitializer),movingVarianceInitializer:Ia(this.movingVarianceInitializer),betaRegularizer:Jn(this.betaRegularizer),gammaRegularizer:Jn(this.gammaRegularizer),betaConstraint:br(this.betaConstraint),gammaConstraint:br(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}}mre.className="BatchNormalization";We(mre);class gre extends Jt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=ma(t.betaInitializer||"zeros"),this.gammaInitializer=ma(t.gammaInitializer||"ones"),this.betaRegularizer=ya(t.betaRegularizer),this.gammaRegularizer=ya(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=vn(t);const n=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=n);for(const s of this.axis)if(s<0||s>=n)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==xh(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const a=this.axis.map(s=>t[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",a,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",a,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,n){const a=$t(t),r=a.shape,s=r.length;return Se(()=>{let{mean:o,variance:l}=iS(a,this.axis,!0);const u=Jp(1,s);for(const y of this.axis)u[y]=r[y];const c=y=>y!=null&&y.shape.length!==s?me(y,u):y;let h=this.scale?c(this.gamma.read()):null,p=this.center?c(this.beta.read()):null;const m=[],g=[];for(let y=0;y<s;++y)this.axis.indexOf(y)!==-1?(m.push(r[y]),g.push(1)):(m.push(1),g.push(r[y]));return o=Ji(o,m),l=Ji(l,m),h!=null&&(h=Ji(h,g)),p!=null&&(p=Ji(p,g)),Rw(a,o,l,p,h,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ia(this.betaInitializer),gammaInitializer:Ia(this.gammaInitializer),betaRegularizer:Jn(this.betaRegularizer),gammaRegularizer:Jn(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}}gre.className="LayerNormalization";We(gre);function art(e,t,n){return Se(()=>{if(e.rank!==4)throw new ye(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ye("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=xl()),n!=="channelsLast"&&n!=="channelsFirst")throw new ye(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return n==="channelsFirst"?a=[[0,0],[0,0],t[0],t[1]]:a=[[0,0],t[0],t[1],[0,0]],vc(e,a)})}class yre extends Jt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?xl():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new ye(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,a;if(typeof t.padding[0]=="number")n=[t.padding[0],t.padding[0]],a=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new ye(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],t.padding[1].length!==2)throw new ye(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);a=t.padding[1]}this.padding=[n,a]}this.inputSpec=[new fr({ndim:4})]}computeOutputShape(t){t=vn(t);let n,a;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?n=t[2]+this.padding[0][0]+this.padding[0][1]:n=null,t[3]!=null&&t[3]>=0?a=t[3]+this.padding[1][0]+this.padding[1][1]:a=null,[t[0],t[1],n,a]):(t[1]!=null&&t[1]>=0?n=t[1]+this.padding[0][0]+this.padding[0][1]:n=null,t[2]!=null&&t[2]>=0?a=t[2]+this.padding[1][0]+this.padding[1][1]:a=null,[t[0],n,a,t[3]])}call(t,n){return Se(()=>art($t(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}yre.className="ZeroPadding2D";We(yre);function WE(e,t,n,a,r,s){return Se(()=>{Wa(r),Dne(s),ho(a),n==null&&(n=[1,1]),a==null&&(a="valid"),r==null&&(r=xl()),s==null&&(s="max"),e=e4(e,r);let i;const o=a==="same"?"same":"valid";return s==="max"?i=sS(e,t,n,o):i=QA(e,t,n,o),r==="channelsFirst"&&(i=an(i,[0,3,1,2])),i})}function bre(e,t,n,a,r,s){return Se(()=>{Wa(r),Dne(s),ho(a),n==null&&(n=[1,1,1]),a==null&&(a="valid"),r==null&&(r=xl()),s==null&&(s="max"),e=Fae(e,r);let i;const o=a==="same"?"same":"valid";return s==="max"?i=FB(e,t,n,o):i=uB(e,t,n,o),r==="channelsFirst"&&(i=an(i,[0,4,1,2,3])),i})}class xre extends Jt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new ye(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Rr(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new ye(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Rr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,ho(this.padding),this.inputSpec=[new fr({ndim:3})]}computeOutputShape(t){t=vn(t);const n=hl(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return Se(()=>{this.invokeCallHook(t,n),t=bS($t(t),2);const a=this.poolingFunction($t(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return yd(a,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}}class vre extends xre{constructor(t){super(t)}poolingFunction(t,n,a,r,s){return Wa(s),ho(r),WE(t,n,a,r,s,"max")}}vre.className="MaxPooling1D";We(vre);class wre extends xre{constructor(t){super(t)}poolingFunction(t,n,a,r,s){return Wa(s),ho(r),WE(t,n,a,r,s,"avg")}}wre.className="AveragePooling1D";We(wre);class Are extends Jt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new ye(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Rr(this.poolSize,"poolSize"),Rr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wa(this.dataFormat),ho(this.padding),this.inputSpec=[new fr({ndim:4})]}computeOutputShape(t){t=vn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],a=this.dataFormat==="channelsFirst"?t[3]:t[2];return n=hl(n,this.poolSize[0],this.padding,this.strides[0]),a=hl(a,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,a]:[t[0],n,a,t[3]]}call(t,n){return Se(()=>(this.invokeCallHook(t,n),this.poolingFunction($t(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Sre extends Are{constructor(t){super(t)}poolingFunction(t,n,a,r,s){return Wa(s),ho(r),WE(t,n,a,r,s,"max")}}Sre.className="MaxPooling2D";We(Sre);class kre extends Are{constructor(t){super(t)}poolingFunction(t,n,a,r,s){return Wa(s),ho(r),WE(t,n,a,r,s,"avg")}}kre.className="AveragePooling2D";We(kre);class Ire extends Jt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new ye(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Rr(this.poolSize,"poolSize"),Rr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wa(this.dataFormat),ho(this.padding),this.inputSpec=[new fr({ndim:5})]}computeOutputShape(t){t=vn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],a=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return n=hl(n,this.poolSize[0],this.padding,this.strides[0]),a=hl(a,this.poolSize[1],this.padding,this.strides[1]),r=hl(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,a,r]:[t[0],n,a,r,t[4]]}call(t,n){return Se(()=>(this.invokeCallHook(t,n),this.poolingFunction($t(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Nre extends Ire{constructor(t){super(t)}poolingFunction(t,n,a,r,s){return Wa(s),ho(r),bre(t,n,a,r,s,"max")}}Nre.className="MaxPooling3D";We(Nre);class Cre extends Ire{constructor(t){super(t)}poolingFunction(t,n,a,r,s){return Wa(s),ho(r),bre(t,n,a,r,s,"avg")}}Cre.className="AveragePooling3D";We(Cre);class Tre extends Jt{constructor(t){super(t),this.inputSpec=[new fr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new jt}}class Ere extends Tre{constructor(t){super(t||{})}call(t,n){return Se(()=>{const a=$t(t);return Sa(a,1)})}}Ere.className="GlobalAveragePooling1D";We(Ere);class $re extends Tre{constructor(t){super(t||{})}call(t,n){return Se(()=>{const a=$t(t);return ao(a,1)})}}$re.className="GlobalMaxPooling1D";We($re);class _re extends Jt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wa(this.dataFormat),this.inputSpec=[new fr({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new jt}getConfig(){const t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Rre extends _re{call(t,n){return Se(()=>{const a=$t(t);return this.dataFormat==="channelsLast"?Sa(a,[1,2]):Sa(a,[2,3])})}}Rre.className="GlobalAveragePooling2D";We(Rre);class Dre extends _re{call(t,n){return Se(()=>{const a=$t(t);return this.dataFormat==="channelsLast"?ao(a,[1,2]):ao(a,[2,3])})}}Dre.className="GlobalMaxPooling2D";We(Dre);class Ore extends Jt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,a={}){const r=n.layer,s=Qu(r,a);delete n.layer;const i={layer:s};return Object.assign(i,n),new t(i)}}class Fre extends Ore{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=vn(t),t.length<3)throw new ye(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=vn(t);const n=[t[0]].concat(t.slice(2)),a=this.layer.computeOutputShape(n),r=t[1];return[a[0],r].concat(a.slice(1))}call(t,n){return Se(()=>(t=$t(t),Gae((i,o)=>[$t(this.layer.call(i,n)),[]],t,[],!1,null,null,!1,!0)[1]))}}Fre.className="TimeDistributed";We(Fre);function rrt(e){Hm(Int,"BidirectionalMergeMode",e)}const srt="concat";class Mre extends Ore{constructor(t){super(t);const n=t.layer.getConfig(),a={};a.className=t.layer.getClassName(),a.config=n,this.forwardLayer=Qu(a),n.goBackwards=n.goBackwards!==!0;const r={};if(r.className=t.layer.getClassName(),r.config=n,this.backwardLayer=Qu(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?srt:t.mergeMode,rrt(this.mergeMode),t.weights)throw new jt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length,a=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,a)),this.backwardLayer.setWeights(t.slice(a))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let a,r,s;return this.returnState&&(s=n.slice(1)),a=n[0],a=a,this.mergeMode==="concat"?(a[a.length-1]*=2,r=[a]):this.mergeMode==null?r=[a,a.slice()]:r=[a],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[a].concat(s).concat(s.slice()):Hs(r)}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const s=Wae(t,a,r,this.numConstants);if(t=s.inputs,a=s.initialState,r=s.constants,Array.isArray(t)&&(a=t.slice(1),t=t[0]),(a==null||a.length===0)&&r==null)return super.apply(t,n);const i=[],o=[];if(a!=null){const u=a.length;if(u%2>0)throw new ye("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=a,i.push(...a);const c=a.map(h=>new fr({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),o.push(...c)}if(r!=null)throw new jt("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof lu;for(const u of i)if(u instanceof lu!==l)throw new ye("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[t].concat(i),c=this.inputSpec.concat(o),h=this.inputSpec;this.inputSpec=c;const p=super.apply(u,n);return this.inputSpec=h,p}else return super.apply(t,n)}call(t,n){return Se(()=>{const a=n.initialState;let r,s;if(a==null)r=this.forwardLayer.call(t,n),s=this.backwardLayer.call(t,n);else{const l=a.slice(0,a.length/2),u=a.slice(a.length/2);r=this.forwardLayer.call(t,Object.assign(n,{initialState:l})),s=this.backwardLayer.call(t,Object.assign(n,{initialState:u}))}let i;this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=oo(s,1));let o;return this.mergeMode==="concat"?o=VP([r,s]):this.mergeMode==="sum"?o=Ue(r,s):this.mergeMode==="ave"?o=he(.5,Ue(r,s)):this.mergeMode==="mul"?o=he(r,s):this.mergeMode==null&&(o=[r,s]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){vp(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),vp(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){Array.isArray(n)&&(n=n[0]);let a;if(this.returnSequences?this.mergeMode==null?a=[n,n]:a=n:this.mergeMode==null?a=[null,null]:a=null,this.returnState){const s=this.forwardLayer.states.map(i=>null);return Array.isArray(a)?a.concat(s).concat(s):[a].concat(s).concat(s)}else return a}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){const a=Qu(n.layer);if(delete n.layer,n.numConstants!=null)throw new jt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=n;return r.layer=a,new t(r)}}Mre.className="Bidirectional";We(Mre);class Lre extends Jt{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return Se(()=>(t=$t(t),t.dtype!=="float32"&&(t=Zl(t,"float32")),Ue(he(t,this.scale),this.offset)))}}Lre.className="Rescaling";We(Lre);const{resizeBilinear:irt,cropAndResize:ort}=sl;class zre extends Jt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,n,a,r,s,i,o,l){return Se(()=>{let u,c=!1;const h=n/i,p=a/o,m=(r+n)/i,g=(s+a)/o,y=[h,p,m,g],b=[];t.rank===3?(c=!0,u=ri([t])):u=t;for(let I=0;I<u.shape[0];I++)b.push(y);const v=Lo(b,[b.length,4]),w=Qp(0,b.length,1,"int32"),k=ort(u,v,w,[r,s],"nearest");return Zl(c?$t(lo(k)):k,l)})}upsize(t,n,a,r){return Se(()=>{const s=irt(t,[n,a]);return Zl(s,r)})}call(t,n){return Se(()=>{const a=$t(t),r=a.dtype,s=a.shape,i=s[s.length-3],o=s[s.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(a,l,u,this.height,this.width,i,o,r):this.upsize(t,this.height,this.width,r)})}getConfig(){const t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=vn(t);const n=t.length-3,a=t.length-2;return t[n]=this.height,t[a]=this.width,t}}zre.className="CenterCrop";We(zre);function lrt(e,t,n,a){let r=$t(e);if(r.dtype!=="int32"&&(r=Zl(r,"int32")),t==="int")return r;const s=r.shape;if(r.rank===0&&(r=us(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=us(r,-1)),r.rank>2)throw new ye(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(t),o=r;let l;if(typeof a<"u"&&t==="count"?l=ON(o,a,n,i):l=ON(o,[],n,i),t!=="tfIdf")return l;if(a)return he(l,a);throw new ye("When outputMode is 'tfIdf', weights must be provided.")}class Bre extends Jt{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){return t=vn(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,n){return Se(()=>{t=$t(t),t.dtype!=="int32"&&(t=Zl(t,"int32"));let a;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new ye(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);a=$t(n.countWeights)}const r=ao(t),s=Ty(t),i=ii(this.numTokens,r).bufferSync().get(0),o=xc(s,0).bufferSync().get(0);if(!(i&&o))throw new ye(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return lrt(t,this.outputMode,this.numTokens,a)})}}Bre.className="CategoryEncoding";We(Bre);const urt=["bilinear","nearest"],oj=new Set(urt);class Pre extends Jt{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(oj.has(t.interpolation))this.interpolation=t.interpolation;else throw new ye(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=vn(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return Se(()=>{const a=[this.height,this.width];if(this.interpolation==="bilinear")return sl.resizeBilinear(t,a,!this.cropToAspectRatio);if(this.interpolation==="nearest")return sl.resizeNearestNeighbor(t,a,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...oj]} are supported`)})}}Pre.className="Resizing";We(Pre);class Vre{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}Vre.className="RandomSeed";class Ure extends Jt{constructor(t){super(t),this.randomGenerator=new Vre(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(t,n),t}}Ure.className="BaseRandomLayer";const crt=["bilinear","nearest"],lj=new Set(crt);class Wre extends Ure{constructor(t){super(t);const{factor:n,interpolation:a="bilinear"}=t;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ye(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ye(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ye(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(a)if(lj.has(a))this.interpolation=a;else throw new ye(`Invalid interpolation parameter: ${a} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=vn(t);const n=t[2];return[this.imgHeight,-1,n]}call(t,n){return Se(()=>{const a=$t(t);this.imgHeight=a.shape[a.shape.length-3];const r=a.shape[a.shape.length-2];this.widthFactor=gd([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*r;s=Math.round(s);const i=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return sl.resizeBilinear(t,i);case"nearest":return sl.resizeNearestNeighbor(t,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...lj]} are supported`)}})}}Wre.className="RandomWidth";We(Wre);const hrt=Ie();hrt.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var xi;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(xi||(xi={}));var uj;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(uj||(uj={}));const i4={};function drt(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};i4[e]=n}function Gre(e){return i4[e]}function prt(e){delete i4[e]}function L(e,t,n,a,r){const s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){const o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return jr(t.inputNames[u],n,a,r);if(s.type==="tensors"){const p=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((g,y)=>{var b;return((b=p[y])===null||b===void 0?void 0:b.op)!=="NoOp"}).map(g=>jr(g,n,a,r))}const c=jr(t.inputNames[u],n,a,r),h=c.dataSync();return s.type==="number"?h[0]:no(c.shape,h)}const i=t.attrParams[e];return i&&i.value}function jr(e,t,n,a){const[r,s]=Ai(e,n);if(a!=null){const o=a.getHashTableHandleByName(r);if(o!=null)return o}const i=n.currentContextIds.find(o=>!!t[HN(r,o)]);return i!==void 0?t[HN(r,i)][s]:void 0}function cj(e,t,n){return t[HN(e,n.currentContextId)]}function Uu(e,t){const[n,a,r]=Ai(e,t);return[HN(n,t&&t.currentContextId),a,r]}function HN(e,t){return t?`${e}-${t}`:e}function Ai(e,t){if(e==="")return["",0,void 0];const n=t!=null&&t.parseNodeNameCache!=null;if(n){const s=t.parseNodeNameCache.get(e);if(s!=null)return s}const a=e.split(":");let r;if(a.length===1)r=[e,0,void 0];else{const s=a[0],i=a.length===3?a[1]:void 0,o=Number(a[a.length-1]);r=[s,o,i]}return n&&t.parseNodeNameCache.set(e,r),r}function GI(e,t,n){let a=L("pad",e,t,n);if(a==="explicit"){a=L("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=a[s*2],r[s][1]=a[s*2+1];return r}return a}function Wu(e){return e.kept?e:Yl(e)}const frt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mrt=Object.freeze(Object.defineProperty({__proto__:null,json:frt},Symbol.toStringTag,{value:"Module"}));const grt=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yrt=Object.freeze(Object.defineProperty({__proto__:null,json:grt},Symbol.toStringTag,{value:"Module"}));const brt=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],xrt=Object.freeze(Object.defineProperty({__proto__:null,json:brt},Symbol.toStringTag,{value:"Module"}));const vrt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],wrt=Object.freeze(Object.defineProperty({__proto__:null,json:vrt},Symbol.toStringTag,{value:"Module"}));const Art=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Srt=Object.freeze(Object.defineProperty({__proto__:null,json:Art},Symbol.toStringTag,{value:"Module"}));const krt=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Irt=Object.freeze(Object.defineProperty({__proto__:null,json:krt},Symbol.toStringTag,{value:"Module"}));const Nrt=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Crt=Object.freeze(Object.defineProperty({__proto__:null,json:Nrt},Symbol.toStringTag,{value:"Module"}));const Trt=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ert=Object.freeze(Object.defineProperty({__proto__:null,json:Trt},Symbol.toStringTag,{value:"Module"}));const $rt=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],_rt=Object.freeze(Object.defineProperty({__proto__:null,json:$rt},Symbol.toStringTag,{value:"Module"}));const Rrt=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Drt=Object.freeze(Object.defineProperty({__proto__:null,json:Rrt},Symbol.toStringTag,{value:"Module"}));const Ort=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Frt=Object.freeze(Object.defineProperty({__proto__:null,json:Ort},Symbol.toStringTag,{value:"Module"}));const Mrt=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Lrt=Object.freeze(Object.defineProperty({__proto__:null,json:Mrt},Symbol.toStringTag,{value:"Module"}));const zrt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Brt=Object.freeze(Object.defineProperty({__proto__:null,json:zrt},Symbol.toStringTag,{value:"Module"}));const Prt=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Vrt=Object.freeze(Object.defineProperty({__proto__:null,json:Prt},Symbol.toStringTag,{value:"Module"}));const Urt=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Wrt=Object.freeze(Object.defineProperty({__proto__:null,json:Urt},Symbol.toStringTag,{value:"Module"}));const Grt=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Hrt=Object.freeze(Object.defineProperty({__proto__:null,json:Grt},Symbol.toStringTag,{value:"Module"}));const jrt=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],qrt=Object.freeze(Object.defineProperty({__proto__:null,json:jrt},Symbol.toStringTag,{value:"Module"}));const Krt=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Xrt=Object.freeze(Object.defineProperty({__proto__:null,json:Krt},Symbol.toStringTag,{value:"Module"}));const Yrt=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Qrt=Object.freeze(Object.defineProperty({__proto__:null,json:Yrt},Symbol.toStringTag,{value:"Module"}));class hj{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[mrt,yrt,xrt,wrt,Srt,Irt,Crt,Ert,_rt,Drt,Frt,Lrt,Brt,Vrt,Wrt,Hrt,qrt,Xrt,Qrt],n=[].concat(...t.map(a=>a.json));this.opMappers=n.reduce((a,r)=>(a[r.tfOpName]=r,a),{})}transformGraph(t,n={}){const a=t.node,r=[],s=[],i=[],o=a.reduce((y,b)=>(y[b.name]=this.mapNode(b),b.op.startsWith("Placeholder")?r.push(y[b.name]):b.op==="Const"?s.push(y[b.name]):(b.input==null||b.input.length===0)&&i.push(y[b.name]),y),{});let l=[];const u=[];let c={},h={};n!=null&&(c=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const p=Object.keys(o);p.forEach(y=>{const b=o[y];b.inputNames.forEach((v,w)=>{const[S,,k]=Uu(v),I=o[S];if(I.outputs!=null){const T=I.outputs.indexOf(k);if(T!==-1){const E=`${S}:${T}`;b.inputNames[w]=E}}b.inputs.push(I),I.children.push(b)})}),Object.keys(h).length===0?p.forEach(y=>{const b=o[y];b.children.length===0&&u.push(b)}):Object.keys(h).forEach(y=>{const[b]=Uu(y),v=o[b];v!=null&&(v.signatureKey=h[y],u.push(v))}),Object.keys(c).length>0?Object.keys(c).forEach(y=>{const[b]=Uu(y),v=o[b];v&&(v.signatureKey=c[y],l.push(v))}):l=r;let m={};t.library!=null&&t.library.function!=null&&(m=t.library.function.reduce((y,b)=>(y[b.signature.name]=this.mapFunction(b),y),{}));const g={nodes:o,inputs:l,outputs:u,weights:s,placeholders:r,signature:n,functions:m};return i.length>0&&(g.initNodes=i),g}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,a)=>(n[t[a].name]=a,n),{})}mapNode(t){const n=Gre(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const a={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return n.inputs!=null&&(a.inputParams=n.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),n.attrs!=null&&(a.attrParams=n.attrs.reduce((r,s)=>{const i=s.type;let o;switch(s.type){case"string":o=PO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=PO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":o=qO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=qO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":o=UO(t.attr,s.tfName,s.defaultValue||0),o===void 0&&s.tfDeprecatedName&&(o=UO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":o=jO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=jO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":o=VO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=VO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":o=XO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=XO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":o=HO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=HO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":o=KO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=KO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":o=WO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=WO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":o=GO(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=GO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":o=dj(t.attr,s.tfName,s.defaultValue),o===void 0&&s.tfDeprecatedName&&(o=dj(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return r[s.name]={value:o,type:i},r},{})),a}mapFunction(t){const n=t.nodeDef,a=[],r=[];let s={};n!=null&&(s=n.reduce((h,p)=>(h[p.name]=this.mapNode(p),p.op==="Const"&&r.push(h[p.name]),h),{}));const i=[],o=[];t.signature.inputArg.forEach(h=>{const[p]=Uu(h.name),m={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:o4(h.type),type:"dtype"}},children:[]};m.signatureKey=h.name,i.push(m),s[p]=m}),Object.keys(s).forEach(h=>{const p=s[h];p.inputNames.forEach((m,g)=>{const[y,,b]=Uu(m),v=s[y];if(v.outputs!=null){const w=v.outputs.indexOf(b);if(w!==-1){const S=`${y}:${w}`;p.inputNames[g]=S}}p.inputs.push(v),v.children.push(p)})});const u=t.ret;t.signature.outputArg.forEach(h=>{const[p,m]=Uu(u[h.name]),g=s[p];g!=null&&(g.defaultOutput=m,o.push(g))});const c=this.mapArgsToSignature(t);return{nodes:s,inputs:i,outputs:o,weights:r,placeholders:a,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,a)=>(n[a.name]=this.mapArgToTensorInfo(a),n),{}),outputs:t.signature.outputArg.reduce((n,a)=>(n[a.name]=this.mapArgToTensorInfo(a,t.ret),n),{})}}mapArgToTensorInfo(t,n){let a=t.name;return n!=null&&(a=n[a]),{name:a,dtype:t.type}}}function Zrt(e){const t=Ie().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Hre(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):Zrt(e);return t?n:n.toLowerCase()}function PO(e,t,n,a=!1){const r=e[t];return r!=null?Hre(r.s,a):n}function VO(e,t,n){const a=e[t];return a?a.b:n}function UO(e,t,n){const a=e[t]||{},r=a.i!=null?a.i:a.f!=null?a.f:n;return typeof r=="number"?r:parseInt(r,10)}function o4(e){switch(typeof e=="string"&&(e=xi[e]),e){case xi.DT_FLOAT:case xi.DT_HALF:return"float32";case xi.DT_INT32:case xi.DT_INT64:case xi.DT_INT8:case xi.DT_UINT8:return"int32";case xi.DT_BOOL:return"bool";case xi.DT_DOUBLE:return"float32";case xi.DT_STRING:return"string";case xi.DT_COMPLEX64:case xi.DT_COMPLEX128:return"complex64";default:return null}}function dj(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function WO(e,t,n){const a=e[t];return a&&a.type?o4(a.type):n}function GO(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map(r=>o4(r)):n}function jre(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function HO(e,t,n){const a=e[t];return a&&a.shape?jre(a.shape):n}function jO(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function qO(e,t,n,a=!1){const r=e[t];return r&&r.list&&r.list.s?r.list.s.map(s=>Hre(s,a)):n}function KO(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(r=>jre(r)):n}function XO(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class Jrt{constructor(t,n,a){this.node=t,this.tensorMap=n,this.context=a,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(t){return jr(t,this.tensorMap,this.context)}getAttr(t,n){const a=this.node.rawAttrs[t];if(a.tensor!=null)return jr(t,this.tensorMap,this.context);if(a.i!=null||a.f!=null)return UO(this.node.rawAttrs,t,n);if(a.s!=null)return PO(this.node.rawAttrs,t,n);if(a.b!=null)return VO(this.node.rawAttrs,t,n);if(a.shape!=null)return HO(this.node.rawAttrs,t,n);if(a.type!=null)return WO(this.node.rawAttrs,t,n);if(a.list!=null){if(a.list.i!=null||a.list.f!=null)return jO(this.node.rawAttrs,t,n);if(a.list.s!=null)return qO(this.node.rawAttrs,t,n);if(a.list.shape!=null)return KO(this.node.rawAttrs,t,n);if(a.list.b!=null)return XO(this.node.rawAttrs,t,n);if(a.list.type!=null)return GO(this.node.rawAttrs,t,n)}return n}}const ts=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:qz,abs:Xa,acos:eB,acosh:tB,add:Ue,addN:Fee,all:qT,any:Iw,argMax:qp,argMin:nB,asin:aB,asinh:rB,atan:sB,atan2:iB,atanh:oB,avgPool:QA,avgPool3d:uB,basicLSTMCell:Mee,batchNorm:o0,batchNorm2d:cB,batchNorm3d:hB,batchNorm4d:dB,batchToSpaceND:ZA,bincount:pB,bitwiseAnd:Lee,booleanMaskAsync:wte,broadcastArgs:zee,broadcastTo:xp,buffer:Gt,cast:Xe,ceil:fB,clipByValue:ni,clone:Yl,complex:nc,concat:za,concat1d:mB,concat2d:gB,concat3d:yB,concat4d:bB,conv1d:KT,conv2d:ac,conv2dTranspose:XT,conv3d:vB,conv3dTranspose:wB,cos:JA,cosh:YT,cosineWindow:vE,cumprod:Tw,cumsum:QT,denseBincount:ON,depthToSpace:AB,depthwiseConv2d:l0,diag:Pee,dilation2d:SB,div:gt,divNoNan:kB,dot:IB,dropout:JB,einsum:sp,elu:u0,enclosingPowerOfTwo:eP,ensureShape:Vee,equal:Bo,erf:ZT,euclideanNorm:CB,exp:ai,expandDims:us,expm1:TB,eye:JT,fft:dS,fill:Vm,floor:h0,floorDiv:jT,fused:$te,gather:d0,gatherND:Ite,greater:ii,greaterEqual:xc,ifft:Dy,imag:eS,image:sl,inTopKAsync:Nte,irfft:fE,isFinite:EB,isInf:$B,isNaN:_B,leakyRelu:tS,less:Ey,lessEqual:md,linalg:aP,linspace:Gee,localResponseNormalization:RB,log:Di,log1p:nS,logSigmoid:DB,logSoftmax:tE,logSumExp:aS,logicalAnd:yl,logicalNot:rS,logicalOr:nE,logicalXor:OB,losses:Lte,lowerBound:jee,matMul:Kt,max:ao,maxPool:sS,maxPool3d:FB,maxPoolWithArgmax:qee,maximum:mu,mean:Sa,meshgrid:Kee,min:Ty,minimum:Uh,mirrorPad:MB,mod:LB,moments:iS,movingAverage:Ate,mul:he,multiRNNCell:Xee,multinomial:Yee,neg:ia,norm:c0,notEqual:Yp,oneHot:$y,ones:qs,onesLike:Oi,op:oe,outerProduct:Qee,pad:vc,pad1d:Zee,pad2d:Jee,pad3d:ete,pad4d:tte,pool:zB,pow:iu,prelu:lS,print:Jz,prod:BB,raggedGather:nte,raggedRange:ate,raggedTensorToTensor:rte,rand:ste,randomGamma:lte,randomNormal:sE,randomStandardNormal:ute,randomUniform:gd,randomUniformInt:cte,range:Qp,real:_y,reciprocal:WB,relu:kl,relu6:iE,reshape:me,reverse:oo,reverse1d:hte,reverse2d:dte,reverse3d:pte,reverse4d:fte,rfft:pS,round:oE,rsqrt:lE,scalar:kt,scatterND:Ste,searchSorted:aE,selu:uE,separableConv2d:cE,setdiff1dAsync:mte,sigmoid:cl,sign:GB,signal:Mte,sin:hE,sinh:dE,slice:ln,slice1d:uS,slice2d:pE,slice3d:cS,slice4d:Ry,softmax:hS,softplus:Um,spaceToBatchND:oS,sparse:zte,sparseToDense:kte,spectral:Fte,split:Ys,sqrt:Lr,square:Vn,squaredDifference:mE,squeeze:yd,stack:ri,step:Wm,stridedSlice:HB,string:Bte,sub:it,sum:ct,tan:jB,tanh:Vh,tensor:Lo,tensor1d:cs,tensor2d:sy,tensor3d:qB,tensor4d:gte,tensor5d:yte,tensor6d:bte,tensorScatterUpdate:xte,tile:Ji,topk:XB,transpose:an,truncatedNormal:yE,unique:YB,unsortedSegmentSum:bE,unstack:lo,upperBound:vte,variable:QB,where:Xr,whereAsync:ZB,zeros:Ya,zerosLike:cn},Symbol.toStringTag,{value:"Module"}));const est=(e,t,n,a=ts)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(L("a",e,t,n),L("b",e,t,n))];case"AddN":return[a.addN(L("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(L("a",e,t,n),L("b",e,t,n))];case"Mul":return[a.mul(L("a",e,t,n),L("b",e,t,n))];case"RealDiv":case"Div":return[a.div(L("a",e,t,n),L("b",e,t,n))];case"DivNoNan":return[a.divNoNan(L("a",e,t,n),L("b",e,t,n))];case"FloorDiv":return[a.floorDiv(L("a",e,t,n),L("b",e,t,n))];case"Sub":return[a.sub(L("a",e,t,n),L("b",e,t,n))];case"Minimum":return[a.minimum(L("a",e,t,n),L("b",e,t,n))];case"Maximum":return[a.maximum(L("a",e,t,n),L("b",e,t,n))];case"Pow":return[a.pow(L("a",e,t,n),L("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(L("a",e,t,n),L("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const tst=(e,t,n,a=ts)=>{switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(L("x",e,t,n))];case"Acos":return[a.acos(L("x",e,t,n))];case"Acosh":return[a.acosh(L("x",e,t,n))];case"Asin":return[a.asin(L("x",e,t,n))];case"Asinh":return[a.asinh(L("x",e,t,n))];case"Atan":return[a.atan(L("x",e,t,n))];case"Atan2":return[a.atan2(L("x",e,t,n),L("y",e,t,n))];case"Atanh":return[a.atanh(L("x",e,t,n))];case"Ceil":return[a.ceil(L("x",e,t,n))];case"Complex":return[a.complex(L("real",e,t,n),L("imag",e,t,n))];case"Cos":return[a.cos(L("x",e,t,n))];case"Cosh":return[a.cosh(L("x",e,t,n))];case"Elu":return[a.elu(L("x",e,t,n))];case"Erf":return[a.erf(L("x",e,t,n))];case"Exp":return[a.exp(L("x",e,t,n))];case"Expm1":return[a.expm1(L("x",e,t,n))];case"Floor":return[a.floor(L("x",e,t,n))];case"Log":return[a.log(L("x",e,t,n))];case"Log1p":return[a.log1p(L("x",e,t,n))];case"Imag":return[a.imag(L("x",e,t,n))];case"Neg":return[a.neg(L("x",e,t,n))];case"Reciprocal":return[a.reciprocal(L("x",e,t,n))];case"Real":return[a.real(L("x",e,t,n))];case"Relu":return[a.relu(L("x",e,t,n))];case"Round":return[a.round(L("x",e,t,n))];case"Selu":return[a.selu(L("x",e,t,n))];case"Sigmoid":return[a.sigmoid(L("x",e,t,n))];case"Sin":return[a.sin(L("x",e,t,n))];case"Sign":return[a.sign(L("x",e,t,n))];case"Sinh":return[a.sinh(L("x",e,t,n))];case"Softplus":return[a.softplus(L("x",e,t,n))];case"Sqrt":return[a.sqrt(L("x",e,t,n))];case"Square":return[a.square(L("x",e,t,n))];case"Tanh":return[a.tanh(L("x",e,t,n))];case"Tan":return[a.tan(L("x",e,t,n))];case"ClipByValue":return[a.clipByValue(L("x",e,t,n),L("clipValueMin",e,t,n),L("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(L("x",e,t,n))];case"Rsqrt":return[a.rsqrt(jr(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(L("x",e,t,n),L("alpha",e,t,n))];case"Prelu":return[a.prelu(L("x",e,t,n),L("alpha",e,t,n))];case"IsNan":return[a.isNaN(jr(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(jr(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(jr(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Do(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){q(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){const r=e[a],s=t[a];q(r<0||s<0||r===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function pj(e){return!(typeof e=="number"||e.some(t=>t<0))}function Tv(e,t,n){let a=YO(e,n);const r=!pj(a);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach(s=>{a=YO(s.shape,a)}),!pj(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function YO(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let a=0;a<e.length;++a){const r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}class nst{constructor(t,n,a,r,s,i,o){this.name=t,this.dtype=n,this.maxSize=a,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=kt(0),dr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),Do(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);a.tensor=n,dr(n),a.written=!0,this.tensors[t]=a}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((a,r)=>this.write(a,n[r]))}gather(t,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return Lo([],[0].concat(this.elementShape));const a=this.readMany(t);return Do(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),ri(a,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Lo([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const a=this.readMany(n);return Do(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),za(a,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const a=Math.max(...t);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(t,lo(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let a=0;const r=t.map(l=>(a+=l,a));if(a!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=a===0?0:n.size/a,i=[];Se(()=>{n=me(n,[1,a,s]);for(let l=0;l<t.length;++l){const c=[0,l===0?0:r[l-1],0],h=[1,t[l],s];i[l]=me(ln(n,c,h),this.elementShape)}return i});const o=[];for(let l=0;l<t.length;l++)o[l]=l;this.writeMany(o,i)}}class ef{get id(){return this.idTensor.id}constructor(t,n,a,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=a,t?.forEach(s=>{if(a!==s.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${s.dtype}`);Do(n,s.shape,"TensorList shape mismatch: "),dr(s)}),this.idTensor=kt(0),this.maxNumElements=r,dr(this.idTensor)}copy(){return new ef([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,a=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(a!==-1&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Do(t,this.elementShape,"TensorList shape mismatch: ");const r=Tv(this.elementShape,this.tensors,t);return Se(()=>{const s=this.tensors.map(i=>me(i,r));return ri(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const a=Tv(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Do(r.shape,t,"TensorList shape mismatch: "),me(r,a)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Do(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");dr(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const n=new ef([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let a=0;a<Math.min(this.tensors.length,t);++a)n.tensors[a]=this.tensors[a];return n}getItem(t,n,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Do(this.tensors[t].shape,n,"TensorList shape mismatch: ");const r=Tv(this.elementShape,this.tensors,n);return me(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Do(this.elementShape,n.shape,"TensorList shape mismatch: "),dr(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,a){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Do(this.elementShape,a,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=Tv(this.elementShape,this.tensors,a);return t.length===0?Lo([],[0].concat(r)):Se(()=>{const s=t.map(i=>me(this.tensors[i],r));return ri(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Do(this.elementShape,n,"TensorList shape mismatch: ");const a=Tv(this.elementShape,this.tensors,n);return this.size()===0?Lo([],[0].concat(a)):Se(()=>{const r=this.tensors.map(s=>me(s,a));return za(r,0)})}}function ast(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);const r=e.shape.slice(1);Do(r,t,"TensorList shape mismatch: ");const s=lo(e);return new ef(s,t,a)}function rst(e,t,n,a){return new ef([],e,t,a)}function sst(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(a!=null&&a!==-1&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);const s=new ef([],n,e.dtype,a),i=lo(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function ist(e,t,n){let a=0;const r=t.map(c=>(a+=c,a));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${e.shape}`);const s=e.shape.slice(1),i=YO(s,n),o=a===0?0:e.size/a,l=Se(()=>{const c=[];e=me(e,[1,a,o]);for(let h=0;h<t.length;++h){const m=[0,h===0?0:r[h-1],0],g=[1,t[h],o];c[h]=me(ln(e,m,g),i)}return e.dispose(),c}),u=new ef([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}const ost=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=L("thenBranch",e,t,n),r=L("elseBranch",e,t,n),s=L("cond",e,t,n),i=L("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=L("body",e,t,n),r=L("cond",e,t,n),s=L("args",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(c=>c.id);let l=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){const c=u;u=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const h=u.map(m=>m.id);c.forEach(m=>{!m.kept&&o.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()});const p=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(m=>{!m.kept&&o.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()})}return u}case"LoopCond":{const a=L("pred",e,t,n);return[Wu(a)]}case"Switch":{const a=L("pred",e,t,n);let r=L("data",e,t,n);return r.kept||(r=Wu(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find(r=>jr(r,t,n)!==void 0);if(a){const r=jr(a,t,n);return[Wu(r)]}return}case"Enter":{const a=L("frameName",e,t,n),r=L("tensor",e,t,n);return n.enterFrame(a),[Wu(r)]}case"Exit":{const a=L("tensor",e,t,n);return n.exitFrame(),[Wu(a)]}case"NextIteration":{const a=L("tensor",e,t,n);return n.nextIteration(),[Wu(a)]}case"TensorArrayV3":{const a=L("size",e,t,n),r=L("dtype",e,t,n),s=L("elementShape",e,t,n),i=L("dynamicSize",e,t,n),o=L("clearAfterRead",e,t,n),l=L("identicalElementShapes",e,t,n),u=L("name",e,t,n),c=new nst(u,r,a,s,l,i,o);return n.addTensorArray(c),[c.idTensor,kt(1)]}case"TensorArrayWriteV3":{const a=L("tensorArrayId",e,t,n),r=L("index",e,t,n),s=L("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case"TensorArrayReadV3":{const a=L("tensorArrayId",e,t,n),r=L("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=L("tensorArrayId",e,t,n),r=L("indices",e,t,n),s=L("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{const a=L("tensorArrayId",e,t,n),r=L("indices",e,t,n),s=L("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case"TensorArrayConcatV3":{const a=L("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=L("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{const a=L("tensorArrayId",e,t,n),r=L("tensor",e,t,n),s=L("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case"TensorArraySizeV3":{const a=L("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return[kt(r.size(),"int32")]}case"TensorArrayCloseV3":{const a=L("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=L("tensorListId",e,t,n),r=L("index",e,t,n),s=L("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case"TensorListGetItem":{const a=L("tensorListId",e,t,n),r=L("index",e,t,n),s=L("elementShape",e,t,n),i=L("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{const a=L("indices",e,t,n),r=L("tensor",e,t,n),s=L("elementShape",e,t,n),i=L("numElements",e,t,n),o=sst(r,a,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=L("elementShape",e,t,n),r=L("elementDType",e,t,n);let s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";const i=L(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=rst(a,r,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const a=L("tensorListId",e,t,n),r=L("indices",e,t,n),s=L("elementShape",e,t,n),i=L("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case"TensorListStack":{const a=L("tensorListId",e,t,n),r=L("elementShape",e,t,n),s=L("elementDType",e,t,n),i=L("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case"TensorListFromTensor":{const a=L("tensor",e,t,n),r=L("elementShape",e,t,n),s=L("elementDType",e,t,n),i=ast(a,r,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=L("tensorListId",e,t,n),r=n.getTensorList(a.id),s=L("dtype",e,t,n),i=L("elementShape",e,t,n);return[r.concat(s,i)]}case"TensorListPushBack":{const a=L("tensorListId",e,t,n),r=L("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const a=L("tensorListId",e,t,n),r=L("elementShape",e,t,n),s=L("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{const a=L("tensor",e,t,n),r=L("elementShape",e,t,n),s=L("lengths",e,t,n),i=ist(a,s,r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const a=L("tensorListId",e,t,n),r=n.getTensorList(a.id);return[kt(r.size(),"int32")]}case"TensorListResize":{const a=L("tensorListId",e,t,n),r=L("size",e,t,n),i=n.getTensorList(a.id).resize(r);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function fj(e,t,n){const[a,r]=L("fusedOps",e,t,n),s=a==="biasadd",i=!s,o=r==="prelu",l=a==="fusedbatchnorm",u=L("numArgs",e,t,n);if(s){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=L("strides",e,t,n),h=GI(e,t,n),p=L("dataFormat",e,t,n).toUpperCase(),m=L("dilations",e,t,n);let[g,y]=L("args",e,t,n);i&&(y=g,g=void 0);const b=L("leakyreluAlpha",e,t,n);return{stride:c,pad:h,dataFormat:p,dilations:m,biasArg:g,preluArg:y,activationFunc:r,leakyreluAlpha:b}}const lst=(e,t,n,a=ts)=>{switch(e.op){case"Conv1D":{const r=L("stride",e,t,n),s=L("pad",e,t,n),i=L("dataFormat",e,t,n).toUpperCase(),o=L("dilation",e,t,n);return[a.conv1d(L("x",e,t,n),L("filter",e,t,n),r,s,i,o)]}case"Conv2D":{const r=L("strides",e,t,n),s=GI(e,t,n),i=L("dataFormat",e,t,n).toUpperCase(),o=L("dilations",e,t,n);return[a.conv2d(L("x",e,t,n),L("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=fj(e,t,n);return[a.fused.conv2d({x:L("x",e,t,n),filter:L("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=fj(e,t,n);return[a.fused.depthwiseConv2d({x:L("x",e,t,n),filter:L("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=L("outputShape",e,t,n),s=L("strides",e,t,n),i=GI(e,t,n);return[a.conv2dTranspose(L("x",e,t,n),L("filter",e,t,n),r,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=L("strides",e,t,n),s=GI(e,t,n),i=L("dilations",e,t,n),o=L("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(L("input",e,t,n),L("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"Conv3D":{const r=L("strides",e,t,n),s=L("pad",e,t,n),i=L("dataFormat",e,t,n).toUpperCase(),o=L("dilations",e,t,n);return[a.conv3d(L("x",e,t,n),L("filter",e,t,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{const r=L("strides",e,t,n),s=L("pad",e,t,n),i=L("kernelSize",e,t,n);return[a.avgPool(L("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=L("strides",e,t,n),s=L("pad",e,t,n),i=L("kernelSize",e,t,n);return[a.maxPool(L("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=L("strides",e,t,n),s=L("pad",e,t,n),i=L("kernelSize",e,t,n),o=L("includeBatchInIndex",e,t,n),{result:l,indexes:u}=a.maxPoolWithArgmax(L("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s,o);return[l,u]}case"AvgPool3D":{const r=L("strides",e,t,n),s=L("pad",e,t,n),i=L("kernelSize",e,t,n);return[a.avgPool3d(L("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=L("strides",e,t,n),s=L("pad",e,t,n),i=L("kernelSize",e,t,n);return[a.maxPool3d(L("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=L("strides",e,t,n),s=L("pad",e,t,n),i=L("dilations",e,t,n),o=r[1],l=r[2],u=i[1],c=i[2];return[a.dilation2d(L("x",e,t,n),L("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const ust=(e,t,n,a=ts)=>{switch(e.op){case"Fill":{const r=L("shape",e,t,n),s=L("dtype",e,t,n),i=L("value",e,t,n);return[a.fill(r,i,s)]}case"LinSpace":{const r=L("start",e,t,n),s=L("stop",e,t,n),i=L("num",e,t,n);return[a.linspace(r,s,i)]}case"Multinomial":{const r=L("logits",e,t,n),s=L("numSamples",e,t,n),i=L("seed",e,t,n);return[a.multinomial(r,s,i)]}case"OneHot":{const r=L("indices",e,t,n),s=L("depth",e,t,n),i=L("onValue",e,t,n),o=L("offValue",e,t,n),l=L("dtype",e,t,n);return[a.oneHot(r,s,i,o,l)]}case"Ones":return[a.ones(L("shape",e,t,n),L("dtype",e,t,n))];case"OnesLike":return[a.onesLike(L("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(L("shape",e,t,n),L("dtype",e,t,n),L("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(L("shape",e,t,n),L("minval",e,t,n),L("maxval",e,t,n),L("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(L("shape",e,t,n),L("minval",e,t,n),L("maxval",e,t,n),L("seed",e,t,n))];case"Range":{const r=L("start",e,t,n),s=L("stop",e,t,n),i=L("step",e,t,n);return[a.range(r,s,i,L("dtype",e,t,n))]}case"TruncatedNormal":{const r=L("shape",e,t,n),s=L("mean",e,t,n),i=L("stdDev",e,t,n),o=L("seed",e,t,n);return[a.truncatedNormal(r,s,i,L("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(L("shape",e,t,n),L("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(L("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function GR(e,t,n){const a=L("boxes",e,t,n),r=L("scores",e,t,n),s=L("maxOutputSize",e,t,n),i=L("iouThreshold",e,t,n),o=L("scoreThreshold",e,t,n),l=L("softNmsSigma",e,t,n);return{boxes:a,scores:r,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}const cst=async(e,t,n,a,r=ts)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=GR(e,t,n),h=await r.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=GR(e,t,n),c=L("padToMaxOutputSize",e,t,n),h=await r.image.nonMaxSuppressionPaddedAsync(s,i,o,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=GR(e,t,n);return[await r.image.nonMaxSuppressionAsync(s,i,o,l,u)]}case"Where":{const s=r.cast(L("condition",e,t,n),"bool"),i=[await r.whereAsync(s)];return s.dispose(),i}case"ListDiff":return r.setdiff1dAsync(L("x",e,t,n),L("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}};const hst=(e,t,n,a=ts)=>{switch(e.op){case"LowerBound":{const r=L("sortedSequence",e,t,n),s=L("values",e,t,n);return[a.lowerBound(r,s)]}case"TopKV2":{const r=L("x",e,t,n),s=L("k",e,t,n),i=L("sorted",e,t,n),o=a.topk(r,s,i);return[o.values,o.indices]}case"UpperBound":{const r=L("sortedSequence",e,t,n),s=L("values",e,t,n);return[a.upperBound(r,s)]}case"Unique":{const r=L("x",e,t,n),s=a.unique(r);return[s.values,s.indices]}case"UniqueV2":{const r=L("x",e,t,n),s=L("axis",e,t,n),i=a.unique(r,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const dst=(e,t,n,a=ts)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=L("default",e,t,n);return[jr(e.name,t,n)||r];case"Placeholder":return[jr(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=L("x",e,t,n);return[Wu(c)]}case"IdentityN":return L("x",e,t,n).map(c=>Wu(c));case"Snapshot":const s=L("x",e,t,n);return[Wu(s)];case"Shape":return[a.tensor1d(L("x",e,t,n).shape,"int32")];case"ShapeN":return L("x",e,t,n).map(c=>a.tensor1d(c.shape));case"Size":return[a.scalar(L("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(L("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const i=L("x",e,t,n),o=L("data",e,t,n),l=L("message",e,t,n),u=L("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}};class pst{get id(){return this.handle.id}constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=kt(0),this.tensorMap=new Map,dr(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return kt(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const a=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),Se(()=>{const r=lo(n),s=a.length,i=r.length;q(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let o=0;o<s;o++){const l=a[o],u=r[o];dr(u),this.tensorMap.set(l,u)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const a=await t.data();return Se(()=>{const r=[];for(let s=0;s<a.length;s++){const i=a[s],o=this.findWithDefault(i,n);r.push(o)}return ri(r)})}findWithDefault(t,n){const a=this.tensorMap.get(t);return a??n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}const fst=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=a.getHashTableHandleByName(e.name);if(r!=null)return[r];{const s=L("keyDType",e,t,n),i=L("valueDType",e,t,n),o=new pst(s,i);return a.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=L("tableHandle",e,t,n,a),s=L("keys",e,t,n),i=L("values",e,t,n);return[await a.getHashTableById(r.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=L("tableHandle",e,t,n,a),s=L("keys",e,t,n),i=L("defaultValue",e,t,n);return[await a.getHashTableById(r.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=L("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const mst=(e,t,n,a=ts)=>{switch(e.op){case"ResizeBilinear":{const r=L("images",e,t,n),s=L("size",e,t,n),i=L("alignCorners",e,t,n),o=L("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{const r=L("images",e,t,n),s=L("size",e,t,n),i=L("alignCorners",e,t,n),o=L("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case"CropAndResize":{const r=L("image",e,t,n),s=L("boxes",e,t,n),i=L("boxInd",e,t,n),o=L("cropSize",e,t,n),l=L("method",e,t,n),u=L("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{const r=L("images",e,t,n),s=L("transforms",e,t,n),i=L("outputShape",e,t,n),o=L("fillValue",e,t,n),l=L("interpolation",e,t,n),u=L("fillMode",e,t,n);return[a.image.transform(r,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const gst=(e,t,n,a=ts)=>{switch(e.op){case"Equal":return[a.equal(L("a",e,t,n),L("b",e,t,n))];case"NotEqual":return[a.notEqual(L("a",e,t,n),L("b",e,t,n))];case"Greater":return[a.greater(L("a",e,t,n),L("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(L("a",e,t,n),L("b",e,t,n))];case"Less":return[a.less(L("a",e,t,n),L("b",e,t,n))];case"LessEqual":return[a.lessEqual(L("a",e,t,n),L("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(L("a",e,t,n),L("b",e,t,n))];case"LogicalNot":return[a.logicalNot(L("a",e,t,n))];case"LogicalOr":return[a.logicalOr(L("a",e,t,n),L("b",e,t,n))];case"Select":case"SelectV2":return[a.where(L("condition",e,t,n),L("a",e,t,n),L("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(L("a",e,t,n),L("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const yst=(e,t,n,a=ts)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(L("a",e,t,n),L("b",e,t,n),L("transposeA",e,t,n),L("transposeB",e,t,n))];case"Einsum":return[a.einsum(L("equation",e,t,n),...L("tensors",e,t,n))];case"Transpose":return[a.transpose(L("x",e,t,n),L("perm",e,t,n))];case"_FusedMatMul":const[r,s]=L("fusedOps",e,t,n),i=r==="biasadd",o=s==="prelu",l=L("numArgs",e,t,n),u=L("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=L("args",e,t,n);return[a.fused.matMul({a:L("a",e,t,n),b:L("b",e,t,n),transposeA:L("transposeA",e,t,n),transposeB:L("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[a.linalg.bandPart(L("a",e,t,n),L("numLower",e,t,n),L("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const bst=(e,t,n,a=ts)=>{switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(L("x",e,t,n),L("axis",e,t,n),L("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[a.batchNorm(L("x",e,t,n),L("mean",e,t,n),L("variance",e,t,n),L("offset",e,t,n),L("scale",e,t,n),L("epsilon",e,t,n))];case"FusedBatchNormV3":return[a.batchNorm(L("x",e,t,n),L("mean",e,t,n),L("variance",e,t,n),L("offset",e,t,n),L("scale",e,t,n),L("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(L("x",e,t,n),L("radius",e,t,n),L("bias",e,t,n),L("alpha",e,t,n),L("beta",e,t,n))];case"Softmax":return[a.softmax(L("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(L("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const xst=(e,t,n,a=ts)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:s}=a.raggedGather(L("paramsNestedSplits",e,t,n),L("paramsDenseValues",e,t,n),L("indices",e,t,n),L("outputRaggedRank",e,t,n));return r.concat(s)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:s}=a.raggedRange(L("starts",e,t,n),L("limits",e,t,n),L("splits",e,t,n));return[r,s]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(L("shape",e,t,n),L("values",e,t,n),L("defaultValue",e,t,n),L("rowPartitionTensors",e,t,n),L("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const vst=(e,t,n,a=ts)=>{switch(e.op){case"Max":{const o=L("axis",e,t,n),l=L("keepDims",e,t,n);return[a.max(L("x",e,t,n),o,l)]}case"Mean":{const o=L("axis",e,t,n),l=L("keepDims",e,t,n);return[a.mean(L("x",e,t,n),o,l)]}case"Min":{const o=L("axis",e,t,n),l=L("keepDims",e,t,n);return[a.min(L("x",e,t,n),o,l)]}case"Sum":{const o=L("axis",e,t,n),l=L("keepDims",e,t,n);return[a.sum(L("x",e,t,n),o,l)]}case"All":{const o=L("axis",e,t,n),l=L("keepDims",e,t,n);return[a.all(L("x",e,t,n),o,l)]}case"Any":{const o=L("axis",e,t,n),l=L("keepDims",e,t,n);return[a.any(L("x",e,t,n),o,l)]}case"ArgMax":{const o=L("axis",e,t,n);return[a.argMax(L("x",e,t,n),o)]}case"ArgMin":{const o=L("axis",e,t,n);return[a.argMin(L("x",e,t,n),o)]}case"Prod":{const o=L("axis",e,t,n),l=L("keepDims",e,t,n);return[a.prod(L("x",e,t,n),o,l)]}case"Cumprod":{const o=L("axis",e,t,n),l=L("exclusive",e,t,n),u=L("reverse",e,t,n);return[a.cumprod(L("x",e,t,n),o,l,u)]}case"Cumsum":{const o=L("axis",e,t,n),l=L("exclusive",e,t,n),u=L("reverse",e,t,n);return[a.cumsum(L("x",e,t,n),o,l,u)]}case"Bincount":const r=L("x",e,t,n),s=L("weights",e,t,n),i=L("size",e,t,n);return[a.bincount(r,s,i)];case"DenseBincount":{const o=L("x",e,t,n),l=L("weights",e,t,n),u=L("size",e,t,n),c=L("binaryOutput",e,t,n);return[a.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const wst=(e,t,n,a=ts)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=L("n",e,t,n),s=L("axis",e,t,n);let i=L("tensors",e,t,n);return i=i.slice(0,r),[a.concat(i,s)]}case"Gather":{const r=L("x",e,t,n),s=L("indices",e,t,n);return[a.gather(r,a.cast(s,"int32"),0)]}case"GatherV2":{const r=L("axis",e,t,n),s=L("batchDims",e,t,n),i=L("x",e,t,n),o=L("indices",e,t,n);return[a.gather(i,a.cast(o,"int32"),r,s)]}case"Reverse":{const r=L("dims",e,t,n),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);const i=L("x",e,t,n);return[a.reverse(i,s)]}case"ReverseV2":{const r=L("axis",e,t,n),s=L("x",e,t,n);return[a.reverse(s,r)]}case"Slice":{const r=L("begin",e,t,n),s=L("size",e,t,n);return[a.slice(L("x",e,t,n),r,s)]}case"StridedSlice":{const r=L("begin",e,t,n),s=L("end",e,t,n),i=L("strides",e,t,n),o=L("beginMask",e,t,n),l=L("endMask",e,t,n),u=L("ellipsisMask",e,t,n),c=L("newAxisMask",e,t,n),h=L("shrinkAxisMask",e,t,n),p=L("x",e,t,n);return[a.stridedSlice(p,r,s,i,o,l,u,c,h)]}case"Pack":return Se(()=>{const r=L("axis",e,t,n),s=L("tensors",e,t,n),i=s[0].shape,o=a.squeeze(s[0]).shape,l=s.map(u=>{const c=tn(u.shape,i);if(!c&&!tn(a.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:a.reshape(u,i)});return[a.stack(l,r)]});case"Unpack":{const r=L("axis",e,t,n),s=L("tensor",e,t,n);return a.unstack(s,r)}case"Tile":{const r=L("reps",e,t,n);return[a.tile(L("x",e,t,n),r)]}case"Split":case"SplitV":{const r=L("axis",e,t,n),s=L("numOrSizeSplits",e,t,n),i=L("x",e,t,n);return a.split(i,s,r)}case"ScatterNd":{const r=L("indices",e,t,n),s=L("values",e,t,n),i=L("shape",e,t,n);return[a.scatterND(r,s,i)]}case"GatherNd":{const r=L("x",e,t,n),s=L("indices",e,t,n);return[a.gatherND(r,s)]}case"SparseToDense":{const r=L("sparseIndices",e,t,n),s=L("outputShape",e,t,n),i=L("sparseValues",e,t,n),o=L("defaultValue",e,t,n);return[a.sparseToDense(r,i,s,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case"TensorScatterUpdate":{const r=L("indices",e,t,n),s=L("values",e,t,n),i=L("tensor",e,t,n);return[a.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const Ast=(e,t,n,a=ts)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(L("indices",e,t,n),L("values",e,t,n),L("denseShape",e,t,n),L("defaultValue",e,t,n));return[r,s,i,o]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(L("inputIndices",e,t,n),L("inputShape",e,t,n),L("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(L("data",e,t,n),L("indices",e,t,n),L("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(L("data",e,t,n),L("indices",e,t,n),L("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const Sst=(e,t,n,a=ts)=>{switch(e.op){case"FFT":return[a.fft(L("x",e,t,n))];case"IFFT":return[a.ifft(L("x",e,t,n))];case"RFFT":return[a.rfft(L("x",e,t,n))];case"IRFFT":return[a.irfft(L("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const kst=(e,t,n,a=ts)=>{switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(L("input",e,t,n),L("pattern",e,t,n),L("rewrite",e,t,n),L("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(L("data",e,t,n),L("dataSplits",e,t,n),L("separator",e,t,n),L("nGramWidths",e,t,n),L("leftPad",e,t,n),L("rightPad",e,t,n),L("padWidth",e,t,n),L("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:i}=a.string.stringSplit(L("input",e,t,n),L("delimiter",e,t,n),L("skipEmpty",e,t,n));return[r,s,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(L("input",e,t,n),L("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const Ist=(e,t,n,a=ts)=>{switch(e.op){case"Cast":return[a.cast(L("x",e,t,n),L("dtype",e,t,n))];case"ExpandDims":{const r=L("axis",e,t,n);return[a.expandDims(L("x",e,t,n),r)]}case"Squeeze":{const r=L("axis",e,t,n);return[a.squeeze(L("x",e,t,n),r)]}case"Reshape":return[a.reshape(L("x",e,t,n),L("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(L("x",e,t,n),L("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(L("x",e,t,n),L("padding",e,t,n),L("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(L("x",e,t,n),L("padding",e,t,n),L("constantValue",e,t,n))];case"SpaceToBatchND":{const r=L("blockShape",e,t,n),s=L("paddings",e,t,n);return[a.spaceToBatchND(L("x",e,t,n),r,s)]}case"BatchToSpaceND":{const r=L("blockShape",e,t,n),s=L("crops",e,t,n);return[a.batchToSpaceND(L("x",e,t,n),r,s)]}case"DepthToSpace":{const r=L("blockSize",e,t,n),s=L("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(L("x",e,t,n),r,s)]}case"BroadcastTo":return[a.broadcastTo(L("x",e,t,n),L("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(L("s0",e,t,n),L("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function mj(e,t,n,a,r=Se){const s=((i,o,l)=>{switch(i.category){case"arithmetic":return r(()=>est(i,o,l));case"basic_math":return r(()=>tst(i,o,l));case"control":return ost(i,o,l);case"convolution":return r(()=>lst(i,o,l));case"creation":return r(()=>ust(i,o,l));case"dynamic":return cst(i,o,l);case"evaluation":return r(()=>hst(i,o,l));case"image":return r(()=>mst(i,o,l));case"graph":return r(()=>dst(i,o,l));case"logical":return r(()=>gst(i,o,l));case"matrices":return r(()=>yst(i,o,l));case"normalization":return r(()=>bst(i,o,l));case"ragged":return r(()=>xst(i,o,l));case"reduction":return r(()=>vst(i,o,l));case"slice_join":return r(()=>wst(i,o,l));case"sparse":return r(()=>Ast(i,o,l));case"spectral":return r(()=>Sst(i,o,l));case"string":return r(()=>kst(i,o,l));case"transformation":return r(()=>Ist(i,o,l));case"hash_table":return fst(i,o,l,a);case"custom":const u=Gre(i.op);if(u&&u.customExecutor)return u.customExecutor(new Jrt(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return zh(s)?s.then(i=>[].concat(i)):[].concat(s)}class gj{constructor(t={},n={},a={},r={},s){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=a,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const a=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(a))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}}function yj(e,t,n,a){const r=new Set,s=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map(p=>Ai(p)[0]));a=a||[];const c=new Set(a.map(p=>Ai(p.name)[0])),h=[...t];for(;h.length>0;){const p=h.pop();if((op(p)||Dst(p)||Ost(p))&&i==null&&(i=p,o=i.children.map(m=>m.name).filter(m=>r.has(m))),r.add(p.name),n[p.name]==null&&!u.has(p.name)&&!c.has(p.name)){if(p.inputs.length===0){s.push(p.name);continue}p.inputs.forEach(m=>{l.has(m.name)||(l.add(m.name),h.push(m))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function Nst(e,t){const{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(b=>Ai(b)[0]).map(b=>e.nodes[b]),s=e.initNodes||[],i=b=>n.has(typeof b=="string"?b:b.name);function o(b){return[...new Map(b.map(v=>[v.name,v])).values()]}const l=o([...r,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(b=>[b.name,b])),h={};for(const b of u){h[b.name]=h[b.name]||0;for(const v of b.children)i(v)||(h[v.name]=Number.POSITIVE_INFINITY),h[v.name]=(h[v.name]||0)+1}const p=Object.entries(h).filter(([,b])=>b===0).map(([b])=>b),m=[...p];for(;p.length>0;){const b=p.pop(),v=c.get(b);for(const w of v.children.filter(i))--h[w.name]===0&&(m.push(w.name),p.push(w.name))}const g=m.map(b=>c.get(b)),y=Cst(g,l);return Tst(y,l),y}function Cst(e,t){const n=new Map(e.map(i=>[i.name,i])),a=t.map(i=>i.name),r=new Set(a);for(;a.length>0;){const i=a.pop(),o=n.get(i);for(const l of o.children)!n.has(l.name)||r.has(l.name)||(r.add(l.name),a.push(l.name))}return e.filter(i=>r.has(i.name))}class pI extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function Tst(e,t){const n=new Map(e.map((o,l)=>[o.name,l])),a=new Set(t.map(o=>o.name)),r=o=>a.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(const o of e){for(const l of o.children.filter(i)){if(!n.has(l.name))throw new pI(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new pI(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(const l of o.inputs){if(!n.has(l.name))throw new pI(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new pI(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function Est(e){const t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,a=e.map((o,l)=>op(o)?n:l),r=o=>{const l=a[t.get(o.name)];return l??-1},s=e.map((o,l)=>o.children.map(r).reduce((u,c)=>Math.max(u,c),a[l])),i=new Map;for(let o=0;o<e.length;++o){const l=s[o];if(l===n)continue;const u=e[o],c=e[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}const $st=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),_st=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Rst=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function op(e){return $st.has(e.op)}function Dst(e){return _st.has(e.op)}function Ost(e){return Rst.has(e.op)}class jN{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(a=>t[a].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(a=>{this._functionExecutorMap[a]=new jN(t.functions[a],this)})}getCompilationKey(t,n){const a=t.map(s=>s.name).sort(),r=n.map(s=>s.name).sort();return a.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,n){const a=yj(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:i}=a;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const u=n.map(h=>h.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const o=Nst(this.graph,a),l=Est(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;const n=t.clone();return dr(n),n}cloneTensorList(t){return t?t.map(a=>this.cloneAndKeepTensor(a)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,a])=>[n,this.cloneTensorList(a)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);const a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);const r=a.map(p=>this.graph.nodes[Ai(p)[0]]),s=n.map(p=>Ai(p)[0]),i=new Set(s);let o=s.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(r,o);let u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const c={},h={};return Se(()=>{const p=new gj(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(v=>{const[w,S]=Ai(v,p),k=[];k[S]=t[v],m[w]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(k))});const g=this.getFrozenTensorIds(m),{orderedNodes:y,nodeLiveUntilMap:b}=u;for(const v of y){if(m[v.name])continue;const w=mj(v,m,p,this._resourceManager);if(zh(w))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);m[v.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList(w)),this.checkTensorForDisposalWithNodeLiveUntilInfo(v,m,p,g,i,b.get(v.name))}return this.parent==null&&p.dispose(g),n.map(v=>jr(v,m,p))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(a=>t[a]).map(a=>a.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,a,r,s,i,o){if(!(op(n)||i.has(t))){for(const l of a[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(const l of n.inputs){if(op(l))continue;const u=cj(l.name,a,r);if(u!=null)for(const c of u){if(!c||c.kept||s.has(c.id))continue;const h=o[c.id];h===1?(c.dispose(),delete o[c.id]):h!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,a,r,s,i){function o(l){return op(l)||s.has(l.name)}if(!(op(t)||i==null))for(const l of i){if(o(l))continue;const u=cj(l.name,n,a);for(const c of u)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,a=!1,r={},s={}){this.disposeIntermediateTensors(),a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const i=new gj(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(t,i,n,a),l=n.map(p=>jr(p,o,i)),u=l.map(p=>p.id),c=Object.keys(t).map(p=>t[p].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(m=>{m&&!m.isDisposed&&!h.has(m.id)&&m.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(t,n,a){const r=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(r,this.outputNodes,!0,n,a)}async executeWithControlFlow(t,n,a,r){const s=Object.keys(t),i=s.map(k=>this.graph.nodes[Ai(k)[0]]),o=a.map(k=>Ai(k)[0]),l=new Set(o);let u=o.map(k=>this.graph.nodes[k]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:p,syncInputs:m}=yj(t,u,this.weightMap,this._initNodes),g=[...i,...this.graph.weights,...this._initNodes||[]].map(k=>({node:k,contexts:n.currentContext})),y=Object.assign({},this.weightMap);Object.keys(t).forEach(k=>{const[I,T]=Ai(k),E=[];E[T]=t[k],y[I]=E});const b={},v=this.getFrozenTensorIds(y),w={};for(;g.length>0;){const k=this.processStack(i,g,n,y,w,v,l,b,c);await Promise.all(k)}p==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const S=u.filter(k=>!op(k)&&!jr(k.name,y,n)).map(k=>k.name);if(S.length>0){let k="";throw p!=null&&(k=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${S}] from the provided inputs [${s}]. Consider providing the following inputs: [${h}]. ${k}`)}return y}processStack(t,n,a,r,s,i,o,l,u){const c=[];for(;n.length>0;){const h=n.pop();a.currentContext=h.contexts;let p="";if(h.node.op==="Enter"&&L("isConstant",h.node,r,a)&&([p]=Uu(h.node.name,a)),r[h.node.name]==null){const m=mj(h.node,r,a,this._resourceManager);p||([p]=Uu(h.node.name,a));const g=a.currentContext;zh(m)?c.push(m.then(y=>(r[p]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(y)),a.currentContext=g,this.checkTensorForDisposal(p,h.node,r,a,i,o,l),this.processChildNodes(h.node,n,a,r,s,u),y))):(r[p]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(m)),this.checkTensorForDisposal(p,h.node,r,a,i,o,l),this.processChildNodes(h.node,n,a,r,s,u))}else this.processChildNodes(h.node,n,a,r,s,u)}return c}processChildNodes(t,n,a,r,s,i){t.children.forEach(o=>{const[l]=Uu(o.name,a);s[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!jr(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})):o.inputNames.every(u=>!!jr(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const a=t[n],[r]=Ai(n),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const i=s.attrParams.shape.value,o=i.length===a.shape.length&&a.shape.every((l,u)=>i[u]===-1||i[u]===l);q(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${a.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&q(a.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(t){var n,a;const r={};for(const s in t){const i=(a=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||a===void 0?void 0:a[s];i!=null?r[i.name]=t[s]:r[s]=t[s]}return r}checkInputs(t){const n=Object.keys(t).filter(a=>{const[r]=Ai(a);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var a,r;const s=(r=(a=this._signature)===null||a===void 0?void 0:a.outputs)===null||r===void 0?void 0:r[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{const[a]=Ai(n);if(!this.graph.nodes[a])throw new Error(`The output '${n}' is not found in the graph`)})}}class Fst{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const Mst="?tfjs-format=file",Lst="model.json";class l4{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,n={},a=dP){this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=a,n==null&&(this.loadOptions={}),this.resourceManager=new Fst}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const n=this.io.getLoadHandlers(t,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return zh(t)?t.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(t)}loadSync(t){const n=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,n)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await kee(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,n)}loadWithWeightMap(t,n){this.artifacts=t;const a=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const s=this.artifacts.userDefinedMetadata;s.signature!=null&&(r=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=r,this.version=`${a.versions.producer}.${a.versions.minConsumer}`,this.executor=new jN(hj.Instance.transformGraph(a,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const s=hj.Instance.transformGraph(t.modelInitializer);this.initializer=new jN(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,n){if(typeof t=="string"){const a=this.io.getSaveHandlers(t);if(a.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(a.length>1)throw new Error(`Found more than one (${a.length}) save handlers for URL '${t}'`);t=a[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const n=t instanceof In?[t]:t,a={};return n.forEach((r,s)=>a[this.structuredOutputKeys[s]]=r),a}return t}predict(t,n){const a=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(a)}async predictAsync(t,n){const a=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(a)}normalizeInputs(t){var n;if(!(t instanceof In)&&!Array.isArray(t)){const s=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(s!=null)for(const i in s){const o=s[i];o.resourceId!=null&&(t[i]=this.resourceIdToCapturedInput[o.resourceId])}return t}t=Array.isArray(t)?t:[t];const a=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+a!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-a} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((s,i)=>{var o,l,u;const c=(u=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[i])===null||u===void 0?void 0:u.resourceId;return c!=null?s[i]=this.resourceIdToCapturedInput[c]:s[i]=t[r++],s},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,a=Object.keys(n);for(let r=0;r<a.length;r++){const s=a[r],i=n[s];this.resourceIdToCapturedInput[i.resourceId]=t[r]}}}execute(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const a=this.executor.execute(t,n);return a.length>1?a:a[0]}async executeAsync(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const a=await this.executor.executeAsync(t,n);return a.length>1?a:a[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,a)=>(n[a]=[t[a]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Yt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function zst(e,t={},n=dP){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Pst(e));const a=new l4(e,t,n);return await a.load(),a}function Bst(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){const[a,r]=e;if(!a)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in a))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in a))throw new Error("Model JSON is missing 'weightsManifest'");const s=DN(a.weightsManifest),i=Qz(a,s,r);t=FN(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=FN(e);else throw new Error("Unknown model format");const n=new l4(t);return n.load(),n}function Pst(e){return e.endsWith("/")||(e=e+"/"),`${e}${Lst}${Mst}`}const Vst="4.22.0";const Ust=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:l4,deregisterOp:prt,loadGraphModel:zst,loadGraphModelSync:Bst,registerOp:drt,version_converter:Vst},Symbol.toStringTag,{value:"Module"}));var bj;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(bj||(bj={}));function pt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&q(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const Wst=xE;class GE extends MC{nextDataId(){return GE.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Mz(this,tl())}write(t,n,a){this.firstUse&&(this.firstUse=!1,Ie().get("IS_NODE")&&qi(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:a,refCount:1}),r}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&Gl(a[0])){const s=a.map(i=>Xl(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,a,r,s){this.data.set(t,{values:n,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:a}=this.data.get(t);if(n==="complex64"){const r=this.readSync(a.real.dataId),s=this.readSync(a.imag.dataId);return rc(r,s)}return eee(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const a=n.map(r=>tc(r));return Gt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Gt(t.shape,t.dtype,n)}makeOutput(t,n,a){return tl().makeTensorFromTensorInfo(this.makeTensorInfo(n,a,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=xs();return t(),{kernelMs:xs()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){pt([t],"where");const n=this.readSync(t.dataId);return Wst(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}GE.nextDataId=0;function qre(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Gst=e=>{const{x:t}=e.inputs,n=e.backend;pt(t,"abs");let a=new Float32Array(_e(t.shape));const r=n.data.get(t.dataId).values;return a=qre(r),n.makeOutput(a,t.shape,t.dtype)},Hst={kernelName:H1,backendName:"cpu",kernelFunc:Gst};function Ga(e){return(t,n,a,r,s)=>{const i=Mt(t,n),o=i.length,l=St(i),u=_e(i),c=Mr(s,u),h=t.length,p=n.length,m=St(t),g=St(n),y=Xp(t,i),b=Xp(n,i);if(y.length+b.length===0)for(let v=0;v<c.length;++v)c[v]=e(a[v%a.length],r[v%r.length]);else for(let v=0;v<c.length;++v){const w=Bm(v,o,l),S=w.slice(-h);y.forEach(E=>S[E]=0);const k=ul(S,h,m),I=w.slice(-p);b.forEach(E=>I[E]=0);const T=ul(I,p,g);c[v]=e(a[k],r[T])}return[c,i]}}function ki(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",i)},o}const jst={kernelName:HC,backendName:"cpu",kernelFunc:ki};function qN(e,t,n="float32"){if(n==="complex64"){const r=qN(e,t,"float32"),s=qN(e,t,"float32");return ki({inputs:{real:r,imag:s},backend:e})}const a=Yr(_e(t),n);return e.makeTensorInfo(t,n,a)}function uu(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const qst={kernelName:Rx,backendName:"cpu",kernelFunc:uu};function tf(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const Kst={kernelName:kT,backendName:"cpu",kernelFunc:tf};function Kre(e,t,n,a){if(a==="int32"){const r=Int32Array.from(e);return[t,"int32",r]}if(a==="bool"){const r=hd([0],n),[s,i]=Ga((o,l)=>o!==l?1:0)(t,[],e,r,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function qh(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return uu({inputs:{x:r},backend:n});const c=qN(n,r.shape,r.dtype),h=qh({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),p=ki({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),p}if(r.dtype==="complex64"){const c=tf({inputs:{input:r},backend:n}),h=qh({inputs:{x:c},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(c),h}if(!Bz(r.dtype,s)){const c=uu({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:s}}const i=n.data.get(r.dataId).values,[o,l,u]=Kre(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}const Xst={kernelName:xx,backendName:"cpu",kernelFunc:qh};function wr(e,t,n,a){return n==null?({inputs:r,backend:s})=>{const{a:i,b:o}=r,l=s;pt([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h=i.dtype==="string"?sc(u):u,p=i.dtype==="string"?sc(c):c,m=a||i.dtype,[g,y]=t(i.shape,o.shape,h,p,m);return l.makeTensorInfo(y,m,g)}:({inputs:r,backend:s})=>{const{a:i,b:o}=r,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){const u=qh({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,p=c.complexTensorInfos.imag,m=l.data.get(h.dataId).values,g=l.data.get(p.dataId).values,y=qh({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),b=l.data.get(y.dataId),v=b.complexTensorInfos.real,w=b.complexTensorInfos.imag,S=l.data.get(v.dataId).values,k=l.data.get(w.dataId).values,[I,T,E]=n(i.shape,o.shape,m,g,S,k),R=l.makeTensorInfo(E,"float32",I),D=l.makeTensorInfo(E,"float32",T),O=ki({inputs:{real:R,imag:D},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(y),l.disposeIntermediateTensorInfo(R),l.disposeIntermediateTensorInfo(D),O}else{const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h=a||i.dtype,[p,m]=t(i.shape,o.shape,u,c,h);return l.makeTensorInfo(m,h,p)}}}function u4(e){return(t,n,a,r,s,i)=>{const o=Mt(t,n),l=_e(o),u=o.length,c=St(o),h=Mr("float32",l),p=Mr("float32",l),m=Xp(t,o),g=Xp(n,o),y=rc(a,r),b=rc(s,i),v=t.length,w=St(t),S=n.length,k=St(n);if(m.length+g.length===0)for(let I=0;I<h.length;I++){const T=I%y.length,E=I%b.length,R=e(y[T*2],y[T*2+1],b[E*2],b[E*2+1]);h[I]=R.real,p[I]=R.imag}else for(let I=0;I<h.length;I++){const T=Bm(I,u,c),E=T.slice(-v);m.forEach(_=>E[_]=0);const R=ul(E,v,w),D=T.slice(-S);g.forEach(_=>D[_]=0);const O=ul(D,S,k),$=e(y[R*2],y[R*2+1],b[O*2],b[O*2+1]);h[I]=$.real,p[I]=$.imag}return[h,p,o]}}const Xre=Ga(((e,t)=>e+t)),Yst=u4(((e,t,n,a)=>({real:e+n,imag:t+a}))),Fy=wr(Pm,Xre,Yst),Qst={kernelName:Pm,backendName:"cpu",kernelFunc:Fy};function c4(e,t,n,a,r){const s=_e(a),i=Yr(r,n);for(let o=0;o<e.length;o++){const l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function Yre(e,t,n,a=!1){const r=e.shape[0],s=e.shape[1],i=Gt([r,n],t.dtype);for(let o=0;o<r;o++)for(let l=0;l<s;l++){const u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(a?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}const Qre=Ga(((e,t)=>e&t)),Zst=wr(J1,Qre),Jst={kernelName:J1,backendName:"cpu",kernelFunc:Zst};function gu(e){return(t,n,a)=>{const r=_a(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function On(e,t,n){const a=gu(t);return vd(e,a,n)}function vd(e,t,n){return({inputs:a,attrs:r,backend:s})=>{const{x:i}=a;pt(i,e);const o=s,l=o.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=sc(l)}else u=l;const c=n||i.dtype,h=t(u,c,r);return o.makeTensorInfo(i.shape,c,h)}}const Zre=gu(e=>Math.ceil(e)),eit=vd(vx,Zre),tit={kernelName:vx,backendName:"cpu",kernelFunc:eit};function Jre(e,t,n,a){const r=_a(n,_e(t));if(a&&n!=="string"){let s=0;e.forEach(i=>{const o=_e(i.shape);r.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{const o=n==="string"?sc(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*t[1]+s;for(let h=0;h<i.shape[1];++h)r[c+h]=o[l++]}s+=i.shape[1]})}return r}const ese=Ga((e,t)=>e===t?1:0),tse=wr(lA,ese,null,"bool"),nit={kernelName:lA,backendName:"cpu",kernelFunc:tse};const nse=gu(e=>Math.exp(e)),ase=vd(Cx,nse,"float32"),ait={kernelName:Cx,backendName:"cpu",kernelFunc:ase};const rse=gu(e=>Math.expm1(e)),rit=vd(Tx,rse),sit={kernelName:Tx,backendName:"cpu",kernelFunc:rit};const sse=gu(e=>Math.floor(e)),iit=vd(Ex,sse),oit={kernelName:Ex,backendName:"cpu",kernelFunc:iit};const ise=Ga((e,t)=>Math.floor(e/t)),lit=wr($x,ise,null,"int32"),uit={kernelName:$x,backendName:"cpu",kernelFunc:lit};function ose(e,t,n,a,r,s,i,o,l){const u=Gt([a,s],n);for(let c=0;c<a;c++){const h=[];let p=0;for(let m=0;m<r;m++){const g=e[c*r+m];p+=g*i[m],h.push(g)}if(p<0||p>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let m=0;m<s;m++)u.values[c*s+m]=t.get(...t.indexToLoc(p*s+m))}return u}function lse(e,t,n){const a=Gt(n,e.dtype);for(let r=0;r<a.size;++r){const i=a.indexToLoc(r).slice(),o=i[0],l=i[2],u=t.locToIndex([o,l]);i[2]=t.values[u];const c=e.locToIndex(i);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const use=Ga((e,t)=>e>t?1:0),cit=wr(dA,use,null,"bool"),hit={kernelName:dA,backendName:"cpu",kernelFunc:cit};const cse=Ga((e,t)=>e>=t?1:0),dit=wr(_x,cse,null,"bool"),pit={kernelName:_x,backendName:"cpu",kernelFunc:dit};const hse=Ga((e,t)=>e<t?1:0),fit=wr(fA,hse,null,"bool"),mit={kernelName:fA,backendName:"cpu",kernelFunc:fit};const dse=Ga((e,t)=>e<=t?1:0),git=wr(mA,dse,null,"bool"),yit={kernelName:mA,backendName:"cpu",kernelFunc:git};function pse(e,t,n){const a=(t-e)/(n-1),r=Yr(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}const fse=gu(e=>Math.log(e)),bit=vd(Mx,fse),xit={kernelName:Mx,backendName:"cpu",kernelFunc:bit};function mse(e,t,n,a){const r=Mr(a,_e(n));for(let s=0;s<r.length;++s){const i=s*t;let o=e[i];for(let l=0;l<t;++l){const u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}r[s]=o}return r}const gse=Ga(((e,t)=>Math.max(e,t))),vit=wr(zx,gse),wit={kernelName:zx,backendName:"cpu",kernelFunc:vit};const yse=Ga(((e,t)=>Math.min(e,t))),Ait=wr(Bx,yse),Sit={kernelName:Bx,backendName:"cpu",kernelFunc:Ait};const h4=Ga(((e,t)=>e*t)),kit=u4(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),HE=wr(Vx,h4,kit),Iit={kernelName:Vx,backendName:"cpu",kernelFunc:HE};function bse(e,t,n){const a=gc(-1,n);return h4([],t,a,e,n)}function Nit(e){const{inputs:t,backend:n}=e,{x:a}=t;pt(a,"neg");const r=n.data.get(a.dataId).values,[s,i]=bse(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}const Cit={kernelName:NA,backendName:"cpu",kernelFunc:Nit};const xse=Ga(((e,t)=>e!==t?1:0)),Tit=wr(CA,xse,null,"bool"),Eit={kernelName:CA,backendName:"cpu",kernelFunc:Tit};function d4(e,t,n,a,r){const s=t.length,i=_e(t),o=St(t),l=St(r),u=Mr(n,_e(r));for(let c=0;c<i;++c){const h=Bm(c,s,o),p=new Array(h.length);for(let g=0;g<p.length;g++)p[g]=h[a[g]];const m=ul(p,s,l);u[m]=e[c]}return u}function si(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;pt(r,"transpose");const i=r.shape.length,o=new Array(i);for(let h=0;h<o.length;h++)o[h]=r.shape[s[h]];const l=a.data.get(r.dataId).values,u=d4(l,r.shape,r.dtype,s,o);return{dataId:a.write(u,o,r.dtype),shape:o,dtype:r.dtype}}const $it={kernelName:bp,backendName:"cpu",kernelFunc:si};function vse(e,t,n,a){const[r,s]=Pr(e,a),i=ei(t,"int32"),o=Yr(_e(r),i),l=_e(s);for(let u=0;u<o.length;++u){const c=u*l;let h=1;for(let p=0;p<l;++p)h*=n[c+p];o[u]=h}return{outVals:o,outShape:r,outDtype:i}}function _it(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;pt(r,"prod");const o=r.shape.length,l=Zt(s,r.shape),u=$a(l,o);let c=l,h=r;const p=[];u!=null&&(h=si({inputs:{x:r},backend:n,attrs:{perm:u}}),p.push(h),c=Ua(c.length,o));const m=n.data.get(h.dataId).values,{outVals:g,outShape:y,outDtype:b}=vse(h.shape,h.dtype,m,c);let v=y;return i&&(v=Ba(y,l)),p.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(v,b,g)}const Rit={kernelName:DA,backendName:"cpu",kernelFunc:_it};function Dit(e,t,n){e.forEach((a,r)=>{if(a<0||a>=n){const s=Bm(r,t.length,St(t)).join(",");throw new Error(`indices[${s}] = ${a} is not in [0, ${n})`)}})}function Oit(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(a.length===0)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let s=1;s<a.length;++s)if(a[s-1]>a[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Fit(e,t,n,a){const r=[];let s=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);Oit(n,a);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let h=1;h<l+1;++h)o[u].push(h*c)}for(let u=0;u<e.length;++u){let c=e[u],h=e[u]+1;for(let p=0;p<n.length;++p){const m=n[p],g=p+t.length-1;if(g>=0){const y=o[g],b=y[y.length-1]-m[c];for(let v=c;v<h;++v)o[g].push(m[v+1]+b)}c=m[c],h=m[h]}h!==c&&(r.push([c,h]),s+=h-c)}return{outSplits:o,valueSlices:r,numValues:s}}function Mit(e){const t=[];for(let n=0;n<e.length;++n){const a=e[n].length,r=_a("int32",a);t.push(r),e[n].forEach((s,i)=>r[i]=s)}return t}function xj(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function Lit(e,t,n,a,r,s){const i=xj(t,2)[1],o=xj(s,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let h=0;h<a;++h)r[l*o+h]=e[c*i+h];++l}}function zit(e,t,n,a,r){const s=t.slice();s[0]=r;const i=_a(n,_e(s)),o=e.length,l=o===0?0:o/t[0];return Lit(e,t,a,l,i,s),[i,s]}function wse(e,t,n,a,r,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(Dit(s,i,l),a.length===0)throw new Error("params.rank must be nonzero");const u=a[0],{outSplits:c,valueSlices:h,numValues:p}=Fit(s,i,e,u),m=Mit(c),g=zit(n,a,r,h,p);return[m,g[0],g[1]]}const vj=2147483647;function Ase(e,t,n,a,r,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=t.length===0,l=r.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(r[0]),u||c.push(i[0]);for(let b=1;b<c.length;++b)if(c[b]!==c[b-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],p=_a("int32",h+1);p[0]=0;for(let b=0;b<h;++b){const v=o?e[0]:e[b],w=l?a[0]:a[b],S=u?s[0]:s[b];if(S===0)throw new Error("Requires delta != 0");let k;if(S>0&&w<v||S<0&&w>v)k=0;else if(k=Math.ceil(Math.abs((w-v)/S)),k>vj)throw new Error(`Requires ((limit - start) / delta) <= ${vj}`);p[b+1]=p[b]+k}const m=p[h],g=_a(n,m);let y=0;for(let b=0;b<h;++b){const v=p[b+1]-p[b];let w=o?e[0]:e[b];const S=u?s[0]:s[b];for(let k=0;k<v;++k)g[y++]=w,w+=S}return[p,g]}var Eo=rl;class KN{constructor(t,n,a,r,s,i,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=a,this.valuesShape=r,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=ane(c),this.raggedRank=rne(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Eo.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Eo.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Eo.VALUE_ROWIDS:return KN.getMaxWidthValueRowID(n);case Eo.ROW_SPLITS:return KN.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Eo[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let a=0;for(let r=0;r<n-1;++r){const s=t[r+1]-t[r];s>a&&(a=s)}return a}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let a=0,r=t[0],s=0;for(let i=1;i<n;++i){const o=t[i];o!==r&&(r=o,s=Math.max(i-a,s),a=i)}return Math.max(n-a,s)}tensorShapeFromTensor(t,n,a=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Aj(t,a)}calculateOutputSize(t){const n=this.valuesShape,a=this.defaultValueShape;sne(a,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=nne(this.raggedRank,r,n);i[0]<0&&(i[0]=t);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(t,n,a){const r=Math.min(t,a),s=[];let i=0;for(let o=0;o<r;++o,i+=n)s.push(i);for(let o=r;o<t;++o)s.push(-1);return q(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,a,r){const s=t.length,i=[];for(let o=0;o<s-1;++o){const l=t[o+1]-t[o];let u=Math.min(r,l),c=n[o];c===-1&&(u=0);for(let h=0;h<u;++h)i.push(c),c+=a;for(let h=0;h<l-u;++h)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,a,r){const s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<s;++c){const h=t[c];if(h===l)u>=0&&(++o,o<r?u+=a:u=-1);else{if(o=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);u=n[h]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,a,r){const s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Eo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,a,r);case Eo.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,a,r);default:throw new Error(`Unsupported partition type: ${Eo[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Eo.FIRST_DIM_SIZE:return t[0];case Eo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Eo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Eo[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),a=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*a[l+1];const s=Aj(a,!1),i=_a(this.valuesDType,_e(s));if(r[0]*a[0]>0){let l=this.calculateFirstParentOutputIndex(n,r[0],a[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],a[u]);this.setOutput(this.raggedRank,l,i,s)}return[s,i]}setOutput(t,n,a,r){if(a.length===0)return;const s=this.values,i=a;let o=r.slice();o=o.slice(t+1);const l=_e(o),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const g=this.defaultValueShape;Se(()=>{const y=me(c,g);c=xp(y,o).dataSync()})}let h=0,p=0,m=0;for(let g=0;g<=u;++g){let y=g<u?n[g]:-1;if(y===m){++m;continue}if(p<m){const b=s.subarray(h*l),v=i.subarray(p*l),w=(m-p)*l;wj(v,b,w)}if(g>=u){const b=a.length;y=Math.floor(b/l)}if(y>m)if(this.defaultValue.length===1)i.subarray(m*l,y*l).fill(this.defaultValue[0]),m=y;else for(;y>m;){const b=i.slice(m*l);wj(b,c,l),++m}y<0?(h=g+1,p=m):(h=g,p=m,m=p+1)}}}function wj(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function Aj(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function Sse(e,t,n,a,r,s,i,o,l,u){return new KN(e,t,n,a,r,s,i,o,l,u).compute()}function kse(e,t,n,a){const r=e===t,s=e<t&&n<0,i=t<e&&n>1;if(r||s||i)return Yr(0,a);const o=Math.abs(Math.ceil((t-e)/n)),l=Yr(o,a);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}const Ise=gu(e=>1/Math.sqrt(e)),Bit=vd(qx,Ise),Pit={kernelName:qx,backendName:"cpu",kernelFunc:Bit};function dp(e,t,n,a,r,s,i,o,l,u){const c=[a/r,r],h=e.values,p=t.values;if(a===0)return Gt(n,t.dtype);const m=l instanceof er?l:Gt(c,t.dtype);typeof l=="string"||typeof l=="number"?m.values.fill(l):typeof l=="boolean"&&m.values.fill(+l);for(let g=0;g<s;g++){const y=[];let b=0;for(let v=0;v<i;v++){const w=h[g*i+v];y.push(w),b+=w*o[v]}if(b<0||b>=a/r)throw new Error(`Invalid indices: ${y} does not index into ${n}`);for(let v=0;v<r;v++)u?m.values[b*r+v]+=p[g*r+v]:m.values[b*r+v]=t.rank===0?p[0]:p[g*r+v]}return m}const Vit=gu(e=>1/(1+Math.exp(-e))),Nse=On(Zx,e=>1/(1+Math.exp(-e))),Uit={kernelName:Zx,backendName:"cpu",kernelFunc:Nse};function Cse(e,t,n,a,r){const s=mP(a,t,n),i=_e(n),o=St(a);if(s){const h=gP(t,o);return r==="string"?e.slice(h,h+i):e.subarray(h,h+i)}const l=r==="string"?sc(e):e,u=Gt(a,r,l),c=Gt(n,r);for(let h=0;h<c.size;++h){const p=c.indexToLoc(h),m=p.map((g,y)=>g+t[y]);c.set(u.get(...m),...p)}return r==="string"?Ine(c.values):c.values}function nf(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a;pt(r,"slice");const[o,l]=$E(r,s,i);pP(r,o,l);const u=n.data.get(r.dataId).values,c=Cse(u,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}const Wit={kernelName:BA,backendName:"cpu",kernelFunc:nf};function Tse(e,t,n,a,r,s,i){const o=t[0],l=s[0],u=new Array(l),c=new Array(o),h=t[1];if(l===0){if(o!==0)throw new Error(dne(o));const b=_a(n,0),v=_a(r,0);return[b,[0,h],v,u,c]}let p=!0,m=0;const g=new Array(l).fill(0);for(let b=0;b<o;++b){const v=e[b*h];if(v<0)throw new Error(pne(b,v));if(v>=l)throw new Error(fne(b,v,l));++g[v],p=p&&v>=m,m=v}let y=!0;for(let b=0;b<l;++b){const v=g[b]===0;u[b]=v,y=y&&!v,g[b]=Math.max(g[b],1),b>0&&(g[b]+=g[b-1])}if(y&&p){const b=e,v=a;for(let w=0;w<o;++w)c[w]=w;return[b,[o,h],v,u,c]}else{const b=g[l-1],v=_a(n,b*h),w=_a(r,b),S=new Array(l).fill(0);for(let k=0;k<o;++k){const I=e[k*h],T=S[I],E=(I===0?0:g[I-1])+T;S[I]++;for(let R=0;R<h;++R)v[E*h+R]=e[k*h+R];w[E]=a[k],c[k]=E}for(let k=0;k<l;++k)if(S[k]===0){const T=k===0?0:g[k-1];v[T*h+0]=k;for(let E=1;E<h;++E)v[T*h+E]=0;w[T]=i}return[v,[b,h],w,u,c]}}function Ese(e,t,n,a,r){const s=_e(a),i=t[0],o=r.length,l=[];let u=1,c=-1;for(let b=0;b<o;++b){const v=r[b];if(v===-1){if(c!==-1)throw new Error(mne(c,b));c=b,l.push(1)}else{if(v<0)throw new Error(gne(b,v));u*=v,l.push(v)}}if(c!==-1){if(u<=0)throw new Error(yne());const b=Math.trunc(s/u);if(u*b!==s)throw new Error(bne(a,l));l[c]=b}if(_e(l)!==s)throw new Error(xne(a,l));const p=a.length,m=[];if(p>0){m[p-1]=1;for(let b=p-2;b>=0;--b)m[b]=m[b+1]*a[b+1]}const g=[];if(o>0){g[o-1]=1;for(let b=o-2;b>=0;--b)g[b]=g[b+1]*l[b+1]}const y=_a(n,i*o);for(let b=0;b<i;++b){let v=0;for(let w=0;w<p;++w)v+=e[b*p+w]*m[w];for(let w=0;w<o;++w)y[b*o+w]=Math.trunc(v/g[w]),v%=g[w]}return[y,[i,o],l]}function p4(e,t,n,a,r,s=!1,i=0){const o=a.length,l=[t[0],e.length/t[0]],u=l[1],h=o>0?r[o-1]+1:0;if(h<0)throw new Error(EO());const p=t.slice();p[0]=h;const m=p.reduce((S,k)=>S*k,1),g=_a(n,m);if(o===0)return h>0&&g.fill(i),[g,p];if(h<=0)throw new Error(EO());let y=0,b=1,v=0,w=r[y];for(;;){let S=0;if(b<o){if(S=r[b],w===S){++b;continue}if(w>=S)throw new Error(vne())}if(w<0||w>=h)throw new Error(wne(w,h));w>v&&g.fill(i,v*u,w*u);for(let k=y;k<b;++k){const I=a[k];if(I<0||I>=l[0])throw new Error(Ane(k,a[k],l[0]));for(let T=0;T<u;T++)g[w*u+T]+=e[I*u+T]}if(s)for(let k=0;k<u;k++)g[w*u+k]/=b-y;if(y=b,++b,v=w+1,w=S,b>o)break}return v<h&&g.fill(i,v*u,h*u),[g,p]}const Git=gu(e=>Math.sqrt(e)),Hit=On(e0,e=>Math.sqrt(e)),jit={kernelName:e0,backendName:"cpu",kernelFunc:Hit};const $se=Ga(((e,t)=>{const n=e-t;return n*n})),qit=wr(t0,$se),Kit={kernelName:t0,backendName:"cpu",kernelFunc:qit};const _se=gu((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)}),Xit=vd(GA,_se),Yit={kernelName:GA,backendName:"cpu",kernelFunc:Xit};function Rse(e,t,n,a){const r=Gt(e,t.dtype);for(let s=0;s<r.size;s++){const i=r.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+a[l];r.set(t.get(...o),...i)}return r}class Qit{constructor(t,n,a,r,s,i){this.separator=Xl(t),this.nGramWidths=n,this.leftPad=Xl(a),this.rightPad=Xl(r),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const a=this.getPadWidth(n);return Math.max(0,t+2*a-n+1)}createNGrams(t,n,a,r,s,i){for(let o=0;o<s;++o){const l=this.getPadWidth(i),u=Math.max(0,l-o),c=Math.max(0,l-(s-(o+1))),h=i-(u+c),p=n+(u>0?0:o-l);let m=0;m+=u*this.leftPad.length;for(let w=0;w<h;++w)m+=t[p+w].length;m+=c*this.rightPad.length;const g=u+c+h-1;m+=g*this.separator.length,a[r+o]=new Uint8Array(m);const y=a[r+o];let b=0;const v=w=>w.forEach(S=>y[b++]=S);for(let w=0;w<u;++w)v(this.leftPad),v(this.separator);for(let w=0;w<h-1;++w)v(t[p+w]),v(this.separator);if(h>0){v(t[p+h-1]);for(let w=0;w<c;++w)v(this.separator),v(this.rightPad)}else{for(let w=0;w<c-1;++w)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(t,n){const a=t.length,r=n.length;if(r>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=n[u]>=l;if(c=c&&n[u]<=a,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${a}]`);l=n[u]}if(l!==a)throw new Error(`Last split value must be data size. Expected ${a}, got ${l}`)}const s=r-1,i=_a("int32",r);if(a===0||r===0){const l=new Array(a);for(let u=0;u<=s;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=s;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}const o=new Array(i[s]);for(let l=0;l<s;++l){const u=n[l];let c=i[l];if(this.nGramWidths.forEach(h=>{const p=n[l+1]-n[l],m=this.getNumNGrams(p,h);this.createNGrams(t,u,o,c,m,h),c+=m}),this.preserveShort&&c===i[l]){const h=n[l+1]-n[l];if(h===0)continue;const p=h+2*this.padWidth;this.createNGrams(t,u,o,c,1,p)}}return[o,i]}}function Dse(e,t,n,a,r,s,i,o){return new Qit(n,a,r,s,i,o).compute(e,t)}function Zit(e,t,n,a){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)a.push(e.subarray(s,s+1));return}if(t.length===1){const s=t[0];let i=e.indexOf(s);for(;i!==-1;){const o=e.subarray(0,i);(!n||o.length!==0)&&a.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&a.push(e);return}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){const i=e.subarray(r,s);(!n||i.length!==0)&&a.push(i),r=s+1}}function Ose(e,t,n){const a=e.length,r=[];let s=0,i=0;const o=new Array(a);for(let p=0;p<a;++p){const m=r.length;Zit(e[p],t,n,r);const g=r.length-m;o[p]=g,s+=g,i=Math.max(i,g)}const l=_a("int32",s*2),u=new Array(s),c=[a,i];let h=0;for(let p=0;p<a;++p)for(let m=0;m<o[p];++m)l[h*2]=p,l[h*2+1]=m,u[h]=r[h],++h;return[l,u,c]}function Fse(e,t){const n=_a("int32",e.length);for(let a=0;a<e.length;++a)n[a]=hee(e[a]).modulo(t).getLowBitsUnsigned();return n}const Mse=Ga(((e,t)=>e-t)),Jit=u4(((e,t,n,a)=>({real:e-n,imag:t-a}))),f4=wr(n0,Mse,Jit),eot={kernelName:n0,backendName:"cpu",kernelFunc:f4};function Lse(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=Gt(n,e.dtype);for(let r=0;r<a.values.length;++r){const s=a.indexToLoc(r),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];const o=e.locToIndex(i);a.values[r]=e.values[o]}return a}const Uv=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function zse(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){const o=a-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),p=Math.max(n,Math.floor(t-l*c/o+h)),m=Math.min(a,Math.floor(t+(o-l)*c/o+h));zse(e,t,p,m)}const r=e[t];let s=n,i=a;for(Hu(e,n,t),Uv(e[a],r)>0&&Hu(e,n,a);s<i;){for(Hu(e,s,i),s++,i--;Uv(e[s],r)<0;)s=s+1;for(;Uv(e[i],r)>0;)i=i-1}Uv(e[n],r)===0?Hu(e,n,i):(i=i+1,Hu(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function Bse(e,t,n,a,r){const s=t[t.length-1],[i,o]=[e.length/s,s],l=Mr(n,i*a),u=Mr("int32",i*a);for(let h=0;h<i;h++){const p=h*o,m=e.subarray(p,p+o);let g=new Array(m.length);m.forEach((w,S)=>g[S]={value:w,index:S}),a<g.length&&(zse(g,a),g=g.slice(0,a)),r&&g.sort(Uv);const y=h*a,b=l.subarray(y,y+a),v=u.subarray(y,y+a);for(let w=0;w<a;w++)b[w]=g[w].value,v[w]=g[w].index}const c=t.slice();return c[c.length-1]=a,[Gt(c,n,l),Gt(c,"int32",u)]}function Pse(e,t,n,a){const r=Zt(t,n)[0],s=[1,n[0],1];for(let g=0;g<r;g++)s[0]*=n[g];s[1]=n[r];for(let g=r+1;g<n.length;g++)s[2]*=n[g];const i=new Map,o=new Int32Array(n[r]),l=new er(s,a,e),u=[],c=s[0]===1&&s[2]===1;for(let g=0;g<n[r];g++){let y;if(c)y=e[g].toString();else{const v=[];for(let w=0;w<s[0];w++)for(let S=0;S<s[2];S++)v.push(l.get(w,g,S));y=v.join(",")}const b=i.get(y);if(b!=null)o[g]=b;else{const v=i.size;i.set(y,v),o[g]=v,u.push(g)}}const h=s.slice();h[1]=i.size;const p=new er(h,a);u.forEach((g,y)=>{for(let b=0;b<s[0];b++)for(let v=0;v<s[2];v++)p.set(l.get(b,g,v),b,y,v)});const m=n.slice();return m[r]=h[1],{outputValues:p.values,outputShape:m,indices:o}}const tot=Object.freeze(Object.defineProperty({__proto__:null,addImpl:Xre,bincountImpl:c4,bincountReduceImpl:Yre,bitwiseAndImpl:Qre,castImpl:Kre,ceilImpl:Zre,concatImpl:Jre,equalImpl:ese,expImpl:nse,expm1Impl:rse,floorDivImpl:ise,floorImpl:sse,gatherNdImpl:ose,gatherV2Impl:lse,greaterEqualImpl:cse,greaterImpl:use,lessEqualImpl:dse,lessImpl:hse,linSpaceImpl:pse,logImpl:fse,maxImpl:mse,maximumImpl:gse,minimumImpl:yse,multiplyImpl:h4,negImpl:bse,notEqualImpl:xse,prodImpl:vse,raggedGatherImpl:wse,raggedRangeImpl:Ase,raggedTensorToTensorImpl:Sse,rangeImpl:kse,rsqrtImpl:Ise,scatterImpl:dp,sigmoidImpl:Vit,simpleAbsImpl:qre,sliceImpl:Cse,sparseFillEmptyRowsImpl:Tse,sparseReshapeImpl:Ese,sparseSegmentReductionImpl:p4,sqrtImpl:Git,squaredDifferenceImpl:$se,staticRegexReplaceImpl:_se,stridedSliceImpl:Rse,stringNGramsImpl:Dse,stringSplitImpl:Ose,stringToHashBucketFastImpl:Fse,subImpl:Mse,tileImpl:Lse,topKImpl:Bse,transposeImpl:d4,uniqueImpl:Pse},Symbol.toStringTag,{value:"Module"}));Kz("cpu",()=>new GE,1);const Vse=On(Ix,e=>e>=0?e:Math.exp(e)-1),not={kernelName:Ix,backendName:"cpu",kernelFunc:Vse};function Use(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;pt([r],"leakyRelu");const i=_e(r.shape),o=n.data.get(r.dataId).values,l=Mr("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(r.shape,"float32",l)}const aot={kernelName:pA,backendName:"cpu",kernelFunc:Use};const rot=Ga((e,t)=>e<0?t*e:e);function Wse(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;pt([a,r],"prelu");const s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,l]=rot(a.shape,r.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}const sot={kernelName:RA,backendName:"cpu",kernelFunc:Wse};const Gse=On(Gx,e=>Math.max(0,e)),iot={kernelName:Gx,backendName:"cpu",kernelFunc:Gse};const Hse=On(Hx,e=>Math.min(Math.max(0,e),6)),oot={kernelName:Hx,backendName:"cpu",kernelFunc:Hse};function XN(e,t,n,a,r){if(n==="linear")return uu({inputs:{x:t},backend:e});if(n==="relu")return Gse({inputs:{x:t},backend:e});if(n==="elu")return Vse({inputs:{x:t},backend:e});if(n==="relu6")return Hse({inputs:{x:t},backend:e});if(n==="prelu")return Wse({inputs:{x:t,alpha:a},backend:e});if(n==="leakyrelu")return Use({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n==="sigmoid")return Nse({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function la(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=_e(r.shape),o=zz(s,i),l=_e(o);q(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=o,h.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const lot={kernelName:OA,backendName:"cpu",kernelFunc:la};function jse(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;pt([r,s],"matMul");const l=r.shape.length,u=s.shape.length,c=i?r.shape[l-2]:r.shape[l-1],h=o?s.shape[u-1]:s.shape[u-2],p=i?r.shape[l-1]:r.shape[l-2],m=o?s.shape[u-2]:s.shape[u-1],g=r.shape.slice(0,-2),y=s.shape.slice(0,-2),b=_e(g),v=_e(y),S=Mt(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,m]);q(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);const k=i?[b,c,p]:[b,p,c],I=o?[v,m,h]:[v,h,m],T=la({inputs:{x:r},backend:n,attrs:{shape:k}}),E=la({inputs:{x:s},backend:n,attrs:{shape:I}}),R=i?T.shape[1]:T.shape[2],D=i?T.shape[2]:T.shape[1],O=o?E.shape[1]:E.shape[2],$=Math.max(b,v),_=n.data.get(T.dataId).values,P=n.data.get(E.dataId).values,U=St(T.shape),W=St(E.shape),[B,H,j]=i?[U[0],1,U[1]]:[U[0],U[1],1],[Z,te,V]=o?[1,W[1],W[0]]:[W[1],1,W[0]],Q=D*O,ee=Gt([$,D,O],T.dtype),ae=ee.values,de=n.blockSize;for(let ke=0;ke<$;ke++){const Te=ke%b,$e=ke%v;for(let Le=0;Le<D;Le+=de){const Ge=Math.min(Le+de,D);for(let Ke=0;Ke<O;Ke+=de){const at=Math.min(Ke+de,O);for(let vt=0;vt<R;vt+=de){const ot=Math.min(vt+de,R);for(let lt=Le;lt<Ge;lt++)for(let tt=Ke;tt<at;tt++){let wt=0;for(let It=vt;It<ot;It++){const jn=_[Te*B+lt*H+It*j],Dt=P[It*Z+tt*te+$e*V];wt+=jn*Dt}ae[ke*Q+(lt*O+tt)]+=wt}}}}}return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(E),n.makeTensorInfo(S,ee.dtype,ee.values)}const uot={kernelName:Q1,backendName:"cpu",kernelFunc:jse};function cot(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=a;let p,m,g;const y=[];p=jse({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(m=Fy({inputs:{a:p,b:i},backend:n}),y.push(p),p=m),c&&(g=XN(n,p,c,o,h),y.push(p),p=g);for(const v of y)n.disposeIntermediateTensorInfo(v);return p}const hot={kernelName:bw,backendName:"cpu",kernelFunc:cot};const dot=On(dx,e=>Math.acos(e)),pot={kernelName:dx,backendName:"cpu",kernelFunc:dot};const fot=On(px,e=>Math.acosh(e)),mot={kernelName:px,backendName:"cpu",kernelFunc:fot};function got(e){const{inputs:t,backend:n}=e,a=t;pt(t,"addN");const r=a.map(o=>n.data.get(o.dataId).values),s=Gt(a[0].shape,a[0].dtype),i=s.values;for(let o=0;o<a.length;o++){const l=r[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}const yot={kernelName:j1,backendName:"cpu",kernelFunc:got};function bot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;pt(r,"all");const o=Zt(s,r.shape);let l=o;const u=$a(l,r.shape.length);let c=r;u!=null&&(c=si({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Ua(l.length,r.shape.length)),es("all",l,c.shape.length);const[h,p]=Pr(c.shape,l),m=_e(p),g=Yr(_e(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){const w=v*m;let S=y[w];for(let k=0;k<m;++k){const I=y[w+k];S=S&&I}g[v]=S}u!=null&&n.disposeIntermediateTensorInfo(c);const b=n.makeTensorInfo(h,c.dtype,g);if(i){const v=Ba(h,o),w=la({inputs:{x:b},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(b),w}return b}const xot={kernelName:BC,backendName:"cpu",kernelFunc:bot};function vot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;pt(r,"any");const o=Zt(s,r.shape);let l=o;const u=$a(l,r.shape.length);let c=r;u!=null&&(c=si({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Ua(l.length,r.shape.length)),es("any",l,c.shape.length);const[h,p]=Pr(c.shape,l),m=_e(p),g=Yr(_e(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){const w=v*m;let S=y[w];for(let k=0;k<m;++k){const I=y[w+k];S=S||I}g[v]=S}u!=null&&n.disposeIntermediateTensorInfo(c);const b=n.makeTensorInfo(h,c.dtype,g);if(i){const v=Ba(h,o),w=la({inputs:{x:b},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(b),w}return b}const wot={kernelName:PC,backendName:"cpu",kernelFunc:vot};function Aot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;pt(r,"argMax");let i=Zt(s,r.shape);const o=$a(i,r.shape.length);let l=r;const u=[];o!=null&&(l=si({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=Ua(i.length,l.shape.length)),i=[i[0]],es("argMax",i,l.shape.length);const[c,h]=Pr(l.shape,i),p=_e(c),m=Yr(p,"int32"),g=_e(h),y=n.data.get(l.dataId).values;for(let b=0;b<m.length;++b){const v=b*g;let w=y[v],S=0;for(let k=0;k<g;++k){const I=y[v+k];I>w&&(w=I,S=k)}m[b]=S}return u.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(c,"int32",m)}const Sot={kernelName:q1,backendName:"cpu",kernelFunc:Aot};function kot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;pt(r,"argMin");let i=Zt(s,r.shape);const o=$a(i,r.shape.length);let l=r;const u=[];o!=null&&(l=si({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=Ua(i.length,l.shape.length)),i=[i[0]],es("argMin",i,l.shape.length);const[c,h]=Pr(l.shape,i),p=_e(c),m=Yr(p,"int32"),g=_e(h),y=n.data.get(l.dataId).values;for(let b=0;b<m.length;++b){const v=b*g;let w=y[v],S=0;for(let k=0;k<g;++k){const I=y[v+k];I<w&&(w=I,S=k)}m[b]=S}return u.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(c,"int32",m)}const Iot={kernelName:K1,backendName:"cpu",kernelFunc:kot};const Not=On(fx,e=>Math.asin(e)),Cot={kernelName:fx,backendName:"cpu",kernelFunc:Not};const Tot=On(mx,e=>Math.asinh(e)),Eot={kernelName:mx,backendName:"cpu",kernelFunc:Tot};const $ot=On(gx,e=>Math.atan(e)),_ot={kernelName:gx,backendName:"cpu",kernelFunc:$ot};const Rot=Ga((e,t)=>Math.atan2(e,t)),Dot=wr(bx,Rot),Oot={kernelName:bx,backendName:"cpu",kernelFunc:Dot};const Fot=On(yx,e=>Math.atanh(e)),Mot={kernelName:yx,backendName:"cpu",kernelFunc:Fot};function m4(e,t,n,a,r,s){const i=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,m=r.padInfo.left,g=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=Gt(r.outShape,n),b=y.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3],w=r.outShape[2]*r.outShape[3],S=r.outShape[3];for(let k=0;k<r.batchSize;++k){const I=k*v,T=k*a[0];for(let E=0;E<r.inChannels;++E)for(let R=0;R<r.outHeight;++R){const D=R*i-p,O=Math.max(0,D),$=Math.min(r.inHeight,c+D),_=I+R*w;for(let P=0;P<r.outWidth;++P){const U=P*o-m,W=Math.max(0,U),B=Math.min(r.inWidth,h+U);let H=g,j=0,Z=0;for(let V=O;V<$;V+=l){const Q=T+V*a[1];for(let ee=W;ee<B;ee+=u){const ae=Q+ee*a[2],de=e[ae+E];s==="max"&&de>H?H=de:s==="avg"&&(j+=de,Z++)}if(isNaN(H))break}const te=_+P*S+E;b[te]=s==="avg"?j/Z:H}}}return y}function qse(e,t,n,a,r=!1,s=!1){const i=Gt(a.outShape,"int32"),o=a.strideHeight,l=a.strideWidth,u=a.dilationHeight,c=a.dilationWidth,h=a.effectiveFilterHeight,p=a.effectiveFilterWidth,m=a.padInfo.top,g=a.padInfo.left,y=Gt(t,n,e);for(let b=0;b<a.batchSize;++b)for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outHeight;++w){const S=w*o-m;let k=S;for(;k<0;)k+=u;const I=Math.min(a.inHeight,h+S);for(let T=0;T<a.outWidth;++T){const E=T*l-g;let R=E;for(;R<0;)R+=c;const D=Math.min(a.inWidth,p+E);let O=Number.NEGATIVE_INFINITY,$=-1;for(let _=k;_<I;_+=u){const P=_-S;for(let U=R;U<D;U+=c){const W=U-E,B=y.get(b,_,U,v);B>O&&(O=B,r?$=s?((b*a.inHeight+_)*a.inWidth+U)*a.inChannels+v:(_*a.inWidth+U)*a.inChannels+v:$=P*p+W)}}i.set($,b,w,T,v)}}return i}function Kse(e,t,n,a,r,s){const i=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,p=r.effectiveFilterDepth,m=r.effectiveFilterHeight,g=r.effectiveFilterWidth,y=r.padInfo.front,b=r.padInfo.top,v=r.padInfo.left,w=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=Gt(r.outShape,n),k=S.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],T=r.outShape[2]*r.outShape[3]*r.outShape[4],E=r.outShape[3]*r.outShape[4],R=r.outShape[4];for(let D=0;D<r.batchSize;++D){const O=D*I,$=D*a[0];for(let _=0;_<r.inChannels;++_)for(let P=0;P<r.outDepth;++P){const U=P*i-y;let W=U;for(;W<0;)W+=u;const B=Math.min(r.inDepth,p+U),H=O+P*T;for(let j=0;j<r.outHeight;++j){const Z=j*o-b;let te=Z;for(;te<0;)te+=c;const V=Math.min(r.inHeight,m+Z),Q=H+j*E;for(let ee=0;ee<r.outWidth;++ee){const ae=ee*l-v;let de=ae;for(;de<0;)de+=h;const ke=Math.min(r.inWidth,g+ae),Te=Q+ee*R;let $e=w,Le=0,Ge=0;for(let at=W;at<B;at+=u){const vt=$+at*a[1];for(let ot=te;ot<V;ot+=c){const lt=vt+ot*a[2];for(let tt=de;tt<ke;tt+=h){const wt=lt+tt*a[3],It=e[wt+_];if(s==="max"&&It>$e?$e=It:s==="avg"&&(Le+=It,Ge++),isNaN($e))break}if(isNaN($e))break}if(isNaN($e))break}const Ke=Te+_;k[Ke]=s==="avg"?Le/Math.max(Ge,1):$e}}}}return S}function Lot(e,t){const n=Gt(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,m=t.padInfo.top,g=t.padInfo.left;for(let y=0;y<t.batchSize;++y)for(let b=0;b<t.inChannels;++b)for(let v=0;v<t.outDepth;++v){const w=v*a-p;let S=w;for(;S<0;)S+=i;const k=Math.min(t.inDepth,u+w);for(let I=0;I<t.outHeight;++I){const T=I*r-m;let E=T;for(;E<0;)E+=o;const R=Math.min(t.inHeight,c+T);for(let D=0;D<t.outWidth;++D){const O=D*s-g;let $=O;for(;$<0;)$+=l;const _=Math.min(t.inWidth,h+O);let P=Number.NEGATIVE_INFINITY,U=-1;for(let W=S;W<k;W+=i){const B=W-w;for(let H=E;H<R;H+=o){const j=H-T;for(let Z=$;Z<_;Z+=l){const te=Z-O,V=e.get(y,W,H,Z,b);V>=P&&(P=V,U=B*c*h+j*c+te)}}}n.set(U,y,v,I,D,b)}}}return n}function zot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;pt(r,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;q(Jr(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Wo(r.shape,s,i,u,o,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&tn(c.inShape,c.outShape))h=uu({inputs:{x:r},backend:n});else{const p=n.data.get(r.dataId).values,m=St(r.shape),g=m4(p,r.shape,r.dtype,m,c,"avg");h=n.makeTensorInfo(c.outShape,r.dtype,g.values)}return h}const Bot={kernelName:X1,backendName:"cpu",kernelFunc:zot};function Pot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;pt(r,"avgPool3d");const c=yc(r.shape,s,i,1,o,l,u),h=n.data.get(r.dataId).values,p=Kse(h,r.shape,r.dtype,St(r.shape),c,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}const Vot={kernelName:Y1,backendName:"cpu",kernelFunc:Pot};function Uot(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;pt([r,s],"avgPool3DGrad");const c=yc(s.shape,i,o,1,l,u),h=c.strideDepth,p=c.strideHeight,m=c.strideWidth,g=c.filterDepth,y=c.filterHeight,b=c.filterWidth,v=c.dilationDepth,w=c.dilationHeight,S=c.dilationWidth,k=c.effectiveFilterDepth,I=c.effectiveFilterHeight,T=c.effectiveFilterWidth,E=k-1-c.padInfo.front,R=T-1-c.padInfo.left,D=I-1-c.padInfo.top,O=Gt(s.shape,"float32"),$=1/(g*y*b),_=n.bufferSync(r);for(let P=0;P<c.batchSize;++P)for(let U=0;U<c.inChannels;++U)for(let W=0;W<c.inDepth;++W)for(let B=0;B<c.inHeight;++B)for(let H=0;H<c.inWidth;++H){const j=W-E,Z=B-D,te=H-R;let V=0;for(let Q=0;Q<k;Q+=v){const ee=(j+Q)/h;if(!(ee<0||ee>=c.outDepth||Math.floor(ee)!==ee))for(let ae=0;ae<I;ae+=w){const de=(Z+ae)/p;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let ke=0;ke<T;ke+=S){const Te=(te+ke)/m;if(Te<0||Te>=c.outWidth||Math.floor(Te)!==Te)continue;const $e=_.get(P,ee,de,Te,U);V+=$e}}}O.set(V*$,P,W,B,H,U)}return n.makeTensorInfo(O.shape,O.dtype,O.values)}const Wot={kernelName:UC,backendName:"cpu",kernelFunc:Uot};function Got(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;pt([r,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=a,c=Wo(i.shape,o,l,1,u),h=c.strideHeight,p=c.strideWidth,m=c.filterHeight,g=c.filterWidth,y=c.dilationHeight,b=c.dilationWidth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,S=w-1-c.padInfo.left,k=v-1-c.padInfo.top,I=Gt(i.shape,"float32"),T=1/(m*g),E=n.data.get(r.dataId).values,R=Gt(r.shape,"float32",E);for(let D=0;D<c.batchSize;++D)for(let O=0;O<c.inChannels;++O)for(let $=0;$<c.inHeight;++$)for(let _=0;_<c.inWidth;++_){const P=$-k,U=_-S;let W=0;for(let B=0;B<v;B+=y){const H=(P+B)/h;if(!(H<0||H>=c.outHeight||Math.floor(H)!==H))for(let j=0;j<w;j+=b){const Z=(U+j)/p;if(Z<0||Z>=c.outWidth||Math.floor(Z)!==Z)continue;const te=R.get(D,H,Z,O);W+=te}}I.set(W*T,D,$,_,O)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const Hot={kernelName:VC,backendName:"cpu",kernelFunc:Got};function jot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:i,mean:o,variance:l}=t;q(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),pt([r,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=a;u==null&&(u=.001);const c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,p=n.data.get(l.dataId).values,m=s?n.data.get(s.dataId).values:new Float32Array([1]),g=i?n.data.get(i.dataId).values:new Float32Array([0]),y=new Float32Array(c.length),b=g.length,v=m.length,w=p.length,S=h.length;let k=0,I=0,T=0,E=0;for(let R=0;R<c.length;++R)y[R]=g[k++]+(c[R]-h[I++])*m[T++]/Math.sqrt(p[E++]+u),k>=b&&(k=0),I>=S&&(I=0),T>=v&&(T=0),E>=w&&(E=0);return n.makeTensorInfo(r.shape,r.dtype,y)}const qot={kernelName:cA,backendName:"cpu",kernelFunc:jot};function Kot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;pt([r],"batchToSpaceND");const o=s.reduce((v,w)=>v*w),l=fS(r.shape,s,o),u=mS(l.length,s.length),c=gS(r.shape,s,o),h=AP(i,s.length),p=SP(c,i,s.length),m=la({inputs:{x:r},backend:n,attrs:{shape:l}}),g=si({inputs:{x:m},backend:n,attrs:{perm:u}}),y=la({inputs:{x:g},backend:n,attrs:{shape:c}}),b=nf({inputs:{x:y},backend:n,attrs:{begin:h,size:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}const Xot={kernelName:Z1,backendName:"cpu",kernelFunc:Kot};function Yot(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=c4(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}const Qot={kernelName:WC,backendName:"cpu",kernelFunc:Yot};function Zot(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=Mt(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Jot={kernelName:GC,backendName:"cpu",kernelFunc:Zot};const elt=On(wx,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),tlt={kernelName:wx,backendName:"cpu",kernelFunc:elt};const nlt=e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(_e(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const c=o[u],h=l[u];a[u]=Math.hypot(c,h)}return n.makeOutput(a,t.shape,"float32")},alt={kernelName:eA,backendName:"cpu",kernelFunc:nlt};function My(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const rlt={kernelName:cT,backendName:"cpu",kernelFunc:My};function Ly(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=Zt(r,t[0].shape)[0],i=t.map(y=>y.shape);xP(i,s);let o=Ql(t.map(y=>y.shape),s);if(_e(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(y=>_e(y.shape)>0);if(l.length===1)return uu({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const y=l.map(k=>tf({inputs:{input:k},backend:n})),b=l.map(k=>My({inputs:{input:k},backend:n})),v=Ly({inputs:y,backend:n,attrs:{axis:s}}),w=Ly({inputs:b,backend:n,attrs:{axis:s}}),S=ki({inputs:{real:v,imag:w},backend:n});return y.forEach(k=>n.disposeIntermediateTensorInfo(k)),b.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),S}const u=l.map(y=>{const v=[-1,_e(y.shape.slice(s))];return la({inputs:{x:y},backend:n,attrs:{shape:v}})}),c=u.map(y=>({vals:n.data.get(y.dataId).values,shape:y.shape}));o=Ql(u.map(y=>y.shape),1);const h=u[0].shape[0]===1,p=Jre(c,o,t[0].dtype,h),m=Ql(l.map(y=>y.shape),s),g=n.makeTensorInfo(m,t[0].dtype,p);return u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const slt={kernelName:tA,backendName:"cpu",kernelFunc:Ly};function Xse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=a;pt([r,s],"conv2d");const h=bc(l),p=Br(r.shape,s.shape,i,u,o,c,!1,h),m=p.filterHeight,g=p.filterWidth,y=p.dilationHeight,b=p.dilationWidth,v=p.padInfo.left,w=p.padInfo.top,S=p.dataFormat==="channelsLast",k=new er(p.outShape,r.dtype),I=St(r.shape),T=St(s.shape),E=I[0],R=S?I[1]:I[2],D=S?I[2]:1,O=S?1:I[1],$=k.strides[0],_=S?k.strides[1]:k.strides[2],P=S?k.strides[2]:1,U=S?1:k.strides[1],W=n.data.get(r.dataId).values,B=n.data.get(s.dataId).values,H=k.values;for(let j=0;j<p.batchSize;++j){const Z=j*E,te=j*$;for(let V=0;V<p.outHeight;++V){const Q=te+V*_,ee=V*p.strideHeight-w;for(let ae=0;ae<m;++ae){const de=ee+ae*y;if(de<0||de>=p.inHeight)continue;const ke=ae*T[0],Te=Z+de*R;for(let $e=0;$e<p.outWidth;++$e){const Le=Q+$e*P,Ge=$e*p.strideWidth-v;for(let Ke=0;Ke<g;++Ke){const at=Ge+Ke*b;if(at<0||at>=p.inWidth)continue;const vt=ke+Ke*T[1],ot=Te+at*D;let lt=vt;for(let tt=0;tt<p.inChannels;++tt){const wt=W[ot+tt*O];for(let It=0;It<p.outChannels;++It)H[Le+It*U]+=wt*B[lt+It];lt+=p.outChannels}}}}}}return n.makeTensorInfo(k.shape,k.dtype,H)}const ilt={kernelName:nA,backendName:"cpu",kernelFunc:Xse};function olt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=a;pt([r,s],"conv2dBackpropFilter");const h=bc(l),p=Br(r.shape,c,i,1,o,u,!1,h),{strideHeight:m,strideWidth:g,filterHeight:y,filterWidth:b}=p,v=p.dataFormat==="channelsLast",w=new er(p.filterShape,"float32"),S=p.padInfo.left,k=p.padInfo.top,I=n.data.get(r.dataId).values,T=n.data.get(s.dataId).values,E=new er(r.shape,r.dtype,I),R=new er(s.shape,s.dtype,T);for(let D=0;D<y;++D){const O=Math.max(0,Math.ceil((k-D)/m)),$=Math.min(p.outHeight,(p.inHeight+k-D)/m);for(let _=0;_<b;++_){const P=Math.max(0,Math.ceil((S-_)/g)),U=Math.min(p.outWidth,(p.inWidth+S-_)/g);for(let W=0;W<p.inChannels;++W)for(let B=0;B<p.outChannels;++B){let H=0;for(let j=0;j<p.batchSize;++j)for(let Z=O;Z<$;++Z){const te=D+Z*m-k;for(let V=P;V<U;++V){const Q=_+V*g-S;v?H+=E.get(j,te,Q,W)*R.get(j,Z,V,B):H+=E.get(j,W,te,Q)*R.get(j,B,Z,V)}}w.set(H,D,_,W,B)}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const llt={kernelName:jC,backendName:"cpu",kernelFunc:olt};function ult(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=a;pt([r,s],"conv2dBackpropInput");const h=St(s.shape),p=St(r.shape);let m=bc(u);const g=Br(i,s.shape,o,1,l,c,!1,m),y=new er(g.inShape,"float32"),b=y.values,v=n.data.get(r.dataId).values,w=n.data.get(s.dataId).values,[S,k,I]=h,{batchSize:T,filterHeight:E,filterWidth:R,inChannels:D,inHeight:O,inWidth:$,outChannels:_,outHeight:P,outWidth:U,strideHeight:W,strideWidth:B}=g;m=g.dataFormat;const H=E-1-g.padInfo.top,j=R-1-g.padInfo.left,Z=m==="channelsLast",te=y.strides[0],V=Z?y.strides[1]:y.strides[2],Q=Z?y.strides[2]:1,ee=Z?1:y.strides[1],ae=p[0],de=Z?p[1]:p[2],ke=Z?p[2]:1,Te=Z?1:p[1];for(let $e=0;$e<T;++$e)for(let Le=0;Le<D;++Le)for(let Ge=0;Ge<O;++Ge){const Ke=Ge-H,at=Math.max(0,Math.ceil(Ke/W)),vt=Math.min(P,(E+Ke)/W);for(let ot=0;ot<$;++ot){const lt=ot-j,tt=Math.max(0,Math.ceil(lt/B)),wt=Math.min(U,(R+lt)/B);let It=0;for(let Dt=at;Dt<vt;++Dt){const qn=Dt*W-Ke;for(let yn=tt;yn<wt;++yn){const ca=yn*B-lt,nn=ae*$e+de*Dt+ke*yn,ua=S*(E-1-qn)+k*(R-1-ca)+I*Le;for(let ea=0;ea<_;++ea){const Cn=v[nn+Te*ea],ta=w[ua+ea];It+=Cn*ta}}}const jn=te*$e+V*Ge+Q*ot+ee*Le;b[jn]=It}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const clt={kernelName:aA,backendName:"cpu",kernelFunc:ult};function hlt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;pt([r,s],"conv3d");const u=pd(r.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:h,filterWidth:p,dilationDepth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=u,v=b.front,w=b.left,S=b.top,k=new er(u.outShape,r.dtype),I=n.data.get(r.dataId).values,T=n.data.get(s.dataId).values,E=k.values,R=St(r.shape),D=St(s.shape);for(let O=0;O<u.batchSize;++O){const $=O*R[0],_=O*k.strides[0];for(let P=0;P<u.outDepth;++P){const U=_+P*k.strides[1],W=P*u.strideDepth-v;for(let B=0;B<c;++B){const H=W+B*m;if(H<0||H>=u.inDepth)continue;const j=B*D[0],Z=$+H*R[1];for(let te=0;te<u.outHeight;++te){const V=U+te*k.strides[2],Q=te*u.strideHeight-S;for(let ee=0;ee<h;++ee){const ae=Q+ee*g;if(ae<0||ae>=u.inHeight)continue;const de=j+ee*D[1],ke=Z+ae*R[2];for(let Te=0;Te<u.outWidth;++Te){const $e=V+Te*u.outChannels,Le=Te*u.strideWidth-w;for(let Ge=0;Ge<p;++Ge){const Ke=Le+Ge*y;if(Ke<0||Ke>=u.inWidth)continue;const at=de+Ge*D[2],vt=ke+Ke*u.inChannels;let ot=at;for(let lt=0;lt<u.inChannels;++lt){const tt=I[vt+lt];for(let wt=0;wt<u.outChannels;++wt)E[$e+wt]+=tt*T[ot+wt];ot+=u.outChannels}}}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const dlt={kernelName:rA,backendName:"cpu",kernelFunc:hlt};function plt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;pt([r,s],"conv3dBackpropFilterV2");const u=St(r.shape),c=St(s.shape),h=pd(r.shape,l,i,1,o),p=h.strideDepth,m=h.strideHeight,g=h.strideWidth,y=h.filterDepth,b=h.filterHeight,v=h.filterWidth,w=new er(h.filterShape,"float32"),S=w.values,[k,I,T,E]=w.strides,R=n.data.get(s.dataId).values,[D,O,$,_]=c,P=n.data.get(r.dataId).values,[U,W,B,H]=u,j=h.padInfo.front,Z=h.padInfo.left,te=h.padInfo.top;for(let V=0;V<y;++V){const Q=Math.max(0,Math.ceil((j-V)/p)),ee=Math.min(h.outDepth,(h.inDepth+j-V)/p),ae=V*k;for(let de=0;de<b;++de){const ke=Math.max(0,Math.ceil((te-de)/m)),Te=Math.min(h.outHeight,(h.inHeight+te-de)/m),$e=de*I+ae;for(let Le=0;Le<v;++Le){const Ge=Math.max(0,Math.ceil((Z-Le)/g)),Ke=Math.min(h.outWidth,(h.inWidth+Z-Le)/g),at=Le*T+$e;for(let vt=0;vt<h.inChannels;++vt){const ot=vt*E+at;for(let lt=0;lt<h.outChannels;++lt){let tt=0;for(let wt=0;wt<h.batchSize;++wt){const It=wt*U,jn=wt*D;for(let Dt=Q;Dt<ee;++Dt){const yn=(V+Dt*p-j)*W+It,ca=Dt*O+jn;for(let nn=ke;nn<Te;++nn){const ea=(de+nn*m-te)*B+yn,Cn=nn*$+ca;for(let ta=Ge;ta<Ke;++ta){const po=(Le+ta*g-Z)*H+ea,Bs=ta*_+Cn;tt+=P[po+vt]*R[Bs+lt]}}}}S[ot+lt]=tt}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const flt={kernelName:qC,backendName:"cpu",kernelFunc:plt};function mlt(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;pt([r],"conv3dBackpropInputV2");const u=St(r.shape),c=St(s.shape),h=pd(l,s.shape,o,1,i),p=new er(h.inShape,"float32"),m=p.values,[g,y,b,v]=p.strides,w=n.data.get(r.dataId).values,[S,k,I,T]=u,E=n.data.get(s.dataId).values,[R,D,O,$]=c,{batchSize:_,filterDepth:P,filterHeight:U,filterWidth:W,inChannels:B,inDepth:H,inHeight:j,inWidth:Z,outChannels:te,outDepth:V,outHeight:Q,outWidth:ee,strideDepth:ae,strideHeight:de,strideWidth:ke}=h,Te=P-1-h.padInfo.front,$e=U-1-h.padInfo.top,Le=W-1-h.padInfo.left;for(let Ge=0;Ge<_;++Ge)for(let Ke=0;Ke<B;++Ke)for(let at=0;at<H;++at){const vt=at-Te,ot=Math.max(0,Math.ceil(vt/ae)),lt=Math.min(V,(P+vt)/ae);for(let tt=0;tt<j;++tt){const wt=tt-$e,It=Math.max(0,Math.ceil(wt/de)),jn=Math.min(Q,(U+wt)/de);for(let Dt=0;Dt<Z;++Dt){const qn=Dt-Le,yn=Math.max(0,Math.ceil(qn/ke)),ca=Math.min(ee,(W+qn)/ke);let nn=0;for(let ua=ot;ua<lt;++ua){const ea=ua*ae-vt;for(let Cn=It;Cn<jn;++Cn){const ta=Cn*de-wt;for(let ys=yn;ys<ca;++ys){const po=ys*ke-qn,Bs=S*Ge+k*ua+I*Cn+T*ys,yu=R*(P-1-ea)+D*(U-1-ta)+O*(W-1-po)+$*Ke;for(let Ha=0;Ha<te;++Ha){const ba=w[Bs+Ha],Fn=E[yu+Ha];nn+=ba*Fn}}}}m[g*Ge+y*at+b*tt+v*Dt+Ke]=nn}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}const glt={kernelName:KC,backendName:"cpu",kernelFunc:mlt};const ylt=On(Ax,e=>Math.cos(e)),blt={kernelName:Ax,backendName:"cpu",kernelFunc:ylt};const xlt=On(Sx,e=>Math.cosh(e)),vlt={kernelName:Sx,backendName:"cpu",kernelFunc:xlt};function wlt(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,[c,h,p,m]=r.shape,g=s.shape[0],[y,b]=o,v=Gt([g,y,b,m],"float32"),w=n.data.get(s.dataId).values,S=n.data.get(i.dataId).values,k=n.data.get(r.dataId).values,I=St(r.shape),T=St(v.shape);for(let E=0;E<g;E++){const R=E*4,D=w[R],O=w[R+1],$=w[R+2],_=w[R+3],P=S[E];if(P>=c)continue;const U=y>1?($-D)*(h-1)/(y-1):0,W=b>1?(_-O)*(p-1)/(b-1):0;for(let B=0;B<y;B++){const H=y>1?D*(h-1)+B*U:.5*(D+$)*(h-1);if(H<0||H>h-1){for(let j=0;j<b;j++)for(let Z=0;Z<m;Z++){const te=Z+j*T[2]+B*T[1]+E*T[0];v.values[te]=u}continue}if(l==="bilinear"){const j=Math.floor(H),Z=Math.ceil(H),te=H-j;for(let V=0;V<b;V++){const Q=b>1?O*(p-1)+V*W:.5*(O+_)*(p-1);if(Q<0||Q>p-1){for(let ke=0;ke<m;ke++){const Te=ke+V*T[2]+B*T[1]+E*T[0];v.values[Te]=u}continue}const ee=Math.floor(Q),ae=Math.ceil(Q),de=Q-ee;for(let ke=0;ke<m;ke++){let Te=ke+ee*I[2]+j*I[1]+P*I[0];const $e=k[Te];Te=ke+ae*I[2]+j*I[1]+P*I[0];const Le=k[Te];Te=ke+ee*I[2]+Z*I[1]+P*I[0];const Ge=k[Te];Te=ke+ae*I[2]+Z*I[1]+P*I[0];const Ke=k[Te],at=$e+(Le-$e)*de,vt=Ge+(Ke-Ge)*de;Te=ke+V*T[2]+B*T[1]+E*T[0],v.values[Te]=at+(vt-at)*te}}}else for(let j=0;j<b;++j){const Z=b>1?O*(p-1)+j*W:.5*(O+_)*(p-1);if(Z<0||Z>p-1){for(let Q=0;Q<m;Q++){const ee=Q+j*T[2]+B*T[1]+E*T[0];v.values[ee]=u}continue}const te=Math.round(Z),V=Math.round(H);for(let Q=0;Q<m;Q++){const ee=Q+te*I[2]+V*I[1]+P*I[0],ae=Q+j*T[2]+B*T[1]+E*T[0];v.values[ae]=k[ee]}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const Alt={kernelName:YC,backendName:"cpu",kernelFunc:wlt};function Slt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;pt(r,"cumprod");const l=$a([s],r.shape.length);let u=r;l!=null&&(u=si({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=Ua(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=ei(u.dtype,"int32"),p=zC(_e(u.shape),h),m=n.data.get(u.dataId).values,g=u.shape[u.shape.length-1],y=o?(v,w)=>v+g-w-1:(v,w)=>v+w;for(let v=0;v<m.length;v+=g)for(let w=0;w<g;w++){const S=y(v,w);if(w===0)p[S]=i?1:m[S];else{const k=y(v,w-1);p[S]=i?m[k]*p[k]:m[S]*p[k]}}const b=n.makeTensorInfo(u.shape,h,p);if(l!=null){const v=fd(l),w=si({inputs:{x:b},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(u),w}return b}const klt={kernelName:XC,backendName:"cpu",kernelFunc:Slt};function Ilt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;pt(r,"cumsum");const l=$a([s],r.shape.length);let u=r;l!=null&&(u=si({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=Ua(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=ei(u.dtype,"int32"),p=Yr(_e(u.shape),h),m=n.data.get(u.dataId).values,g=u.shape[u.shape.length-1],y=o?(v,w)=>v+g-w-1:(v,w)=>v+w;for(let v=0;v<m.length;v+=g)for(let w=0;w<g;w++){const S=y(v,w);if(w===0)p[S]=i?0:m[S];else{const k=y(v,w-1);p[S]=i?m[k]+p[k]:m[S]+p[k]}}const b=n.makeTensorInfo(u.shape,h,p);if(l!=null){const v=fd(l),w=si({inputs:{x:b},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(u),w}return b}const Nlt={kernelName:sA,backendName:"cpu",kernelFunc:Ilt};function Clt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){const l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=c4(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){const l=n.bufferSync(r),u=n.bufferSync(s),c=Yre(l,u,i,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Tlt={kernelName:QC,backendName:"cpu",kernelFunc:Clt};function Elt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a;q(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*s,p=u*s,m=c/(s*s),g=n.data.get(r.dataId).values,y=new Float32Array(o*h*p*m);let b=0;for(let v=0;v<o;++v)for(let w=0;w<h;++w){const S=Math.floor(w/s),k=w%s;for(let I=0;I<p;++I){const T=Math.floor(I/s),E=I%s,R=(k*s+E)*m;for(let D=0;D<m;++D){const $=D+R+c*(T+u*(S+l*v));y[b++]=g[$]}}}return n.makeTensorInfo([o,h,p,m],r.dtype,y)}const $lt={kernelName:ZC,backendName:"cpu",kernelFunc:Elt};function Yse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a;pt([r,s],"depthwiseConv2DNative");const c=St(r.shape),h=St(s.shape);let p=l;p==null&&(p=[1,1]),q(Jr(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);const m=Br(r.shape,s.shape,i,p,o,u,!0),{filterHeight:g,filterWidth:y,dilationHeight:b,dilationWidth:v,padInfo:w}=m,S=w.left,k=w.top,I=m.outChannels/m.inChannels,T=new er(m.outShape,r.dtype),E=n.data.get(r.dataId).values,R=n.data.get(s.dataId).values,D=T.values;for(let O=0;O<m.batchSize;++O){const $=O*c[0],_=O*T.strides[0];for(let P=0;P<m.outHeight;++P){const U=_+P*T.strides[1],W=P*m.strideHeight-k;for(let B=0;B<g;++B){const H=W+B*b;if(H<0||H>=m.inHeight)continue;const j=B*h[0],Z=$+H*c[1];for(let te=0;te<m.outWidth;++te){const V=U+te*T.strides[2],Q=te*m.strideWidth-S;for(let ee=0;ee<y;++ee){const ae=Q+ee*v;if(ae<0||ae>=m.inWidth)continue;const de=j+ee*h[1],ke=Z+ae*m.inChannels;let Te=V,$e=de;for(let Le=0;Le<m.inChannels;++Le){const Ge=E[ke+Le];for(let Ke=0;Ke<I;++Ke)D[Te+Ke]+=Ge*R[$e+Ke];Te+=I,$e+=I}}}}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const _lt={kernelName:iA,backendName:"cpu",kernelFunc:Yse};function Rlt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=a;pt([r,s],"depthwiseConv2dNativeBackpropFilter");const h=Br(r.shape,c,i,o,l,u,!0),{strideHeight:p,strideWidth:m,filterHeight:g,filterWidth:y}=h,b=new er(h.filterShape,"float32"),v=h.padInfo.left,w=h.padInfo.top,S=h.outChannels/h.inChannels,k=n.data.get(r.dataId).values,I=new er(r.shape,r.dtype,k),T=n.data.get(s.dataId).values,E=new er(s.shape,s.dtype,T);for(let R=0;R<g;++R){const D=Math.max(0,Math.ceil((w-R)/p)),O=Math.min(h.outHeight,(h.inHeight+w-R)/p);for(let $=0;$<y;++$){const _=Math.max(0,Math.ceil((v-$)/m)),P=Math.min(h.outWidth,(h.inWidth+v-$)/m);for(let U=0;U<h.outChannels;++U){const W=Math.trunc(U/S),B=U%S;let H=0;for(let j=0;j<h.batchSize;++j)for(let Z=D;Z<O;++Z){const te=R+Z*p-w;for(let V=_;V<P;++V){const Q=$+V*m-v;H+=I.get(j,te,Q,W)*E.get(j,Z,V,U)}}b.set(H,R,$,W,B)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const Dlt={kernelName:JC,backendName:"cpu",kernelFunc:Rlt};function Olt(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=a;pt([r,s],"depthwiseConv2DNativeBackpropInput");const h=St(r.shape),p=St(s.shape),m=Br(c,s.shape,i,o,l,u,!0),g=new er(m.inShape,"float32"),y=g.values,[b,v,w]=g.strides,S=n.data.get(r.dataId).values,[k,I,T]=h,E=n.data.get(s.dataId).values,[R,D,O]=p,{batchSize:$,filterHeight:_,filterWidth:P,inChannels:U,inHeight:W,inWidth:B,outChannels:H,outHeight:j,outWidth:Z,strideHeight:te,strideWidth:V}=m,Q=_-1-m.padInfo.top,ee=P-1-m.padInfo.left,ae=H/U;for(let de=0;de<$;++de)for(let ke=0;ke<U;++ke)for(let Te=0;Te<W;++Te){const $e=Te-Q,Le=Math.max(0,Math.ceil($e/te)),Ge=Math.min(j,(_+$e)/te);for(let Ke=0;Ke<B;++Ke){const at=Ke-ee,vt=Math.max(0,Math.ceil(at/V)),ot=Math.min(Z,(P+at)/V);let lt=0;for(let tt=Le;tt<Ge;++tt){const wt=tt*te-$e;for(let It=vt;It<ot;++It){const jn=It*V-at,Dt=k*de+I*tt+T*It,qn=R*(_-1-wt)+D*(P-1-jn)+O*ke;for(let yn=0;yn<ae;++yn){const ca=ke*ae+yn,nn=S[Dt+ca],ua=E[qn+yn];lt+=nn*ua}}}y[b*de+v*Te+w*Ke+ke]=lt}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const Flt={kernelName:eT,backendName:"cpu",kernelFunc:Olt};function Mlt(e){const{inputs:t,backend:n}=e,{x:a}=t,r=_e(a.shape),s=n.data.get(a.dataId).values,i=Gt([r,r],a.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*r+u]=s[u];const l=[...a.shape,...a.shape];return n.makeTensorInfo(l,i.dtype,i.values)}const Llt={kernelName:tT,backendName:"cpu",kernelFunc:Mlt};const zlt={kernelName:oA,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(a.dataId).values,c=a.shape.length,h=l.data.get(r.dataId).values,p=r.shape.length,{batchSize:m,inHeight:g,inWidth:y,inChannels:b,outHeight:v,outWidth:w,padInfo:S,strideHeight:k,strideWidth:I,filterHeight:T,filterWidth:E,dilationHeight:R,dilationWidth:D,outShape:O}=YA(a.shape,r.shape,s,i,"NHWC",o),$=_e(O),_=O.length,P=_a(a.dtype,$);for(let W=0;W<m;++W)for(let B=0;B<v;++B){const H=B*k-S.top;for(let j=0;j<w;++j){const Z=j*I-S.left;for(let te=0;te<b;++te){let V=Number.MIN_SAFE_INTEGER;for(let ee=0;ee<T;++ee){const ae=H+ee*R;if(ae>=0&&ae<g)for(let de=0;de<E;++de){const ke=Z+de*D;if(ke>=0&&ke<y){const Te=ul([W,ae,ke,te],c,St(a.shape)),$e=ul([ee,de,te],p,St(r.shape)),Le=u[Te]+h[$e];Le>V&&(V=Le)}}}const Q=ul([W,B,j,te],_,St(O));P[Q]=V}}}return{dataId:l.write(hd(P,a.dtype),O,a.dtype),shape:O,dtype:a.dtype}}};const Blt={kernelName:$N,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=no(a.shape,u.data.get(a.dataId).values),h=no(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:w,strideHeight:S,strideWidth:k,filterHeight:I,filterWidth:T,dilationHeight:E,dilationWidth:R,outShape:D}=YA(a.shape,r.shape,i,o,"NHWC",l);q(s.rank===D.length,()=>`Error in ${$N}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);const O=no(D,u.data.get(s.dataId).values),$=Pz(r.shape,r.dtype);for(let P=0;P<p;++P)for(let U=0;U<b;++U){const W=U*S-w.top;for(let B=0;B<v;++B){const H=B*k-w.left;for(let j=0;j<y;++j){let Z=Number.MIN_SAFE_INTEGER,te=0,V=0;for(let Q=0;Q<I;++Q){const ee=W+Q*E;if(ee>=0&&ee<m)for(let ae=0;ae<T;++ae){const de=H+ae*R;if(de>=0&&de<g){const ke=c[P][ee][de][j]+h[Q][ae][j];ke>Z&&(Z=ke,te=Q,V=ae)}}}$[te][V][j]+=O[P][U][B][j]}}}return{dataId:u.write(hd($,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const Plt={kernelName:EN,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=no(a.shape,u.data.get(a.dataId).values),h=no(r.shape,u.data.get(r.dataId).values),{batchSize:p,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:w,strideHeight:S,strideWidth:k,filterHeight:I,filterWidth:T,dilationHeight:E,dilationWidth:R,outShape:D}=YA(a.shape,r.shape,i,o,"NHWC",l);q(s.rank===D.length,()=>`Error in ${EN}, dy must have the same rank as output ${D.length}, but got ${s.rank}`);const O=no(D,u.data.get(s.dataId).values),$=Pz(a.shape,a.dtype);for(let P=0;P<p;++P)for(let U=0;U<b;++U){const W=U*S-w.top;for(let B=0;B<v;++B){const H=B*k-w.left;for(let j=0;j<y;++j){let Z=Number.MIN_SAFE_INTEGER,te=W<0?0:W,V=H<0?0:H;for(let Q=0;Q<I;++Q){const ee=W+Q*E;if(ee>=0&&ee<m)for(let ae=0;ae<T;++ae){const de=H+ae*R;if(de>=0&&de<g){const ke=c[P][ee][de][j]+h[Q][ae][j];ke>Z&&(Z=ke,te=ee,V=de)}}}$[P][te][V][j]+=O[P][U][B][j]}}}return{dataId:u.write(hd($,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function Vlt(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:i}=a,{contextOptions:o,imageOptions:l}=i||{},u=l?.alpha||1,c=o?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=s.getContext(c,o?.contextAttributes||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[p,m]=r.shape.slice(0,2),g=r.shape.length===2?1:r.shape[2],y=n.data.get(r.dataId).values,b=r.dtype==="float32"?255:1,v=new Uint8ClampedArray(m*p*4);for(let S=0;S<p*m;++S){const k=[0,0,0,255*u];for(let T=0;T<g;T++){const E=y[S*g+T];if(r.dtype==="float32"){if(E<0||E>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${E}.`)}else if(r.dtype==="int32"&&(E<0||E>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${E}.`);g===1?(k[0]=E*b,k[1]=E*b,k[2]=E*b):k[T]=E*b}const I=S*4;v[I+0]=Math.round(k[0]),v[I+1]=Math.round(k[1]),v[I+2]=Math.round(k[2]),v[I+3]=Math.round(k[3])}s.width=m,s.height=p;const w=new ImageData(v,m,p);return h.putImageData(w,0,0),r}const Ult={kernelName:nT,backendName:"cpu",kernelFunc:Vlt};function IS(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;pt(r,"sum");let o;r.dtype==="bool"?o=qh({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):o=uu({inputs:{x:r},backend:n});const l=o.shape.length,u=Zt(s,o.shape),c=$a(u,l);let h=u,p=o;c!=null&&(p=si({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Ua(h.length,l)),es("sum",h,p.shape.length);const[m,g]=Pr(p.shape,h),y=ei(p.dtype,"int32");let b=qN(n,m,y);const v=_e(g),w=n.data.get(b.dataId).values,S=n.data.get(p.dataId).values;for(let k=0;k<w.length;++k){const I=k*v;let T=0;for(let E=0;E<v;++E)T+=S[I+E];w[k]=T}if(i){const k=Ba(b.shape,u),I=b;b=la({inputs:{x:b},backend:n,attrs:{shape:k}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(p),b}const Wlt={kernelName:PA,backendName:"cpu",kernelFunc:IS};function Glt(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=_P(r,s.length);DP(i.length,l,s);const{path:u,steps:c}=OP(o,l),h=c.length;let p=null,m=i.length;const g=[];for(let y=0;y<h;++y){for(const b of c[y]){const{permutationIndices:v,expandDims:w}=RP(m,l[b]);let S;FP(v)?S=s[b]:(S=si({inputs:{x:s[b]},backend:n,attrs:{perm:v}}),g.push(S));const k=S.shape.slice();for(let I=0;I<w.length;++I)k.splice(w[I],0,1);tn(S.shape,k)||(S=la({inputs:{x:S},backend:n,attrs:{shape:k}}),g.push(S)),p===null?p=S:(p=HE({inputs:{a:S,b:p},backend:n}),g.push(p))}y<h-1&&(u[y]>=0&&(p=IS({inputs:{x:p},backend:n,attrs:{axis:u[y]-(i.length-m),keepDims:!1}}),g.push(p)),m--)}for(const y of g)y!==p&&n.disposeIntermediateTensorInfo(y);return p}const Hlt={kernelName:aT,backendName:"cpu",kernelFunc:Glt};function jlt(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;pt([a,r],"eluGrad");const s=new Float32Array(_e(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];u>=0?s[l]=o[l]:s[l]=o[l]*(u+1)}return n.makeTensorInfo(r.shape,"float32",s)}const qlt={kernelName:rT,backendName:"cpu",kernelFunc:jlt};const Klt=kP,Xlt=IP,Ylt=NP,Qlt=CP,Zlt=TP,Jlt=EP,eut=On(Nx,e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+Klt*n);return t*(1-((((Jlt*a+Zlt)*a+Qlt)*a+Ylt)*a+Xlt)*a*Math.exp(-n*n))}),tut={kernelName:Nx,backendName:"cpu",kernelFunc:eut};function YN(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice();let l=s;return s<0&&(q(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),la({inputs:{x:r},backend:n,attrs:{shape:o}})}const nut={kernelName:uA,backendName:"cpu",kernelFunc:YN};const aut=Ga((e,t)=>e/t),g4=wr(kx,aut),QO={kernelName:kx,backendName:"cpu",kernelFunc:g4};function Qse(e,t,n){const a=e.shape,r=a[0],s=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[r,s],c=_e(u),h=Mr("float32",c),p=Mr("float32",c);for(let b=0;b<r;b++){const v=nf({inputs:{x:o},backend:n,attrs:{begin:[b,0],size:[1,s]}}),w=nf({inputs:{x:l},backend:n,attrs:{begin:[b,0],size:[1,s]}}),S=ki({inputs:{real:v,imag:w},backend:n}),{real:k,imag:I}=rut(S,t,n),T=rc(k,I);for(let E=0;E<s;E++){const R=$P(T,E);h[b*s+E]=R.real,p[b*s+E]=R.imag}n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(S)}const m=n.makeTensorInfo(u,"float32",h),g=n.makeTensorInfo(u,"float32",p),y=ki({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}function rut(e,t,n){const a=_e(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(sut(a)){const o=ZO(s,i,a,t,n),l=[e.shape[0],e.shape[1]];if(t){const u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",gc(a,"float32")),p=uu({inputs:{x:h},backend:n}),m=QO.kernelFunc({inputs:{a:u,b:h},backend:n}),g=QO.kernelFunc({inputs:{a:c,b:p},backend:n}),y=n.data.get(m.dataId).values,b=n.data.get(g.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),{real:y,imag:b}}return o}else{const o=rc(s,i),l=iut(o,a,t);return ine(l)}}function sut(e){return(e&e-1)===0}function ZO(e,t,n,a,r){if(n===1)return{real:e,imag:t};const s=rc(e,t),i=n/2,o=one(s),l=o.real,u=o.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),p=r.makeTensorInfo(c,"float32",u),m=ki({inputs:{real:h,imag:p},backend:r}),g=lne(s),y=g.real,b=g.imag,v=[y.length],w=r.makeTensorInfo(v,"float32",y),S=r.makeTensorInfo(v,"float32",b),k=ki({inputs:{real:w,imag:S},backend:r}),I=ZO(l,u,i,a,r),T=I.real,E=I.imag,R=[T.length],D=r.makeTensorInfo(R,"float32",T),O=r.makeTensorInfo(R,"float32",E),$=ki({inputs:{real:D,imag:O},backend:r}),_=ZO(y,b,i,a,r),P=_.real,U=_.imag,W=[P.length],B=r.makeTensorInfo(W,"float32",P),H=r.makeTensorInfo(W,"float32",U),j=ki({inputs:{real:B,imag:H},backend:r}),Z=cne(n,a),te=[Z.real.length],V=r.makeTensorInfo(te,"float32",Z.real),Q=r.makeTensorInfo(te,"float32",Z.imag),ee=ki({inputs:{real:V,imag:Q},backend:r}),ae=HE({inputs:{a:ee,b:j},backend:r}),de=Fy({inputs:{a:$,b:ae},backend:r}),ke=f4({inputs:{a:$,b:ae},backend:r}),Te=tf({inputs:{input:de},backend:r}),$e=tf({inputs:{input:ke},backend:r}),Le=My({inputs:{input:de},backend:r}),Ge=My({inputs:{input:ke},backend:r}),Ke=Ly({inputs:[Te,$e],backend:r,attrs:{axis:0}}),at=Ly({inputs:[Le,Ge],backend:r,attrs:{axis:0}}),vt=r.data.get(Ke.dataId).values,ot=r.data.get(at.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(Ge),r.disposeIntermediateTensorInfo(Ke),r.disposeIntermediateTensorInfo(at),{real:vt,imag:ot}}function iut(e,t,n){const a=new Float32Array(t*2);for(let r=0;r<t;r++){let s=0,i=0;for(let o=0;o<t;o++){const l=hne(r*o,t,n),u=$P(e,o);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(s/=t,i/=t),une(a,s,i,r)}return a}function out(e){const{inputs:t,backend:n}=e,{input:a}=t,r=_e(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=la({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=Qse(o,!1,n),u=la({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const lut={kernelName:sT,backendName:"cpu",kernelFunc:out};function y4(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,i=s||zm(r),o=_a(i,_e(a));return cut(o,r,i),t.makeTensorInfo(a,i,o)}const uut={kernelName:iT,backendName:"cpu",kernelFunc:y4};function cut(e,t,n){e.fill(t)}const hut={kernelName:oT,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,r=n,s=Mr(a.dtype,_e(a.shape)),[i,o,l,u]=a.shape,c=r.data.get(a.dataId).values;for(let p=0;p<i;p++){const m=p*l*o*u;for(let g=0;g<o;g++){const y=g*(l*u);for(let b=0;b<l;b++){const v=b*u;for(let w=0;w<u;w++){const S=Math.round(l-b-1),k=m+y+v+w;let I=c[k];if(S>=0&&S<l){const T=S*u,E=m+y+T+w;I=c[E]}s[k]=I}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function dut(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=a;let y=Xse({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){const b=y;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const v=la({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});y=Fy({inputs:{a:y,b:v},backend:n}),n.disposeIntermediateTensorInfo(v)}else y=Fy({inputs:{a:y,b:i},backend:n});n.disposeIntermediateTensorInfo(b)}if(m){const b=y;if(c==="NCHW"&&m==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const v=la({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});y=XN(n,y,m,v,g),n.disposeIntermediateTensorInfo(v)}else y=XN(n,y,m,o,g);n.disposeIntermediateTensorInfo(b)}return y}const put={kernelName:xw,backendName:"cpu",kernelFunc:dut};function fut(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=a;let y=Yse({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p}});if(i){const b=y;y=Fy({inputs:{a:y,b:i},backend:n}),n.disposeIntermediateTensorInfo(b)}if(m){const b=y;y=XN(n,y,m,o,g),n.disposeIntermediateTensorInfo(b)}return y}const mut={kernelName:vw,backendName:"cpu",kernelFunc:fut};function gut(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=_e(a.shape),i=r.shape,o=i[i.length-1],[l,u,c,h]=EE(a,r);if(u===0)return n.makeTensorInfo(l,a.dtype,[]);const p=n.data.get(r.dataId).values,m=n.bufferSync(a),g=ose(p,m,a.dtype,u,o,c,h,a.shape,s);return n.makeTensorInfo(l,a.dtype,g.values)}const yut={kernelName:lT,backendName:"cpu",kernelFunc:gut};function but(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a;pt([r,s],"gatherV2");const l=Zt(i,r.shape)[0],u=n.data.get(s.dataId).values,c=r.shape[l];for(let k=0;k<u.length;++k){const I=u[k];q(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let h=o;o==null&&(h=0);const p=_e(s.shape),m=LP(r,s,l,h),g=la({inputs:{x:r},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),y=la({inputs:{x:s},backend:n,attrs:{shape:[m.batchSize,p/m.batchSize]}}),b=[m.batchSize,m.outerSize,p/m.batchSize,m.sliceSize],v=n.bufferSync(y),w=n.bufferSync(g),S=lse(w,v,b);return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.makeTensorInfo(m.outputShape,S.dtype,S.values)}const xut={kernelName:hA,backendName:"cpu",kernelFunc:but};function vut(e){const{inputs:t,backend:n}=e,{input:a}=t,r=_e(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=la({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=Qse(o,!0,n),u=la({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const wut={kernelName:uT,backendName:"cpu",kernelFunc:vut};const Aut=On(Dx,e=>Number.isFinite(e)?1:0,"bool"),Sut={kernelName:Dx,backendName:"cpu",kernelFunc:Aut};const kut=On(Ox,e=>Math.abs(e)===1/0?1:0,"bool"),Iut={kernelName:Ox,backendName:"cpu",kernelFunc:kut};const Nut=On(Fx,e=>Number.isNaN(e)?1:0,"bool"),Cut={kernelName:Fx,backendName:"cpu",kernelFunc:Nut};function Tut(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=pse(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}const Eut={kernelName:hT,backendName:"cpu",kernelFunc:Tut};const $ut=On(Lx,e=>Math.log1p(e)),_ut={kernelName:Lx,backendName:"cpu",kernelFunc:$ut};const Rut=Ga((e,t)=>e&&t),Dut=wr(gA,Rut,null,"bool"),Out={kernelName:gA,backendName:"cpu",kernelFunc:Dut};const Fut=On(yA,e=>e?0:1,"bool"),Mut={kernelName:yA,backendName:"cpu",kernelFunc:Fut};const Lut=Ga((e,t)=>e||t),zut=wr(bA,Lut,null,"bool"),But={kernelName:bA,backendName:"cpu",kernelFunc:zut};function Put(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;pt(r,"LRN");const u=r.shape[3],c=u-1,h=n.data.get(r.dataId).values,p=_e(r.shape),m=new Float32Array(p);function g(y){const b=y%u;let v=y-b+Math.max(0,b-s);const w=y-b+Math.min(b+s,c);let S=0;for(;v<=w;v++){const k=h[v];S+=k*k}return S}for(let y=0;y<p;y++){const b=g(y),v=h[y]*Math.pow(i+o*b,-l);m[y]=v}return n.makeTensorInfo(r.shape,r.dtype,m)}const Vut={kernelName:xA,backendName:"cpu",kernelFunc:Put};function Uut(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=a;pt(i,"LRNGrad");const h=_e(i.shape),p=i.shape[3],m=n.data.get(i.dataId).values,g=n.data.get(r.dataId).values,y=n.data.get(s.dataId).values,b=new Float32Array(h),v=h;for(let w=0;w<v;w++){const S=w%p,k=w-S+Math.max(0,S-o),I=w-S+Math.min(p,S+o+1);let T=0;for(let E=k;E<I;E++)T+=Math.pow(g[E],2);T=u*T+l;for(let E=k;E<I;E++){let R=-2*u*c*g[E]*y[w]/T;w===E&&(R+=Math.pow(T,-c)),R*=m[w],b[E]+=R}}return n.makeTensorInfo(i.shape,r.dtype,b)}const Wut={kernelName:dT,backendName:"cpu",kernelFunc:Uut};function Zse(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=n;let l=r.shape;const u=l.length,c=Zt(s,l);let h=c;const p=$a(h,u);let m=o.data.get(r.dataId).values;if(p!=null){const k=new Array(u);for(let I=0;I<k.length;I++)k[I]=l[p[I]];m=d4(m,l,r.dtype,p,k),h=Ua(h.length,u),l=k}pt(r,"max"),es("max",h,u);const[g,y]=Pr(l,h),b=_e(y),v=mse(m,b,g,r.dtype),w=o.write(v,g,r.dtype);let S=g;return i&&(S=Ba(g,c)),{dataId:w,shape:S,dtype:r.dtype}}const Gut={kernelName:vA,backendName:"cpu",kernelFunc:Zse};function Hut(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;pt(r,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;q(Jr(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Wo(r.shape,s,i,u,o,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&tn(c.inShape,c.outShape))h=uu({inputs:{x:r},backend:n});else{const p=n.data.get(r.dataId).values,m=St(r.shape),g=m4(p,r.shape,r.dtype,m,c,"max");h=n.makeTensorInfo(c.outShape,r.dtype,g.values)}return h}const jut={kernelName:wA,backendName:"cpu",kernelFunc:Hut};function qut(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;pt(r,"maxPool3d");const c=yc(r.shape,s,i,1,o,l,u),h=n.data.get(r.dataId).values,p=Kse(h,r.shape,r.dtype,St(r.shape),c,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}const Kut={kernelName:AA,backendName:"cpu",kernelFunc:qut};function Xut(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;pt([r,s],"maxPool3DGrad");const c=yc(s.shape,i,o,1,l,u),h=n.bufferSync(s),p=Lot(h,c),m=c.strideDepth,g=c.strideHeight,y=c.strideWidth,b=c.dilationDepth,v=c.dilationHeight,w=c.dilationWidth,S=c.effectiveFilterDepth,k=c.effectiveFilterHeight,I=c.effectiveFilterWidth,T=S-1-c.padInfo.front,E=I-1-c.padInfo.left,R=k-1-c.padInfo.top,D=Gt(s.shape,"float32"),O=n.bufferSync(r);for(let $=0;$<c.batchSize;++$)for(let _=0;_<c.inChannels;++_)for(let P=0;P<c.inDepth;++P)for(let U=0;U<c.inHeight;++U)for(let W=0;W<c.inWidth;++W){const B=P-T,H=U-R,j=W-E;let Z=0;for(let te=0;te<S;te+=b){const V=(B+te)/m;if(!(V<0||V>=c.outDepth||Math.floor(V)!==V))for(let Q=0;Q<k;Q+=v){const ee=(H+Q)/g;if(!(ee<0||ee>=c.outHeight||Math.floor(ee)!==ee))for(let ae=0;ae<I;ae+=w){const de=(j+ae)/y;if(de<0||de>=c.outWidth||Math.floor(de)!==de)continue;const ke=S*k*I-1-p.get($,V,ee,de,_),Te=te*k*I+Q*I+ae,$e=ke===Te?1:0;if($e===0)continue;const Le=O.get($,V,ee,de,_);Z+=Le*$e}}}D.set(Z,$,P,U,W,_)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}const Yut={kernelName:fT,backendName:"cpu",kernelFunc:Xut};function Qut(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;pt([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=a,p=Wo(o.shape,l,u,1,c,h),m=n.data.get(o.dataId).values,g=Gt(p.outShape,o.dtype,qse(m,o.shape,o.dtype,p).values),y=p.strideHeight,b=p.strideWidth,v=p.dilationHeight,w=p.dilationWidth,S=p.effectiveFilterHeight,k=p.effectiveFilterWidth,I=k-1-p.padInfo.left,T=S-1-p.padInfo.top,E=Gt(o.shape,"float32"),R=n.data.get(r.dataId).values,D=Gt(r.shape,"float32",R);for(let O=0;O<p.batchSize;++O)for(let $=0;$<p.inChannels;++$)for(let _=0;_<p.inHeight;++_)for(let P=0;P<p.inWidth;++P){const U=_-T,W=P-I;let B=0;for(let H=0;H<S;H+=v){const j=(U+H)/y;if(!(j<0||j>=p.outHeight||Math.floor(j)!==j))for(let Z=0;Z<k;Z+=w){const te=(W+Z)/b;if(te<0||te>=p.outWidth||Math.floor(te)!==te)continue;const V=S*k-1-g.get(O,j,te,$),Q=H*k+Z,ee=V===Q?1:0;if(ee===0)continue;const ae=D.get(O,j,te,$);B+=ae*ee}}E.set(B,O,_,P,$)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const Zut={kernelName:pT,backendName:"cpu",kernelFunc:Qut};function Jut(e,t,n,a,r){const s=St(t),i=m4(e,t,n,s,r,"max"),o=qse(e,t,n,r,!0,a);return[i.values,o.values]}const ect={kernelName:mT,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;pt(a,"MaxPoolWithArgmax");const u=l.data.get(a.dataId).values,c=Wo(a.shape,r,s,[1,1],i),[h,p]=Jut(u,a.shape,a.dtype,o,c),m=l.write(h,c.outShape,a.dtype),g=l.write(p,c.outShape,a.dtype);return[{dataId:m,shape:c.outShape,dtype:a.dtype},{dataId:g,shape:c.outShape,dtype:"int32"}]}};function tct(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=Zt(s,r.shape),u=Pr(r.shape,o)[1],c=_e(u),h=[],p=n.makeTensorInfo([],"float32",new Float32Array([c]));h.push(p);const m=qh({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});h.push(m);const g=g4({inputs:{a:m,b:p},backend:n});h.push(g);const y=IS({inputs:{x:g},backend:n,attrs:{axis:s,keepDims:i}});return h.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const nct={kernelName:SA,backendName:"cpu",kernelFunc:tct};function act(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;pt(r,"min");const o=Zt(s,r.shape);let l=o;const u=$a(l,r.shape.length);let c=r;u!=null&&(c=si({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Ua(l.length,r.shape.length)),es("min",l,c.shape.length);const[h,p]=Pr(c.shape,l),m=_e(p),g=Yr(_e(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){const w=v*m;let S=y[w];for(let k=0;k<m;++k){const I=y[w+k];(Number.isNaN(I)||I<S)&&(S=I)}g[v]=S}u!=null&&n.disposeIntermediateTensorInfo(c);const b=n.makeTensorInfo(h,c.dtype,g);if(i){const v=Ba(h,o),w=la({inputs:{x:b},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(b),w}return b}const rct={kernelName:kA,backendName:"cpu",kernelFunc:act};function sct(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a;pt(r,"mirrorPad");const o=s.map((S,k)=>S[0]+r.shape[k]+S[1]),l=s.map(S=>S[0]),u=s.map((S,k)=>S[0]+r.shape[k]),c=i==="reflect"?0:1,h=n.data.get(r.dataId).values,p=r.shape.length,m=St(r.shape),g=_e(o),y=o.length,b=St(o),v=Mr(r.dtype,g);for(let S=0;S<g;S++){let k=Bm(S,y,b);for(let T=0;T<y;T++)k[T]<l[T]?k[T]=l[T]*2-k[T]-c:k[T]>=u[T]&&(k[T]=(u[T]-1)*2-k[T]+c);k=k.map((T,E)=>T-l[E]);const I=ul(k,p,m);v[S]=h[I]}return{dataId:n.write(v,o,r.dtype),shape:o,dtype:r.dtype}}const ict={kernelName:IA,backendName:"cpu",kernelFunc:sct};const oct=Ga(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),lct=wr(Px,oct),uct={kernelName:Px,backendName:"cpu",kernelFunc:lct};function Jse(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=r.shape.length;let o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Zt([o],r.shape),u=Zse({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Ba(u.shape,l),h=la({inputs:{x:u},backend:n,attrs:{shape:c}}),p=f4({inputs:{a:r,b:h},backend:n}),m=ase({inputs:{x:p},backend:n}),g=IS({inputs:{x:m},backend:n,attrs:{axis:l,keepDims:!1}}),y=la({inputs:{x:g},backend:n,attrs:{shape:c}}),b=g4({inputs:{a:m,b:y},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}const cct={kernelName:WA,backendName:"cpu",kernelFunc:Jse};function hct(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;pt(r,"multinomial");const l=o?r:Jse({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,p=[u,s],m=Yr(_e(p),"int32");for(let g=0;g<u;++g){const y=g*c,b=new Float32Array(c-1);b[0]=h[y];for(let S=1;S<b.length;++S)b[S]=b[S-1]+h[y+S];const v=rE.alea(i.toString()),w=g*s;for(let S=0;S<s;++S){const k=v();m[w+S]=b.length;for(let I=0;I<b.length;I++)if(k<b[I]){m[w+S]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",m)}const dct={kernelName:gT,backendName:"cpu",kernelFunc:hct};const pct=IE;function fct(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a;pt(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:h}=pct(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const mct={kernelName:yT,backendName:"cpu",kernelFunc:fct};const gct=NE;function yct(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a;pt(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:p,validOutputs:m}=gct(c,h,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([m]))]}const bct={kernelName:bT,backendName:"cpu",kernelFunc:yct};const xct=CE;function vct(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a;pt(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,p=i,m=o,g=l,y=u,{selectedIndices:b,selectedScores:v}=xct(c,h,p,m,g,y);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const wct={kernelName:xT,backendName:"cpu",kernelFunc:vct};function Act(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a;pt(r,"oneHot");const u=_e(r.shape),c=new Float32Array(u*i);c.fill(l);const h=n.data.get(r.dataId).values;for(let p=0;p<u;++p)h[p]>=0&&h[p]<i&&(c[p*i+h[p]]=o);return n.makeTensorInfo([...r.shape,i],s,c)}const Sct={kernelName:EA,backendName:"cpu",kernelFunc:Act};function QN(e){const{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(a.dtype==="complex64"){const r=tf({inputs:{input:a},backend:n}),s=QN({inputs:{x:r},backend:n}),i=My({inputs:{input:a},backend:n}),o=QN({inputs:{x:i},backend:n}),l=ki({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return y4({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const kct={kernelName:qA,backendName:"cpu",kernelFunc:QN};function eie(e){const{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(a.dtype==="complex64"){const r=tf({inputs:{input:a},backend:n}),s=eie({inputs:{x:r},backend:n}),i=My({inputs:{input:a},backend:n}),o=QN({inputs:{x:i},backend:n}),l=ki({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return y4({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}const Ict={kernelName:TA,backendName:"cpu",kernelFunc:eie};function tie(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return YN({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,i=t[0].dtype;t.forEach(c=>{Zr(s,c.shape,"All tensors passed to stack must have matching shapes"),q(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const h=YN({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),u=Ly({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const Nct={kernelName:$A,backendName:"cpu",kernelFunc:tie};function Cct(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;pt(r,"pad");const o=s.map((w,S)=>w[0]+r.shape[S]+w[1]),l=s.map(w=>w[0]),u=n.data.get(r.dataId).values,c=_e(r.shape),h=r.shape.length,p=St(r.shape),m=_e(o),g=o.length,y=St(o),b=Mr(r.dtype,m);i!==0&&b.fill(i);for(let w=0;w<c;w++){const k=Bm(w,h,p).map((T,E)=>T+l[E]),I=ul(k,g,y);b[I]=u[w]}return{dataId:n.write(b,o,r.dtype),shape:o,dtype:r.dtype}}const nie={kernelName:_A,backendName:"cpu",kernelFunc:Cct};const Tct=Ga((e,t)=>Math.pow(e,t)),Ect=wr(Ux,Tct),$ct={kernelName:Ux,backendName:"cpu",kernelFunc:Ect};function _ct(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(v=>n.data.get(v.dataId).values),u=r.map(v=>v.shape),c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,[p,m,g]=wse(l,u,c,s.shape,s.dtype,h,i.shape),y=p.map(v=>n.makeTensorInfo([v.length],"int32",v)),b=n.makeTensorInfo(g,s.dtype,m);return y.concat([b])}const Rct={kernelName:vT,backendName:"cpu",kernelFunc:_ct};function Dct(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=Ase(i,a.shape,a.dtype,o,r.shape,l,s.shape),h=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],a.dtype,c);return[h,p]}const Oct={kernelName:wT,backendName:"cpu",kernelFunc:Dct};function Fct(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,p=o.map(b=>n.data.get(b.dataId).values),m=o.map(b=>b.shape),[g,y]=Sse(u,r.shape,c,s.shape,s.dtype,h,i.shape,p,m,l);return n.makeTensorInfo(g,s.dtype,y)}const Mct={kernelName:AT,backendName:"cpu",kernelFunc:Fct};function Lct(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=kse(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}const zct={kernelName:ST,backendName:"cpu",kernelFunc:Lct};const Bct=On(Wx,e=>1/e),Pct={kernelName:Wx,backendName:"cpu",kernelFunc:Bct};function Vct(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;pt(r,"resizeBilinear");const l=St(r.shape),[u,c]=o,[h,p,m,g]=r.shape,y=n.data.get(r.dataId).values,b=new Float32Array(_e([h,u,c,g])),v=[s&&u>1?p-1:p,s&&c>1?m-1:m],w=[s&&u>1?u-1:u,s&&c>1?c-1:c];let S=0;const k=v[0]/w[0],I=v[1]/w[1];for(let T=0;T<h;T++)for(let E=0;E<u;E++){let R;i?R=k*(E+.5)-.5:R=k*E;const D=Math.max(0,Math.floor(R)),O=R-D,$=Math.min(p-1,Math.ceil(R)),_=T*l[0]+D*l[1],P=T*l[0]+$*l[1];for(let U=0;U<c;U++){let W;i?W=I*(U+.5)-.5:W=I*U;const B=Math.max(0,Math.floor(W)),H=W-B,j=Math.min(m-1,Math.ceil(W)),Z=_+B*l[2],te=P+B*l[2],V=_+j*l[2],Q=P+j*l[2];for(let ee=0;ee<g;ee++){const ae=y[Z+ee],de=y[te+ee],ke=y[V+ee],Te=y[Q+ee],$e=ae+(ke-ae)*H,Le=de+(Te-de)*H,Ge=$e+(Le-$e)*O;b[S++]=Ge}}}return n.makeTensorInfo([h,u,c,g],"float32",b)}const Uct={kernelName:MA,backendName:"cpu",kernelFunc:Vct};function Wct(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;pt([s,r],"resizeBilinearGrad");const o=St(r.shape),[l,u,c,h]=r.shape,[,p,m]=s.shape,g=new Float32Array(l*u*c*h),y=[i&&p>1?u-1:u,i&&m>1?c-1:c],b=[i&&p>1?p-1:p,i&&m>1?m-1:m],v=y[0]/b[0],w=y[1]/b[1],S=n.data.get(s.dataId).values;let k=0;for(let I=0;I<l;I++){const T=I*o[0];for(let E=0;E<p;E++){const R=E*v,D=Math.floor(R),O=Math.min(Math.ceil(R),u-1),$=T+D*o[1],_=T+O*o[1],P=R-D,U=1-P;for(let W=0;W<m;W++){const B=W*w,H=Math.floor(B),j=Math.min(Math.ceil(B),c-1),Z=B-H,te=1-Z,V=$+H*o[2],Q=$+j*o[2],ee=_+H*o[2],ae=_+j*o[2],de=U*te,ke=U*Z,Te=P*te,$e=P*Z;for(let Le=0;Le<h;Le++){const Ge=S[k++];g[V+Le]+=Ge*de,g[Q+Le]+=Ge*ke,g[ee+Le]+=Ge*Te,g[ae+Le]+=Ge*$e}}}}return n.makeTensorInfo([l,c,u,h],"float32",g)}const Gct={kernelName:NT,backendName:"cpu",kernelFunc:Wct};function Hct(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;pt(r,"resizeNearestNeighbor");const l=St(r.shape),[u,c]=o,[h,p,m,g]=r.shape,y=n.data.get(r.dataId).values,b=new Float32Array(h*u*c*g),v=[s&&u>1?p-1:p,s&&c>1?m-1:m],w=[s&&u>1?u-1:u,s&&c>1?c-1:c],S=v[0]/w[0],k=v[1]/w[1];let I=0;for(let T=0;T<h;T++){const E=T*l[0];for(let R=0;R<u;R++){const D=i?S*(R+.5):S*R;let O=Math.min(p-1,s?Math.round(D):Math.floor(D));i&&(O=Math.max(0,O));const $=E+O*l[1];for(let _=0;_<c;_++){const P=i?k*(_+.5):k*_;let U=Math.min(m-1,s?Math.round(P):Math.floor(P));i&&(U=Math.max(0,U));const W=$+U*l[2];for(let B=0;B<g;B++){const H=y[W+B];b[I++]=H}}}}return n.makeTensorInfo([h,u,c,g],r.dtype,b)}const jct={kernelName:FA,backendName:"cpu",kernelFunc:Hct};function qct(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;pt([s,r],"resizeNearestNeighborGrad");const o=St(r.shape),l=St(s.shape),[u,c,h,p]=r.shape,[,m,g]=s.shape,y=new Float32Array(u*c*h*p),b=n.data.get(s.dataId).values,v=[i&&m>1?c-1:c,i&&g>1?h-1:h],w=[i&&m>1?m-1:m,i&&g>1?g-1:g],S=v[0]/w[0],k=v[1]/w[1],I=1/S,T=1/k,E=Math.ceil(I)*2+2,R=Math.ceil(T)*2+2;for(let D=0;D<u;D++){const O=D*o[0];for(let $=0;$<c;$++){const _=O+$*o[1],P=Math.floor($*I),U=Math.floor(P-E/2);for(let W=0;W<h;W++){const B=_+W*o[2],H=Math.floor(W*T),j=Math.floor(H-R/2);for(let Z=0;Z<p;Z++){let te=0;for(let V=0;V<E;V++){const Q=V+U;if(Q<0||Q>=m)continue;const ee=O+Q*l[1],ae=Q*S,de=Math.min(c-1,i?Math.round(ae):Math.floor(ae));if($===de)for(let ke=0;ke<R;ke++){const Te=ke+j;if(Te<0||Te>=g)continue;const $e=ee+Te*l[2],Le=Te*k,Ge=Math.min(h-1,i?Math.round(Le):Math.floor(Le));W===Ge&&(te+=b[$e+Z])}}y[B+Z]=te}}}}return n.makeTensorInfo(r.shape,r.dtype,y)}const Kct={kernelName:IT,backendName:"cpu",kernelFunc:qct};function Xct(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;pt(r,"reverse");const i=r.shape.length,o=Zt(s,r.shape);if(i===0)return uu({inputs:{x:r},backend:n});const l=new er(r.shape,r.dtype),u=n.bufferSync(r);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),p=h.slice();o.forEach(m=>p[m]=r.shape[m]-1-p[m]),l.set(u.get(...p),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const Yct={kernelName:LA,backendName:"cpu",kernelFunc:Xct};const Qct={kernelName:WT,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=Mr(a.dtype,_e(a.shape)),[u,c,h,p]=a.shape,[m,g]=wP(i,c,h),y=255,b=Math.sin(r),v=Math.cos(r),w=o.data.get(a.dataId).values;for(let k=0;k<u;k++){const I=k*h*c*p;for(let T=0;T<c;T++){const E=T*(h*p);for(let R=0;R<h;R++){const D=R*p;for(let O=0;O<p;O++){const $=[u,T,R,O],_=$[2],P=$[1];let U=(_-m)*v-(P-g)*b,W=(_-m)*b+(P-g)*v;U=Math.round(U+m),W=Math.round(W+g);let B=s;if(typeof s!="number"&&(O===3?B=y:B=s[O]),U>=0&&U<h&&W>=0&&W<c){const j=W*(h*p),Z=U*p,te=I+j+Z+O;B=w[te]}const H=I+E+D+O;l[H]=B}}}}return{dataId:o.write(l,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const Zct=On(jx,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),Jct={kernelName:jx,backendName:"cpu",kernelFunc:Zct};function eht(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=bd(s,r,i),p=!0,m=n.bufferSync(r),g=n.bufferSync(s),y=dp(m,g,i,h,u,l,o,c,0,p);return n.makeTensorInfo(i,y.dtype,y.values)}const tht={kernelName:CT,backendName:"cpu",kernelFunc:eht};function nht(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function aht(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}function rht(e,t,n,a,r,s){const i=_a("int32",n*r);for(let o=0;o<n;++o){const l=e.slice(o*a,(o+1)*a),u=o*r;for(let c=0;c<r;++c)i[u+c]=s==="left"?nht(l,t[c+u]):aht(l,t[c+u])}return i}function sht(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=rht(o,l,r.shape[0],r.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",u)}const iht={kernelName:ET,backendName:"cpu",kernelFunc:sht};function oht(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;pt([a,r,s],"select");const i=a.shape.length,o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=ei(r.dtype,s.dtype),h=Yr(_e(r.shape),c);let p=0;const m=i===0||i>1||r.shape.length===1?1:_e(r.shape.slice(1));for(let g=0;g<o.length;g++)for(let y=0;y<m;y++)o[g]===1?h[p++]=l[g]:h[p++]=u[g];return n.makeTensorInfo(r.shape,c,h)}const lht={kernelName:zA,backendName:"cpu",kernelFunc:oht};const uht=RE,cht=DE,hht=On(Kx,e=>e>=0?cht*e:uht*(Math.exp(e)-1)),dht={kernelName:Kx,backendName:"cpu",kernelFunc:hht};const pht=On(Qx,e=>e<0?-1:e>0?1:0),fht={kernelName:Qx,backendName:"cpu",kernelFunc:pht};const mht=On(Xx,e=>Math.sin(e)),ght={kernelName:Xx,backendName:"cpu",kernelFunc:mht};const yht=On(Yx,e=>Math.sinh(e)),bht={kernelName:Yx,backendName:"cpu",kernelFunc:yht};const xht=11920928955078125e-23,Sj=Math.log(xht)+2,vht=On(Jx,e=>{const t=e>-Sj,n=e<Sj,a=Math.exp(e);let r;return n?r=a:t?r=e:r=Math.log(1+a),r}),wht={kernelName:Jx,backendName:"cpu",kernelFunc:vht};function Aht(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;pt([r],"spaceToBatchND");const o=_e(s),l=[[0,0]];l.push(...i);for(let T=1+s.length;T<r.shape.length;++T)l.push([0,0]);const u=nie.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=fS(u.shape,s,o,!1),h=mS(c.length,s.length,!1),p=gS(u.shape,s,o,!1),y=la({inputs:{x:u},backend:n,attrs:{shape:c}}),w=si({inputs:{x:y},backend:n,attrs:{perm:h}}),I=la({inputs:{x:w},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),I}const Sht={kernelName:VA,backendName:"cpu",kernelFunc:Aht};function kht(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[h,p,m,g,y]=Tse(o,a.shape,a.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(p,a.dtype,h),n.makeTensorInfo([p[0]],r.dtype,m),n.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(b=>Number(b)))),n.makeTensorInfo([y.length],a.dtype,new Int32Array(y))]}const Iht={kernelName:$T,backendName:"cpu",kernelFunc:kht};function Nht(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,h]=Ese(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(c,a.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}const Cht={kernelName:_T,backendName:"cpu",kernelFunc:Nht};function Tht(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=p4(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(c,a.dtype,u)}const Eht={kernelName:RT,backendName:"cpu",kernelFunc:Tht};function $ht(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,c]=p4(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(c,a.dtype,u)}const _ht={kernelName:DT,backendName:"cpu",kernelFunc:$ht};function Rht(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=bd(s,r,o),m=!1,g=n.bufferSync(r);let y;switch(s.dtype){case"bool":{const b=n.bufferSync(s),v=!!n.data.get(i.dataId).values[0];y=dp(g,b,o,p,c,u,l,h,v,m);break}case"float32":{const b=n.bufferSync(s),v=n.data.get(i.dataId).values[0];y=dp(g,b,o,p,c,u,l,h,v,m);break}case"int32":{const b=n.bufferSync(s),v=n.data.get(i.dataId).values[0];y=dp(g,b,o,p,c,u,l,h,v,m);break}case"string":{const b=n.bufferSync(s),v=tc(n.data.get(i.dataId).values[0]);y=dp(g,b,o,p,c,u,l,h,v,m);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,y.dtype,y.values)}const Dht={kernelName:OT,backendName:"cpu",kernelFunc:Rht};function Oht(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=Zt(i,r.shape)[0],l=MP(r,s,o),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{const p=[...c];p[o]=h;const m=nf({inputs:{x:r},backend:n,attrs:{begin:u,size:p}});return u[o]+=h,m})}const Fht={kernelName:UA,backendName:"cpu",kernelFunc:Oht};const Mht={kernelName:FT,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,a=t;pt(n,"square");const r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let o=0;o<r.length;++o){const l=r[o];s[o]=l*l}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};const Lht=On(i0,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),zht={kernelName:i0,backendName:"cpu",kernelFunc:Lht};function Bht(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=a;pt(r,"stridedSlice");const{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:b,isSimpleSlice:v,begin:w,end:S,strides:k}=yP(r.shape,s,i,o,l,u,c,h,p);let I;if(y)I=la({inputs:{x:r},backend:n,attrs:{shape:g}});else if(b||v){q(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const T=fP(w,S,k),E=nf({inputs:{x:r},backend:n,attrs:{begin:w,size:T}});I=la({inputs:{x:E},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(E)}else{const T=n.bufferSync(r),E=Rse(m,T,k,w);I=n.makeTensorInfo(g,E.dtype,E.values)}return I}const Pht={kernelName:MT,backendName:"cpu",kernelFunc:Bht};function Vht(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:c,dataSplits:h}=t,p=n.data.get(c.dataId).values,m=n.data.get(h.dataId).values,[g,y]=Dse(p,m,r,s,i,o,l,u);return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(h.shape,"int32",y)]}const Uht={kernelName:LT,backendName:"cpu",kernelFunc:Vht};function Wht(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,h]=Ose(o,l,r),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const Ght={kernelName:zT,backendName:"cpu",kernelFunc:Wht};function Hht(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(s.dataId).values,o=Fse(i,r);return n.makeTensorInfo(s.shape,"int32",o)}const jht={kernelName:BT,backendName:"cpu",kernelFunc:Hht};const qht=On(a0,e=>Math.tan(e)),Kht={kernelName:a0,backendName:"cpu",kernelFunc:qht};const Xht=On(r0,e=>Math.tanh(e)),Yht={kernelName:r0,backendName:"cpu",kernelFunc:Xht};function Qht(e){const{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=bd(s,r,a.shape),h=!1,p=n.bufferSync(r),m=n.bufferSync(s),g=n.bufferSync(a),y=dp(p,m,a.shape,c,l,o,i,u,g,h);return n.makeTensorInfo(a.shape,y.dtype,y.values)}const Zht={kernelName:TT,backendName:"cpu",kernelFunc:Qht};function Jht(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;pt(r,"tile");const i=Lse(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const edt={kernelName:s0,backendName:"cpu",kernelFunc:Jht};function tdt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;pt(r,"topk");const o=n.data.get(r.dataId).values,[l,u]=Bse(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const ndt={kernelName:PT,backendName:"cpu",kernelFunc:tdt};function adt(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,p,m]=r.shape,[g,y]=u??[h,p],b=[c,g,y,m],v=St(r.shape),w=v[0],S=v[1],k=v[2],I=St(b),T=I[0],E=I[1],R=I[2],D=Mr(r.dtype,_e(b));D.fill(l);const O=a.data.get(r.dataId).values,$=a.data.get(s.dataId).values;for(let P=0;P<c;++P){const U=s.shape[0]===1?$:$.subarray(P*8,P*8+8);for(let W=0;W<g;++W)for(let B=0;B<y;++B)for(let H=0;H<m;++H){let j;const Z=U[6]*B+U[7]*W+1;if(Z===0)continue;const te=(U[0]*B+U[1]*W+U[2])/Z,V=(U[3]*B+U[4]*W+U[5])/Z,Q=kj(te,p,o),ee=kj(V,h,o);switch(i){case"nearest":j=udt(O,h,p,w,S,k,P,ee,Q,H,l);break;case"bilinear":j=cdt(O,h,p,w,S,k,P,ee,Q,H,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const ae=P*T+W*E+B*R+H;D[ae]=j}return a.makeTensorInfo(b,r.dtype,D)}return{dataId:a.write(D,b,r.dtype),shape:r.shape,dtype:r.dtype}}const rdt={kernelName:VT,backendName:"cpu",kernelFunc:adt};function kj(e,t,n){switch(n){case"reflect":return sdt(e,t);case"wrap":return idt(e,t);case"nearest":return ldt(e,t);default:return odt(e)}}function sdt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const a=2*t;n<a&&(n=a*Math.trunc(-n/a)+n),n=n<-t?n+a:-n-1}else if(n>t-1)if(t<=1)n=0;else{const a=2*t;n-=a*Math.trunc(n/a),n>=t&&(n=a-n-1)}return Mh(0,n,t-1)}function idt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const a=t-1;n+=t*(Math.trunc(-n/a)+1)}else if(n>t-1)if(t<=1)n=0;else{const a=t-1;n-=t*Math.trunc(n/a)}return Mh(0,n,t-1)}function odt(e,t){return e}function ldt(e,t){return Mh(0,e,t-1)}function Wv(e,t,n,a,r,s,i,o,l,u,c){const h=i*a+o*r+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[h]:c}function udt(e,t,n,a,r,s,i,o,l,u,c){const h=Math.round(o),p=Math.round(l);return Wv(e,t,n,a,r,s,i,h,p,u,c)}function cdt(e,t,n,a,r,s,i,o,l,u,c){const h=Math.floor(o),p=Math.floor(l),m=h+1,g=p+1,y=(g-l)*Wv(e,t,n,a,r,s,i,h,p,u,c)+(l-p)*Wv(e,t,n,a,r,s,i,h,g,u,c),b=(g-l)*Wv(e,t,n,a,r,s,i,m,p,u,c)+(l-p)*Wv(e,t,n,a,r,s,i,m,g,u,c);return(m-o)*y+(o-h)*b}function hdt(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;pt(s,"unique");const i=a.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=Pse(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],"int32",u)]}const ddt={kernelName:UT,backendName:"cpu",kernelFunc:hdt};function pdt(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const i=r.shape.length,o=r.shape[s],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==s&&(l[u++]=r.shape[m]);const c=new Array(i).fill(0),h=r.shape.slice();h[s]=1;const p=new Array(o);for(let m=0;m<p.length;m++){c[s]=m;const g=nf({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});p[m]=la({inputs:{x:g},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(g)}return p}const fdt={kernelName:HA,backendName:"cpu",kernelFunc:pdt};function mdt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a;pt(r,"unsortedSegmentSum");const o=r.shape.length,l=s.shape.length,u=[],c=[],h=o-l;let p=s;for(let g=0;g<h;++g){const y=YN({inputs:{input:p},backend:n,attrs:{dim:g+1}});p=y,c.push(y)}for(let g=0;g<i;++g){const y=gc(g,"int32"),b=n.makeTensorInfo([],"int32",y),v=tse({inputs:{a:b,b:p},backend:n}),w=qh({inputs:{x:v},backend:n,attrs:{dtype:"float32"}}),S=HE({inputs:{a:w,b:r},backend:n}),k=IS({inputs:{x:S},backend:n,attrs:{axis:0,keepDims:!1}});u.push(k),c.push(b),c.push(v),c.push(w),c.push(S),c.push(k)}const m=tie({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const gdt={kernelName:jA,backendName:"cpu",kernelFunc:mdt};const ydt=[hot,Hst,pot,mot,Qst,yot,xot,wot,Sot,Iot,Cot,Eot,_ot,Oot,Mot,Bot,Vot,Wot,Hot,uot,qot,Xot,Qot,Jst,Jot,Xst,tit,tlt,jst,alt,slt,ilt,llt,clt,dlt,flt,glt,blt,vlt,Alt,klt,Nlt,Tlt,$lt,_lt,Dlt,Flt,Llt,zlt,Blt,Plt,Ult,Hlt,not,qlt,nit,tut,ait,nut,sit,lut,uut,hut,oit,uit,put,mut,yut,xut,hit,pit,qst,wut,rlt,Sut,Iut,Cut,aot,mit,yit,Eut,xit,_ut,Out,Mut,But,Vut,Wut,Gut,wit,jut,Kut,Yut,Zut,ect,nct,rct,Sit,ict,uct,dct,Iit,Cit,mct,bct,wct,Eit,Sct,Ict,Nct,nie,$ct,sot,Rit,Rct,Oct,Mct,zct,Kst,QO,Pct,iot,oot,lot,Uct,Gct,jct,Kct,Yct,Qct,Jct,Pit,tht,iht,lht,dht,Uit,fht,ght,bht,Wit,cct,wht,Sht,Iht,Cht,Eht,_ht,Dht,Fht,jit,Mht,Kit,Yit,zht,Pht,Uht,Ght,jht,eot,Wlt,Kht,Yht,Zht,edt,ndt,rdt,$it,ddt,fdt,gdt,kct];for(const e of ydt)GT(e);const lp={},fI={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function bdt(e,t){lp[e]=t}function vl(e,t){if(!(e in lp)||t!=null){const a=vdt(e,t);if(a!==null)lp[e]=a;else return console.log("Could not get context for WebGL version",e),null}const n=lp[e];return n==null||n.isContextLost()?(delete lp[e],vl(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),lp[e])}function xdt(e){if(!Ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function vdt(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=t??xdt(e);return n.addEventListener("webglcontextlost",a=>{a.preventDefault(),delete lp[e]},!1),Ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(fI.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",fI)||n.getContext("experimental-webgl",fI):n.getContext("webgl2",fI)}var Dw;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(Dw||(Dw={}));var eo;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(eo||(eo={}));var qr;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(qr||(qr={}));function NS(e,t){return[t,e]}function wdt(e,t){return e*t}function mI(e){const t=_e(e),n=Math.ceil(t/4);return NN(n)}function m0(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Adt(e,t){const[n,a]=m0(e,t);return n*a*4}function b4(e,t){const n=e;let a,r,s,i,o,l,u,c,h,p;return Ie().getNumber("WEBGL_VERSION")===2?(a=n.R32F,r=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,h=t!=null?t.HALF_FLOAT_OES:null,p=e.FLOAT,l=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:p}}function rt(e,t){const n=t();return Ie().getBool("DEBUG")&&Sdt(e),n}function Sdt(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+Cdt(e,t))}const kdt=596e-10,Idt=65504;function Ndt(e){return!!(Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||kdt<Math.abs(e)&&Math.abs(e)<Idt)}function Cdt(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function gI(e,t){return Sc(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function Tdt(e,t){const n=Sc(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(rt(e,()=>e.shaderSource(n,t)),rt(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function Edt(e,t){const n=Sc(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(rt(e,()=>e.shaderSource(n,t)),rt(e,()=>e.compileShader(n)),Ie().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw aie(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const $dt=/ERROR: [0-9]+:([0-9]+):/g;function aie(e,t){const n=$dt.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}const a=+n[1],r=e.split(`
`),s=r.length.toString().length+2,i=r.map((h,p)=>yp((p+1).toString(),s)+h);let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const l=i.slice(0,a-1),u=i.slice(a-1,a),c=i.slice(a);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${yp(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function _dt(e){return Sc(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function Rdt(e,t){if(rt(e,()=>e.linkProgram(t)),!Ie().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function HR(e,t){if(rt(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Ddt(e,t){const n=Sc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return rt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),rt(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Odt(e,t){const n=Sc(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return rt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),rt(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Fdt(e){return Sc(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function Mdt(e,t){const n=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const a=`[${e}x${t}]`;throw new Error("Requested texture size "+a+" is invalid.")}if(e>n||t>n){const a=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Ldt(e){return Sc(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Ij(e,t,n,a,r,s,i){const o=e.getAttribLocation(t,n);return o===-1?!1:(rt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),rt(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),rt(e,()=>e.enableVertexAttribArray(o)),!0)}function zdt(e,t,n){Wdt(e,n),rt(e,()=>e.activeTexture(e.TEXTURE0+n)),rt(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function Bdt(e,t,n){return Sc(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function Pdt(e,t,n){return e.getUniformLocation(t,n)}function Vdt(e,t,n,a){rt(e,()=>zdt(e,t,a)),rt(e,()=>e.uniform1i(n,a))}function jR(e,t,n){rt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),rt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function Nj(e,t){rt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),rt(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function yI(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Udt(e,t))}function Udt(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Sc(e,t,n){const a=rt(e,()=>t());if(a==null)throw new Error(n);return a}function Wdt(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function zy(e,t=2){return _e(e.slice(0,e.length-t))}function By(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function bI(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[zy(e),...By(e)]),t}function Gdt(e,t=!1){let n=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=Ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");a===1/0&&Ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n=n*2,a=a*2,e=e.map((o,l)=>l>=e.length-2?LC(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=mc(e).newShape);let r=_e(e),s=null;e.length<=1&&r<=n?s=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const i=s!=null&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){const o=zy(e);let l=2,u=2;e.length&&([l,u]=By(e)),r=o*(l/2)*(u/2),s=NN(r).map(c=>c*2)}else s=NN(r);return s}function xI(e){return e%2===0}function ZN(e,t){if(e=e.slice(-2),t=t.slice(-2),tn(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a||xI(n)&&xI(a)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&xI(e[0])&&xI(t[0])}let qR,KR;function Hdt(e){if(qR==null){const t=vl(e);qR=t.getParameter(t.MAX_TEXTURE_SIZE)}return qR}function jdt(e){if(KR==null){const t=vl(e);KR=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,KR)}function qdt(e){if(e===0)return 0;let t;const n=vl(e);return Fo(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Fo(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Fo(e,t){return e.getExtension(t)!=null}function Cj(e){try{if(vl(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Kdt(e){if(e===0)return!1;const t=vl(e);if(e===1){if(!Fo(t,"OES_texture_float"))return!1}else if(!Fo(t,"EXT_color_buffer_float"))return!1;return JO(t)}function Xdt(e){if(e===0)return!1;const t=vl(e);if(e===1){if(!Fo(t,"OES_texture_float")||!Fo(t,"WEBGL_color_buffer_float"))return!1}else{if(Fo(t,"EXT_color_buffer_float"))return JO(t);const a="EXT_color_buffer_half_float";if(Fo(t,a)){const r=t.getExtension(a);return Ydt(t,r)}return!1}return JO(t)}function JO(e){const t=b4(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),i}function Ydt(e,t){const n=b4(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(i),o}function Qdt(e){return e!==2?!1:vl(e).fenceSync!=null}function CS(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&q(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const mt=Ie();mt.registerFlag("HAS_WEBGL",()=>mt.getNumber("WEBGL_VERSION")>0);mt.registerFlag("WEBGL_VERSION",()=>Cj(2)?2:Cj(1)?1:0);mt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);mt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>mt.get("WEBGL_VERSION")===2);mt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);mt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);mt.registerFlag("WEBGL_PACK",()=>mt.getBool("HAS_WEBGL"));mt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_CLIP",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_REDUCE",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_LAZILY_UNPACK",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_CONV_IM2COL",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Hdt(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>jdt(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=mt.getNumber("WEBGL_VERSION");return e===0?0:qdt(e)});mt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>mt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Hz());mt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Kdt(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>mt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:mt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));mt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Xdt(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Qdt(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>mt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);mt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});mt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Hz()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});mt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);mt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);mt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);mt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);mt.registerFlag("WEBGL_EXP_CONV",()=>!1);mt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>mt.getBool("IS_TEST"));mt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);mt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);mt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);mt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function zs(){let e,t,n,a,r,s,i,o,l,u;return Ie().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",i="out vec4 outputColor;",o=Ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function qm(e,t,n="index"){const a=St(t);return a.map((r,s)=>{const i=`int ${e[s]} = ${n} / ${r}`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r}`:`index -= ${e[s]} * ${r}`;return`${i}; ${o};`}).join("")}function jE(e,t,n="index"){const a=St(t);return a.map((r,s)=>{const i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function Zdt(e,t){const n=e.length,a=e.map(s=>`${t}[${s}]`),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]=`(${r[s+1]} * ${a[s+1]})`;return r}function Jdt(e,t,n="index"){const a=e.map((s,i)=>i),r=Zdt(a,t);return r.map((s,i)=>{const o=`int ${e[i]} = ${n} / ${r[i]}`,l=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${l};`}).join("")}function x4(e){const t=St(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function v4(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const rie=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:sie}=Nne;function ept(e,t,n){const a=[];if(e.forEach(m=>{const g=_e(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?a.push(`uniform float ${m.name}${g>1?`[${g}]`:""};`):(a.push(`uniform sampler2D ${m.name};`),a.push(`uniform int offset${m.name};`)),n.enableShapeUniforms){const{uniformShape:y}=w4(n.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(y.length){case 1:a.push(`uniform int ${m.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${m.name}Shape;`);break}a.push(`uniform ivec2 ${m.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;");break}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(m=>{a.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});const r=a.join(`
`),s=e.map(m=>tpt(m,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=zs(),l=rpt(o);let u,c,h=opt(o);return t.isPacked?(u=npt(t.logicalShape,i,n.enableShapeUniforms),c=ipt(o)):(u=apt(t.logicalShape,i,n.enableShapeUniforms),c=spt(o)),n.packedInputs&&(h+=hpt),[h,l,c,r,u,s,n.userCode].join(`
`)}function g0(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Spt(e,t);case 1:return Ipt(e,t);case 2:return Cpt(e,t);case 3:return Ept(e,t);case 4:return _pt(e,t);case 5:return Rpt(e);case 6:return Dpt(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function iie(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return Apt(e);case 1:return kpt(e,t);case 2:return Npt(e,t);case 3:return Tpt(e,t);default:return $pt(e,t)}}function tpt(e,t,n=!1,a){let r="";n?r+=iie(e,a):r+=g0(e,a);const s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?r+=Opt(e,t):r+=Fpt(e,t)),r}function npt(e,t,n){switch(e.length){case 0:return oie();case 1:return dpt(e,t,n);case 2:return vpt(e,t,n);case 3:return fpt(e,t,n);default:return gpt(e,t,n)}}function apt(e,t,n){switch(e.length){case 0:return oie();case 1:return ppt(e,t,n);case 2:return wpt(e,t,n);case 3:return mpt(e,t,n);case 4:return ypt(e,t,n);case 5:return bpt(e,t);case 6:return xpt(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function rpt(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function spt(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function ipt(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function opt(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${lpt}
    ${upt}
    ${cpt}
  `}const lpt=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,upt=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,cpt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hpt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function oie(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function dpt(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${a[1]}.0);
      }
    `:a[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${a[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);
    }
  `}function ppt(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function fpt(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function mpt(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${jE(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;const a=qm(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec3(r, c, d);
    }
  `}function gpt(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${e.length}(${l});
    }
  `}function ypt(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${jE(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;const a=qm(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `}function bpt(e,t){const n=qm(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function xpt(e,t){const n=qm(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function vpt(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(tn(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));
      }
    `;const r=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));

      int index = resTexRC.x * ${a[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function wpt(e,t,n){return tn(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Km(e){return`offset${e}`}function Apt(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=zs();return`
    vec4 ${n}() {
      return ${a.texture2D}(${t}, halfCR);
    }
  `}function Spt(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;const[r,s]=e.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${a}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Km(n);if(t)return`
    float ${a}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,l]=e.shapeInfo.texShape;return`
    float ${a}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function kpt(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=zs();if(t)return`
    vec4 ${a}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${a}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function Ipt(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${a}(int index) {
        ${y0(e)}
      }
    `;const r=e.shapeInfo.texShape,s=r[0],i=r[1];if(i===1&&s===1)return`
      float ${a}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Km(n);return i===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Npt(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=zs();if(s!=null&&tn(n,s))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);

        return ${l.texture2D}(${a}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${a}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `}function Cpt(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(s!=null&&tn(n,s)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;const p=s[0],m=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${a}, uv);
    }
  `}const{newShape:i,keptDims:o}=mc(n),l=i;if(l.length<n.length){const p=b0(e,l),m=["row","col"];return`
      ${g0(p,t)}
      float ${r}(int row, int col) {
        return ${r}(${x0(m,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${y0(e)}
      }
    `;const u=s[0],c=s[1],h=Km(a);return c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${a}, uv);
    }
  `:u===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${a}, uv);
  }
`}function Tpt(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){const p=n.slice(1),m=[1,2],g=b0(e,p),y=["b","row","col"];return`
        ${iie(g,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${x0(y,m)});
        }
      `}const o=zs();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `}function Ept(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=mc(n),u=o;if(u.length<n.length){const y=b0(e,u),b=["row","col","depth"];return`
        ${g0(y,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${x0(b,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${y0(e)}
      }
    `;const c=e.shapeInfo.texShape,h=c[0],p=c[1],m=e.shapeInfo.flatOffset;if(p===s&&m==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${h}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(p===i&&m==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${a}, uv);
    }
  `;const g=Km(a);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${g};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${g};
        vec2 uv = uvFromFlat(${h}, ${p}, index);
        return sampleTexture(${a}, uv);
      }
  `}function $pt(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=zs();if(t)return`
    vec4 ${a}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;const s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(s[i-1]/2);let p=h*Math.ceil(s[i-2]/2),m="int b, int row, int col",g=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let y=2;y<i-1;y++)m=`int b${y}, `+m,p*=s[i-y-1],g=`b${y} * ${p} + `+g;return`
    vec4 ${a}(${m}) {
      int index = ${g};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${n}, uv);
    }
  `}function _pt(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=mc(n);if(l.length<n.length){const w=b0(e,l),S=["row","col","depth","depth2"];return`
      ${g0(w,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${x0(S,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${y0(e)}
      }
    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],m=h[1],g=`int stride2 = ${a}Shape[3];`,y=`int stride1 = ${a}Shape[2] * stride2;`,b=`int stride0 = ${a}Shape[1] * stride1;`;if(m===o&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${g}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(m===s&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${a}, uv);
      }
    `;const v=Km(a);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${g}
      ${y}
      ${b}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${v});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${p}, ${m}, index + ${v});
      return sampleTexture(${a}, uv);
    }
  `}function Rpt(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=mc(t);if(l.length<t.length){const y=b0(e,l),b=["row","col","depth","depth2","depth3"];return`
      ${g0(y)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${x0(b,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${r})) +
          depth3;
        ${y0(e)}
      }
    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],m=h[1];if(m===o&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===r&&c==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const g=Km(n);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${r} + depth3 + ${g};
      vec2 uv = uvFromFlat(${p}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Dpt(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=mc(t);if(r.length<t.length){const b=b0(e,r),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${g0(b)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${x0(v,s)});
      }
    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${y0(e)}
      }
    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,m=p[0],g=p[1];if(g===c&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===i&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=Km(n);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${y};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function y0(e){const t=e.name,n=_e(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Opt(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=sie(e.shapeInfo.logicalShape,t.logicalShape),l=Hn(i),u=i-s;let c;const h=["x","y","z","w","u","v"];s===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(w=>`coords.${h[w+u]} = 0;`).join(`
`);let p="";i<2&&s>0?p="coords":p=e.shapeInfo.logicalShape.map((w,S)=>`coords.${h[S+u]}`).join(", ");let m="return outputValue;";const y=_e(e.shapeInfo.logicalShape)===1,v=_e(t.logicalShape)===1;if(s===1&&!y&&!v)m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(y&&!v)i===1?m=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:m=`
        return vec4(outputValue.x);
      `;else if(o.length){const w=s-2,S=s-1;o.indexOf(w)>-1&&o.indexOf(S)>-1?m="return vec4(outputValue.x);":o.indexOf(w)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(S)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${a}(${p});
      ${m}
    }
  `}function Fpt(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&tn(i,s))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=Hn(l),c=sie(e.shapeInfo.logicalShape,t.logicalShape),h=l-o;let p;const m=["x","y","z","w","u","v"];o===0?p="":l<2&&c.length>=1?p="coords = 0;":p=c.map(y=>`coords.${m[y+h]} = 0;`).join(`
`);let g="";return l<2&&o>0?g="coords":g=e.shapeInfo.logicalShape.map((y,b)=>`coords.${m[b+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${p}
      return get${a}(${g});
    }
  `}function Hn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function w4(e,t,n){const{newShape:a,keptDims:r}=mc(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):a,l=!e&&s>1&&!tn(t,n)&&a.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:r}}function b0(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function x0(e,t){return t.map(n=>e[n]).join(", ")}function Mpt(e,t,n,a){const r=n.map((c,h)=>{const p={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(p.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:p}}),s=r.map(c=>c.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=ept(r,i,t),l=Edt(e.gl,o),u=e.createProgram(l);return Ie().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},lie(e,t,u)))}function lie(e,t,n){const a=[],r=[];let s,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),Ie().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of t.variableNames){const p={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(p.shape=e.getUniformLocation(n,`${h}Shape`,c),p.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),a.push(p)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const h of t.customUniforms)r.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:a,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function Tj(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,a)=>{const r=n.logicalShape,s=t[a],i=s.shape;if(!tn(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&s.isUniform)return;const o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!tn(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function Lpt(e,t,n,a,r){t.program.enableShapeUniforms||(Tj(t.inShapeInfos,n),Tj([t.outShapeInfo],[a]));const s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),Ie().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const u=n[l],{uniform:c,offset:h,shape:p,texShape:m}=t.variablesLocations[l];if(p){const{uniformShape:g}=w4(t.program.packedInputs,u.shape,u.texData.texShape);switch(g.length){case 1:e.gl.uniform1iv(p,new Int32Array(g));break;case 2:e.gl.uniform2iv(p,new Int32Array(g));break;case 3:e.gl.uniform3iv(p,new Int32Array(g));break;case 4:e.gl.uniform4iv(p,new Int32Array(g));break}}if(m&&e.gl.uniform2i(m,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(_e(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let g=u.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),e.gl.uniform1fv(c,g)}continue}u.texData.slice!=null&&h!=null&&e.gl.uniform1i(h,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape));break}if(t.outShapeStridesLocation){const l=St(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){const u=t.program.customUniforms[l],c=t.customUniformLocations[l],h=r[l];if(u.type==="float")e.gl.uniform1fv(c,h);else if(u.type==="vec2")e.gl.uniform2fv(c,h);else if(u.type==="vec3")e.gl.uniform3fv(c,h);else if(u.type==="vec4")e.gl.uniform4fv(c,h);else if(u.type==="int")e.gl.uniform1iv(c,h);else if(u.type==="ivec2")e.gl.uniform2iv(c,h);else if(u.type==="ivec3")e.gl.uniform3iv(c,h);else if(u.type==="ivec4")e.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function zpt(e,t,n){let a="";t.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=w4(e.packedInputs,i.shape,l);let p="",m="",g="";if(c.length===1&&e.packedInputs){const I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${I[0]>1}_${I[1]>1}`}else if(c.length===2&&!e.packedInputs)m=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){const I=St(c);g=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}const y=i.shape.length,b=c.length===2&&tn(i.shape,l),v=_e(i.shape)===1,w=Xp(i.shape,n.shape),S=!e.packedInputs&&y===n.shape.length&&tn(l,n.texData.texShape),k=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;a+=`${y}_${S}_${u?h:""}_${c.length}_${v}_${w}_${b}_${p}_${m}_${g}_${k}_${o}`}else{const l=i.isUniform?"uniform":i.texData.texShape;a+=`${i.shape}_${l}_${o}`}});const r=e.userCode;let s=e.constructor.name;return s+="_"+a+"_"+r+`${Ie().getNumber("WEBGL_VERSION")}`,s}function gs(e){return Ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class Bpt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Dw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=zs();this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?jE(["r","c","d"],t):qm(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}class Ppt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Dw.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=zs();this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?jE(["r","c","d"],t):qm(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}class Vpt{constructor(t){this.variableNames=["A"],this.outTexUsage=eo.DOWNLOAD;const n=zs();this.outputShape=t,this.userCode=`
      ${rie}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}class Upt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=eo.DOWNLOAD;const n=zs();this.outputShape=t,this.userCode=`
      ${rie}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}const Wpt={R:0,G:1,B:2,A:3};class Ej{constructor(t,n=!1,a="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=zs();this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length);let s="result";n&&(s="floor(result * 255. + 0.5)");let i="";for(let o=0;o<a.length;o++){const l=a[o];i+=`
          if(offset == ${o}) {
            result = values[${Wpt[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?v4():x4(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${a.length});

        flatIndex = idiv(flatIndex, ${a.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}class Gpt{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=zs();this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length);let r="",s="result";n&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const l=i*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${a.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?v4():x4(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${a.output} = ${s};
        }
    `}}function Hpt(e){const t=zs(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Tdt(e,n)}function jpt(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Ddt(e,t)}function qpt(e){const t=new Uint16Array([0,1,2,2,1,3]);return Odt(e,t)}function TS(e,t,n,a,r,s){Mdt(t,n);const i=Fdt(e),o=e.TEXTURE_2D;return rt(e,()=>e.bindTexture(o,i)),rt(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),rt(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),rt(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),rt(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),Ie().getNumber("WEBGL_VERSION")===1?rt(e,()=>e.texImage2D(o,0,a,t,n,0,r,s,null)):rt(e,()=>e.texStorage2D(o,1,a,t,n)),rt(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function uie(e){return e.internalFormatFloat}function Kpt(e,t,n,a){const[r,s]=NS(t,n);return TS(e,r,s,uie(a),a.textureFormatFloat,e.FLOAT)}function cie(e){return e.internalFormatHalfFloat}function Xpt(e,t,n,a){const[r,s]=NS(t,n);return TS(e,r,s,cie(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function hie(e){return e.downloadTextureFormat}function Ypt(e,t,n,a){const[r,s]=NS(t,n);return TS(e,r,s,hie(a),e.RGBA,e.UNSIGNED_BYTE)}function die(e){return e.internalFormatPackedFloat}function Qpt(e,t,n,a){const[r,s]=m0(t,n);return TS(e,r,s,die(a),e.RGBA,e.FLOAT)}function pie(e){return e.internalFormatPackedHalfFloat}function Zpt(e,t,n,a){const[r,s]=m0(t,n);return TS(e,r,s,pie(a),e.RGBA,a.textureTypeHalfFloat)}function Jpt(e,t,n){return rt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Ij(e,t,"clipSpacePos",n,3,20,0)&&Ij(e,t,"uv",n,2,20,12)}function eft(e,t,n,a,r,s){rt(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;r instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(r),Ie().getNumber("WEBGL_VERSION")===2?rt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):rt(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,o,i)),rt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function tft(e,t,n){rt(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?Ie().getNumber("WEBGL_VERSION")===2?rt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):rt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):Ie().getNumber("WEBGL_VERSION")===2?rt(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):rt(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),rt(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function nft(e,t,n,a){const r=e.createBuffer();rt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));const o=4*4*t*n;return rt(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),rt(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),rt(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function aft(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function rft(e,t,n,a){const[r,s]=NS(t,n),i=4,o=new Uint8Array(wdt(t*n,i));return rt(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function sft(e,t,n,a,r,s,i,o){const l=e,u=new Float32Array(Adt(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function ift(e,t,n){const a=new Float32Array(t*n*4);return rt(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}class XR{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=Ie().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,bdt(n,t)):this.gl=vl(n),t=this.gl,Ie().getNumber("WEBGL_VERSION")===2){const s=t;this.createVertexArray=()=>rt(s,()=>s.createVertexArray()),this.bindVertexArray=i=>rt(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>rt(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>rt(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(t!=null){const s=t.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>rt(t,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>rt(t,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>rt(t,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>rt(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let a="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ie().getNumber("WEBGL_VERSION")===1){const s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=gI(this.gl,s),Fo(this.gl,i))this.textureHalfFloatExtension=gI(this.gl,i);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(a),Fo(this.gl,r))this.colorBufferHalfFloatExtension=gI(this.gl,r);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(a="EXT_color_buffer_float",Fo(this.gl,a))this.colorBufferFloatExtension=this.gl.getExtension(a);else if(Fo(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=jpt(this.gl),this.indexBuffer=qpt(this.gl),this.framebuffer=Ldt(this.gl),this.textureConfig=b4(this.gl,this.textureHalfFloatExtension)}get debug(){return Ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;rt(t,()=>t.finish()),rt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),rt(t,()=>t.deleteFramebuffer(this.framebuffer)),rt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),rt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),rt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),Kpt(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),Xpt(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),Ypt(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),tft(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,a,r){this.throwIfDisposed(),eft(this.gl,t,n,a,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),Zpt(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),Qpt(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Nj(this.gl,this.framebuffer),this.outputTexture=null),rt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,a){return this.downloadMatrixDriver(t,()=>rft(this.gl,n,a,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,a,r,s,i){return sft(this.gl,t,n,a,r,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return aft(this.gl,t,n)}createBufferFromTexture(t,n,a){this.bindTextureToFrameBuffer(t);const r=nft(this.gl,n,a,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,a;if(Ie().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),a=()=>{const i=r.clientWaitSync(s,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},n=s}else Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),a=()=>this.isQueryAvailable(n,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):a=()=>!0;return{query:n,isFencePassed:a}}downloadMatrixFromPackedTexture(t,n,a){return this.downloadMatrixDriver(t,()=>ift(this.gl,n,a))}createProgram(t){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=Hpt(n));const a=_dt(n);rt(n,()=>n.attachShader(a,this.vertexShader)),rt(n,()=>n.attachShader(a,t)),Rdt(n,a);const r=Object.assign(a,{vao:this.createVertexArray()});return this.debug&&HR(n,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const n=this.gl;rt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Jpt(n,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(rt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&HR(this.gl,this.program),rt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,a=!0){return this.throwIfDisposed(),a?Bdt(this.gl,t,n):Pdt(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),rt(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,a){this.throwIfDisposed(),this.throwIfNoProgram(),Vdt(this.gl,t,n,a)}setOutputMatrixTexture(t,n,a){this.setOutputMatrixTextureDriver(t,a,n)}setOutputPackedMatrixTexture(t,n,a){this.throwIfDisposed();const[r,s]=m0(n,a);this.setOutputMatrixTextureDriver(t,r,s)}setOutputMatrixWriteRegion(t,n,a,r){this.setOutputMatrixWriteRegionDriver(a,t,r,n)}setOutputPackedMatrixWriteRegion(t,n,a,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&HR(this.gl,this.program),yI(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}rt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),rt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=gI(this.gl,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const a=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=a.createQuery();return a.beginQuery(r.TIME_ELAPSED_EXT,s),s}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,a=this.getQueryTimerExtensionWebGL2();n.endQuery(a.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await uO(()=>this.disposed||this.isQueryAvailable(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){const a=this.gl;return a.getQueryParameter(t,a.QUERY_RESULT)/1e6}else{const a=this.getQueryTimerExtensionWebGL1();return a.getQueryObjectEXT(t,a.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){const a=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=a.getQueryParameter(t,a.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{const a=this.getQueryTimerExtensionWebGL1(),r=a.getQueryObjectEXT(t,a.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=oft(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:a}=this.itemsToPoll[n];a()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1)return;let a;"setTimeoutCustom"in Ie().platform&&(a=Ie().platform.setTimeoutCustom.bind(Ie().platform)),uO(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,a)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),jR(this.gl,t,this.framebuffer),this.debug&&yI(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(jR(this.gl,this.outputTexture,this.framebuffer),this.debug&&yI(this.gl)):Nj(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const a=n();return this.unbindTextureToFrameBuffer(),a}setOutputMatrixTextureDriver(t,n,a){this.throwIfDisposed();const r=this.gl;jR(r,t,this.framebuffer),this.debug&&yI(r),this.outputTexture=t,rt(r,()=>r.viewport(0,0,n,a)),rt(r,()=>r.scissor(0,0,n,a))}setOutputMatrixWriteRegionDriver(t,n,a,r){this.throwIfDisposed(),rt(this.gl,()=>this.gl.scissor(t,n,a,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function oft(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}const{addImpl:lft,bincountImpl:fie,bincountReduceImpl:uft,bitwiseAndImpl:cft,castImpl:hft,ceilImpl:dft,concatImpl:pft,equalImpl:fft,expImpl:mft,expm1Impl:gft,floorImpl:yft,gatherNdImpl:bft,gatherV2Impl:xft,greaterImpl:vft,greaterEqualImpl:wft,lessImpl:Aft,lessEqualImpl:Sft,linSpaceImpl:kft,logImpl:Ift,maxImpl:Nft,maximumImpl:Cft,minimumImpl:Tft,multiplyImpl:Eft,negImpl:$ft,notEqualImpl:_ft,prodImpl:Rft,raggedGatherImpl:Dft,raggedRangeImpl:Oft,raggedTensorToTensorImpl:Fft,rangeImpl:Mft,rsqrtImpl:Lft,scatterImpl:zft,sigmoidImpl:Bft,simpleAbsImpl:mie,sliceImpl:Pft,sparseFillEmptyRowsImpl:Vft,sparseReshapeImpl:Uft,sparseSegmentReductionImpl:gie,sqrtImpl:Wft,staticRegexReplaceImpl:Gft,stridedSliceImpl:Hft,stringNGramsImpl:jft,stringSplitImpl:qft,stringToHashBucketFastImpl:Kft,subImpl:Xft,tileImpl:Yft,topKImpl:Qft,transposeImpl:A4,uniqueImpl:Zft}=tot;function yie(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Ns(e,t){return t===1?[e]:yie(e,t)}function Jft(e,t){if(e===1)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}class emt{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=gs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=Ns("rc",this.rank),a=Hn(this.rank),r=this.getOutOfBoundsCondition(n),s=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){const n=[];for(let a=0;a<=1;a++)for(let r=0;r<=1;r++){let s=`${a===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;n.push(s)}return n}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let a=this.rank-2;a<this.rank;a++)n+=`${t[a]} >= ${this.enableShapeUniforms?`outShape[${a}]`:this.outputShape[a]}`,a<this.rank-1&&(n+="||");return n}getSetup(t){if(this.rank===1)return"";const n=t.slice(-2),a=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${a};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){const n=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}class bie{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length);let a="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),a+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${tmt(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?v4():x4(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${a}

        setOutput(result);
      }
    `}}function tmt(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Jdt(["r","c","d"],"inputShape"):qm(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}class nmt{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,n,a){const r=_j(n,a),s=Rj(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const i=$j(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[s].pop();return this.usedTextures[s].push(l),l}let o;return r===qr.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===qr.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===qr.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===qr.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===qr.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,n,a,r){if(this.freeTextures==null)return;const s=_j(a,r),i=Rj(n,s,r);i in this.freeTextures||(this.freeTextures[i]=[]);const o=$j(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=Ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(t);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function amt(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function $j(e,t,n,a,r){const s=rmt(t,a);let i;if(r){const[l,u]=m0(e[0],e[1]);i=l*u}else{const[l,u]=NS(e[0],e[1]);i=l*u}const o=amt(n,s);return i*o}function rmt(e,t){switch(e){case qr.PACKED_2X2_FLOAT32:return die(t);case qr.PACKED_2X2_FLOAT16:return pie(t);case qr.UNPACKED_FLOAT32:return uie(t);case qr.UNPACKED_FLOAT16:return cie(t);case qr.PACKED_4X1_UNSIGNED_BYTE:return hie(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function smt(e){return Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?qr.PACKED_2X2_FLOAT32:qr.UNPACKED_FLOAT32:e?qr.PACKED_2X2_FLOAT16:qr.UNPACKED_FLOAT16}function _j(e,t){if(e===eo.UPLOAD)return qr.PACKED_2X2_FLOAT32;if(e===eo.RENDER||e==null)return smt(t);if(e===eo.DOWNLOAD||e===eo.PIXELS)return qr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Rj(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Hl{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ho="if (isnan(x)) return x;",imt="return x;",Dj="return abs(x);",omt="return (x >= 0.0) ? x : (exp(x) - 1.0);",lmt=Ho+`
  return (x < 0.0) ? 0.0 : x;
`,umt=Ho+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ih="return x;",cmt="return 1.0 / (1.0 + exp(-1.0 * x));";const hmt="return x;",dmt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,pmt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,fmt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mmt="return 1.0 / (1.0 + exp(-1.0 * x));";class fh{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class gmt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length);const n=t.length,a=Ns("rc",n),r=Hn(n),s=Jft(n,a),i=a.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}const ymt=xE,bmt=1e-7,xmt=1e-4,vI={};function vmt(e){return e in vI||(vI[e]={}),vI[e]}const wmt=Ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Amt=600;function Smt(){return Ie().global.screen==null?1024:Ie().global.screen.height*Ie().global.screen.width*window.devicePixelRatio*Amt/1024/1024}class qE extends MC{nextDataId(){return qE.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof XR)n=t;else{const a=vl(Ie().getNumber("WEBGL_VERSION"),t);n=new XR(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const a=vl(Ie().getNumber("WEBGL_VERSION"));n=new XR(a),this.binaryCache=vmt(Ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new nmt(this.gpgpu),this.numMBBeforeWarning=Smt(),this.texData=new Mz(this,tl())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,a,r,s,i){const o=this.makeTensorInfo(n,a),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,s]},l.texShape=[r,s];const u=bI(n),c=new Ej(u,!1,i),h=this.runWebGLProgram(c,[o],a,[[r,s]]);return h.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(t,n,a){if((Ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ie().getBool("DEBUG"))&&this.checkNumericalProblems(t),a==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:t,usage:eo.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,a,r,s){if(Ie().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:a,dtype:r,values:n,usage:eo.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:a,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let p;l?p=new fh(o,ih):p=new Hl(o,ih);const m=this.runWebGLProgram(p,[{dataId:t,shape:o,dtype:r}],r),g=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(a!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return a;const u=this.activeTimers!=null;let c;u&&(c=xs());let h;if(r==="complex64"){const p=this.readSync(s.real.dataId),m=this.readSync(s.imag.dataId);h=rc(p,m)}else h=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=xs()-c),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const g=this.pendingRead.get(t);return new Promise(y=>g.push(y))}const n=this.texData.get(t),{values:a,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let g;l?g=new fh(r,ih):g=new Hl(r,ih);const y=this.runWebGLProgram(g,[{dataId:t,shape:r,dtype:i}],i),b=this.read(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(a!=null)return this.convertAndCacheOnCPU(t);if(Ie().getBool("DEBUG")&&!Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&Ie().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);const g=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(g.texture.texture,...mI(r))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const g=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),y=g[0],b=g[1];h=rc(y,b)}else if(u==null)h=this.getValuesFromTexture(t);else{const g=_e(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,g)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const g=this.gpgpu.gl;rt(g,()=>g.deleteBuffer(u))}const p=this.convertAndCacheOnCPU(t,h),m=this.pendingRead.get(t);return this.pendingRead.delete(t),m.forEach(g=>g(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&tl().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,n={}){const a=this.texData.get(t),{values:r,shape:s,slice:i,dtype:o,isPacked:l,texture:u}=a;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let m;l?m=new fh(s,ih):m=new Hl(s,ih);const g=this.runWebGLProgram(m,[{dataId:t,shape:s,dtype:o}],o),y=this.readToGPU(g,n);return this.disposeIntermediateTensorInfo(g),y}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,n.customTexShape),h=tl().makeTensorFromTensorInfo(c),p=this.texData.get(c.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const a=n.map(r=>tc(r));return Gt(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Gt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){const a=t[n];if(!Ndt(a))throw Ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:a,isPacked:r}=this.texData.get(t),s=_e(n);if(Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(t),m=this.texData.get(p.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...mI(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(p),g}const i=Ie().getBool("WEBGL_PACK")&&r===!0,o=i?bI(n):n,l=i?new Upt(o):new Vpt(o),u=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:t}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,a=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,t();const s=ru(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=ru(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(s);o.kernelMs=qJ(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:xs(),endMs:null}}endTimer(t){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=xs(),t)}async getQueryTime(t){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,n),this.disposeData(a.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:a,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(n,r,s,i)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=wmt){return Ie().getBool("WEBGL_CPU_FORWARD")&&t.every(a=>this.texData.get(a.dataId).texture==null&&_e(a.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){qi("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return ymt(t.shape,n)}packedUnaryOp(t,n,a){const r=new fh(t.shape,n),s=this.compileAndRun(r,[t],a);return tl().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const r=mie(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Dj,t.dtype);const n=new Hl(t.shape,Dj),a=this.compileAndRun(n,[t]);return tl().makeTensorFromTensorInfo(a)}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&Gl(a[0])){const s=a.map(i=>Xl(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,a){return tl().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,a),this)}unpackTensor(t){const n=new gmt(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new emt(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){const a=[zy(t.shape),...By(t.shape)],r={dtype:t.dtype,shape:a,dataId:t.dataId},s=[zy(n),...By(n)],i=new bie(s,a),o=!0,l=[a],u=this.runWebGLProgram(i,[r],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){const a=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=a;if(n!=null){const p=_e(s),m=n[0]*n[1]*4;q(p<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=bI(s);let l;r?l=new Ppt(o):l=new Bpt(o);const u=!0,c=[n??mI(o)],h=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,c,u,n);return{dtype:i,shape:s,dataId:h.dataId}}runWebGLProgram(t,n,a,r,s=!1,i){const o=this.makeTensorInfo(t.outputShape,a),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Dw.DENSE){const v=i??mI(t.outputShape);l.texShape=v.map(w=>w*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),_e(o.shape)===0)return l.values=Mr(o.dtype,0),o;const u=[],c=n.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(w.texture==null){if(!t.packedInputs&&_e(v.shape)<=Ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};t.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!t.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),u.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!ZN(w.shape,v.shape)){const S=v,k=v.shape;v.shape=w.shape,v=this.packedReshape(v,k),u.push(v),w=this.texData.get(v.dataId),S.shape=k}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(o.dataId);const h={shape:o.shape,texData:l,isUniform:!1},p=zpt(t,c,h),m=this.getAndSaveBinary(p,()=>Mpt(this.gpgpu,t,c,h)),g=this.activeTimers!=null;let y;g&&(y=this.startTimer()),Ie().get("ENGINE_COMPILE_ONLY")||Lpt(this.gpgpu,m,c,h,r),u.forEach(v=>this.disposeIntermediateTensorInfo(v)),g&&(y=this.endTimer(y),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(y)}));const b=Ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(b>0){const v=xs();v-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!Ie().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){const v=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),v}return o}compileAndRun(t,n,a,r,s=!1){return a=a||n[0].dtype,this.runWebGLProgram(t,n,a,r,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Se(()=>{if(!Ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Ie().getBool("DEBUG");Ie().set("DEBUG",!1);const n=this.abs(kt(1e-8)).dataSync()[0];if(Ie().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?bmt:xmt}uploadToGPU(t){const n=this.texData.get(t),{shape:a,dtype:r,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;const u=this.activeTimers!=null;let c;u&&(c=xs());let h=n.texShape;if(h==null&&(h=Gdt(a,l),n.texShape=h),s!=null){const p=bI(a);let m,g=h[1],y=h[0];const b=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!b)&&([g,y]=m0(h[0],h[1])),l?m=new Gpt(p,b):m=new Ej(p,b);const v=b?[y,g]:h,w=this.makeTensorInfo(v,r),S=this.texData.get(w.dataId);b?S.usage=eo.PIXELS:S.usage=eo.UPLOAD,S.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),g,y,s);const k=[[y,g]],T=this.runWebGLProgram(m,[w],r,k,!0),E=this.texData.get(T.dataId);n.texShape=E.texShape,n.isPacked=E.isPacked,n.usage=E.usage,Ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(T.dataId):(n.texture=E.texture,n.values=null,this.texData.delete(T.dataId)),this.disposeIntermediateTensorInfo(w),u&&(this.uploadWaitMs+=xs()-c)}else{const p=this.acquireTexture(h,o,r,l);n.texture=p}}convertAndCacheOnCPU(t,n){const a=this.texData.get(t),{dtype:r}=a;return n!=null&&(a.values=kmt(n,r)),a.values}acquireTexture(t,n,a,r){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*yw(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const a=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(s){throw s}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await bP(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(aie(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:n,customUniformLocations:a,infLoc:r,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=lie(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=a,t.infLoc=r,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,a){t.channels=t.channels||"RGBA";const{texture:r,height:s,width:i,channels:o}=t,l=tl().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,n,a,s,i,o);return tl().makeTensorFromDataId(u,n,a,l)}}qE.nextDataId=0;function kmt(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<n.length;++a)n[a]=Math.round(e[a]);return n}else throw new Error(`Unknown dtype ${t}`)}jz()&&Kz("webgl",()=>new qE,2);const S4=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class af{constructor(t,n,a){this.variableNames=["A","B"],this.outputShape=Mt(n,a),this.enableShapeUniforms=gs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Xm=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class v0{constructor(t,n,a,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Mt(n,a);const s=this.outputShape.length;this.enableShapeUniforms=gs(s);let i="";if(r)if(s===0||_e(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Hn(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Ns("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}function Mi(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const Imt={kernelName:Rx,backendName:"webgl",kernelFunc:Mi};function wd(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(s.dataId),o=Mi({inputs:{x:a},backend:n}),l=Mi({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:l},s}const Nmt={kernelName:HC,backendName:"webgl",kernelFunc:wd};const xie="return (a < 0.) ? b * a : a;",vie=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Cmt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,i=n.makeTensorInfo([],"float32",gc(s,"float32")),o=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v0(vie,r.shape,i.shape):new af(xie,r.shape,i.shape),l=n.runWebGLProgram(o,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const Tmt={kernelName:pA,backendName:"webgl",kernelFunc:Cmt};const wie="return (a < 0.) ? b * a : a;",Aie=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Emt(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v0(Aie,a.shape,r.shape):new af(wie,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}const $mt={kernelName:RA,backendName:"webgl",kernelFunc:Emt};const w0="if (isnan(x)) return x;";function gn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{const{x:i}=r,o=s,l=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const h=o.texData.get(i.dataId),p=n(h.values,l);return o.makeTensorInfo(i.shape,l,p)}const u=Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let c;return u?c=new fh(i.shape,t):c=new Hl(i.shape,e),o.runWebGLProgram(c,[i],l)}}function ns({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(a&&l.dtype==="complex64"){const g=c.texData.get(l.dataId),y=c.texData.get(u.dataId),[b,v]=[[g.complexTensorInfos.real,y.complexTensorInfos.real],[g.complexTensorInfos.imag,y.complexTensorInfos.imag]].map(S=>{const[k,I]=S,T={dataId:k.dataId,dtype:k.dtype,shape:l.shape},E={dataId:I.dataId,dtype:I.dtype,shape:u.shape},R=new af(e,l.shape,u.shape);return c.runWebGLProgram(R,[T,E],ei(k.dtype,I.dtype))}),w=wd({inputs:{real:b,imag:v},backend:c});return c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(v),w}const h=s||ei(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const g=c.texData.get(l.dataId).values,y=c.texData.get(u.dataId).values,b=l.dtype==="string"?sc(g):g,v=l.dtype==="string"?sc(y):y,[w,S]=r(l.shape,u.shape,b,v,h),k=c.makeTensorInfo(S,h),I=c.texData.get(k.dataId);return I.values=w,k}const p=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let m;return p?m=new v0(t,l.shape,u.shape,n):m=new af(e,l.shape,u.shape),c.runWebGLProgram(m,[l,u],h)}}function Ow(e,t=!1){if(e==="linear")return t?hmt:imt;if(e==="relu")return t?pmt:lmt;if(e==="elu")return t?dmt:omt;if(e==="relu6")return t?fmt:umt;if(e==="prelu")return t?Aie:wie;if(e==="leakyrelu")return t?vie:xie;if(e==="sigmoid")return t?mmt:cmt;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Sie{constructor(t,n,a,r=!1,s=!1,i=!1,o=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.enableShapeUniforms=gs(this.outputShape.length);const c=r?t[1]:t[2],h=Math.ceil(c/2),p=r?"i * 2, rc.y":"rc.y, i * 2",m=s?"rc.z, i * 2":"i * 2, rc.z",g=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],y=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let b="",v="";o&&(l?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:b=`vec4 activation(vec4 x) {
          ${o}
        }`,v="result = activation(result);");const w=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let S="rc.x",k="rc.x";t[0]<n[0]?S=`imod(rc.x, ${t[0]})`:n[0]<t[0]&&(k=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${b}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${S};
        int batchB = ${k};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${y[0]});
          result += (${g[1]} * ${y[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${v}

        setOutput(result);
      }
    `}}const Oj={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Fj{constructor(t,n,a){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Mt(n,a),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const Mj="return a * b;";function k4(e){const{inputs:t,backend:n}=e,{a,b:r}=t,s=ei(a.dtype,r.dtype);if(a.dtype==="complex64"){const o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),u=new Fj(Oj.REAL,a.shape,r.shape),c=new Fj(Oj.IMAG,a.shape,r.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],p=n.runWebGLProgram(u,h,"float32"),m=n.runWebGLProgram(c,h,"float32"),g=wd({inputs:{real:p,imag:m},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}if(n.shouldExecuteOnCPU([a,r])){const o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),[u,c]=Eft(a.shape,r.shape,o.values,l.values,s),h=n.makeTensorInfo(c,s),p=n.texData.get(h.dataId);return p.values=u,h}let i;return Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new v0(Mj,a.shape,r.shape):i=new af(Mj,a.shape,r.shape),n.runWebGLProgram(i,[a,r],s)}const _mt={kernelName:Vx,backendName:"webgl",kernelFunc:k4};function Rmt(e,t,n){const a=[zy(e.shape),...By(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[zy(t),...By(t)],i=new bie(s,a),o=!0,l=[a],u=n.runWebGLProgram(i,[r],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function Je(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=n,o=_e(r.shape),l=zz(s,o),u=_e(l);q(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(r.dataId);return c.isPacked&&!ZN(r.shape,l)&&!(c.texture!==null&&ZN(c.shape,l))?Rmt(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const Dmt={kernelName:OA,backendName:"webgl",kernelFunc:Je};class Lj{constructor(t,n){this.variableNames=["x"];const{windowSize:a,batchSize:r,inSize:s,outSize:i}=t;this.outputShape=[r,i];const o=Math.floor(a/4)*4,l=a%4;let u="sumValue += dot(values, ones);";if(n!=null){const h=1/n;u=`sumValue += dot(values * ${Wp(h)?h.toPrecision(2):h}, ones);`}let c="";s%a>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}class Omt{constructor(t,n){this.variableNames=["x"];const{windowSize:a,batchSize:r,inSize:s,outSize:i}=t;this.outputShape=[r,i];let o="0.0",l="";n==="prod"?o="1.0":n==="min"?(o="1.0 / 1e-20",l="min"):n==="max"&&(o="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");const c=Math.floor(a/4)*4,h=a%4;let p=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";n==="all"?(o="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):n==="any"&&(o="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let g="";s%a>0&&(g=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}function Fmt(e){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const n=t.length?t[t.length-1].outSize:e[1],a=_E(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function Ym(e,t,n,a){const r=Fmt(e.shape);let s=e;for(let i=0;i<r.length;i++){const{inSize:o,windowSize:l,outSize:u}=r[i];let c,h;n==="mean"?c=i===0?new Lj({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new Lj({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new Omt({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=s,s=a.runWebGLProgram(c,[s],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return s}class Mmt{constructor(t,n){this.variableNames=["A"];const a=new Array(t.length);for(let i=0;i<a.length;i++)a[i]=t[n[i]];this.outputShape=a,this.rank=a.length;const r=Hn(this.rank),s=Lmt(n);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}}function Lmt(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}class zmt{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const a=new Array(t.length);for(let c=0;c<a.length;c++)a[c]=t[n[c]];if(this.outputShape=a,this.rank=a.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Hn(this.rank),s=yie("rc",this.rank),i=new Array(this.rank);for(let c=0;c<n.length;c++)i[n[c]]=s[c];const o=`vec2(${i.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${a[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${a[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}function KE(e,t,n){const a=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zmt(e.shape,t):new Mmt(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function Bmt(e,t,n,a){const r=t,s=e.shape.length,i=Zt(r,e.shape);let o=i;const l=$a(o,s),u=l!=null;let c=e;u&&(c=KE(e,l,a),o=Ua(o.length,s)),es("sum",o,s);const[h,p]=Pr(c.shape,o);let m=h;n&&(m=Ba(h,i));const g=_e(p),b=_e(e.shape)/g,v=Je({inputs:{x:c},attrs:{shape:[b,g]},backend:a}),w=HT(e.dtype),S=Ym(v,w,"sum",a),k=Je({inputs:{x:S},attrs:{shape:m},backend:a});return a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(S),u&&a.disposeIntermediateTensorInfo(c),k}function XE(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;return Bmt(r,s,i,n)}const Pmt={kernelName:PA,backendName:"webgl",kernelFunc:XE};function Rs(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,i=n,o=r.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=r.shape[s[c]];let u;if(i.shouldExecuteOnCPU([r])){const h=i.texData.get(r.dataId).values,p=A4(h,r.shape,r.dtype,s,l);u=i.makeTensorInfo(l,r.dtype);const m=i.texData.get(u.dataId);m.values=p}else u=KE(r,s,i);return u}const Vmt={kernelName:bp,backendName:"webgl",kernelFunc:Rs};const kie=1e3;function JN({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,h=n?e.shape[u-2]:e.shape[u-1],p=a?t.shape[c-1]:t.shape[c-2],m=n?e.shape[u-1]:e.shape[u-2],g=a?t.shape[c-2]:t.shape[c-1],y=e.shape.slice(0,-2),b=t.shape.slice(0,-2),v=_e(y),w=_e(b),k=Mt(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([m,g]);q(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);const I=n?[v,h,m]:[v,m,h],T=a?[w,g,p]:[w,p,g],E=Je({inputs:{x:e},backend:r,attrs:{shape:I}}),R=Je({inputs:{x:t},backend:r,attrs:{shape:T}}),D=[E,R],O=Math.max(v,w),$=n?E.shape[1]:E.shape[2],_=s!=null,P=i!=null,U=l==="leakyrelu",W=l!=null?Ow(l,!0):null,B=_||P||U||W!=null;let H;if((m===1||g===1)&&$>kie&&B===!1){let Z=E,te=R;n&&(Z=Rs({inputs:{x:E},backend:r,attrs:{perm:[0,2,1]}}),D.push(Z)),a&&(te=Rs({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),D.push(te));const V=g!==1,Q=g===1;let ee=Z;V&&(ee=Je({inputs:{x:Z},backend:r,attrs:{shape:[O,$,1]}}),D.push(ee));const ae=g===1?2:1;let de=te;Q&&(de=Je({inputs:{x:te},backend:r,attrs:{shape:[O,1,$]}}),D.push(de));const ke=k4({inputs:{a:ee,b:de},backend:r});H=XE({inputs:{x:ke},backend:r,attrs:{axis:ae,keepDims:!0}}),D.push(ke)}else{const Z=ei(e.dtype,t.dtype),te=new Sie(I,T,[O,m,g],n,a,_,W,P,U),V=[E,R];if(s!=null&&V.push(s),P&&V.push(i),U){const Q=r.makeTensorInfo([],"float32",gc(o,"float32"));V.push(Q),D.push(Q)}H=r.runWebGLProgram(te,V,Z)}const j=Je({inputs:{x:H},backend:r,attrs:{shape:k}});D.push(H);for(const Z of D)r.disposeIntermediateTensorInfo(Z);return j}function Umt(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=a;return JN({a:r,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}const Wmt={kernelName:bw,backendName:"webgl",kernelFunc:Umt};const zj="return abs(x);";function Gmt(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){const s=n.texData.get(a.dataId),i=mie(s.values);return n.makeTensorInfo(a.shape,a.dtype,i)}let r;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new fh(a.shape,zj):r=new Hl(a.shape,zj),n.runWebGLProgram(r,[a],a.dtype)}const Hmt={kernelName:H1,backendName:"webgl",kernelFunc:Gmt};const jmt=Ho+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,qmt=gn({opSnippet:jmt}),Kmt={kernelName:dx,backendName:"webgl",kernelFunc:qmt};const Xmt=Ho+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Ymt=gn({opSnippet:Xmt}),Qmt={kernelName:px,backendName:"webgl",kernelFunc:Ymt};const Bj="return a + b;",Zmt=ns({opSnippet:Bj,packedOpSnippet:Bj,supportsComplex:!0,cpuKernelImpl:lft}),Jmt={kernelName:Pm,backendName:"webgl",kernelFunc:Zmt};class egt{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((s,i)=>`T${i}`);const a=[];this.variableNames.forEach(s=>{a.push(`float v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${a.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class tgt{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((s,i)=>`T${i}`);const a=[];this.variableNames.forEach(s=>{a.push(`vec4 v${s} = get${s}AtOutCoords();`)});const r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${a.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function HI(e){const{inputs:t,backend:n}=e,a=t;if(a.length===1)return Mi({inputs:{x:a[0]},backend:n});if(a.length>Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(a.length/2),u=HI({inputs:a.slice(0,l),backend:n}),c=HI({inputs:a.slice(l),backend:n});return HI({inputs:[u,c],backend:n})}const r=a.map(l=>l.dtype).reduce((l,u)=>ei(l,u)),s=a.map(l=>l.shape),o=Ie().getBool("WEBGL_PACK")?new tgt(a[0].shape,s):new egt(a[0].shape,s);return n.runWebGLProgram(o,a,r)}const ngt={kernelName:j1,backendName:"webgl",kernelFunc:HI};function agt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=Zt(s,r.shape);let u=l;const c=$a(u,o);let h=r;c!=null&&(h=Rs({inputs:{x:r},backend:n,attrs:{perm:c}}),u=Ua(u.length,o)),es("all",u,o);const[p,m]=Pr(h.shape,u),g=_e(m),y=Je({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=Ym(y,y.dtype,"all",n);let v;if(i){const w=Ba(p,l);v=Je({inputs:{x:b},backend:n,attrs:{shape:w}})}else v=Je({inputs:{x:b},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),c!=null&&n.disposeIntermediateTensorInfo(h),v}const rgt={kernelName:BC,backendName:"webgl",kernelFunc:agt};function sgt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=Zt(s,r.shape);let u=l;const c=$a(u,o);let h=r;c!=null&&(h=Rs({inputs:{x:r},backend:n,attrs:{perm:c}}),u=Ua(u.length,o)),es("any",u,o);const[p,m]=Pr(h.shape,u),g=_e(m),y=Je({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=Ym(y,y.dtype,"any",n);let v;if(i){const w=Ba(p,l);v=Je({inputs:{x:b},backend:n,attrs:{shape:w}})}else v=Je({inputs:{x:b},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),c!=null&&n.disposeIntermediateTensorInfo(h),v}const igt={kernelName:PC,backendName:"webgl",kernelFunc:sgt};class ogt{constructor(t,n,a){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:i}=t;a||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];const o=n==="max"?">":"<",l=a?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class lgt{constructor(t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,q(t.length>2,()=>`Packed arg${a.charAt(0).toUpperCase()+a.slice(1)} supports only inputs with rank above 2.`);const s=t[t.length-1],i=Math.ceil(s/n);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=Hn(l),c=Ns("coords",l);let h,p;if(i===1){p=l+1;const R=Hn(p);h=`
        ${R} sourceLocR = ${R}(${c.join()}, 0);
        ++${c[l-1]};
        ${R} sourceLocG = ${R}(${c.join()}, 0);
        ++${c[l-2]};
        ${R} sourceLocA = ${R}(${c.join()}, 0);
        --${c[l-1]};
        ${R} sourceLocB = ${R}(${c.join()}, 0);
        --${c[l-2]};`}else p=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const m=["x","y","z","w","u","v"].slice(0,p),g="."+m[p-1],y=m.map(R=>"int "+R),b=Ns("sourceLocR",p-1).concat("inIdx.r"),v=Ns("sourceLocG",p-1).concat("inIdx.g"),w=Ns("sourceLocB",p-1).concat("inIdx.b"),S=Ns("sourceLocA",p-1).concat("inIdx.a"),k=a==="max"?"greaterThan":"lessThan",I=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()})));`,T=`vec4(
            getAChannel(${b.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,E=r?"":`
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${y.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${o[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${T};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${T};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function Iie(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];a!=null&&(r=a.shape[0],s=a.shape[1]);const i=_E(s),o={windowSize:i,inSize:s,batchSize:r,outSize:Math.ceil(s/i)},l=new ogt(o,n,a==null),u=[t];a!=null&&u.push(a);const c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=Iie(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function Nie(e,t,n,a=null){const r=a!=null?a.shape:t.shape,s=r[r.length-1],i=_E(s),o=new lgt(r,i,n,a==null),l=a==null?[t]:[t,a],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){const c=Nie(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function Cie(e,t,n,a){const r=[n];if(es("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!Ie().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked;let l=t;o&&(l=e.unpackTensor(t),s.push(l));const[u,c]=Pr(l.shape,r),h=_e(c),p=Je({inputs:{x:l},backend:e,attrs:{shape:[-1,h]}});s.push(p);const m=Iie(e,p,a);s.push(m);const g=Je({inputs:{x:m},backend:e,attrs:{shape:u}});return s.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}return Nie(e,t,a)}function ugt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let i=Zt(s,r.shape);const o=$a(i,r.shape.length);let l=r;const u=[];o!=null&&(l=Rs({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=Ua(i.length,l.shape.length)),es("argMax",[i[0]],l.shape.length);const c=Cie(n,l,i[0],"max");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const cgt={kernelName:q1,backendName:"webgl",kernelFunc:ugt};function hgt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let i=Zt(s,r.shape);const o=$a(i,r.shape.length);let l=r;const u=[];o!=null&&(l=Rs({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=Ua(i.length,l.shape.length)),es("argMin",[i[0]],l.shape.length);const c=Cie(n,l,i[0],"min");return u.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const dgt={kernelName:K1,backendName:"webgl",kernelFunc:hgt};const pgt=Ho+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,fgt=gn({opSnippet:pgt}),mgt={kernelName:fx,backendName:"webgl",kernelFunc:fgt};const ggt=Ho+"return log(x + sqrt(x * x + 1.0));",ygt=gn({opSnippet:ggt}),bgt={kernelName:mx,backendName:"webgl",kernelFunc:ygt};const xgt=Ho+`
  return atan(x);
`,vgt=gn({opSnippet:xgt}),wgt={kernelName:gx,backendName:"webgl",kernelFunc:vgt};const Agt=S4+`
  return atan(a, b);
`,Sgt=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xm+`
  return result;
`,kgt=ns({opSnippet:Agt,packedOpSnippet:Sgt}),Igt={kernelName:bx,backendName:"webgl",kernelFunc:kgt};const Ngt=Ho+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Cgt=gn({opSnippet:Ngt}),Tgt={kernelName:yx,backendName:"webgl",kernelFunc:Cgt};class Fw{constructor(t,n,a,r=!1,s=!1){if(this.variableNames=["x"],n==="avg"&&a)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.top,g=t.padInfo.left;this.outputShape=t.outShape;const y=n==="avg",b=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,v=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let w="0.0";if(y||(w="-1.0 / 1e-20"),a){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${m}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?b:v:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let k=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(k="avgValue / max(count, 1.0)");const I=Math.floor(i/4)*4,T=i%4,E=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${m}, ${g});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${I};
          if (${T===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${T===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${T===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${k});
      }
    `}}class I4{constructor(t,n,a,r=!1,s=!1){if(this.variableNames=["x"],n==="avg"&&a)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,p=t.dilationWidth,m=t.effectiveFilterDepth,g=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=t.padInfo.front,v=t.padInfo.top,w=t.padInfo.left;this.outputShape=t.outShape;const S=n==="avg";let k="0.0";if(S||(k="-1.0 / 1e-20"),a){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${u});
        const ivec3 pads = ivec3(${b}, ${v}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${y};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${g} * ${y} +
                      wR * ${y} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let T=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(T="avgValue / max(count, 1.0)");const E=Math.floor(i/4)*4,R=i%4,D=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${u});
      const ivec3 pads = ivec3(${b}, ${v}, ${w});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${E};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${T});
      }
    `}}function Egt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;CS(r,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;q(Jr(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Wo(r.shape,s,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&tn(c.inShape,c.outShape))return Mi({inputs:{x:r},backend:n});const h=new Fw(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}const $gt={kernelName:X1,backendName:"webgl",kernelFunc:Egt};function _gt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,c=[1,1,1],h=yc(r.shape,s,i,c,o,l,u),p=new I4(h,"avg",!1);return n.runWebGLProgram(p,[r],"float32")}const Rgt={kernelName:Y1,backendName:"webgl",kernelFunc:_gt};class Dgt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,a=t.filterWidth,r=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,h=u-1-t.padInfo.left,p=1/(n*a);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Ogt{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,a=t.filterHeight,r=t.filterWidth,s=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,h=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=h-1-t.padInfo.front,y=p-1-t.padInfo.top,b=m-1-t.padInfo.left,v=1/(n*a*r);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Fgt(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=a,h=[1,1,1],p=yc(i.shape,o,l,h,u,c),m=new Ogt(p);return n.runWebGLProgram(m,[r],i.dtype)}const Mgt={kernelName:UC,backendName:"webgl",kernelFunc:Fgt};function Lgt(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;CS([r,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=a,c=Wo(i.shape,o,l,1,u),h=new Dgt(c);return n.runWebGLProgram(h,[r],i.dtype)}const zgt={kernelName:VC,backendName:"webgl",kernelFunc:Lgt};function Bgt(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return JN({a:r,b:s,transposeA:i,transposeB:o,backend:n})}const Pgt={kernelName:Q1,backendName:"webgl",kernelFunc:Bgt};class Vgt{constructor(t,n,a,r,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Mt(t,n),Mt(t,a);let o="0.0";r!=null&&(Mt(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";s!=null&&(Mt(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Ugt{constructor(t,n,a,r,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Mt(t,n),Mt(t,a);let o="vec4(0.0)";r!=null&&(Mt(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(Mt(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const Wgt=({inputs:e,backend:t,attrs:n})=>{const{x:a,mean:r,variance:s,offset:i,scale:o}=e;q(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[a,r,s];let c=null;i!=null&&(c=i.shape,u.push(i));let h=null;o!=null&&(h=o.shape,u.push(o));const p=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new Ugt(a.shape,r.shape,s.shape,c,h,l):new Vgt(a.shape,r.shape,s.shape,c,h,l);return t.runWebGLProgram(p,u,u[0].dtype)},Ggt={kernelName:cA,backendName:"webgl",kernelFunc:Wgt};class Hgt{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=Hn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const a=jgt(this.rank);let r;const s=t.map((i,o)=>`sourceLoc.${eF[o]} = start[${o}] + coords.${eF[o]};`);r=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${a}));
      }
    `}}const eF=["x","y","z","w","u","v"];function jgt(e){if(e===1)return"sourceLoc";if(e<=6)return eF.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}class qgt{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Hn(this.rank),a=Ns("coords",this.rank),r=Ns("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${s})`,o=`
      result.x = ${i};
      if (++${a[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${a[this.rank-1]};
      if (++${a[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${a[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((c,h)=>`start[${h}]`).join()});`:t.map((c,h)=>`${r[h]} = ${a[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}function Kgt(e,t,n,a){const r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=gP(t,St(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};const l=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,l+1),s}function A0(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a,[o,l]=$E(r,s,i);if(pP(r,o,l),_e(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=n.texData.get(r.dataId),p=Pft(h.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,p)}const{isPacked:u}=n.texData.get(r.dataId),c=mP(r.shape,o,l);if(u||!c){const h=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qgt(l):new Hgt(l),p=[o];return n.runWebGLProgram(h,[r],r.dtype,p)}return n.uploadToGPU(r.dataId),Kgt(r,o,l,n)}const Xgt={kernelName:BA,backendName:"webgl",kernelFunc:A0};const Ygt=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;q(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=s.reduce((w,S)=>w*S),l=fS(r.shape,s,o),u=mS(l.length,s.length),c=gS(r.shape,s,o),h=AP(i,s.length),p=SP(c,i,s.length),m=[],g=Je({inputs:{x:r},backend:n,attrs:{shape:l}}),y=Rs({inputs:{x:g},backend:n,attrs:{perm:u}}),b=Je({inputs:{x:y},backend:n,attrs:{shape:c}}),v=A0({inputs:{x:b},backend:n,attrs:{begin:h,size:p}});return m.push(g),m.push(y),m.push(b),m.forEach(w=>n.disposeIntermediateTensorInfo(w)),v},Qgt={kernelName:Z1,backendName:"webgl",kernelFunc:Ygt};function Zgt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=fie(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}const Jgt={kernelName:WC,backendName:"webgl",kernelFunc:Zgt};const eyt=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,tyt=`
  return float(int(a.r) & int(b.r));
`;function nyt(e){const{inputs:t,backend:n}=e,{a,b:r}=t,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=Ie().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||i===1){const l=n.texData.get(a.dataId).values,u=n.texData.get(r.dataId).values,[c,h]=cft(a.shape,r.shape,l,u,a.dtype),p=n.makeTensorInfo(h,a.dtype),m=n.texData.get(p.dataId);return m.values=c,p}let o;return s?o=new v0(eyt,a.shape,r.shape,!1):o=new af(tyt,a.shape,r.shape),n.runWebGLProgram(o,[a,r],a.dtype)}const ayt={kernelName:J1,backendName:"webgl",kernelFunc:nyt};function ryt(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),o=Mt(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const syt={kernelName:GC,backendName:"webgl",kernelFunc:ryt};const iyt="return float(a != b);",Tie=ns({opSnippet:iyt,cpuKernelImpl:_ft,dtype:"bool"}),oyt={kernelName:CA,backendName:"webgl",kernelFunc:Tie};function ES(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Mi({inputs:{x:r.complexTensorInfos.real},backend:n})}const lyt={kernelName:kT,backendName:"webgl",kernelFunc:ES};const uyt="return float(int(x));";function cyt(e,t){const n=new Hl(e.shape,uyt),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function tF(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return Mi({inputs:{x:r},backend:n});const i=Ya(r.shape),o=tF({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=wd({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(r.dtype==="complex64"){const i=ES({inputs:{input:r},backend:n}),o=tF({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!Bz(r.dtype,s)){const i=Mi({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([r])){const i=n.texData.get(r.dataId).values,[o,l,u]=hft(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}if(s==="int32")return cyt(r,n);if(s==="bool"){const i=n.makeTensorInfo([],"bool",Mr("bool",1)),l=Tie({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}const hyt={kernelName:xx,backendName:"webgl",kernelFunc:tF};const Pj="return ceil(x);",dyt=gn({opSnippet:Pj,packedOpSnippet:Pj,cpuKernelImpl:dft}),pyt={kernelName:vx,backendName:"webgl",kernelFunc:dyt};class fyt{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class myt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function gyt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a;let o;Ie().getBool("WEBGL_PACK_CLIP")?o=new myt(r.shape):o=new fyt(r.shape);const l=[[s],[i]];return n.runWebGLProgram(o,[r],r.dtype,l)}const yyt={kernelName:wx,backendName:"webgl",kernelFunc:gyt};class byt{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function Vj(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function xyt(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new byt(a.shape),i=[Vj(a,r.complexTensorInfos.real),Vj(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}const vyt={kernelName:eA,backendName:"webgl",kernelFunc:xyt};class wyt{constructor(t){this.outputShape=[],this.outputShape=Ql(t,1),this.variableNames=t.map((i,o)=>`T${o}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+t[i][1];const a=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const o=n[i-1];a.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const r=n.length,s=n[n.length-1];a.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${a.join(`
        `)}
      }
    `}}class Ayt{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ql(t,n);const a=this.outputShape,r=a.length,s=Hn(r),i=Ns("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((y,b)=>`T${b}`);const l=new Array(t.length-1);l[0]=t[0][n];for(let y=1;y<l.length;y++)l[y]=l[y-1]+t[y][n];const u=o[n],c=o.slice(-2),h=o.join();let p=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let y=1;y<l.length;y++){const b=l[y-1];p+=`
        if (${u} < ${l[y]}  && ${u} >= ${l[y-1]}) {
          return getChannel(
            getT${y}(${wI(o,u,b)}),
            vec2(${wI(c,u,b)}));
        }`}const m=l.length,g=l[l.length-1];p+=`
        return getChannel(
          getT${m}(${wI(o,u,g)}),
          vec2(${wI(c,u,g)}));`,this.userCode=`
      float getValue(${o.map(y=>"int "+y)}) {
        ${p}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${a[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${a[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${a[r-2]} &&
            ${i[r-1]} < ${a[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function wI(e,t,n){const a=e.indexOf(t);return e.map((s,i)=>i===a?`${s} - ${n}`:s).join()}function YE(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Mi({inputs:{x:r.complexTensorInfos.imag},backend:n})}const Syt={kernelName:cT,backendName:"webgl",kernelFunc:YE};function Gv(e,t,n){const a=e[0].dtype;if(a==="complex64"){const m=e.map(w=>ES({inputs:{input:w},backend:n})),g=e.map(w=>YE({inputs:{input:w},backend:n})),y=Gv(m,t,n),b=Gv(g,t,n),v=wd({inputs:{real:y,imag:b},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),v}let r=n.shouldExecuteOnCPU(e);if(a==="string"&&(r=!0),r){const m=e.map(k=>{const T=[-1,_e(k.shape.slice(t))];return Je({inputs:{x:k},backend:n,attrs:{shape:T}})}),g=m.map(k=>({vals:n.readSync(k.dataId),shape:k.shape})),y=Ql(m.map(k=>k.shape),1),b=m[0].shape[0]===1,v=pft(g,y,a,b),w=Ql(e.map(k=>k.shape),t),S=n.makeTensorInfo(w,a,v);return m.forEach(k=>n.disposeIntermediateTensorInfo(k)),S}const s=e.filter(m=>_e(m.shape)>0),i=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){const m=i?new Hl(e[0].shape,ih):new fh(e[0].shape,ih);return n.runWebGLProgram(m,e,a)}const o=Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const m=[];for(let y=0;y<s.length;y+=o){const b=s.slice(y,y+o);m.push(Gv(b,t,n))}const g=Gv(m,t,n);for(const y of m)n.disposeIntermediateTensorInfo(y);return g}if(i){const m=new Ayt(s.map(g=>g.shape),t);return n.runWebGLProgram(m,s,a)}const{tensors2D:l,outShape:u}=kyt(s,t,n),c=new wyt(l.map(m=>m.shape)),h=n.runWebGLProgram(c,l,a);l.forEach(m=>n.disposeIntermediateTensorInfo(m));const p=Je({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),p}function kyt(e,t,n){const a=Ql(e.map(s=>s.shape),t);return{tensors2D:e.map(s=>Je({inputs:{x:s},attrs:{shape:[-1,_e(s.shape.slice(t))]},backend:n})),outShape:a}}function Eie(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=Zt(r,t[0].shape)[0],i=t.map(u=>u.shape);xP(i,s);const o=Ql(t.map(u=>u.shape),s);if(_e(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(u=>_e(u.shape)>0);return l.length===1?Mi({inputs:{x:l[0]},backend:n}):Gv(l,s,n)}const Iyt={kernelName:tA,backendName:"webgl",kernelFunc:Eie};class $ie{constructor(t,n=!1,a=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,o=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,p=t.filterHeight,m=t.filterWidth,g=Math.floor(t.inChannels/4)*4,y=t.inChannels%4,b=t.dataFormat==="channelsLast",v=b?1:2,w=b?2:3,S=b?3:1;let k="",I="";a&&(r?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:s?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:k=`
          float activation(float x) {
            ${a}
          }
        `,I="result = activation(result);");const T=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${b}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${y===1}) {

              if (${b}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${y===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${b}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${y===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${b}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${T}
        ${I}
        setOutput(result);
      }
    `}}class Nyt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,a=t.padInfo.top,r=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,h=t.filterDepth,p=t.filterHeight,m=t.filterWidth,g=Math.floor(t.inChannels/4)*4,y=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${a}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${y===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${y===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${y===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class _ie{constructor(t,n=!1,a=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=gs(this.outputShape.length);const i=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,h=c;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<c;b++)p+=`
           vec4 xTexelC${b*2};
           int xTexelC${b*2}Ready;
           vec4 xTexelC${b*2+1};
           int xTexelC${b*2+1}Ready;
           vec4 xC${b};`;p+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let b=0;b<c;b++)p+=`
           xTexelC${b*2} = vec4(0.0);
           xTexelC${b*2}Ready = 0;
           xTexelC${b*2+1} = vec4(0.0);
           xTexelC${b*2+1}Ready = 0;
           xC${b} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let b=0;b<(h+1)/2;b++){const v=b*2;if(p+=`
           xC = xCCorner + ${v*l};
           `,o===1){if(v<c&&(i%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,l===1&&v>0?p+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<c)){const w=i%2===0?LC(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:p+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):w===1?p+=`
                     xC${v+1} = xTexelC${v};
                     `:p+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<c&&(i%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<c&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<c&&(p+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<c&&(p+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<c&&(p+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let m="",g="";a&&(r?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${a}
         }`:s?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${a}
         }`:m=`vec4 activation(vec4 x) {
           ${a}
         }`,g="result = activation(result);");const y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${y}
         ${g}
         setOutput(result);
       }
     `}}class Cyt{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=gs(this.outputShape.length);const{dataFormat:a}=n,r=zs(),s=a==="channelsLast",i=s?1:2,o=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}function e2(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function Rie({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=a.texData.get(e.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],p=n.outChannels,m=n.dataFormat==="channelsLast",g=!1,y=!1;let b;const v=[];if(s!=null){const k=e2(s.shape,m);k!=null&&(s=Je({inputs:{x:s},backend:a,attrs:{shape:k}}),v.push(s))}if(r!=null){const k=e2(r.shape,m);k!=null&&(r=Je({inputs:{x:r},backend:a,attrs:{shape:k}}),v.push(r))}if(!((h===1||p===1)&&c>kie)&&u.isPacked&&m&&u.texture!=null&&l[2]%2!==0&&tn(u.shape.slice(-3),l.slice(-3))){const k=l[0]*l[1]*(l[2]+1),I={dataId:e.dataId,shape:[1,k,n.inChannels],dtype:e.dtype},T=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,q(ZN(u.shape,I.shape),()=>`packed reshape ${u.shape} to ${I.shape} isn't free`);const E=Je({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});v.push(E);const R=JN({a:I,b:E,backend:a,transposeA:g,transposeB:y,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),D=a.texData.get(R.dataId);q(D.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=T,D.shape=n.outShape,b=Mi({inputs:{x:R},backend:a}),b.shape=n.outShape,v.push(R)}else{const k=n.outHeight*n.outWidth,I=Je({inputs:{x:e},backend:a,attrs:{shape:m?[n.batchSize,k,n.inChannels]:[n.batchSize,n.inChannels,k]}}),T=Je({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),E=JN({a:m?I:T,b:m?T:I,transposeA:!m,transposeB:y,backend:a,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i});b=Je({inputs:{x:E},backend:a,attrs:{shape:n.outShape}}),v.push(I),v.push(T),v.push(E)}for(const k of v)a.disposeIntermediateTensorInfo(k);return b}function Die({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:p,dataFormat:m}=n,g=m==="channelsLast",y=l*u*c,b=p*h,v=[n.batchSize,y,b],w=!0,S=!1,k=[];if(s!=null){const j=e2(s.shape,g);j!=null&&(s=Je({inputs:{x:s},backend:a,attrs:{shape:j}}),k.push(s))}if(r!=null){const j=e2(r.shape,g);j!=null&&(r=Je({inputs:{x:r},backend:a,attrs:{shape:j}}),k.push(r))}const I=Je({inputs:{x:t},backend:a,attrs:{shape:[1,y,_e(t.shape)/y]}});k.push(I);const T=new Cyt(v,n),E=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],R=a.runWebGLProgram(T,[e],"float32",E),D=Je({inputs:{x:R},backend:a,attrs:{shape:v}});k.push(R),k.push(D);const O=r!=null,$=s!=null,_=o==="leakyrelu",P=o?Ow(o,!0):null,U=new Sie(g?D.shape:I.shape,g?I.shape:D.shape,g?[n.batchSize,b,n.outChannels]:[n.batchSize,n.outChannels,b],w,S,O,P,$,_),W=g?[D,I]:[I,D];if(r&&W.push(r),$&&W.push(s),_){const j=a.makeTensorInfo([],"float32",gc(i,"float32"));W.push(j),k.push(j)}const B=a.runWebGLProgram(U,W,"float32"),H=Je({inputs:{x:B},backend:a,attrs:{shape:n.outShape}});k.push(B);for(const j of k)a.disposeIntermediateTensorInfo(j);return H}function Tyt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=a,h=bc(l),p=Br(r.shape,s.shape,i,u,o,c,!1,h);let m;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))m=Rie({x:r,filter:s,convInfo:p,backend:n});else if(p.strideWidth<=2&&h==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){const y=new _ie(p),b=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];m=n.runWebGLProgram(y,[r,s],"float32",b)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))m=Die({x:r,filter:s,convInfo:p,backend:n});else{const y=new $ie(p);m=n.runWebGLProgram(y,[r,s],"float32")}const g=Je({inputs:{x:m},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(m),g}const Eyt={kernelName:nA,backendName:"webgl",kernelFunc:Tyt};class $yt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,a=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${a} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class _yt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,a=t.filterWidth,r=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",o=n-1-t.padInfo.top,l=a-1-t.padInfo.left,u=i?1:2,c=i?2:3,h=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${a} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Ryt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideDepth,a=t.strideHeight,r=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,o=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${a} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Dyt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,a=t.filterHeight,r=t.filterWidth,s=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=n-1-t.padInfo.front,u=a-1-t.padInfo.top,c=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${a}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${a} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Oyt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=a,h=bc(l),p=Br(r.shape,c,i,1,o,u,!1,h),m=new $yt(p);return n.runWebGLProgram(m,[r,s],"float32")}const Fyt={kernelName:jC,backendName:"webgl",kernelFunc:Oyt};class Myt{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=gs(this.outputShape.length);const n=t.filterHeight,a=t.filterWidth,r=n-1-t.padInfo.top,s=a-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            int wCPerm = ${a} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Lyt(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=a,h=bc(u),p=Br(i,s.shape,o,1,l,c,!1,h);if(Ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const m=[[p.strideHeight,p.strideWidth]],g=new Myt(p);return n.runWebGLProgram(g,[r,s],"float32",m)}else{const m=new _yt(p);return n.runWebGLProgram(m,[r,s],"float32")}}const zyt={kernelName:aA,backendName:"webgl",kernelFunc:Lyt};function Byt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=pd(r.shape,s.shape,i,l,o),c=new Nyt(u);return n.runWebGLProgram(c,[r,s],"float32")}const Pyt={kernelName:rA,backendName:"webgl",kernelFunc:Byt};function Vyt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a,u=pd(r.shape,l,i,1,o),c=new Ryt(u);return n.runWebGLProgram(c,[r,s],"float32")}const Uyt={kernelName:qC,backendName:"webgl",kernelFunc:Vyt};function Wyt(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a,u=pd(l,s.shape,o,1,i),c=new Dyt(u);return n.runWebGLProgram(c,[r,s],"float32")}const Gyt={kernelName:KC,backendName:"webgl",kernelFunc:Wyt};const Hyt=w0+`
  return cos(x);
`,jyt=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Xm}
  return result;
`,qyt=gn({opSnippet:Hyt,packedOpSnippet:jyt}),Kyt={kernelName:Ax,backendName:"webgl",kernelFunc:qyt};const Xyt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Yyt=gn({opSnippet:Xyt}),Qyt={kernelName:Sx,backendName:"webgl",kernelFunc:Yyt};class Zyt{constructor(t,n,a,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,l,u]=t,[c]=n,[h,p]=a;this.outputShape=[c,h,p,u];const m=r==="bilinear"?1:0,[g,y]=[`${o-1}.0`,`${l-1}.0`],[b,v,w]=h>1?[`${(o-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[S,k,I]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${y} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${y}`];this.userCode=`
      const float height_ratio = float(${b});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${k};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const Jyt=e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,c=new Zyt(r.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[r,s,i],"float32")},ebt={kernelName:YC,backendName:"webgl",kernelFunc:Jyt};var Mw;(function(e){e.Prod="*",e.Sum="+"})(Mw||(Mw={}));class Uj{constructor(t,n,a,r){this.op=t,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,i=this.op===Mw.Prod?"1.0":"0.0",o=a?i:`getX(${Wj(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";a?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Hn(s)} coords = getOutputCoords();
        int end = ${Gj(s,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${Gj(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${Wj(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Wj(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Gj(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Oie(e,t,n,a,r,s){const i=t.shape.length,o=$a([a],i);let l=t;o!=null&&(l=Rs({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=Ua(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);const c=l.shape[u];let h=Mi({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){const m=new Uj(e,l.shape,!1,s),g=[[p]],y=h;h=n.runWebGLProgram(m,[h],h.dtype,g),n.disposeIntermediateTensorInfo(y)}if(r){const p=new Uj(e,l.shape,r,s),m=h;h=n.runWebGLProgram(p,[h],h.dtype),n.disposeIntermediateTensorInfo(m)}if(o!=null){const p=fd(o),m=Rs({inputs:{x:h},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),m}return h}function tbt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return Oie(Mw.Prod,r,n,s,i,o)}const nbt={kernelName:XC,backendName:"webgl",kernelFunc:tbt};function abt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return Oie(Mw.Sum,r,n,s,i,o)}const rbt={kernelName:sA,backendName:"webgl",kernelFunc:abt};function sbt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){const l=n.readSync(r.dataId),u=n.readSync(s.dataId),c=fie(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){const l=n.bufferSync(r),u=n.bufferSync(s),c=uft(l,u,i,o);return n.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const ibt={kernelName:QC,backendName:"webgl",kernelFunc:sbt};class obt{constructor(t,n,a){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=a,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function lbt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],u=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],h=l*s,p=u*s,m=c/(s*s),g=i==="NHWC"?[o,h,p,m]:[o,m,h,p],y=new obt(g,s,i);return n.runWebGLProgram(y,[r],r.dtype)}const ubt={kernelName:ZC,backendName:"webgl",kernelFunc:lbt};class Fie{constructor(t,n=!1,a=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=gs(this.outputShape.length);const i=t.filterHeight,o=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";a&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:u=`
          float activation(float x) {
            ${a}
          }
        `,c="result = activation(result);");const h=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}class Mie{constructor(t,n=!1,a=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=gs(this.outputShape.length);const i=t.outChannels/t.inChannels,o=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,p=h;let m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<h;v++)m+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;m+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let v=0;v<h;v++)m+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(p+1)/2;v++){const w=v*2;if(m+=`
          xC = xCCorner + ${w*u};
          `,l===1){if(w<h&&(o%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,u===1&&w>0?m+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<h)){const S=o%2===0?LC(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,u>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:m+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):S===1?m+=`
                    xC${w+1} = xTexelC${w};
                    `:m+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<h&&(o%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<h&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<h&&(m+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<h&&(m+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<h&&(m+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let g="",y="";a&&(r?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:s?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${b}
        ${y}
        setOutput(result);
      }
    `}}function cbt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a;let c=l;c==null&&(c=[1,1]),q(Jr(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=Br(r.shape,s.shape,i,c,o,u,!0);let p;Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?p=new Mie(h):p=new Fie(h);const m=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(p,[r,s],"float32",m)}const hbt={kernelName:iA,backendName:"webgl",kernelFunc:cbt};class dbt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,a=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${a} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class pbt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,a=t.filterWidth,r=t.strideHeight,s=t.strideWidth,i=n-1-t.padInfo.top,o=a-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${a} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function fbt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=a,h=Br(r.shape,c,i,o,l,u,!0),p=new dbt(h);return n.runWebGLProgram(p,[r,s],"float32")}const mbt={kernelName:JC,backendName:"webgl",kernelFunc:fbt};function gbt(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=a,h=Br(c,s.shape,i,o,l,u,!0),p=new pbt(h);return n.runWebGLProgram(p,[r,s],"float32")}const ybt={kernelName:eT,backendName:"webgl",kernelFunc:gbt};class bbt{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function xbt(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=_e(a.shape),i=Je({inputs:{x:a},backend:n,attrs:{shape:[s]}}),o=new bbt(s),l=n.runWebGLProgram(o,[i],i.dtype),u=Je({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}const vbt={kernelName:tT,backendName:"webgl",kernelFunc:xbt};class wbt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:a,padInfo:r,strideHeight:s,strideWidth:i,filterHeight:o,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:h,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${h}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${a}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function Abt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=YA(r.shape,s.shape,i,o,"NHWC",l);let c;const h=new wbt(u);c=n.runWebGLProgram(h,[r,s],"float32");const p=Je({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),p}const Sbt={kernelName:oA,backendName:"webgl",kernelFunc:Abt};function kbt(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=_P(r,s.length);DP(i.length,l,s);const{path:u,steps:c}=OP(o,l),h=c.length;let p=null,m=i.length;const g=[];for(let y=0;y<h;++y){for(const b of c[y]){const{permutationIndices:v,expandDims:w}=RP(m,l[b]);let S;FP(v)?S=s[b]:(S=Rs({inputs:{x:s[b]},backend:n,attrs:{perm:v}}),g.push(S));const k=S.shape.slice();for(let I=0;I<w.length;++I)k.splice(w[I],0,1);tn(S.shape,k)||(S=Je({inputs:{x:S},backend:n,attrs:{shape:k}}),g.push(S)),p===null?p=S:(p=k4({inputs:{a:S,b:p},backend:n}),g.push(p))}y<h-1&&(u[y]>=0&&(p=XE({inputs:{x:p},backend:n,attrs:{axis:u[y]-(i.length-m),keepDims:!1}}),g.push(p)),m--)}for(const y of g)y!==p&&n.disposeIntermediateTensorInfo(y);return p}const Ibt={kernelName:aT,backendName:"webgl",kernelFunc:kbt};const Nbt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Cbt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Tbt=gn({opSnippet:Nbt,packedOpSnippet:Cbt}),Ebt={kernelName:Ix,backendName:"webgl",kernelFunc:Tbt};const $bt="return (b >= 0.0) ? a : a * (b + 1.0);",_bt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Rbt=e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new v0(_bt,a.shape,r.shape):new af($bt,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)},Dbt={kernelName:rT,backendName:"webgl",kernelFunc:Rbt};const Obt=`
  return vec4(equal(a, b));
`,Fbt="return float(a == b);",Mbt=ns({opSnippet:Fbt,packedOpSnippet:Obt,dtype:"bool",cpuKernelImpl:fft}),Lbt={kernelName:lA,backendName:"webgl",kernelFunc:Mbt};const zbt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${kP};
  float a1 = ${IP};
  float a2 = ${NP};
  float a3 = ${CP};
  float a4 = ${TP};
  float a5 = ${EP};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Bbt=gn({opSnippet:zbt}),Pbt={kernelName:Nx,backendName:"webgl",kernelFunc:Bbt};const Vbt=w0+`
  return exp(x);
`,Ubt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Lie=gn({opSnippet:Vbt,packedOpSnippet:Ubt,cpuKernelImpl:mft,dtype:"float32"}),Wbt={kernelName:Cx,backendName:"webgl",kernelFunc:Lie};function nF(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice();let l=r;return r<0&&(q(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),o.splice(l,0,1),Je({inputs:{x:s},backend:a,attrs:{shape:o}})}const Gbt={kernelName:uA,backendName:"webgl",kernelFunc:nF};const Hj="return exp(x) - 1.0;",Hbt=gn({opSnippet:Hj,packedOpSnippet:Hj,cpuKernelImpl:gft}),jbt={kernelName:Tx,backendName:"webgl",kernelFunc:Hbt};class jj{constructor(t,n,a){this.variableNames=["real","imag"];const r=n[1];this.outputShape=n;const s=a?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=a?`${r}.0`:"1.0";let o;if(t==="real")o="return real * expR - imag * expI;";else if(t==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function zie(e,t,n){const a=n.texData.get(e.dataId),r=_e(e.shape),s=e.shape[e.shape.length-1],i=r/s,o=Je({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new jj("real",l,t),c=new jj("imag",l,t),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:l},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(u,h,"float32"),m=n.runWebGLProgram(c,h,"float32"),g=wd({inputs:{real:p,imag:m},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m);const y=Je({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(g),y}function qbt(e){const{inputs:t,backend:n}=e,{input:a}=t;return zie(a,!1,n)}const Kbt={kernelName:sT,backendName:"webgl",kernelFunc:qbt};class Xbt{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function $S(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:s}=n;if(s=s||zm(r),s==="string"){const i=_a(s,_e(a));return i.fill(r),t.makeTensorInfo(a,s,i)}else{const i=new Xbt(a,r),o=[[r]];return t.runWebGLProgram(i,[],s,o)}}const Ybt={kernelName:iT,backendName:"webgl",kernelFunc:$S};class Qbt{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const Zbt={kernelName:oT,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,a=t,r=new Qbt(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}};const qj="return floor(x);",Jbt=gn({opSnippet:qj,packedOpSnippet:qj,cpuKernelImpl:yft}),ext={kernelName:Ex,backendName:"webgl",kernelFunc:Jbt};const txt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,nxt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,axt=ns({opSnippet:txt,packedOpSnippet:nxt,dtype:"int32"}),rxt={kernelName:$x,backendName:"webgl",kernelFunc:axt};class sxt{constructor(t){this.variableNames=["A"];const n=zs(),[a,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${a}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class ixt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=zs(),[a,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${a}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}const oxt={kernelName:_N,backendName:"webgl",kernelFunc:lxt};let Gg,YR=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function lxt(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:s}=a,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,s];if(o||i){const y=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Gg==null||y!==YR)&&(YR=y,Gg=document.createElement("canvas").getContext("2d",{willReadFrequently:YR})),Gg.canvas.width=l,Gg.canvas.height=u,Gg.drawImage(r,0,0,l,u),r=Gg.canvas}const p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=eo.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),r);const m=Ie().getBool("WEBGL_PACK")?new ixt(h):new sxt(h),g=n.runWebGLProgram(m,[p],"int32");return n.disposeData(p.dataId),g}function uxt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=a,y=bc(c),b=Br(r.shape,s.shape,l,h,u,p,!1,y);let v;const w=[],S=i!=null,k=o!=null,I=m==="leakyrelu",T=()=>{const R=[r,s],D=(O,$)=>{if($==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const _=Je({inputs:{x:O},backend:n,attrs:{shape:[O.shape[0],1,1]}});return w.push(_),_}return O};if(S&&R.push(D(i,c)),k&&R.push(D(o,c)),I){const O=n.makeTensorInfo([],"float32",gc(g,"float32"));R.push(O),w.push(O)}return R};if(b.filterHeight===1&&b.filterWidth===1&&b.dilationHeight===1&&b.dilationWidth===1&&b.strideHeight===1&&b.strideWidth===1&&(b.padInfo.type==="SAME"||b.padInfo.type==="VALID"))v=Rie({x:r,filter:s,convInfo:b,backend:n,bias:i,activation:m,preluActivationWeights:o,leakyreluAlpha:g});else if(b.strideWidth<=2&&y==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){const R=m?Ow(m,!0):null,D=new _ie(b,S,R,k,I),O=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],$=T();v=n.runWebGLProgram(D,$,"float32",O)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))v=Die({x:r,filter:s,convInfo:b,backend:n,bias:i,activation:m,preluActivationWeights:o,leakyreluAlpha:g});else{const R=m?Ow(m,!1):null,D=new $ie(b,S,R,k,I),O=T();v=n.runWebGLProgram(D,O,"float32")}const E=Je({inputs:{x:v},backend:n,attrs:{shape:b.outShape}});return w.push(v),w.forEach(R=>n.disposeIntermediateTensorInfo(R)),E}const cxt={kernelName:xw,backendName:"webgl",kernelFunc:uxt};function hxt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:p,leakyreluAlpha:m}=a,g=[];let y=c;y==null&&(y=[1,1]),q(Jr(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const b=Br(r.shape,s.shape,l,y,u,h,!0),v=Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,w=p?Ow(p,v):null,S=[r,s],k=i!=null,I=o!=null,T=p==="leakyrelu";if(k&&S.push(i),I&&S.push(o),T){const O=n.makeTensorInfo([],"float32",gc(m,"float32"));S.push(O),g.push(O)}let E;v?E=new Mie(b,k,w,I,T):E=new Fie(b,k,w,I,T);const R=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],D=n.runWebGLProgram(E,S,"float32",R);return g.forEach(O=>n.disposeIntermediateTensorInfo(O)),D}const dxt={kernelName:vw,backendName:"webgl",kernelFunc:hxt};class pxt{constructor(t,n,a,r){this.sliceDim=t,this.strides=n,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=a;const s=Hn(a.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function fxt(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,i=s[s.length-1],o=_e(a.shape),[l,u,c,h]=EE(a,r),p=Je({inputs:{x:r},backend:n,attrs:{shape:[u,i]}}),m=Je({inputs:{x:a},backend:n,attrs:{shape:[_e(a.shape)/c,c]}});if(n.shouldExecuteOnCPU([a,r])||a.dtype==="string"){const v=n.readSync(r.dataId),w=n.bufferSync(a),S=bft(v,w,a.dtype,u,i,c,h,a.shape,o);return n.makeTensorInfo(l,a.dtype,S.values)}const g=new pxt(i,h,[u,c],a.shape),y=n.runWebGLProgram(g,[m,p],m.dtype),b=Je({inputs:{x:y},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}const mxt={kernelName:lT,backendName:"webgl",kernelFunc:fxt};class gxt{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const a=Hn(this.rank),r=yxt(t);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function yxt(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)r===2?a.push("index"):a.push(`${n[r]}`);return a.join()}function Bie(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a,l=Zt(i,r.shape)[0];if(Ie().get("DEBUG")){const w=n.readSync(s.dataId),S=r.shape[l];for(let k=0;k<w.length;++k){const I=w[k];q(I<=S-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${S-1}]`)}}const u=LP(r,s,l,o),c=_e(s.shape),h=[],p=Je({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),m=Je({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(p),h.push(m);const g=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const w=n.bufferSync(m),S=n.bufferSync(p),k=xft(S,w,g);return h.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(u.outputShape,k.dtype,k.values)}const y=new gxt(p.shape,g),b=n.runWebGLProgram(y,[p,m],p.dtype);h.push(b);const v=Je({inputs:{x:b},backend:n,attrs:{shape:u.outputShape}});return h.forEach(w=>n.disposeIntermediateTensorInfo(w)),v}const bxt={kernelName:hA,backendName:"webgl",kernelFunc:Bie};const xxt="return float(a > b);",vxt=`
  return vec4(greaterThan(a, b));
`,wxt=ns({opSnippet:xxt,packedOpSnippet:vxt,cpuKernelImpl:vft,dtype:"bool"}),Axt={kernelName:dA,backendName:"webgl",kernelFunc:wxt};const Sxt="return float(a >= b);",kxt=`
  return vec4(greaterThanEqual(a, b));
`,Ixt=ns({opSnippet:Sxt,packedOpSnippet:kxt,dtype:"bool",cpuKernelImpl:wft}),Nxt={kernelName:_x,backendName:"webgl",kernelFunc:Ixt};function Cxt(e){const{inputs:t,backend:n}=e,{input:a}=t;return zie(a,!0,n)}const Txt={kernelName:uT,backendName:"webgl",kernelFunc:Cxt};const Ext="return float(!isnan(x) && !isinf(x));",$xt=gn({opSnippet:Ext,dtype:"bool"}),_xt={kernelName:Dx,backendName:"webgl",kernelFunc:$xt};const Rxt="return float(isinf(x));",Dxt=gn({opSnippet:Rxt,dtype:"bool"}),Oxt={kernelName:Ox,backendName:"webgl",kernelFunc:Dxt};const Fxt="return float(isnan(x));",Mxt=gn({opSnippet:Fxt,dtype:"bool"}),Lxt={kernelName:Fx,backendName:"webgl",kernelFunc:Mxt};const zxt="return float(a < b);",Bxt=`
  return vec4(lessThan(a, b));
`,Pxt=ns({opSnippet:zxt,packedOpSnippet:Bxt,cpuKernelImpl:Aft,dtype:"bool"}),Vxt={kernelName:fA,backendName:"webgl",kernelFunc:Pxt};const Uxt="return float(a <= b);",Wxt=`
  return vec4(lessThanEqual(a, b));
`,Gxt=ns({opSnippet:Uxt,packedOpSnippet:Wxt,cpuKernelImpl:Sft,dtype:"bool"}),Hxt={kernelName:mA,backendName:"webgl",kernelFunc:Gxt};function jxt(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=kft(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}const qxt={kernelName:hT,backendName:"webgl",kernelFunc:jxt};const Kxt=w0+`
  return x < 0.0 ? 0./0. : log(x);
`,Xxt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Yxt=gn({opSnippet:Kxt,packedOpSnippet:Xxt,cpuKernelImpl:Ift}),Qxt={kernelName:Mx,backendName:"webgl",kernelFunc:Yxt};const Zxt=w0+`
  return log(1.0 + x);
`,Jxt=gn({opSnippet:Zxt}),e0t={kernelName:Lx,backendName:"webgl",kernelFunc:Jxt};const t0t="return float(a >= 1.0 && b >= 1.0);",n0t=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,a0t=ns({opSnippet:t0t,packedOpSnippet:n0t,dtype:"bool"}),r0t={kernelName:gA,backendName:"webgl",kernelFunc:a0t};const s0t="return float(!(x >= 1.0));",i0t=gn({opSnippet:s0t}),o0t={kernelName:yA,backendName:"webgl",kernelFunc:i0t};const l0t="return float(a >= 1.0 || b >= 1.0);",u0t=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,c0t=ns({opSnippet:l0t,packedOpSnippet:u0t,dtype:"bool"}),h0t={kernelName:bA,backendName:"webgl",kernelFunc:c0t};class d0t{constructor(t,n,a,r,s){this.variableNames=["x"],this.outputShape=[];const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${a}) + float(${r}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class p0t{constructor(t,n,a,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${a}) + float(${r}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const f0t=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a,u=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new p0t(r.shape,s,i,o,l):new d0t(r.shape,s,i,o,l);return n.runWebGLProgram(u,[r],r.dtype)},m0t={kernelName:xA,backendName:"webgl",kernelFunc:f0t};class g0t{constructor(t,n,a,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=a,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${a});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const y0t=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=a,h=new g0t(r.shape,o,l,u,c);return n.runWebGLProgram(h,[r,s,i],r.dtype)},b0t={kernelName:dT,backendName:"webgl",kernelFunc:y0t};function x0t(e,t,n,a){const r=_e(t),i=_e(e.shape)/r,o=Je({inputs:{x:e},attrs:{shape:[i,r]},backend:a}),l=Ym(o,e.dtype,"max",a),u=Je({inputs:{x:l},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(l),u}function Pie(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=r.shape.length,l=Zt(s,r.shape);let u=l;const c=$a(u,o),h=c!=null,p=n.shouldExecuteOnCPU([r]);let m=r;if(h){if(p){const S=n.texData.get(m.dataId).values,k=new Array(o);for(let E=0;E<k.length;E++)k[E]=r.shape[c[E]];const I=A4(S,r.shape,r.dtype,c,k);m=n.makeTensorInfo(k,r.dtype);const T=n.texData.get(m.dataId);T.values=I}else m=KE(r,c,n);u=Ua(u.length,o)}es("max",u,o);const[g,y]=Pr(m.shape,u);let b=g;i&&(b=Ba(g,l));let v;if(p){const S=n.texData.get(m.dataId).values,k=Nft(S,_e(y),b,r.dtype);v=n.makeTensorInfo(b,r.dtype);const I=n.texData.get(v.dataId);I.values=k}else v=x0t(m,y,b,n);return h&&n.disposeIntermediateTensorInfo(m),v}const v0t={kernelName:vA,backendName:"webgl",kernelFunc:Pie};const w0t=S4+`
  return max(a, b);
`,A0t=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xm+`
  return result;
`,S0t=ns({opSnippet:w0t,packedOpSnippet:A0t,cpuKernelImpl:Cft}),k0t={kernelName:zx,backendName:"webgl",kernelFunc:S0t};function I0t(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;CS(r,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;q(Jr(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Wo(r.shape,s,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&tn(c.inShape,c.outShape))return Mi({inputs:{x:r},backend:n});const h=new Fw(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}const N0t={kernelName:wA,backendName:"webgl",kernelFunc:I0t};function C0t(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=a,c=[1,1,1],h=yc(r.shape,s,i,c,o,u,l),p=new I4(h,"max",!1);return n.runWebGLProgram(p,[r],r.dtype)}const T0t={kernelName:AA,backendName:"webgl",kernelFunc:C0t};class E0t{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideHeight,a=t.strideWidth,r=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,o=s-1-t.padInfo.top,l=i-1-t.padInfo.left,u=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class $0t{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideDepth,a=t.strideHeight,r=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,h=l-1-t.padInfo.front,p=u-1-t.padInfo.top,m=c-1-t.padInfo.left,g=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${p}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function _0t(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=a,h=[1,1,1],p=yc(i.shape,o,l,h,u,c),m=new I4(p,"max",!0),g=n.runWebGLProgram(m,[i],i.dtype),y=new $0t(p),b=n.runWebGLProgram(y,[r,g],i.dtype);return n.disposeIntermediateTensorInfo(g),b}const R0t={kernelName:fT,backendName:"webgl",kernelFunc:_0t};function D0t(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;CS([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=a,p=Wo(o.shape,l,u,1,c,h),m=!0,g=new Fw(p,"max",m),y=n.runWebGLProgram(g,[o],o.dtype),b=new E0t(p),v=n.runWebGLProgram(b,[r,y],o.dtype);return n.disposeIntermediateTensorInfo(y),v}const O0t={kernelName:pT,backendName:"webgl",kernelFunc:D0t};function F0t(e,t,n,a){let r=new Fw(n,"max",!1);const s=a.runWebGLProgram(r,[e],"float32");r=new Fw(n,"max",!0,!0,t);const i=a.runWebGLProgram(r,[e],"float32");return[s,i]}const M0t={kernelName:mT,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;q(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);const u=[1,1];q(Jr(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);const c=Wo(a.shape,r,s,u,i),[h,p]=F0t(a,o,c,l);return[h,p]}};function L0t(e,t,n,a){const r=_e(t),i=_e(e.shape)/r,o=Je({inputs:{x:e},attrs:{shape:[i,r]},backend:a}),l=Ym(o,"float32","mean",a),u=Je({inputs:{x:l},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(l),u}const z0t={kernelName:SA,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{keepDims:r,axis:s}=t,i=n,o=a.shape.length,l=Zt(s,a.shape);let u=l;const c=$a(u,o),h=c!=null,p=i.shouldExecuteOnCPU([a]),m=[];let g=a;if(h){if(p){const k=i.texData.get(g.dataId).values,I=new Array(o);for(let R=0;R<I.length;R++)I[R]=a.shape[c[R]];const T=A4(k,a.shape,a.dtype,c,I);g=i.makeTensorInfo(I,a.dtype);const E=i.texData.get(g.dataId);E.values=T}else g=KE(a,c,i);m.push(g),u=Ua(u.length,o)}es("sum",u,o);const[y,b]=Pr(g.shape,u);let v=y;r&&(v=Ba(y,l));const w=L0t(g,b,v,i);for(const S of m)i.disposeIntermediateTensorInfo(S);return w}};function B0t(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=Zt(s,r.shape);let u=l;const c=$a(u,o);let h=r;c!=null&&(h=Rs({inputs:{x:r},backend:n,attrs:{perm:c}}),u=Ua(u.length,r.shape.length)),es("min",u,o);const[p,m]=Pr(h.shape,u),g=_e(m),y=Je({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=Ym(y,y.dtype,"min",n);let v;if(i){const w=Ba(p,l);v=Je({inputs:{x:b},backend:n,attrs:{shape:w}})}else v=Je({inputs:{x:b},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),c!=null&&n.disposeIntermediateTensorInfo(h),v}const P0t={kernelName:kA,backendName:"webgl",kernelFunc:B0t};const V0t=S4+`
  return min(a, b);
`,U0t=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xm+`
  return result;
`,W0t=ns({opSnippet:V0t,packedOpSnippet:U0t,cpuKernelImpl:Tft}),G0t={kernelName:Bx,backendName:"webgl",kernelFunc:W0t};class H0t{constructor(t,n,a){this.variableNames=["x"],this.outputShape=n.map((c,h)=>c[0]+t[h]+c[1]);const r=t.length,s=Hn(r),i=n.map(c=>c[0]).join(","),o=n.map((c,h)=>c[0]+t[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=a==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class j0t{constructor(t,n,a){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((g,y)=>g[0]+t[y]+g[1]);const r=t.length,s=Hn(r),i=n.map(g=>g[0]).join(","),o=n.map((g,y)=>g[0]+t[y]).join(","),l=Ns("rc",r),u=Ns("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,p=a==="reflect"?0:1;let m="";if(r===1){const g=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;m=`
        ${s} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const g=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;m=`
        ${s} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${g}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[r-1]} += 1;
          if(${c}) {
            ${g}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}const q0t=({inputs:e,backend:t,attrs:n})=>{const{x:a}=e,{paddings:r,mode:s}=n,i=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new j0t(a.shape,r,s):new H0t(a.shape,r,s);return t.runWebGLProgram(i,[a],a.dtype)},K0t={kernelName:IA,backendName:"webgl",kernelFunc:q0t};const X0t=`if (b == 0.0) return NAN;
  return mod(a, b);`,Y0t=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Xm+`
  return result;
`,Q0t=ns({opSnippet:X0t,packedOpSnippet:Y0t}),Z0t={kernelName:Px,backendName:"webgl",kernelFunc:Q0t};class J0t{constructor(t,n,a){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,a],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}const evt=`
if (a == b) {
  return 1.0;
};
return a / b;`,tvt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Vie=ns({opSnippet:evt,packedOpSnippet:tvt,checkOutOfBounds:!0}),nvt={kernelName:kx,backendName:"webgl",kernelFunc:Vie};const Kj="return a - b;",Uie=ns({opSnippet:Kj,packedOpSnippet:Kj,supportsComplex:!0,cpuKernelImpl:Xft}),avt={kernelName:n0,backendName:"webgl",kernelFunc:Uie};function Wie(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=Zt([s],r.shape),o=Pie({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Ba(o.shape,i),u=Je({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Uie({inputs:{a:r,b:u},backend:n}),h=Lie({inputs:{x:c},backend:n}),p=XE({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),m=Je({inputs:{x:p},backend:n,attrs:{shape:l}}),g=Vie({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}const rvt={kernelName:WA,backendName:"webgl",kernelFunc:Wie};function svt(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,l=o?r:Wie({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new J0t(u,c,s),p=[[i]],m=n.runWebGLProgram(h,[l],"int32",p);return o||n.disposeIntermediateTensorInfo(l),m}const ivt={kernelName:gT,backendName:"webgl",kernelFunc:svt};const ovt=Ho+`
  return -x;
`,lvt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function uvt(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const s=n.texData.get(a.dataId),[i,o]=$ft(s.values,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,i)}let r;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new fh(a.shape,lvt):r=new Hl(a.shape,ovt),n.runWebGLProgram(r,[a],a.dtype)}const cvt={kernelName:NA,backendName:"webgl",kernelFunc:uvt};const hvt=IE;function dvt(e){qi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a,u=n.readSync(r.dataId),c=n.readSync(s.dataId),{selectedIndices:h}=hvt(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const pvt={kernelName:yT,backendName:"webgl",kernelFunc:dvt};const fvt=NE;function mvt(e){qi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a,c=n.readSync(r.dataId),h=n.readSync(s.dataId),{selectedIndices:p,validOutputs:m}=fvt(c,h,i,o,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([m]))]}const gvt={kernelName:bT,backendName:"webgl",kernelFunc:mvt};const yvt=CE;function bvt(e){qi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a,c=n.readSync(r.dataId),h=n.readSync(s.dataId),p=i,m=o,g=l,y=u,{selectedIndices:b,selectedScores:v}=yvt(c,h,p,m,g,y);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const xvt={kernelName:xT,backendName:"webgl",kernelFunc:bvt};class vvt{constructor(t,n,a,r){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${a}),
                      float(index == coords.y)));
      }
    `}}const wvt=e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,u=_e(r.shape),c=new vvt(u,i,o,l),h=Je({inputs:{x:r},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(c,[h],s);n.disposeIntermediateTensorInfo(h);const m=[...r.shape,i],g=Je({inputs:{x:p},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(p),g},Avt={kernelName:EA,backendName:"webgl",kernelFunc:wvt};function t2(e){const{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="complex64"){const r=ES({inputs:{input:a},backend:n}),s=t2({inputs:{x:r},backend:n}),i=YE({inputs:{input:a},backend:n}),o=t2({inputs:{x:i},backend:n}),l=wd({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $S({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype==="string"?"":0},backend:n})}const Svt={kernelName:qA,backendName:"webgl",kernelFunc:t2};function Gie(e){const{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(a.dtype==="complex64"){const r=ES({inputs:{input:a},backend:n}),s=Gie({inputs:{x:r},backend:n}),i=YE({inputs:{input:a},backend:n}),o=t2({inputs:{x:i},backend:n}),l=wd({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $S({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}const kvt={kernelName:TA,backendName:"webgl",kernelFunc:Gie};function Ivt(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return nF({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,i=t[0].dtype;t.forEach(c=>{Zr(s,c.shape,"All tensors passed to stack must have matching shapes"),q(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const h=nF({inputs:{input:c},backend:n,attrs:{dim:r}});return o.push(h),h}),u=Eie({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const Nvt={kernelName:$A,backendName:"webgl",kernelFunc:Ivt};class Cvt{constructor(t,n,a){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+t[c]+u[1]);const r=t.length,s=Hn(r),i=n.map(u=>u[0]).join(","),o=n.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class Tvt{constructor(t,n,a){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((y,b)=>y[0]+t[b]+y[1]);const r=t.length,s=Hn(r),i=n.map(y=>y[0]).join(","),o=n.map((y,b)=>y[0]+t[b]).join(","),l=Ns("rc",r),u=Ns("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,p=[`${s} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],m=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let y=0,b=r===1?2:4;y<b;y++)g+=`
        ${p[y]}
        if (${m}) {
          result[${y}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${y}] = getChannel(getX(${u.join()}), ${h});
        }
      `;g+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}const Hie=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;if(_e(r.shape)===0){const u=s.map((c,h)=>c[0]+r.shape[h]+c[1]);return $S({backend:n,attrs:{shape:u,value:i,dtype:r.dtype}})}const o=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Tvt(r.shape,s,i):new Cvt(r.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[r],r.dtype,l)},Evt={kernelName:_A,backendName:"webgl",kernelFunc:Hie};const $vt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,_vt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Xm+`
  return result;
`,Rvt=ns({opSnippet:$vt,packedOpSnippet:_vt}),Dvt={kernelName:Ux,backendName:"webgl",kernelFunc:Rvt};function Ovt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=[],u=Zt(s,r.shape);let c=u;const h=$a(c,o);let p=r;h!=null&&(p=Rs({inputs:{x:r},backend:n,attrs:{perm:h}}),c=Ua(c.length,o),l.push(p)),es("prod",c,o);let m;if(n.shouldExecuteOnCPU([p])){const g=n.texData.get(p.dataId).values,{outVals:y,outShape:b,outDtype:v}=Rft(p.shape,p.dtype,g,c);m=n.makeTensorInfo(b,v,y)}else{const[g,y]=Pr(p.shape,c),b=_e(y),v=Je({inputs:{x:p},backend:n,attrs:{shape:[-1,b]}}),w=HT(r.dtype),S=Ym(v,w,"prod",n);m=Je({inputs:{x:S},backend:n,attrs:{shape:g}}),l.push(v),l.push(S)}if(i){l.push(m);const g=Ba(m.shape,u);m=Je({inputs:{x:m},backend:n,attrs:{shape:g}})}return l.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const Fvt={kernelName:DA,backendName:"webgl",kernelFunc:Ovt};function Mvt(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(v=>n.readSync(v.dataId)),u=r.map(v=>v.shape),c=n.readSync(s.dataId),h=n.readSync(i.dataId),[p,m,g]=Dft(l,u,c,s.shape,s.dtype,h,i.shape,o),y=p.map(v=>n.makeTensorInfo([v.length],"int32",v)),b=n.makeTensorInfo(g,s.dtype,m);return y.concat([b])}const Lvt={kernelName:vT,backendName:"webgl",kernelFunc:Mvt};function zvt(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=Oft(i,a.shape,a.dtype,o,r.shape,l,s.shape),h=n.makeTensorInfo([u.length],"int32",u),p=n.makeTensorInfo([c.length],a.dtype,c);return[h,p]}const Bvt={kernelName:wT,backendName:"webgl",kernelFunc:zvt};function Pvt(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.readSync(r.dataId),c=n.readSync(s.dataId),h=n.readSync(i.dataId),p=o.map(b=>n.readSync(b.dataId)),m=o.map(b=>b.shape),[g,y]=Fft(u,r.shape,c,s.shape,s.dtype,h,i.shape,p,m,l);return n.makeTensorInfo(g,s.dtype,y)}const Vvt={kernelName:AT,backendName:"webgl",kernelFunc:Pvt};const jie=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=Mft(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},Uvt={kernelName:ST,backendName:"webgl",kernelFunc:jie};const Wvt="return 1.0 / x;",Gvt=gn({opSnippet:Wvt}),Hvt={kernelName:Wx,backendName:"webgl",kernelFunc:Gvt};const jvt=Ho+`
  return (x < 0.0) ? 0.0 : x;
`,qvt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Kvt=gn({opSnippet:jvt,packedOpSnippet:qvt}),Xvt={kernelName:Gx,backendName:"webgl",kernelFunc:Kvt};const Yvt=Ho+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Qvt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Zvt=gn({opSnippet:Yvt,packedOpSnippet:Qvt}),Jvt={kernelName:Hx,backendName:"webgl",kernelFunc:Zvt};class ewt{constructor(t,n,a,r,s){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,a,u];const c=[r&&n>1?o-1:o,r&&a>1?l-1:l],h=[r&&n>1?n-1:n,r&&a>1?a-1:a];let p;s?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class twt{constructor(t,n,a,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,a,u];const c=[r&&n>1?o-1:o,r&&a>1?l-1:l],h=[r&&n>1?n-1:n,r&&a>1?a-1:a];let p;s?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${a-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function nwt(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,c=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new twt(r.shape,l,u,s,i):new ewt(r.shape,l,u,s,i);return n.runWebGLProgram(c,[r],"float32")}const awt={kernelName:MA,backendName:"webgl",kernelFunc:nwt};class rwt{constructor(t,n,a){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,s]=n,[,i,o]=t,l=[a&&i>1?r-1:r,a&&o>1?s-1:s],u=[a&&i>1?i-1:i,a&&o>1?o-1:o],c=l[0]/u[0],h=l[1]/u[1],p=1/c,m=1/h,g=Math.ceil(p)*2+2,y=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function swt(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new rwt(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}const iwt={kernelName:NT,backendName:"webgl",kernelFunc:swt};class owt{constructor(t,n,a,r,s){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,a,u];const c=[r&&n>1?o-1:o,r&&a>1?l-1:l],h=[r&&n>1?n-1:n,r&&a>1?a-1:a],p=r?"0.5":"0.0";let m;s?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class lwt{constructor(t,n,a,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,a,u];const c=[r&&n>1?o-1:o,r&&a>1?l-1:l],h=[r&&n>1?n-1:n,r&&a>1?a-1:a],p=r?"0.5":"0.0";let m;s?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${a-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function uwt(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,c=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lwt(r.shape,l,u,s,i):new owt(r.shape,l,u,s,i);return n.runWebGLProgram(c,[r],r.dtype)}const cwt={kernelName:FA,backendName:"webgl",kernelFunc:uwt};class hwt{constructor(t,n,a){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,s]=n,[,i,o]=t,l=[a&&i>1?r-1:r,a&&o>1?s-1:s],u=[a&&i>1?i-1:i,a&&o>1?o-1:o],c=l[0]/u[0],h=l[1]/u[1],p=1/c,m=1/h,g=Math.ceil(p)*2+2,y=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${a} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${a} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function dwt(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new hwt(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}const pwt={kernelName:IT,backendName:"webgl",kernelFunc:dwt};class fwt{constructor(t,n){this.variableNames=["x"];const a=t.length;if(a>4)throw new Error(`WebGL backend: Reverse of rank-${a} tensor is not yet supported`);if(this.outputShape=t,a===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=o=>n.indexOf(o)!==-1&&t[o]!==1?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`,s=t.map((o,l)=>r(l)).join(","),i=Hn(a);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}}class mwt{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const a=t.length;if(a>4)throw new Error(`WebGL backend: Reverse of rank-${a} tensor is not yet supported`);this.outputShape=t;const r=Ns("rc",a),s=`${r[a-1]} + 1 < ${this.outputShape[a-1]}`,i=`${r[a-2]} + 1 < ${this.outputShape[a-2]}`,o=Hn(a);a===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${s}){
            result.g = ${u(r.slice())};
          }
          if(${i}) {
            result.b = ${c(r.slice())};
            if(${s}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(g){return p(g)}function u(g){return g[a-1]="("+g[a-1]+" + 1)",p(g)}function c(g){return g[a-2]="("+g[a-2]+" + 1)",p(g)}function h(g){return g[a-1]="("+g[a-1]+" + 1)",g[a-2]="("+g[a-2]+" + 1)",p(g)}function p(g){const y=t.map((w,S)=>m(S,g)),b=y.join(","),v=y.slice(-2).join(",");return`getChannel(getX(${b}), vec2(${v}))`}function m(g,y){return n.indexOf(g)!==-1&&t[g]!==1?`${t[g]} - ${y[g]} - 1`:`${y[g]}`}}}function gwt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=r.shape.length,o=Zt(s,r.shape);if(i===0)return Mi({inputs:{x:r},backend:n});const l=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mwt(r.shape,o):new fwt(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}const ywt={kernelName:LA,backendName:"webgl",kernelFunc:gwt};class bwt{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const a=t[1],r=t[2];this.outputShape=t;let s="";typeof n=="number"?s=`float outputValue = ${n.toFixed(2)};`:s=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${a}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const xwt={kernelName:WT,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=new bwt(a.shape,s),[u,c]=wP(i,a.shape[1],a.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[a],a.dtype,h)}};const vwt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,wwt=gn({opSnippet:vwt}),Awt={kernelName:jx,backendName:"webgl",kernelFunc:wwt};const Swt="return inversesqrt(x);",kwt=gn({opSnippet:Swt,cpuKernelImpl:Lft}),Iwt={kernelName:qx,backendName:"webgl",kernelFunc:kwt};class N4{constructor(t,n,a,r,s,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Hn(s.length),c=Hn(i.length);let h="";a===1?h="i":a===2&&(h="i, j");const p=`getIndices(${h})`;let m="";r===1?m="i":r===2&&(m="i, coords[1]");const g=`getUpdates(${m})`;let y="";l&&(y="coords[0], coords[1]");const b=`getDefaultValue(${y})`,v=n>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${b}, sum, float(found)));
        }
      `}}class Nwt{constructor(t,n,a,r,s,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Hn(s.length),c=Hn(i.length);let h="";a===1?h="i":a===2&&(h="i, j");const p=`getIndices(${h})`;let m="";r===1?m="i":r===2&&(m="i, coords[1]");const g=`getUpdates(${m})`;let y="";l&&(y="coords[0], coords[1]");const b=`getDefaultValue(${y})`,v=n>1?"strides[j]":"strides",w=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${w};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${b}, sum, found));
        }
      `}}function Cwt(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=bd(s,r,i),p=[h/u,u];if(h===0)return n.makeTensorInfo(i,r.dtype);const m=Je({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),g=Je({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),y=n.makeTensorInfo([],"float32",new Float32Array([0]));let b;Ie().getBool("WEBGL_PACK")?b=new Nwt(l,o,m.shape.length,g.shape.length,c,p):b=new N4(l,o,m.shape.length,g.shape.length,c,p);const v=n.runWebGLProgram(b,[g,m,y],g.dtype),w=Je({inputs:{x:v},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(y),w}const Twt={kernelName:CT,backendName:"webgl",kernelFunc:Cwt};class Ewt{constructor(t,n,a,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,a];const s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,o=Ie().getNumber("WEBGL_VERSION")===2?s:i,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function $wt(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new Ewt(r.shape[0],r.shape[1],s.shape[1],i),l=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],"int32",l)}const _wt={kernelName:ET,backendName:"webgl",kernelFunc:$wt};class Rwt{constructor(t,n,a){this.variableNames=["c","a","b"],this.outputShape=n;let r,s;if(a>4)throw Error(`Where for rank ${a} is not yet supported`);if(a===1)s="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${o[c]}`),c<t&&l.push(`${o[c]}`);r=l.join(),s=u.join()}const i=Hn(a);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}}function Dwt(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=new Rwt(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[a,r,s],ei(r.dtype,s.dtype))}const Owt={kernelName:zA,backendName:"webgl",kernelFunc:Dwt};const Fwt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${RE};
  float scale = ${DE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Mwt=gn({opSnippet:Fwt}),Lwt={kernelName:Kx,backendName:"webgl",kernelFunc:Mwt};const zwt=w0+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Bwt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Pwt=gn({opSnippet:zwt,packedOpSnippet:Bwt,cpuKernelImpl:Bft}),Vwt={kernelName:Zx,backendName:"webgl",kernelFunc:Pwt};const Uwt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Wwt=gn({opSnippet:Uwt}),Gwt={kernelName:Qx,backendName:"webgl",kernelFunc:Wwt};const Hwt=w0+`
  return sin(x);
`,jwt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Xm}
  return result;
`,qwt=gn({opSnippet:Hwt,packedOpSnippet:jwt}),Kwt={kernelName:Xx,backendName:"webgl",kernelFunc:qwt};const Xwt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Ywt=gn({opSnippet:Xwt}),Qwt={kernelName:Yx,backendName:"webgl",kernelFunc:Ywt};const Zwt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Jwt=gn({opSnippet:Zwt}),e1t={kernelName:Jx,backendName:"webgl",kernelFunc:Jwt};const t1t=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;q(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=s.reduce((v,w)=>v*w),l=[[0,0]];l.push(...i);for(let v=1+s.length;v<r.shape.length;++v)l.push([0,0]);const u=[],c=Hie({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=fS(c.shape,s,o,!1),p=mS(h.length,s.length,!1),m=gS(c.shape,s,o,!1),g=Je({inputs:{x:c},backend:n,attrs:{shape:h}}),y=Rs({inputs:{x:g},backend:n,attrs:{perm:p}}),b=Je({inputs:{x:y},backend:n,attrs:{shape:m}});return u.push(c),u.push(g),u.push(y),u.forEach(v=>n.disposeIntermediateTensorInfo(v)),b},n1t={kernelName:VA,backendName:"webgl",kernelFunc:t1t};function a1t(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(r.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[h,p,m,g,y]=Vft(o,a.shape,a.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(p,a.dtype,h),n.makeTensorInfo([p[0]],r.dtype,m),n.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(b=>Number(b)))),n.makeTensorInfo([y.length],a.dtype,new Int32Array(y))]}const r1t={kernelName:$T,backendName:"webgl",kernelFunc:a1t};function s1t(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,h]=Uft(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(c,a.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}const i1t={kernelName:_T,backendName:"webgl",kernelFunc:s1t};function o1t(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);const i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=gie(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(c,a.dtype,u)}const l1t={kernelName:RT,backendName:"webgl",kernelFunc:o1t};function u1t(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);const i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,c]=gie(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(c,a.dtype,u)}const c1t={kernelName:DT,backendName:"webgl",kernelFunc:u1t};function h1t(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:p}=bd(s,r,o),m=!1;if(s.dtype==="string"){const v=n.bufferSync(r),w=n.bufferSync(s),S=tc(n.readSync(i.dataId)[0]),k=zft(v,w,o,p,c,u,l,h,S,m);return n.makeTensorInfo(o,k.dtype,k.values)}const g=new N4(u,l,r.shape.length,s.shape.length,h,[p,1],m),y=n.runWebGLProgram(g,[s,r,i],s.dtype),b=Je({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(y),b}const d1t={kernelName:OT,backendName:"webgl",kernelFunc:h1t};function p1t(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=Zt(i,r.shape)[0],l=MP(r,s,o),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(p=>{const m=[...h];m[o]=p;const g=A0({inputs:{x:r},backend:n,attrs:{begin:c,size:m}});return c[o]+=p,g})}const f1t={kernelName:UA,backendName:"webgl",kernelFunc:p1t};const Xj="return sqrt(x);",m1t=gn({opSnippet:Xj,packedOpSnippet:Xj,cpuKernelImpl:Wft}),g1t={kernelName:e0,backendName:"webgl",kernelFunc:m1t};const y1t="return x * x;",b1t=gn({opSnippet:y1t}),x1t={kernelName:FT,backendName:"webgl",kernelFunc:b1t};const Yj="return (a - b) * (a - b);",v1t=ns({opSnippet:Yj,packedOpSnippet:Yj}),w1t={kernelName:t0,backendName:"webgl",kernelFunc:v1t};function A1t(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const s=n.readSync(r.dataId),i=sc(s),o=Gft(i,"string",a);return n.makeTensorInfo(r.shape,"string",o)}const S1t={kernelName:GA,backendName:"webgl",kernelFunc:A1t};function k1t({inputs:e,attrs:t,backend:n}){const{x:a}=e,r=Ho+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Hl(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}const I1t={kernelName:i0,backendName:"webgl",kernelFunc:k1t};class N1t{constructor(t,n,a){this.variableNames=["x"],this.outputShape=a;const r=a.length,s=Hn(a.length),i=Hn(a.length);let o="";if(r===1)o="coords * strides + begin";else{let l=0;o=a.map((u,c)=>(l++,a.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}function C1t(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:b,isSimpleSlice:v,begin:w,end:S,strides:k}=yP(r.shape,s,i,o,l,u,c,h,p);let I;if(y)I=Je({inputs:{x:r},backend:n,attrs:{shape:g}});else if(b||v){q(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const E=fP(w,S,k),R=A0({inputs:{x:r},backend:n,attrs:{begin:w,size:E}});I=Je({inputs:{x:R},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(R)}else if(n.shouldExecuteOnCPU([r])){const R=n.readSync(r.dataId),D=Gt(r.shape,r.dtype,R),O=Hft(m,D,k,w);I=n.makeTensorInfo(g,r.dtype,O.values)}else{const R=new N1t(w,k,m);I=n.runWebGLProgram(R,[r],r.dtype)}const T=Je({inputs:{x:I},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(I),T}const T1t={kernelName:MT,backendName:"webgl",kernelFunc:C1t};function E1t(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:c,dataSplits:h}=t,p=n.readSync(c.dataId),m=n.readSync(h.dataId),[g,y]=jft(p,m,r,s,i,o,l,u);return[n.makeTensorInfo([g.length],"string",g),n.makeTensorInfo(h.shape,"int32",y)]}const $1t={kernelName:LT,backendName:"webgl",kernelFunc:E1t};function _1t(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,h]=qft(o,l,r),p=c.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const R1t={kernelName:zT,backendName:"webgl",kernelFunc:_1t};function D1t(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(s.dataId),o=Kft(i,r);return n.makeTensorInfo(s.shape,"int32",o)}const O1t={kernelName:BT,backendName:"webgl",kernelFunc:D1t};const F1t="return tan(x);",M1t=gn({opSnippet:F1t}),L1t={kernelName:a0,backendName:"webgl",kernelFunc:M1t};const z1t=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,B1t=gn({opSnippet:z1t}),P1t={kernelName:r0,backendName:"webgl",kernelFunc:B1t};function V1t(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=bd(i,s,r.shape),p=[h/u,u];if(h===0)return n.makeTensorInfo(r.shape,s.dtype);const m=Je({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),g=Je({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),y=Je({inputs:{x:r},backend:n,attrs:{shape:p}}),b=new N4(l,o,m.shape.length,g.shape.length,c,p,!1,!0),v=n.runWebGLProgram(b,[g,m,y],y.dtype),w=Je({inputs:{x:v},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),w}const U1t={kernelName:TT,backendName:"webgl",kernelFunc:V1t};class W1t{constructor(t,n){this.variableNames=["A"];const a=new Array(t.length);for(let i=0;i<a.length;i++)a[i]=t[i]*n[i];this.outputShape=a,this.rank=a.length;const r=Hn(this.rank),s=G1t(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function G1t(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push(`imod(${n[r]}, ${e[r]})`);return a.join()}function qie(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if(r.dtype==="string"||r.shape.length>5){const l=n.readSync(r.dataId),u=r.dtype==="string"?l.map(p=>tc(p)):l,c=Gt(r.shape,r.dtype,u),h=Yft(c,s);return n.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new W1t(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}const H1t={kernelName:s0,backendName:"webgl",kernelFunc:qie};class j1t{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class q1t{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function qd(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function Qj(e){let t=1;for(;t<e;)t*=2;return t}function K1t(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=Ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([r])||c<o||s>l){const O=n.readSync(r.dataId),[$,_]=Qft(O,u,r.dtype,s,i);return[n.makeTensorInfo($.shape,$.dtype,$.values),n.makeTensorInfo(_.shape,_.dtype,_.values)]}if(s===0)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[r,$S({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),p=h!==null&&h.isPacked,m=p?n.unpackTensor(r):r,y=_e(u)/c,b=Je({inputs:{x:m},attrs:{shape:[y,c]},backend:n});p&&qd(n,m);const v=Qj(s),w=Qj(c);let S=null;const k=()=>S===null?[b,b]:[b,S],I=(O,$,_)=>{const P=k(),U=new j1t(_),B=[[c],[S===null?1:0],[Number.NEGATIVE_INFINITY],[O],[$]],H=S;S=n.runWebGLProgram(U,P,"int32",B),qd(n,H)};for(let O=1;O<v;O*=2){const $=O*2;for(let _=O;_>=1;_/=2)I($,_,[y,w])}for(let O=w;O>v;O/=2){const $=k(),_=new q1t([y,O/2]),U=[[c],[S===null?1:0],[v]],W=S;S=n.runWebGLProgram(_,$,"int32",U),qd(n,W);const B=v/2,H=B*2;for(let j=B;j>=1;j/=2)I(H,j,S.shape)}let T=S;S=A0({inputs:{x:S},backend:n,attrs:{begin:0,size:[y,s]}}),qd(n,T);let E=Bie({inputs:{x:b,indices:S},backend:n,attrs:{axis:1,batchDims:1}});qd(n,b);const R=u.slice(0,-1);R.push(s),T=S,S=Je({inputs:{x:S},attrs:{shape:R},backend:n}),qd(n,T);const D=E;return E=Je({inputs:{x:E},attrs:{shape:R},backend:n}),qd(n,D),[E,S]}const X1t={kernelName:PT,backendName:"webgl",kernelFunc:K1t};class Y1t{constructor(t,n,a,r,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=a==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function Q1t(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=a,[c,h,p,m]=r.shape,[g,y]=u??[h,p],b=[c,g,y,m],v=new Y1t(h,p,i,o,l,b);return n.runWebGLProgram(v,[r,s],"float32")}const Z1t={kernelName:VT,backendName:"webgl",kernelFunc:Q1t};function J1t(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;CS(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=a.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=Zft(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],"int32",u)]}const eAt={kernelName:UT,backendName:"webgl",kernelFunc:J1t};function tAt(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const i=r,o=i.shape.length,l=r.shape[s],u=new Array(o-1);let c=0;for(let y=0;y<o;y++)y!==s&&(u[c++]=i.shape[y]);const h=[],p=new Array(o).fill(0),m=i.shape.slice();m[s]=1;const g=new Array(l);for(let y=0;y<g.length;y++){p[s]=y;const b=A0({inputs:{x:i},backend:n,attrs:{begin:p,size:m}}),v=Je({inputs:{x:b},backend:n,attrs:{shape:u}});g[y]=v,h.push(b)}return h.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const nAt={kernelName:HA,backendName:"webgl",kernelFunc:tAt};class aAt{constructor(t,n){this.variableNames=["x","segmentIds"];const a=t.windowSize,r=t.batchSize,s=t.inSize,i=t.numSegments,o=i*Math.ceil(s/a);this.outputShape=[r,o];const l="0.0",u="sumValue",c=Math.floor(a/4)*4,h=a%4,p=`
        sumValue += dot(values, segFilter);
    `;let m="";s%a>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let g="";s%a>0&&(g=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${a}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${u});
      }
    `}}function rAt(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a,o=r.shape.length,l=[];let u=0;const c=$a([u],o);let h=r;c!=null&&(h=Rs({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(h),u=Ua(1,o)[0]);const p=kne(h.shape,u,i),m=_e([h.shape[u]]),g=Je({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}});l.push(g);const y=HT(r.dtype),b=(k,I,T,E,R)=>{const D=k.shape[0],O=k.shape[1],$=Sne(O,R),_={windowSize:$,inSize:O,batchSize:D,numSegments:R},P=new aAt(_,I),U=n.compileAndRun(P,[k,T],E);if(l.push(U),U.shape[1]===R)return U;const W=jie({backend:n,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),B=qie({inputs:{x:W},backend:n,attrs:{reps:[O/$]}});return l.push(W),l.push(B),b(U,I,B,E,R)},v=b(g,"unsortedSegmentSum",s,y,i),w=Je({inputs:{x:v},backend:n,attrs:{shape:p}});let S=w;if(c!=null){l.push(w);const k=fd(c);S=Rs({inputs:{x:S},backend:n,attrs:{perm:k}})}return l.forEach(k=>n.disposeIntermediateTensorInfo(k)),S}const sAt={kernelName:jA,backendName:"webgl",kernelFunc:rAt};const iAt=[Wmt,Hmt,Kmt,Qmt,Jmt,ngt,rgt,igt,cgt,dgt,mgt,bgt,wgt,Igt,Tgt,$gt,Rgt,Mgt,zgt,Pgt,Ggt,Qgt,Jgt,ayt,syt,hyt,pyt,yyt,Nmt,vyt,Iyt,Eyt,Fyt,zyt,Pyt,Uyt,Gyt,Kyt,Qyt,ebt,nbt,rbt,ibt,ubt,hbt,mbt,ybt,vbt,Sbt,Ibt,Ebt,Dbt,Lbt,Pbt,Wbt,Gbt,jbt,Kbt,Ybt,Zbt,ext,rxt,oxt,cxt,dxt,mxt,bxt,Axt,Nxt,Imt,Txt,Syt,_xt,Oxt,Lxt,Tmt,Vxt,Hxt,qxt,Qxt,e0t,r0t,o0t,h0t,m0t,b0t,v0t,k0t,N0t,T0t,R0t,O0t,M0t,z0t,P0t,G0t,K0t,Z0t,ivt,_mt,cvt,pvt,gvt,xvt,oyt,Avt,kvt,Nvt,Evt,Dvt,$mt,Fvt,Lvt,Bvt,Vvt,Uvt,lyt,nvt,Hvt,Xvt,Jvt,Dmt,awt,iwt,cwt,pwt,ywt,xwt,Awt,Iwt,Twt,_wt,Owt,Lwt,Vwt,Gwt,Kwt,Qwt,Xgt,rvt,e1t,n1t,r1t,i1t,l1t,c1t,d1t,f1t,g1t,x1t,w1t,S1t,I1t,T1t,$1t,R1t,O1t,avt,Pmt,L1t,P1t,U1t,H1t,X1t,Z1t,Vmt,eAt,nAt,sAt,Svt];for(const e of iAt)GT(e);var Hv={exports:{}};const oAt=aF(Ust),lAt=aF(het);var uAt=Hv.exports,Zj;function cAt(){return Zj||(Zj=1,(function(e,t){(function(n,a){a(t,oAt,lAt)})(uAt,(function(n,a,r){const s={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class i{constructor(l,u){this.modelPath=u||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(l)}/model.json`}getPrefix(l){return l==="lite_mobilenet_v2"?`ssd${l}`:`ssd_${l}`}async load(){this.model=await a.loadGraphModel(this.modelPath);const l=r.zeros([1,300,300,3],"int32"),u=await this.model.executeAsync(l);await Promise.all(u.map((c=>c.data()))),u.map((c=>c.dispose())),l.dispose()}async infer(l,u,c){const h=r.tidy((()=>(l instanceof r.Tensor||(l=r.browser.fromPixels(l)),r.expandDims(l)))),p=h.shape[1],m=h.shape[2],g=await this.model.executeAsync(h),y=g[0].dataSync(),b=g[1].dataSync();h.dispose(),r.dispose(g);const[v,w]=this.calculateMaxScores(y,g[0].shape[1],g[0].shape[2]),S=r.getBackend();r.getBackend()==="webgl"&&r.setBackend("cpu");const k=r.tidy((()=>{const T=r.tensor2d(b,[g[1].shape[1],g[1].shape[3]]);return r.image.nonMaxSuppression(T,v,u,c,c)})),I=k.dataSync();return k.dispose(),S!==r.getBackend()&&r.setBackend(S),this.buildDetectedObjects(m,p,b,v,I,w)}buildDetectedObjects(l,u,c,h,p,m){const g=p.length,y=[];for(let b=0;b<g;b++){const v=[];for(let T=0;T<4;T++)v[T]=c[4*p[b]+T];const w=v[0]*u,S=v[1]*l,k=v[2]*u,I=v[3]*l;v[0]=S,v[1]=w,v[2]=I-S,v[3]=k-w,y.push({bbox:v,class:s[m[p[b]]+1].displayName,score:h[p[b]]})}return y}calculateMaxScores(l,u,c){const h=[],p=[];for(let m=0;m<u;m++){let g=Number.MIN_VALUE,y=-1;for(let b=0;b<c;b++)l[m*c+b]>g&&(g=l[m*c+b],y=b);h[m]=g,p[m]=y}return[h,p]}async detect(l,u=20,c=.5){return this.infer(l,u,c)}dispose(){this.model!=null&&this.model.dispose()}}n.ObjectDetection=i,n.load=async function(o={}){if(r==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const l=o.base||"lite_mobilenet_v2",u=o.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(l)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${l}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const c=new i(l,u);return await c.load(),c},n.version="2.2.3",Object.defineProperty(n,"__esModule",{value:!0})}))})(Hv,Hv.exports)),Hv.exports}var hAt=cAt();const dAt=()=>{const[e]=Oce(),t=e.get("userId")||"Peserta",n=Ae.useRef(null),a=Ae.useRef(null),r=Ae.useRef(new F8e),s=Ae.useRef(null),[i,o]=Ae.useState(!1),[l,u]=Ae.useState(0),[c,h]=Ae.useState(!0),[p,m]=Ae.useState(!1),[g,y]=Ae.useState("environment");Ae.useEffect(()=>((async()=>{try{await vee(),a.current=await hAt.load({base:"lite_mobilenet_v2"}),o(!0)}catch(w){console.error("AI Load Error:",w)}})(),()=>{r.current.disable(),xee()}),[]),Ae.useEffect(()=>{if(!i)return;const w=setInterval(async()=>{const S=n.current?.video;if(S?.readyState===4){const I=(await a.current.detect(S)).filter(T=>T.class==="person"&&T.score>.4);u(I.length),I.length>1?(s.current||(s.current=Date.now()),Date.now()-s.current>2e3&&h(!1)):(s.current=null,h(!0))}},800);return()=>clearInterval(w)},[i]);const b=()=>{r.current.enable(),m(!0)};return ce.jsxs("div",{className:`h-screen flex flex-col transition-colors duration-700 ${c?"bg-slate-950":"bg-red-900"}`,children:[!i&&ce.jsxs("div",{className:"fixed inset-0 z-[60] bg-slate-950 flex flex-col items-center justify-center text-white p-10",children:[ce.jsx(dF,{size:40,className:"animate-spin text-indigo-500 mb-4"}),ce.jsx("h2",{className:"text-xl font-black italic tracking-tighter",children:"BOOTING AI GUARD..."})]}),!p&&i&&ce.jsxs("div",{className:"fixed inset-0 z-50 bg-indigo-600 flex flex-col items-center justify-center p-8 text-center text-white",children:[ce.jsx(I5,{size:64,className:"mb-6 animate-bounce"}),ce.jsx("h2",{className:"text-3xl font-black uppercase italic tracking-tighter mb-2",children:"Sync Completed"}),ce.jsx("p",{className:"text-indigo-100 text-sm mb-8 opacity-80",children:"Letakkan HP di samping belakang Anda untuk pengawasan sudut lebar."}),ce.jsx("button",{onClick:b,className:"bg-white text-indigo-600 font-black px-12 py-5 rounded-[2rem] shadow-2xl active:scale-95 transition-all text-lg",children:"AKTIFKAN SENSOR"})]}),ce.jsxs("div",{className:"p-4 flex justify-between items-center bg-black/40 backdrop-blur-md border-b border-white/5",children:[ce.jsxs("div",{className:"flex flex-col",children:[ce.jsx("span",{className:"text-slate-500 text-[8px] uppercase font-black tracking-widest",children:"Node ID"}),ce.jsx("h1",{className:"text-white font-black text-sm italic uppercase",children:t})]}),ce.jsxs("div",{className:`flex items-center gap-2 px-3 py-1 rounded-full border ${c?"border-emerald-500/50 text-emerald-400":"bg-red-500 text-white animate-pulse"}`,children:[c?ce.jsx(pF,{size:12}):ce.jsx(x5,{size:12}),ce.jsx("span",{className:"text-[10px] font-black uppercase",children:c?"Active":"Warning"})]})]}),ce.jsx("div",{className:"flex-1 relative flex items-center justify-center p-4",children:ce.jsxs("div",{className:"relative w-full aspect-[3/4] rounded-[2.5rem] overflow-hidden border-2 border-white/10 shadow-2xl bg-black",children:[ce.jsx(i2,{ref:n,audio:!1,videoConstraints:{facingMode:g},className:"w-full h-full object-cover grayscale-[0.3]"}),ce.jsx("button",{onClick:()=>y(v=>v==="user"?"environment":"user"),className:"absolute top-4 right-4 bg-black/50 p-3 rounded-2xl text-white backdrop-blur-md",children:ce.jsx(k5,{size:20})})]})}),ce.jsxs("div",{className:"p-6 grid grid-cols-2 gap-3 bg-black/40",children:[ce.jsxs("div",{className:"bg-white/5 p-4 rounded-3xl border border-white/5",children:[ce.jsx("p",{className:"text-[9px] font-black text-slate-500 uppercase tracking-widest mb-1",children:"Detection"}),ce.jsxs("p",{className:`text-xl font-black ${c?"text-white":"text-red-500"}`,children:[l," ",ce.jsx("span",{className:"text-xs opacity-50",children:"Pers."})]})]}),ce.jsxs("div",{className:"bg-white/5 p-4 rounded-3xl border border-white/5",children:[ce.jsx("p",{className:"text-[9px] font-black text-slate-500 uppercase tracking-widest mb-1",children:"Battery Save"}),ce.jsxs("div",{className:"flex items-center gap-2 text-emerald-400",children:[ce.jsx(_he,{size:14})," ",ce.jsx("span",{className:"text-xs font-black uppercase",children:"Optimized"})]})]})]})]})},pAt=({user:e,screen:t,setScreen:n,handleLoginSuccess:a,handleLogout:r})=>ce.jsx("div",{className:"min-h-screen bg-slate-50 font-sans text-slate-900",children:ce.jsxs("main",{className:"max-w-6xl mx-auto",children:[t==="login"&&ce.jsx(Dhe,{onLoginSuccess:a,onGoToRegister:()=>n("register")}),t==="register"&&ce.jsx(Rhe,{onDone:()=>n("login")}),e&&ce.jsxs(ce.Fragment,{children:[t==="verify"&&ce.jsx(E8e,{user:e,onVerified:()=>n("exam"),onLogout:r}),t==="exam"&&ce.jsx(_8e,{user:e,onLogout:r})]})]})});function fAt(){const[e,t]=Ae.useState(()=>{const i=sessionStorage.getItem("loggedInUser");return i?JSON.parse(i):null}),[n,a]=Ae.useState(()=>sessionStorage.getItem("loggedInUser")?"verify":"login"),r=()=>{sessionStorage.removeItem("loggedInUser"),t(null),a("login")},s=i=>{sessionStorage.setItem("loggedInUser",JSON.stringify(i)),t(i),a("verify")};return ce.jsx(Ece,{children:ce.jsxs(rce,{children:[ce.jsx(AI,{path:"/",element:ce.jsx(pAt,{user:e,screen:n,setScreen:a,handleLoginSuccess:s,handleLogout:r})}),ce.jsx(AI,{path:"/rear-proctoring",element:ce.jsx(dAt,{})}),ce.jsx(AI,{path:"*",element:ce.jsx(nce,{to:"/"})})]})})}iue.createRoot(document.getElementById("root")).render(ce.jsx(Ae.StrictMode,{children:ce.jsx(fAt,{})}));
